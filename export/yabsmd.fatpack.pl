#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Array/Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARRAY_UTILS';
  package Array::Utils;
  
  =head1 NAME
  
  Array::Utils - small utils for array manipulation
  
  =head1 SYNOPSIS
  
  	use Array::Utils qw(:all);
  	
  	my @a = qw( a b c d );
  	my @b = qw( c d e f );
  
  	# symmetric difference
  	my @diff = array_diff(@a, @b);
  
  	# intersection
  	my @isect = intersect(@a, @b);
  	
  	# unique union
  	my @unique = unique(@a, @b);
  	
  	# check if arrays contain same members
  	if ( !array_diff(@a, @b) ) {
  		# do something
  	}
  	
  	# get items from array @a that are not in array @b
  	my @minus = array_minus( @a, @b );
  	
  =head1 DESCRIPTION
  
  A small pure-perl module containing list manipulation routines. The module
  emerged because I was tired to include same utility routines in numerous projects.
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item C<unique>
  
  Returns an array of unique items in the arguments list.
  
  =item C<intersect>
  
  Returns an intersection of two arrays passed as arguments, keeping the order of the
  second parameter. A nice side effect of this function can be exploited in situations as:
  
  	@atreides = qw( Leto Paul Alia 'Leto II' );
  	@mylist = qw( Alia Leto );
  	@mylist = intersect( @mylist, @atreides );  # and @mylist is ordered as Leto,Alia
  
  =item C<array_diff>
  
  Return symmetric difference of two arrays passed as arguments.
  
  =item C<array_minus>
  
  Returns the difference of the passed arrays A and B (only those 
  array elements that exist in A and do not exist in B). 
  If an empty array is returned, A is subset of B.
  
  Function was proposed by Laszlo Forro <salmonix@gmail.com>.
  
  =back
  
  =head1 BUGS
  
  None known yet
  
  =head1 AUTHOR
  
  Sergei A. Fedorov <zmij@cpan.org>
  
  I will be happy to have your feedback about the module.
  
  =head1 COPYRIGHT
  
  This module is Copyright (c) 2007 Sergei A. Fedorov.
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public
  License or the Artistic License, as specified in the Perl README file.
  
  =head1 WARRANTY
  
  This is free software. IT COMES WITHOUT WARRANTY OF ANY KIND.
  
  =cut
  
  use strict;
  
  require Exporter;
  our @ISA = qw(Exporter);
  
  our %EXPORT_TAGS = (
  	all	=> [ qw(
  		&unique
  		&intersect
  		&array_diff
  		&array_minus
  	) ],
  );
  our @EXPORT_OK = ( @{ $EXPORT_TAGS{'all'} } );
  
  our $VERSION = '0.5';
  
  sub unique(@) {
  	return keys %{ {map { $_ => undef } @_}}; 
  }
  
  sub intersect(\@\@) {
  	my %e = map { $_ => undef } @{$_[0]};
  	return grep { exists( $e{$_} ) } @{$_[1]};
  }
  
  sub array_diff(\@\@) {
  	my %e = map { $_ => undef } @{$_[1]};
  	return @{[ ( grep { (exists $e{$_}) ? ( delete $e{$_} ) : ( 1 ) } @{ $_[0] } ), keys %e ] };
  }
  
  sub array_minus(\@\@) {
  	my %e = map{ $_ => undef } @{$_[1]};
  	return grep( ! exists( $e{$_} ), @{$_[0]} ); 
  }
  
  1;
ARRAY_UTILS

$fatpacked{"Feature/Compat/Try.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FEATURE_COMPAT_TRY';
  #  You may distribute under the terms of either the GNU General Public License
  #  or the Artistic License (the same terms as Perl itself)
  #
  #  (C) Paul Evans, 2021-2022 -- leonerd@leonerd.org.uk
  
  package Feature::Compat::Try 0.05;
  
  use v5.14;
  use warnings;
  use feature ();
  
  # Core's use feature 'try' only supports 'finally' since 5.35.8
  use constant HAVE_FEATURE_TRY => $] >= 5.035008;
  
  =head1 NAME
  
  C<Feature::Compat::Try> - make C<try/catch> syntax available
  
  =head1 SYNOPSIS
  
     use Feature::Compat::Try;
  
     sub foo
     {
        try {
           attempt_a_thing();
           return "success";
        }
        catch ($e) {
           warn "It failed - $e";
           return "failure";
        }
     }
  
  =head1 DESCRIPTION
  
  This module makes syntax support for C<try/catch> control flow easily
  available.
  
  Perl added such syntax at version 5.34.0, and extended it to support optional
  C<finally> blocks at 5.35.9, which is enabled by
  
     use feature 'try';
  
  On that version of perl or later, this module simply enables the core feature
  equivalent to using it directly. On such perls, this module will install with
  no non-core dependencies, and requires no C compiler.
  
  On older versions of perl before such syntax is available, it is currently
  provided instead using the L<Syntax::Keyword::Try> module, imported with a
  special set of options to configure it to recognise exactly and only the same
  syntax as the core perl feature, thus ensuring that any code using it will
  still continue to function on that newer perl.
  
  =cut
  
  =head1 KEYWORDS
  
  =head2 try
  
     try {
        STATEMENTS...
     }
     ...
  
  A C<try> statement provides the main body of code that will be invoked, and
  must be followed by a C<catch> statement. It may optionally be followed by
  a C<finally> statement.
  
  Execution of the C<try> statement itself begins from the block given to the
  statement and continues until either it throws an exception, or completes
  successfully by reaching the end of the block.
  
  The body of a C<try {}> block may contain a C<return> expression. If executed,
  such an expression will cause the entire containing function to return with
  the value provided. This is different from a plain C<eval {}> block, in which
  circumstance only the C<eval> itself would return, not the entire function.
  
  The body of a C<try {}> block may contain loop control expressions (C<redo>,
  C<next>, C<last>) which will have their usual effect on any loops that the
  C<try {}> block is contained by.
  
  The parsing rules for the set of statements (the C<try> block and its
  associated C<catch>) are such that they are parsed as a self-contained
  statement. Because of this, there is no need to end with a terminating
  semicolon.
  
  Even though it parses as a statement and not an expression, a C<try> block can
  still yield a value if it appears as the final statement in its containing
  C<sub> or C<do> block. For example:
  
     my $result = do {
        try { attempt_func() }
        catch ($e) { "Fallback Value" }
     };
  
  =head2 catch
  
     ...
     catch ($var) {
        STATEMENTS...
     }
  
  A C<catch> statement provides a block of code to the preceding C<try>
  statement that will be invoked in the case that the main block of code throws
  an exception. A new lexical variable is created to store the exception in.
  
  Presence of this C<catch> statement causes any exception thrown by the
  preceding C<try> block to be non-fatal to the surrounding code. If the
  C<catch> block wishes to optionally handle some exceptions but not others, it
  can re-raise it (or another exception) by calling C<die> in the usual manner.
  
  As with C<try>, the body of a C<catch {}> block may also contain a C<return>
  expression, which as before, has its usual meaning, causing the entire
  containing function to return with the given value. The body may also contain
  loop control expressions (C<redo>, C<next> or C<last>) which also have their
  usual effect.
  
  =head2 finally
  
     ...
     finally {
        STATEMENTS...
     }
  
  A C<finally> statement provides an optional block of code to the preceding
  C<try>/C<catch> pair which is executed afterwards, both in the case of a
  normal execution or a thrown exception. This code block may be used to
  provide whatever clean-up operations might be required by preceding code.
  
  Because it is executed during a stack cleanup operation, a C<finally {}> block
  may not cause the containing function to return, or to alter the return value
  of it. It also cannot see the containing function's C<@_> arguments array
  (though as it is block scoped within the function, it will continue to share
  any normal lexical variables declared up until that point). It is protected
  from disturbing the value of C<$@>. If the C<finally {}> block code throws an
  exception, this will be printed as a warning and discarded, leaving C<$@>
  containing the original exception, if one existed.
  =cut
  
  sub import
  {
     if( HAVE_FEATURE_TRY ) {
        feature->import(qw( try ));
        require warnings;
        warnings->unimport(qw( experimental::try ));
     }
     else {
        require Syntax::Keyword::Try;
        Syntax::Keyword::Try->VERSION( '0.27' );
        Syntax::Keyword::Try->import(qw( try -require_catch -require_var ));
     }
  }
  
  =head1 COMPATIBILITY NOTES
  
  This module may use either L<Syntax::Keyword::Try> or the perl core C<try>
  feature to implement its syntax. While the two behave very similarly, and both
  conform to the description given above, the following differences should be
  noted.
  
  =over 4
  
  =item * Visibility to C<caller()>
  
  The C<Syntax::Keyword::Try> module implements C<try> blocks by using C<eval>
  frames. As a result, they are visible to the C<caller()> function and hence to
  things like C<Carp::longmess> when viewed as stack traces.
  
  By comparison, core's C<feature 'try'> creates a new kind of context stack
  entry that is ignored by C<caller()> and hence these blocks do not show up in
  stack traces.
  
  This should not matter to most use-cases - e.g. even C<Carp::croak> will be
  fine here. But if you are using C<caller()> with calculated indexes to inspect
  the state of callers to your code and there may be C<try> frames in the way,
  you will need to somehow account for the difference in stack height.
  
  =item * C<B::Deparse>
  
  The core C<feature 'try'> is implemented by emitting real opcodes that
  represent its behaviour, which is recognised by the version of L<B::Deparse>
  that ships with core perl. As a result, any code using this implementation
  will deparse currently with tools like C<perl -MO=Deparse ...>, or others
  related to it such as coverage checkers.
  
  By comparison, since C<Syntax::Keyword::Try> uses C<OP_CUSTOM> it is not
  recognised by C<B::Deparse> and so attempts to deparse this will result in
  error messages like
  
     unexpected OP_CUSTOM (catch) at ...
  
  This is rather unavoidable due to the way that C<B::Deparse> is implemented
  and does not easily support custom operators.
  
  See also L<https://rt.cpan.org/Ticket/Display.html?id=134812>.
  
  =back
  
  =cut
  
  =head1 AUTHOR
  
  Paul Evans <leonerd@leonerd.org.uk>
  
  =cut
  
  0x55AA;
FEATURE_COMPAT_TRY

$fatpacked{"File/Slurp/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SLURP_TINY';
  package File::Slurp::Tiny;
  $File::Slurp::Tiny::VERSION = '0.004';
  use strict;
  use warnings;
  
  use Carp 'croak';
  use Exporter 5.57 'import';
  use File::Spec::Functions 'catfile';
  use FileHandle;
  our @EXPORT_OK = qw/read_file read_lines write_file read_dir/;
  
  my $default_layer = $^O eq 'MSWin32' ? ':crlf' : ':unix';
  
  sub read_file {
  	my ($filename, %options) = @_;
  	my $layer = $options{binmode} || $default_layer;
  	my $buf_ref = defined $options{buf_ref} ? $options{buf_ref} : \my $buf;
  
  	open my $fh, "<$layer", $filename or croak "Couldn't open $filename: $!";
  	if (my $size = -s $fh) {
  		my ($pos, $read) = 0;
  		do {
  			defined($read = read $fh, ${$buf_ref}, $size - $pos, $pos) or croak "Couldn't read $filename: $!";
  			$pos += $read;
  		} while ($read && $pos < $size);
  	}
  	else {
  		${$buf_ref} = do { local $/; <$fh> };
  	}
  	close $fh;
  	return if not defined wantarray or $options{buf_ref};
  	return $options{scalar_ref} ? $buf_ref : $buf;
  }
  
  sub read_lines {
  	my ($filename, %options) = @_;
  	my $layer = delete $options{binmode} || ':';
  	
  	open my $fh, "<$layer", $filename or croak "Couldn't open $filename: $!";
  	return <$fh> if not %options;
  	my @buf = <$fh>;
  	close $fh;
  	chomp @buf if $options{chomp};
  	return $options{array_ref} ? \@buf : @buf;
  }
  
  sub write_file {
  	my ($filename, undef, %options) = @_;
  	my $layer = $options{binmode} || $default_layer;
  	my $mode = $options{append} ? '>>' : '>';
  	my $buf_ref = defined $options{buf_ref} ? $options{buf_ref} : \$_[1];
  
  	open my $fh, $mode.$layer, $filename or croak "Couldn't open $filename: $!";
  	$fh->autoflush(1);
  	print $fh ${$buf_ref} or croak "Couldn't write to $filename: $!";
  	close $fh or croak "Couldn't close $filename: $!";
  	return;
  }
  
  sub read_dir {
  	my ($dirname, %options) = @_;
  	opendir my ($dir), $dirname or croak "Could not open $dirname: $!";
  	my @ret = grep { not m/ \A \.\.? \z /x } readdir $dir;
  	@ret = map { catfile($dirname, $_) } @ret if $options{prefix};
  	closedir $dir;
  	return @ret;
  }
  
  1;
  
  # ABSTRACT: A simple, sane and efficient file slurper [DISCOURAGED]
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  File::Slurp::Tiny - A simple, sane and efficient file slurper [DISCOURAGED]
  
  =head1 VERSION
  
  version 0.004
  
  =head1 SYNOPSIS
  
   use File::Slurp::Tiny 'read_file';
   my $content = read_file($filename);
  
  =head1 DISCOURAGED
  
  B<This module is discouraged in favor of L<File::Slurper|File::Slurper>>. While a useful experiment, it turned out to be both too similar to File::Slurp (still containing most problematic features of File::Slurp's interface) and yet not similar enough to be a true drop-in replacement.
  
  Bugs will still be fixed, but new features will probably not be added.
  
  =head1 DESCRIPTION
  
  This module provides functions for fast and correct slurping and spewing. All functions are optionally exported.
  
  =head1 FUNCTIONS
  
  =head2 read_file($filename, %options)
  
  Reads file C<$filename> into a scalar. By default it returns this scalar. Can optionally take these named arguments:
  
  =over 4
  
  =item * binmode
  
  Set the layers to read the file with. The default will be something sensible on your platform.
  
  =item * buf_ref
  
  Pass a reference to a scalar to read the file into, instead of returning it by value. This has performance benefits.
  
  =item * scalar_ref
  
  If set to true, C<read_file> will return a reference to a scalar containing the file content.
  
  =back
  
  =head2 read_lines($filename, %options)
  
  Reads file C<$filename> into a list/array. By default it returns this list. Can optionally take these named arguments:
  
  =over 4
  
  =item * binmode
  
  Set the layers to read the file with. The default will be something sensible on your platform.
  
  =item * array_ref
  
  Pass a reference to an array to read the lines into, instead of returning them by value. This has performance benefits.
  
  =item * chomp
  
  C<chomp> the lines.
  
  =back
  
  =head2 write_file($filename, $content, %options)
  
  Open C<$filename>, and write C<$content> to it. Can optionally take this named argument:
  
  =over 4
  
  =item * binmode
  
  Set the layers to write the file with. The default will be something sensible on your platform.
  
  =back
  
  =head2 read_dir($dirname, %options)
  
  Open C<dirname> and return all entries except C<.> and C<..>. Can optionally take this named argument:
  
  =over 4
  
  =item * prefix
  
  This will prepend C<$dir> to the entries
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Path::Tiny>
  
  A minimalistic abstraction not only around 
  
  =item * L<File::Slurp>
  
  Another file slurping tool.
  
  =back
  
  =head1 AUTHOR
  
  Leon Timmermans <leont@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Leon Timmermans.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
FILE_SLURP_TINY

$fatpacked{"Net/OpenSSH.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH';
  package Net::OpenSSH;
  
  our $VERSION = '0.80';
  
  use strict;
  use warnings;
  
  our $debug ||= 0;
  our $debug_fh ||= \*STDERR;
  
  our $FACTORY;
  
  use Carp qw(carp croak);
  use POSIX qw(:sys_wait_h);
  use Socket;
  use File::Spec;
  use Cwd ();
  use Scalar::Util ();
  use Errno ();
  use Net::OpenSSH::Constants qw(:error :_state);
  use Net::OpenSSH::ModuleLoader;
  use Net::OpenSSH::ShellQuoter;
  use Digest::MD5;
  
  my $thread_generation = 0;
  
  sub CLONE { $thread_generation++ };
  
  sub _debug {
      local ($!, $@);
      print {$debug_fh} '# ', (map { defined($_) ? $_ : '<undef>' } @_), "\n"
  }
  
  sub _debug_dump {
      local ($!, $@);
      require Data::Dumper;
      local $Data::Dumper::Terse = 1;
      local $Data::Dumper::Indent = 0;
      my $head = shift;
      _debug("$head: ", Data::Dumper::Dumper(@_));
  }
  
  sub _hexdump {
      no warnings qw(uninitialized);
      my $data = shift;
      while ($data =~ /(.{1,32})/smg) {
          my $line=$1;
          my @c= (( map { sprintf "%02x",$_ } unpack('C*', $line)),
                  (("  ") x 32))[0..31];
          $line=~s/(.)/ my $c=$1; unpack("c",$c)>=32 ? $c : '.' /egms;
          print {$debug_fh} "#> ", join(" ", @c, '|', $line), "\n";
      }
  }
  
  {
      my %good;
  
      sub _sub_options {
          my $sub = shift;
          $good{__PACKAGE__ . "::$sub"} = { map { $_ => 1 } @_ };
      }
  
      sub _croak_bad_options (\%) {
          my $opts = shift;
          if (%$opts) {
  	    my $sub = (caller 1)[3];
              my $good = $good{$sub};
              my @keys = grep defined($opts->{$_}), ( $good ? grep !$good->{$_}, keys %$opts : keys %$opts);
              if (@keys) {
                  croak "Invalid or bad combination of options ('" . CORE::join("', '", @keys) . "')";
              }
          }
      }
  }
  
  sub _croak_scalar_context {
      my ($sub, $wantarray) = (caller 1)[3, 5];
      unless ($wantarray) {
          $sub =~ s/^.*:://;
          croak "method '$sub' called in scalar context";
      }
  }
  
  sub _tcroak {
      if (${^TAINT} > 0) {
  	push @_, " while running with -T switch";
          goto &croak;
      }
      if (${^TAINT} < 0) {
  	push @_, " while running with -t switch";
          goto &carp;
      }
  }
  
  sub _catch_tainted_args {
      my $i;
      for (@_) {
          next unless $i++;
          if (Scalar::Util::tainted($_)) {
              my (undef, undef, undef, $subn) = caller 1;
              my $msg = ( $subn =~ /::([a-z]\w*)$/
                          ? "Insecure argument '$_' on '$1' method call"
                          : "Insecure argument '$_' on method call" );
              _tcroak($msg);
          }
          elsif (ref($_) eq 'HASH') {
              for (grep Scalar::Util::tainted($_), values %$_) {
  		my (undef, undef, undef, $subn) = caller 1;
  		my $msg = ( $subn =~ /::([a-z]\w*)$/
  			    ? "Insecure argument on '$1' method call"
  			    : "Insecure argument on method call" );
  		_tcroak($msg);
              }
          }
      }
  }
  
  sub _set_error {
      my $self = shift;
      my $code = shift || 0;
      my @extra = grep defined, @_;
      my $err = $self->{_error} = ( $code
                                    ? Scalar::Util::dualvar($code, join(': ', @{$self->{_error_prefix}},
                                                                        (@extra ? @extra : "Unknown error $code")))
                                    : 0 );
      $debug and $debug & 1 and _debug "set_error($code - $err)";
      return $err
  }
  
  my $check_eval_re = do {
      my $path = quotemeta $INC{"Net/OpenSSH.pm"};
      qr/at $path line \d+.$/
  };
  
  sub _check_eval_ok {
      my ($self, $code) = @_;
      if ($@) {
          my $err = $@;
          $err =~ s/$check_eval_re//;
          $self->_set_error($code, $err);
          return;
      }
      1
  }
  
  sub _or_set_error {
      my $self = shift;
      $self->{_error} or $self->_set_error(@_);
  }
  
  sub _first_defined { defined && return $_ for @_; return }
  
  my $obfuscate = sub {
      # just for the casual observer...
      my $txt = shift;
      $txt =~ s/(.)/chr(ord($1) ^ 47)/ges
          if defined $txt;
      $txt;
  };
  
  my $deobfuscate = $obfuscate;
  
  # regexp from Regexp::IPv6
  my $IPv6_re = qr((?-xism::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))));
  
  sub parse_connection_opts {
      my ($class, $opts) = @_;
      my ($user, $passwd, $ipv6, $host, $port, $host_squared);
  
      my $target = delete $opts->{host};
      defined $target or croak "mandatory host argument missing";
  
      ($user, $passwd, $ipv6, $host, $port) =
          $target =~ m{^
                         \s*               # space
                         (?:
                           ([^:]+)         # username
                           (?::(.*))?      # : password
                           \@              # @
                         )?
                         (?:               # host
                            (              #   IPv6...
                              \[$IPv6_re(?:\%[^\[\]]*)\] #     [IPv6]
                              |            #     or
                              $IPv6_re     #     IPv6
                            )
                            |              #   or
                            ([^\[\]\@:]+)  #   hostname / ipv4
                         )
                         (?::([^\@:]+))?   # port
                         \s*               # space
                       $}ix
                  or croak "bad host/target '$target' specification";
  
      if (defined $ipv6) {
          ($host) = $ipv6 =~ /^\[?(.*?)\]?$/;
          $host_squared = "[$host]";
      }
      else {
          $host_squared = $host;
      }
  
      $user = delete $opts->{user} unless defined $user;
      $port = delete $opts->{port} unless defined $port;
      $passwd = delete $opts->{passwd} unless defined $passwd;
      $passwd = delete $opts->{password} unless defined $passwd;
  
      wantarray and return ($host, $port, $user, $passwd, $host_squared);
  
      my %r = ( user => $user,
                password => $passwd,
                host => $host,
                host_squared => $host_squared,
                port => $port );
      $r{ipv6} = 1 if defined $ipv6;
      return \%r;
  }
  
  my $sizeof_sun_path = ($^O eq 'linux' ? 108 :
                         $^O =~ /bsd/i  ? 104 :
                         $^O eq 'hpux'  ? 92  : undef);
  
  sub new {
      ${^TAINT} and &_catch_tainted_args;
  
      my $class = shift;
      @_ & 1 and unshift @_, 'host';
  
      return $FACTORY->($class, @_) if defined $FACTORY;
  
      my %opts = @_;
  
      my $external_master = delete $opts{external_master};
      # reuse_master is an obsolete alias:
      $external_master = delete $opts{reuse_master} unless defined $external_master;
  
      if (not defined $opts{host} and defined $external_master) {
          $opts{host} = '0.0.0.0';
      }
  
      my ($host, $port, $user, $passwd, $host_squared) = $class->parse_connection_opts(\%opts);
  
      my ($passphrase, $key_path, $login_handler);
      unless (defined $passwd) {
          $key_path = delete $opts{key_path};
          $passwd = delete $opts{passphrase};
          if (defined $passwd) {
              $passphrase = 1;
          }
          else {
              $login_handler = delete $opts{login_handler};
          }
      }
  
      my $ssh_version = delete $opts{ssh_version};
      my $batch_mode = delete $opts{batch_mode};
      my $ctl_path = delete $opts{ctl_path};
      my $ctl_dir = delete $opts{ctl_dir};
      my $proxy_command = delete $opts{proxy_command};
      my $gateway = delete $opts{gateway} unless defined $proxy_command;
      my $ssh_cmd = _first_defined delete $opts{ssh_cmd}, 'ssh';
      my $rsync_cmd = _first_defined delete $opts{rsync_cmd}, 'rsync';
      my $scp_cmd = delete $opts{scp_cmd};
      my $sshfs_cmd = _first_defined delete $opts{sshfs_cmd}, 'sshfs';
      my $sftp_server_cmd = _first_defined delete $opts{sftp_server_cmd},
                                           '/usr/lib/openssh/sftp-server';
      my $timeout = delete $opts{timeout};
      my $kill_ssh_on_timeout = delete $opts{kill_ssh_on_timeout};
      my $strict_mode = _first_defined delete $opts{strict_mode}, 1;
      my $connect = _first_defined delete $opts{connect}, 1;
      my $async = delete $opts{async};
      my $remote_shell = _first_defined delete $opts{remote_shell}, 'POSIX';
      my $expand_vars = delete $opts{expand_vars};
      my $vars = _first_defined delete $opts{vars}, {};
      my $default_encoding = delete $opts{default_encoding};
      my $default_stream_encoding =
          _first_defined delete $opts{default_stream_encoding}, $default_encoding;
      my $default_argument_encoding =
          _first_defined delete $opts{default_argument_encoding}, $default_encoding;
      my $forward_agent = delete $opts{forward_agent};
      $forward_agent and $passphrase and
          croak "agent forwarding can not be used when a passphrase has also been given";
      my $forward_X11 = delete $opts{forward_X11};
      my $passwd_prompt = delete $opts{password_prompt};
      my $master_pty_force = delete $opts{master_pty_force};
      $passwd_prompt = delete $opts{passwd_prompt} unless defined $passwd_prompt;
  
      my ($master_opts, @master_opts,
          $master_stdout_fh, $master_stderr_fh,
  	$master_stdout_discard, $master_stderr_discard,
          $master_setpgrp);
      unless ($external_master) {
          ($master_stdout_fh = delete $opts{master_stdout_fh} or
           $master_stdout_discard = delete $opts{master_stdout_discard});
  
          ($master_stderr_fh = delete $opts{master_stderr_fh} or
           $master_stderr_discard = delete $opts{master_stderr_discard});
  
          $master_opts = delete $opts{master_opts};
          if (defined $master_opts) {
              if (ref $master_opts) {
                  @master_opts = @$master_opts;
              }
              else {
                  carp "'master_opts' argument looks like if it should be splited first"
                      if $master_opts =~ /^-\w\s+\S/;
                  @master_opts = $master_opts;
              }
          }
          $master_setpgrp = delete $opts{master_setpgrp};
  
          # when a password/passphrase is given, calling setpgrp is
          # useless because the process runs attached to a different tty
          undef $master_setpgrp if $login_handler or defined $passwd;
      }
  
      my $default_ssh_opts = delete $opts{default_ssh_opts};
      carp "'default_ssh_opts' argument looks like if it should be splited first"
          if defined $default_ssh_opts and not ref $default_ssh_opts and $default_ssh_opts =~ /^-\w\s+\S/;
  
      my ($default_stdout_fh, $default_stderr_fh, $default_stdin_fh,
  	$default_stdout_file, $default_stderr_file, $default_stdin_file,
  	$default_stdout_discard, $default_stderr_discard, $default_stdin_discard);
  
      $default_stdout_file = (delete $opts{default_stdout_discard}
  			    ? '/dev/null'
  			    : delete $opts{default_stdout_file});
      $default_stdout_fh = delete $opts{default_stdout_fh}
  	unless defined $default_stdout_file;
  
      $default_stderr_file = (delete $opts{default_stderr_discard}
  			    ? '/dev/null'
  			    : delete $opts{default_stderr_file});
      $default_stderr_fh = delete $opts{default_stderr_fh}
  	unless defined $default_stderr_file;
  
      $default_stdin_file = (delete $opts{default_stdin_discard}
  			    ? '/dev/null'
  			    : delete $opts{default_stdin_file});
      $default_stdin_fh = delete $opts{default_stdin_fh}
  	unless defined $default_stdin_file;
  
      _croak_bad_options %opts;
  
      my @ssh_opts;
      # TODO: are those options really requiered or just do they eat on
      # the command line limited length?
      push @ssh_opts, -l => $user if defined $user;
      push @ssh_opts, -p => $port if defined $port;
  
      my $home = do {
  	local ($@, $SIG{__DIE__});
  	eval { Cwd::realpath((getpwuid $>)[7]) }
      };
  
      if (${^TAINT}) {
  	($home) = $home =~ /^(.*)$/;
  	Scalar::Util::tainted($ENV{PATH}) and
  		_tcroak('Insecure $ENV{PATH}');
      }
  
      my $self = { _error => 0,
  		 _error_prefix => [],
  		 _perl_pid => $$,
                   _thread_generation => $thread_generation,
                   _ssh_version => $ssh_version,
                   _ssh_cmd => $ssh_cmd,
  		 _scp_cmd => $scp_cmd,
  		 _rsync_cmd => $rsync_cmd,
                   _sshfs_cmd => $sshfs_cmd,
                   _sftp_server_cmd => $sftp_server_cmd,
                   _pid => undef,
                   _host => $host,
  		 _host_squared => $host_squared,
                   _user => $user,
                   _port => $port,
                   _passwd => $obfuscate->($passwd),
                   _passwd_prompt => $passwd_prompt,
                   _passphrase => $passphrase,
                   _key_path => $key_path,
                   _login_handler => $login_handler,
                   _timeout => $timeout,
                   _proxy_command => $proxy_command,
                   _gateway_args => $gateway,
                   _kill_ssh_on_timeout => $kill_ssh_on_timeout,
                   _batch_mode => $batch_mode,
                   _home => $home,
                   _forward_agent => $forward_agent,
                   _forward_X11 => $forward_X11,
                   _external_master => $external_master,
                   _default_ssh_opts => $default_ssh_opts,
  		 _default_stdin_fh => $default_stdin_fh,
  		 _default_stdout_fh => $default_stdout_fh,
  		 _default_stderr_fh => $default_stderr_fh,
  		 _master_stdout_fh => $master_stdout_fh,
  		 _master_stderr_fh => $master_stderr_fh,
  		 _master_stdout_discard => $master_stdout_discard,
  		 _master_stderr_discard => $master_stderr_discard,
                   _master_setpgrp => $master_setpgrp,
                   _master_pty_force => $master_pty_force,
  		 _remote_shell => $remote_shell,
                   _default_stream_encoding => $default_stream_encoding,
                   _default_argument_encoding => $default_argument_encoding,
  		 _expand_vars => $expand_vars,
  		 _vars => $vars,
                   _master_state => _STATE_START,
                 };
      bless $self, $class;
  
      $self->_detect_ssh_version;
  
      # default file handles are opened so late in order to have the
      # $self object to report errors
      $self->{_default_stdout_fh} = $self->_open_file('>', $default_stdout_file)
  	if defined $default_stdout_file;
      $self->{_default_stderr_fh} = $self->_open_file('>', $default_stderr_file)
  	if defined $default_stderr_file;
      $self->{_default_stdin_fh} = $self->_open_file('<', $default_stdin_file)
  	if defined $default_stdin_file;
  
      if ($self->{_error} == OSSH_SLAVE_PIPE_FAILED) {
          $self->_master_fail($async, "Unable to create default slave stream", $self->{_error});
          return $self;
      }
  
      $self->{_ssh_opts} = [$self->_expand_vars(@ssh_opts)];
      $self->{_master_opts} = [$self->_expand_vars(@master_opts)];
  
      $ctl_path = $self->_expand_vars($ctl_path);
      $ctl_dir = $self->_expand_vars($ctl_dir);
  
      if  (defined $ctl_path) {
          if ($external_master) {
              unless (-S $ctl_path) {
                  $self->_master_fail($async, "ctl_path $ctl_path does not point to a socket");
                  return $self;
              }
          }
          else {
              if (-e $ctl_path) {
                  $self->_master_fail($async, "unable to use ctl_path $ctl_path, a file object already exists there");
                  return $self;
              }
          }
      }
      else {
          $external_master and croak "external_master is set but ctl_path is not defined";
  
          unless (defined $ctl_dir) {
              unless (defined $self->{_home}) {
                  $self->_master_fail($async, "unable to determine home directory for uid $>");
                  return $self;
              }
  
              $ctl_dir = File::Spec->catdir($self->{_home}, ".libnet-openssh-perl");
          }
  
          mkdir $ctl_dir, 0700;
          unless (-d $ctl_dir) {
              $self->_master_fail($async, "unable to create ctl_dir $ctl_dir");
              return $self;
          }
  
          my $target = join('-', grep defined, $user, $host, $port);
  
          for (1..10) {
              my $ctl_file = Digest::MD5::md5_hex(sprintf "%s-%d-%d-%d", $target, $$, time, rand 1e6);
              $ctl_path = File::Spec->join($ctl_dir, $ctl_file);
              last unless -e $ctl_path
          }
          if (-e $ctl_path) {
              $self->_master_fail($async, "unable to find unused name for ctl_path inside ctl_dir $ctl_dir");
              return $self;
          }
      }
  
      if (defined $sizeof_sun_path and length $ctl_path > $sizeof_sun_path) {
          $self->_master_fail($async, "ctl_path $ctl_path is too long (max permissible size for $^O is $sizeof_sun_path)");
          return $self;
      }
  
      $ctl_dir = File::Spec->catpath((File::Spec->splitpath($ctl_path))[0,1], "");
      $debug and $debug & 2 and _debug "ctl_path: $ctl_path, ctl_dir: $ctl_dir";
  
      if ($strict_mode and !$self->_is_secure_path($ctl_dir)) {
   	$self->_master_fail($async, "ctl_dir $ctl_dir is not secure");
   	return $self;
      }
  
      $self->{_ctl_path} = $ctl_path;
  
      $self->_master_wait($async) if $connect;
  
      $self;
  }
  
  sub get_user { shift->{_user} }
  sub get_host { shift->{_host} }
  sub get_port { shift->{_port} }
  sub get_master_pid { shift->{_pid} }
  sub get_ctl_path { shift->{_ctl_path} }
  sub get_expand_vars { shift->{_expand_vars} }
  
  sub get_master_pty_log { shift->{_master_pty_log} }
  
  sub set_expand_vars {
      my $self = shift;
      $self->{_expand_vars} = (shift(@_) ? 1 : 0);
  }
  
  sub set_var {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my $k = shift;
      $k =~ /^(?:USER|HOST|PORT)$/
  	and croak "internal variable %$k% can not be set";
      $self->{_vars}{$k} = shift;
  }
  
  sub get_var {
      my ($self, $k) = @_;
      my $v = ( $k =~ /^(?:USER|HOST|PORT)$/
  	      ? $self->{lc "_$k"}
  	      : $self->{_vars}{$k} );
      (defined $v ? $v : '');
  }
  
  sub _expand_vars {
      my ($self, @str) = @_;
      if (ref $self and $self->{_expand_vars}) {
  	for (@str) {
  	    s{%(\w*)%}{length ($1) ? $self->get_var($1) : '%'}ge
  		if defined $_;
  	}
      }
      wantarray ? @str : $str[0]
  }
  
  sub error { shift->{_error} }
  
  sub die_on_error {
      my $ssh = shift;
      $ssh->{_error} and croak(@_ ? "@_: $ssh->{_error}" : $ssh->{_error});
  }
  
  
  sub _is_secure_path {
      my ($self, $path) = @_;
      my @parts = File::Spec->splitdir(Cwd::realpath($path));
      my $home = $self->{_home};
      for my $last (reverse 0..$#parts) {
          my $dir = File::Spec->catdir(@parts[0..$last]);
          unless (-d $dir) {
              $debug and $debug & 2 and _debug "$dir is not a directory";
              return undef;
          }
          my ($mode, $uid) = (stat $dir)[2, 4];
          $debug and $debug & 2 and _debug "_is_secure_path(dir: $dir, file mode: $mode, file uid: $uid, euid: $>";
          return undef unless(($uid == $> or $uid == 0 ) and (($mode & 022) == 0 or ($mode & 01000)));
          return 1 if (defined $home and $home eq $dir);
      }
      return 1;
  }
  
  sub _detect_ssh_version {
      my $self = shift;
      if (defined $self->{_ssh_version}) {
          $debug and $debug & 4 and _debug "ssh version given as $self->{_ssh_version}";
      }
      else {
          my (undef, $out, undef, $pid) = $self->open_ex({_cmd => 'raw',
                                                          _no_master_required => 1,
                                                          stdout_pipe => 1,
                                                          stdin_discard => 1,
                                                          stderr_to_stdout => 1 },
                                                         $self->{_ssh_cmd}, '-V');
          my ($txt) = $self->_io3($out, undef, undef, undef, 10, 'bytes');
          local $self->{_kill_ssh_on_timeout} = 1;
          $self->_waitpid($pid, 10);
          if (my ($full, $num) = $txt =~ /^OpenSSH_((\d+\.\d+)\S*)/mi) {
              $debug and $debug & 4 and _debug "OpenSSH version is $full";
              $self->{_ssh_version} = $num;
          }
          else {
              $self->{_ssh_version} = 0;
              $debug and $debug & 4 and _debug "unable to determine version, '$self->{_ssh_cmd} -V', output:\n$txt"
          }
      }
  }
  
  sub _make_ssh_call {
      my $self = shift;
      my @before = @{shift || []};
      my @args = ($self->{_ssh_cmd}, @before,
  		-S => $self->{_ctl_path},
                  @{$self->{_ssh_opts}}, $self->{_host},
                  '--',
                  (@_ ? "@_" : ()));
      $debug and $debug & 8 and _debug_dump 'call args' => \@args;
      @args;
  }
  
  sub _scp_cmd {
      my $self = shift;
      $self->{_scp_cmd} ||= do {
  	my $scp = $self->{_ssh_cmd};
  	$scp =~ s/ssh$/scp/i or croak "scp command name not set";
  	$scp;
      }
  }
  
  sub _make_scp_call {
      my $self = shift;
      my @before = @{shift || []};
      my @args = ($self->_scp_cmd, @before,
  		-o => "ControlPath=$self->{_ctl_path}",
                  -S => $self->{_ssh_cmd},
                  (defined $self->{_port} ? (-P => $self->{_port}) : ()),
                  '--', @_);
  
      $debug and $debug & 8 and _debug_dump 'scp call args' => \@args;
      @args;
  }
  
  sub _rsync_quote {
      my ($self, @args) = @_;
      for (@args) {
  	if (/['"\s]/) {
  	    s/"/""/g;
  	    $_ = qq|"$_"|;
  	}
  	s/%/%%/;
      }
      wantarray ? @args : join(' ', @args);
  }
  
  sub _make_rsync_call {
      my $self = shift;
      my $before = shift;
      my @transport = ($self->{_ssh_cmd}, @$before,
                      -S => $self->{_ctl_path});
      my $transport = $self->_rsync_quote(@transport);
      my @args = ( $self->{_rsync_cmd},
  		 -e => $transport,
  		 @_);
  
      $debug and $debug & 8 and _debug_dump 'rsync call args' => \@args;
      @args;
  }
  
  sub _make_W_option {
      my $self = shift;
      if (@_ == 1) {
          my $path = shift;
          $path = "./$path" unless $path =~ m|/|;
          $path =~ s/([\\:])/\\$1/g;
          return "-W$path";
      }
      if (@_ == 2) {
          return "-W" . join(':', @_);
      }
      croak "bad number of arguments for creating a tunnel"
  }
  
  sub _make_tunnel_call {
      my $self = shift;
      my @before = @{shift||[]};
      push @before, $self->_make_W_option(@_);
      my @args = $self->_make_ssh_call(\@before);
      $debug and $debug & 8 and _debug_dump 'tunnel call args' => \@args;
      @args;
  }
  
  sub master_exited {
      my $self = shift;
      $self->_master_gone(1)
  }
  
  sub _master_gone {
      my $self = shift;
      my $async = shift;
      delete $self->{_pid};
      $self->_master_fail($async, (@_ ? @_ : "master process exited unexpectedly"));
  }
  
  my @kill_signal = qw(0 0 TERM TERM TERM KILL);
  
  sub __has_sigchld_handle {
      my $h = $SIG{CHLD};
      defined $h and $h ne 'IGNORE' and $h ne 'DEFAULT'
  }
  
  sub _master_kill {
      my ($self, $async) = @_;
  
      if (my $pid = $self->_my_master_pid) {
          $debug and $debug & 32 and _debug '_master_kill: ', $pid;
  
          my $now = time;
          my $start = $self->{_master_kill_start} ||= $now;
          $self->{_master_kill_last} ||= $now;
          $self->{_master_kill_count} ||= 0;
  
          local $SIG{CHLD} = sub {} unless $async or __has_sigchld_handle;
          while (1) {
              if ($self->{_master_kill_last} < $now) {
                  $self->{_master_kill_last} = $now;
                  my $sig = $kill_signal[$self->{_master_kill_count}++];
                  $sig = 'KILL' unless defined $sig;
                  $debug and $debug & 32 and _debug "killing master $$ with signal $sig";
                  kill $sig, $pid;
              }
              my $deceased = waitpid($pid, WNOHANG);
              $debug and $debug & 32 and _debug "waitpid(master: $pid) => pid: $deceased, rc: $!";
              last if $deceased == $pid or ($deceased < 0 and $! == Errno::ECHILD());
              if ($self->{_master_kill_count} > 20) {
                  # FIXME: remove the hard-coded 20 retries?
                  $debug and $debug & 32 and _debug "unable to kill SSH master process, giving up";
                  last;
              }
              return if $async;
              select(undef, undef, undef, 0.2);
              $now = time;
          }
      }
      else {
          $debug and $debug & 32 and _debug("not killing master SSH (", $self->{_pid}, ") started from " .
                                            "process ", $self->{_perl_pid}, "/", $self->{_thread_generation},
                                            ", current ", $$, "/", $thread_generation, ")");
      }
      $self->_master_gone($async);
  }
  
  sub disconnect {
      my ($self, $async) = @_;
      @_ <= 2 or croak 'Usage: $self->disconnect([$async])';
      $self->_disconnect($async, 1);
  }
  
  sub disown_master {
      my $self = shift;
      if (my $pid = $self->_my_master_pid) {
          if ($self->wait_for_master) {
              $self->{_external_master} = 1;
              return $pid;
          }
      }
      undef;
  }
  
  sub restart {
      my ($self, $async) = @_;
      $self->{_external_master} and croak "Can restart SSH connection when using external master";
  
      # user is responsible for calling us in STATE_GONE in async mode
      $self->_disconnect($async, 1) unless $async;
  
      if ($self->{_master_state} != _STATE_GONE) {
  	croak "restart method called in wrong state (terminate the connection first!)" if $async;
  	return $self->_master_fail($async, "Unable to restart SSH session from state $self->{_master_state}")
      }
  
      # These slots should be deleted when exiting the KILLING state but
      # I like keeping them around for throubleshoting purposes.
      delete $self->{_master_kill_start};
      delete $self->{_master_kill_last};
      delete $self->{_master_kill_count};
      $self->_master_jump_state(_STATE_START, $async);
  }
  
  sub _my_master_pid {
      my $self = shift;
      unless ($self->{_external_master}) {
          my $pid = $self->{_pid};
          return $pid if
              $pid and $self->{_perl_pid} == $$ and $self->{_thread_generation} == $thread_generation;
      }
      ()
  }
  
  sub _disconnect {
      my ($self, $async, $send_ctl) = @_;
      return if $self->{_master_state} == _STATE_GONE;
  
      if (!$async and
          $self->{_master_state} == _STATE_RUNNING and
          ($send_ctl or $self->_my_master_pid)) {
          # we have successfully created the master connection so we
          # can send control commands:
          $debug and $debug & 32 and _debug("sending exit control to master");
          $self->_master_ctl('exit');
      }
      $self->_master_fail($async, 'aborted')
  }
  
  sub _check_is_system_fh {
      my ($name, $fh) = @_;
      my $fn = fileno(defined $fh ? $fh : $name);
      defined $fn and $fn >= 0 and return;
      croak "child process $name is not a real system file handle";
  }
  
  sub _master_redirect {
      my $self = shift;
      my $uname = uc shift;
      my $name = lc $uname;
  
      no strict 'refs';
      if ($self->{"_master_${name}_discard"}) {
  	open *$uname, '>>', '/dev/null';
      }
      else {
  	my $fh = $self->{"_master_${name}_fh"};
  	$fh = $self->{"_default_${name}_fh"} unless defined $fh;
  	if (defined $fh) {
  	    _check_is_system_fh $uname => $fh;
  	    if (fileno $fh != fileno *$uname) {
  		open *$uname, '>>&', $fh or POSIX::_exit(255);
  	    }
  	}
      }
  }
  
  sub _waitpid {
      my ($self, $pid, $timeout) = @_;
      $? = 0;
      if ($pid) {
          $timeout = $self->{_timeout} unless defined $timeout;
  
          my $time_limit;
          if (defined $timeout and $self->{_kill_ssh_on_timeout}) {
              $timeout = 0 if $self->{_error} == OSSH_SLAVE_TIMEOUT;
              $time_limit = time + $timeout;
          }
          local $SIG{CHLD} = sub {} unless __has_sigchld_handle;
  	while (1) {
              my $deceased;
              if (defined $time_limit) {
                  while (1) {
                      # TODO: we assume that all OSs return 0 when the
                      # process is still running, that may be wrong!
                      $deceased = waitpid($pid, WNOHANG) and last;
                      my $remaining = $time_limit - time;
                      if ($remaining <= 0) {
                          $debug and $debug & 16 and _debug "killing SSH slave, pid: $pid";
                          kill TERM => $pid;
                          $self->_or_set_error(OSSH_SLAVE_TIMEOUT, "ssh slave failed", "timed out");
                      }
                      # There is a race condition here. We try to
                      # minimize it keeping the waitpid and the select
                      # together and limiting the sleep time to 1s:
                      my $sleep = ($remaining < 0.1 ? 0.1 : 1);
                      $debug and $debug & 16 and
                          _debug "waiting for slave, timeout: $timeout, remaining: $remaining, sleep: $sleep";
                      $deceased = waitpid($pid, WNOHANG) and last;
                      select(undef, undef, undef, $sleep);
                  }
              }
              else {
                  $deceased = waitpid($pid, 0);
              }
              $debug and $debug & 16 and _debug "_waitpid($pid) => pid: $deceased, rc: $?, err: $!";
  	    if ($deceased == $pid) {
  		if ($?) {
  		    my $signal = ($? & 255);
  		    my $errstr = "child exited with code " . ($? >> 8);
  		    $errstr .= ", signal $signal" if $signal;
  		    $self->_or_set_error(OSSH_SLAVE_CMD_FAILED, $errstr);
  		    return undef;
  		}
  		return 1;
  	    }
  	    elsif ($deceased < 0) {
  		# at this point $deceased < 0 and so, $! has a valid error value.
  		next if $! == Errno::EINTR();
  		if ($! == Errno::ECHILD()) {
  		    $self->_or_set_error(OSSH_SLAVE_FAILED, "child process $pid does not exist", $!);
  		    return undef
  		}
  		warn "Internal error: unexpected error (".($!+0).": $!) from waitpid($pid) = $deceased. Report it, please!";
  	    }
  	    elsif ($deceased > 0) {
  		warn "Internal error: spurious process $deceased exited"
  	    }
  
  	    # wait a bit before trying again
  	    select(undef, undef, undef, 0.1);
  	}
      }
      else {
  	$self->_or_set_error(OSSH_SLAVE_FAILED, "spawning of new process failed");
  	return undef;
      }
  }
  
  sub check_master {
      my $self = shift;
      @_ and croak 'Usage: $ssh->check_master()';
      $self->_master_check(0);
  }
  
  sub wait_for_master {
      my ($self, $async) = @_;
      @_ <= 2 or croak 'Usage: $ssh->wait_for_master([$async])';
      $self->{_error} = 0
          unless $self->{_error} == OSSH_MASTER_FAILED;
      $self->_master_wait($async);
  }
  
  sub _master_start {
      my ($self, $async) = @_;
      $self->_set_error;
  
      my $timeout = int((($self->{_timeout} || 90) + 2)/3);
      my $ssh_flags= '-2MN';
      $ssh_flags .= ($self->{_forward_agent} ? 'A' : 'a') if defined $self->{_forward_agent};
      $ssh_flags .= ($self->{_forward_X11} ? 'X' : 'x');
      my @master_opts = (@{$self->{_master_opts}},
                         -o => "ServerAliveInterval=$timeout",
                         ($self->{_ssh_version} >= 5.6 ? (-o => "ControlPersist=no") : ()),
                        $ssh_flags);
  
      my ($mpty, $use_pty, $pref_auths);
      $use_pty = 1 if ( $self->{_master_pty_force} or
                        defined $self->{_login_handler} );
      if (defined $self->{_passwd}) {
          $use_pty = 1;
          $pref_auths = ($self->{_passphrase}
                         ? 'publickey'
                         : 'keyboard-interactive,password');
          push @master_opts, -o => 'NumberOfPasswordPrompts=1';
      }
      elsif ($self->{_batch_mode}) {
          push @master_opts, -o => 'BatchMode=yes';
      }
  
      if (defined $self->{_key_path}) {
          $pref_auths = 'publickey';
          push @master_opts, -i => $self->{_key_path};
      }
  
      my $proxy_command = $self->{_proxy_command};
  
      my $gateway;
      if (my $gateway_args = $self->{_gateway_args}) {
          if (ref $gateway_args eq 'HASH') {
              _load_module('Net::OpenSSH::Gateway');
              my $errors;
              unless ($gateway = Net::OpenSSH::Gateway->find_gateway(errors => $errors,
                                                                     host => $self->{_host}, port => $self->{_port},
                                                                     %$gateway_args)) {
                  return $self->_master_fail($async, 'Unable to build gateway object', join(', ', @$errors));
              }
          }
          else {
              $gateway = $gateway_args
          }
          $self->{_gateway} = $gateway;
          $gateway->before_ssh_connect or
              return $self->_master_fail($async, 'Gateway setup failed', join(', ', $gateway->errors));
          $proxy_command = $gateway->proxy_command;
      }
  
      if (defined $proxy_command) {
          push @master_opts, -o => "ProxyCommand=$proxy_command";
      }
  
      if ($use_pty) {
          _load_module('IO::Pty');
          $self->{_mpty} = $mpty = IO::Pty->new;
      }
  
      push @master_opts, -o => "PreferredAuthentications=$pref_auths"
          if defined $pref_auths;
  
      my @call = $self->_make_ssh_call(\@master_opts);
  
      my $pid = fork;
      unless ($pid) {
          defined $pid
              or return $self->_master_fail($async, "unable to fork ssh master: $!");
  
          if ($debug and $debug & 512) {
              require Net::OpenSSH::OSTracer;
              Net::OpenSSH::OSTracer->trace;
          }
  
          $mpty->make_slave_controlling_terminal if $mpty;
  
  	$self->_master_redirect('STDOUT');
  	$self->_master_redirect('STDERR');
  
          delete $ENV{SSH_ASKPASS} if defined $self->{_passwd};
          delete $ENV{SSH_AUTH_SOCK} if defined $self->{_passphrase};
  
          setpgrp if $self->{_master_setpgrp};
  
  	local $SIG{__DIE__};
          eval { exec @call };
          POSIX::_exit(255);
      }
      $self->{_pid} = $pid;
      1;
  }
  
  sub _master_check {
      my ($self, $async) = @_;
      my $error;
      if ($async) {
          if (-S $self->{_ctl_path}) {
              delete $self->{_master_pty_log};
              return 1
          }
          $error = "master SSH connection broken";
      }
      else {
          my $out = $self->_master_ctl('check');
          $error = $self->{_error};
          unless ($error) {
              my $pid = $self->{_pid};
              if ($out =~ /pid=(\d+)/) {
                  if (!$pid or $1 == $pid) {
                      delete $self->{_master_pty_log};
                      return 1;
                  }
                  $error = "bad ssh master at $self->{_ctl_path} socket owned by pid $1 (pid $pid expected)";
              }
              else {
                  $error = ($out =~ /illegal option/i
                            ? 'OpenSSH 4.1 or later required'
                            : 'unknown error');
              }
          }
      }
      $self->_master_fail($async, $error);
  }
  
  sub _master_fail {
      my $self = shift;
      my $async = shift;
      if ($self->{_error} != OSSH_MASTER_FAILED) {
          $self->_set_error(OSSH_MASTER_FAILED, @_);
      }
      $self->_master_jump_state($self->{_pid} ? _STATE_KILLING : _STATE_GONE, $async);
  }
  
  sub _master_jump_state {
      my ($self, $state, $async) = @_;
      $debug and $debug & 4 and _debug "master state jumping from $self->{_master_state} to $state";
      if ($state == $self->{_master_state} and
          $state != _STATE_KILLING and
          $state != _STATE_GONE) {
          croak "internal error: state jump to itself ($state)!";
      }
      $self->{_master_state} = $state;
      return $self->_master_wait($async);
  }
  
  sub _master_wait {
      my ($self, $async) = @_;
  
      my $pid = $self->_my_master_pid;
      if ($pid) {
  	my $deceased = waitpid($pid, WNOHANG);
          if ($deceased == $pid or ($deceased < 0 and $! == Errno::ECHILD())) {
              $debug and $debug & 4 and _debug "master $pid exited, rc:", $?,", err: ",$!;
              return $self->_master_gone($async);
          }
      }
  
      if ($self->{_master_state} == _STATE_RUNNING) {
          return 1 if -S $self->{_ctl_path};
          return $self->_master_fail($async, "master SSH connection broken");
      }
  
      if ($self->{_master_state} == _STATE_KILLING) {
          $debug and $debug & 4 and _debug "killing master";
          return $self->_master_kill($async);
      }
  
      if ($self->{_master_state} == _STATE_START) {
          if ($self->{_external_master}) {
              return ($self->_master_jump_state(_STATE_RUNNING, $async) and
                      $self->_master_check($async))
          }
  
          $self->_master_start($async) or return;
          if ($self->{_mpty}) {
              $self->{_wfm_bout} = '';
              $self->{_master_pty_log} = '';
              if (defined $self->{_passwd} or $self->{_login_handler}) {
                  return $self->_master_jump_state(_STATE_LOGIN, $async);
              }
          }
          return $self->_master_jump_state(_STATE_AWAITING_MUX, $async);
      }
  
      if ($self->{_master_state} == _STATE_GONE) {
  	if (my $mpty = delete $self->{_mpty}) {
  	    close($mpty)
  	}
  	return 0;
      }
      if ($self->{_master_state} == _STATE_STOPPED) {
          return 0;
      }
  
      # At this point we are either in state AWAITIN_MUX or LOGIN
  
      local $self->{_error_prefix} = [@{$self->{_error_prefix}},
  				    "unable to establish master SSH connection"];
  
      $pid or return $self->_master_gone($async,
                                         "perl process was forked or threaded before SSH connection had been established");
  
      my $old_tcpgrp;
      if ($self->{_master_setpgrp} and not $async and
          not $self->{_batch_mode} and not $self->{_external_master}) {
          $old_tcpgrp = POSIX::tcgetpgrp(0);
          if ($old_tcpgrp > 0) {
              # let the master process ask for passwords at the TTY
              POSIX::tcsetpgrp(0, $pid);
          }
          else {
              undef $old_tcpgrp;
          }
      }
  
      my $mpty = $self->{_mpty};
      my $fnopty;
      my $rv = '';
      if ($mpty and 
          ( $self->{_master_state} == _STATE_LOGIN or
            $self->{_master_state} == _STATE_AWAITING_MUX )) {
          $fnopty = fileno $mpty;
          vec($rv, $fnopty, 1) = 1
      }
  
      my $timeout = $self->{_timeout};
      my $dt = ($async ? 0 : 0.02);
      my $start_time = time;
      my $error;
  
      # Loop until the mux socket appears or something goes wrong:
      while (1) {
          $dt *= 1.10 if $dt < 0.2; # adaptative delay
          if (-e $self->{_ctl_path}) {
              $debug and $debug & 4 and _debug "file object found at $self->{_ctl_path}";
              last;
          }
          $debug and $debug & 4 and _debug "file object not yet found at $self->{_ctl_path}, state:", $self->{_master_state};
  
          if (defined $timeout and (time - $start_time) > $timeout) {
              $error = "login timeout";
              last;
          }
  
  	my $deceased = waitpid($pid, WNOHANG);
          if ($deceased == $pid or ($deceased < 0 and $! == Errno::ECHILD())) {
              $error = "master process exited unexpectedly";
              $error = "bad pass" . ($self->{_passphrase} ? 'phrase' : 'word') . " or $error"
                  if defined $self->{_passwd};
              delete $self->{_pid};
              last;
          }
  
          if ($self->{_login_handler} and $self->{_master_state} == _STATE_LOGIN) {
              local ($@, $SIG{__DIE__});
              if (eval { $self->{_login_handler}->($self, $mpty, \$self->{_wfm_bout}) }) {
                  $self->{_master_state} = _STATE_AWAITING_MUX;
                  next;
              }
              if ($@) {
                  $error = "custom login handler failed: $@";
                  last;
              }
              # fallback
          }
          else {
              # we keep reading from mpty even after leaving state
              # STATE_LOGIN in order to search for additional password
              # prompts.
              my $rv1 = $rv;
              my $n = select($rv1, undef, undef, $dt);
              if ($n > 0) {
                  vec($rv1, $fnopty, 1) or die "internal error";
                  my $read = sysread($mpty, $self->{_wfm_bout}, 4096, length $self->{_wfm_bout});
                  if ($read) {
                      $self->{_master_pty_log} .= substr($self->{_wfm_bout}, -$read);
                      if ((my $remove = length($self->{_master_pty_log}) - 4096) > 0) {
                          substr($self->{_master_pty_log}, 0, $remove) = ''
                      }
  
                      if ($self->{_wfm_bout} =~ /The authenticity of host.*can't be established/si) {
                          $error = "the authenticity of the target host can't be established; the remote host " .
                              "public key is probably not present in the '~/.ssh/known_hosts' file";
                          last;
                      }
  
                      if ($self->{_wfm_bout} =~ /WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED/si) {
                          $error = "the authenticity of the target host can't be established; the remote host " .
                              "public key doesn't match the one stored locally";
                          last;
                      }
  
                      my $passwd_prompt = _first_defined $self->{_passwd_prompt}, qr/[:?]/;
                      $passwd_prompt = quotemeta $passwd_prompt unless ref $passwd_prompt;
  
                      if ($self->{_master_state} == _STATE_LOGIN) {
                          if ($self->{_wfm_bout} =~ /^(.*$passwd_prompt)/s) {
                              $debug and $debug & 4 and _debug "passwd/passphrase requested ($1)";
                              print $mpty $deobfuscate->($self->{_passwd}) . "\n";
                              $self->{_wfm_bout} = ''; # reset
                              $self->{_master_state} = _STATE_AWAITING_MUX;
                          }
                      }
                      elsif (length($passwd_prompt) and $self->{_wfm_bout} =~ /^(.*$passwd_prompt)\s*$/s) {
                          $debug and $debug & 4 and _debug "passwd/passphrase requested again ($1)";
                          $error = "password authentication failed";
                          last;
                      }
                      next; # skip delay
                  }
              }
          }
          return if $async;
          select(undef, undef, undef, $dt);
      }
  
      if (defined $old_tcpgrp) {
          $debug and $debug & 4 and
              _debug("ssh pid: $pid, pgrp: ", getpgrp($pid),
                     ", \$\$: ", $$,
                     ", tcpgrp: ", POSIX::tcgetpgrp(0),
                     ", old_tcppgrp: ", $old_tcpgrp);
          local $SIG{TTOU} = 'IGNORE';
          POSIX::tcsetpgrp(0, $old_tcpgrp);
      }
  
      if ($error) {
          return $self->_master_fail($async, $error);
      }
  
      $self->_master_jump_state(_STATE_RUNNING, $async)
          and $self->_master_check($async);
  }
  
  sub _master_ctl {
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      my $cmd = shift;
  
      local $?;
      local $self->{_error_prefix} = [@{$self->{_error_prefix}},
                                      "control command failed"];
      $self->capture({ %opts,
                       encoding => 'bytes', # don't let the encoding
  					  # stuff get in the way
  		     stdin_discard => 1, tty => 0,
                       stderr_to_stdout => 1, ssh_opts => [-O => $cmd]});
  }
  
  sub stop {
      my ($self, $timeout) = @_;
      my $pid = $self->{_pid};
      local $self->{_kill_ssh_on_timeout} = 1;
      $self->_master_ctl({timeout => $timeout}, 'stop');
      unless ($self->{_error}) {
          $self->_set_error(OSSH_MASTER_FAILED, "master stopped");
          $self->_master_jump_state(_STATE_STOPPED, 1);
      }
  }
  
  sub _make_pipe {
      my $self = shift;
      my ($r, $w);
      if (pipe $r, $w) {
          my $old = select;
          select $r; $ |= 1;
          select $w; $ |= 1;
          select $old;
          return ($r, $w);
      }
      $self->_set_error(OSSH_SLAVE_PIPE_FAILED, "unable to create pipe: $!");
      return;
  }
  
  sub _remote_quoter {
      my ($self, $remote_shell) = @_;
      if (ref $self and (!defined $remote_shell or $remote_shell eq $self->{_remote_shell})) {
          return $self->{remote_quoter} ||= Net::OpenSSH::ShellQuoter->quoter($self->{_remote_shell});
      }
      Net::OpenSSH::ShellQuoter->quoter($remote_shell);
  }
  
  sub _quote_args {
      my $self = shift;
      my $opts = shift;
      ref $opts eq 'HASH' or die "internal error";
      my $quote = delete $opts->{quote_args};
      my $quote_extended = delete $opts->{quote_args_extended};
      my $glob_quoting = delete $opts->{glob_quoting};
      $quote = (@_ > 1) unless defined $quote;
  
      if ($quote) {
          my $remote_shell = delete $opts->{remote_shell};
          my $quoter = $self->_remote_quoter($remote_shell);
          my $quote_method = ($glob_quoting ? 'quote_glob' : 'quote');
  	# foo   => $quoter
  	# \foo  => $quoter_glob
  	# \\foo => no quoting at all and disable extended quoting as it is not safe
  	my @quoted;
  	for (@_) {
  	    if (ref $_) {
  		if (ref $_ eq 'SCALAR') {
  		    push @quoted, $quoter->quote_glob($self->_expand_vars($$_));
  		}
  		elsif (ref $_ eq 'REF' and ref $$_ eq 'SCALAR') {
  		    push @quoted, $self->_expand_vars($$$_);
  		    undef $quote_extended;
  		}
  		else {
  		    croak "invalid reference in remote command argument list"
  		}
  	    }
  	    else {
  		push @quoted, $quoter->$quote_method($self->_expand_vars($_));
  	    }
  	}
  
  	if ($quote_extended) {
              my @fragments;
              if ( $opts->{stdout_discard} and
                   ( $opts->{stderr_discard} or $opts->{stderr_to_stdout} ) ) {
                  @fragments = ('stdout_and_stderr_discard');
                  push @fragments, 'stdin_discard' if $opts->{stdin_discard};
              }
              else {
                  @fragments = grep $opts->{$_}, qw(stdin_discard stdout_discard
                                                    stderr_discard stderr_to_stdout);
              }
              push @quoted, $quoter->shell_fragments(@fragments);
  	}
  	wantarray ? @quoted : join(" ", @quoted);
      }
      else {
  	croak "reference found in argument list when argument quoting is disabled"
  	    if (grep ref, @_);
  
  	my @args = $self->_expand_vars(@_);
  	wantarray ? @args : join(" ", @args);
      }
  }
  
  sub shell_quote {
      shift->_quote_args({quote_args => 1}, @_);
  }
  
  sub shell_quote_glob {
      shift->_quote_args({quote_args => 1, glob_quoting => 1}, @_);
  }
  
  sub _array_or_scalar_to_list { map { defined($_) ? (ref $_ eq 'ARRAY' ? @$_ : $_ ) : () } @_ }
  
  sub make_remote_command {
      my $self = shift;
      $self->wait_for_master or return;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      my @ssh_opts = _array_or_scalar_to_list delete $opts{ssh_opts};
      my $tty = delete $opts{tty};
      my $ssh_flags = '';
      $ssh_flags .= ($tty ? 'qtt' : 'T') if defined $tty;
      if ($self->{_forward_agent}) {
          my $forward_agent = delete $opts{forward_agent};
          $ssh_flags .= ($forward_agent ? 'A' : 'a') if defined $forward_agent;
      }
      if ($self->{_forward_X11}) {
          my $forward_X11 = delete $opts{forward_X11};
          $ssh_flags .= ($forward_X11 ? 'X' : 'x');
      }
      my $tunnel = delete $opts{tunnel};
      my (@args);
      if ($tunnel) {
          push @ssh_opts, $self->_make_W_option(@_);
      }
      else {
          my $subsystem = delete $opts{subsystem};
          if ($subsystem) {
              push @ssh_opts, '-s';
              @_ == 1 or croak "wrong number of arguments for subsystem command";
          }
          @args = $self->_quote_args(\%opts, @_);
      }
      _croak_bad_options %opts;
  
      push @ssh_opts, "-$ssh_flags" if length $ssh_flags;
      my @call = $self->_make_ssh_call(\@ssh_opts, @args);
      if (wantarray) {
  	$debug and $debug & 16 and _debug_dump make_remote_command => \@call;
  	return @call;
      }
      else {
  	my $call = join ' ', $self->shell_quote(@call);
  	$debug and $debug & 16 and _debug_dump 'make_remote_command (quoted)' => $call;
  	return $call
      }
  }
  
  sub _open_file {
      my ($self, $default_mode, $name_or_args) = @_;
      my ($mode, @args) = (ref $name_or_args
  			 ? @$name_or_args
  			 : ($default_mode, $name_or_args));
      @args = $self->_expand_vars(@args);
      if (open my $fh, $mode, @args) {
  	return $fh;
      }
      else {
  	$self->_set_error(OSSH_SLAVE_PIPE_FAILED,
  			  "Unable to open file '$args[0]': $!");
  	return undef;
      }
  }
  
  sub _fileno_dup_over {
      my ($good_fn, $fh) = @_;
      if (defined $fh) {
          my $fn = fileno $fh;
          for (1..5) {
              $fn >= $good_fn and return $fn;
              $fn = POSIX::dup($fn);
          }
          POSIX::_exit(255);
      }
      undef;
  }
  
  sub _exec_dpipe {
      my ($self, $cmd, $io, $err) = @_;
      my $io_fd  = _fileno_dup_over(3 => $io);
      my $err_fd = _fileno_dup_over(3 => $err);
      POSIX::dup2($io_fd, 0);
      POSIX::dup2($io_fd, 1);
      POSIX::dup2($err_fd, 2) if defined $err_fd;
      if (ref $cmd) {
          exec @$cmd;
      }
      else {
          exec $cmd;
      }
  }
  
  sub _delete_stream_encoding {
      my ($self, $opts) = @_;
      _first_defined(delete $opts->{stream_encoding},
                     $opts->{encoding},
                     $self->{_default_stream_encoding});
  }
  
  sub _delete_argument_encoding {
      my ($self, $opts) = @_;
      _first_defined(delete $opts->{argument_encoding},
                     delete $opts->{encoding},
                     $self->{_default_argument_encoding});
  }
  
  sub open_ex {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      unless (delete $opts{_no_master_required}) {
          $self->wait_for_master or return;
      }
  
      my $ssh_flags = '';
      my $tunnel = delete $opts{tunnel};
      my ($cmd, $close_slave_pty, @args);
      if ($tunnel) {
  	@args = @_;
      }
      else {
          my $argument_encoding = $self->_delete_argument_encoding(\%opts);
  	my $tty = delete $opts{tty};
  	$ssh_flags .= ($tty ? 'qtt' : 'T') if defined $tty;
  
  	$cmd = delete $opts{_cmd} || 'ssh';
  	$opts{quote_args_extended} = 1
  	    if (not defined $opts{quote_args_extended} and $cmd eq 'ssh');
          @args = $self->_quote_args(\%opts, @_);
          $self->_encode_args($argument_encoding, @args) or return;
      }
  
      my ($stdinout_socket, $stdinout_dpipe_make_parent);
      my $stdinout_dpipe = delete $opts{stdinout_dpipe};
      if ($stdinout_dpipe) {
          $stdinout_dpipe_make_parent = delete $opts{stdinout_dpipe_make_parent};
          $stdinout_socket = 1;
      }
      else {
          $stdinout_socket = delete $opts{stdinout_socket};
      }
  
      my ($stdin_discard, $stdin_pipe, $stdin_fh, $stdin_file, $stdin_pty,
          $stdout_discard, $stdout_pipe, $stdout_fh, $stdout_file, $stdout_pty,
          $stderr_discard, $stderr_pipe, $stderr_fh, $stderr_file, $stderr_to_stdout);
      unless ($stdinout_socket) {
          unless ($stdin_discard = delete $opts{stdin_discard} or
                  $stdin_pipe = delete $opts{stdin_pipe} or
                  $stdin_fh = delete $opts{stdin_fh} or
                  $stdin_file = delete $opts{stdin_file}) {
              unless ($tunnel) {
                  if ($stdin_pty = delete $opts{stdin_pty}) {
                      $close_slave_pty = _first_defined delete $opts{close_slave_pty}, 1;
                  }
              }
          }
  
          ( $stdout_discard = delete $opts{stdout_discard} or
            $stdout_pipe = delete $opts{stdout_pipe} or
            $stdout_fh = delete $opts{stdout_fh} or
            $stdout_file = delete $opts{stdout_file} or
            (not $tunnel and $stdout_pty = delete $opts{stdout_pty}) );
  
          $stdout_pty and !$stdin_pty
              and croak "option stdout_pty requires stdin_pty set";
      }
  
      ( $stderr_discard = delete $opts{stderr_discard} or
        $stderr_pipe = delete $opts{stderr_pipe} or
        $stderr_fh = delete $opts{stderr_fh} or
        $stderr_to_stdout = delete $opts{stderr_to_stdout} or
        $stderr_file = delete $opts{stderr_file} );
  
      my $ssh_opts = delete $opts{ssh_opts};
      $ssh_opts = $self->{_default_ssh_opts} unless defined $ssh_opts;
      my @ssh_opts = $self->_expand_vars(_array_or_scalar_to_list $ssh_opts);
  
      if ($self->{_forward_agent}) {
          my $forward_agent = delete $opts{forward_agent};
          $ssh_flags .= ($forward_agent ? 'A' : 'a') if defined $forward_agent;
      }
      if ($self->{_forward_X11}) {
          my $forward_X11 = delete $opts{forward_X11};
          $ssh_flags .= ($forward_X11 ? 'X' : 'x');
      }
      if (delete $opts{subsystem}) {
          $ssh_flags .= 's';
      }
  
      my $setpgrp = delete $opts{setpgrp};
      undef $setpgrp if defined $stdin_pty;
  
      _croak_bad_options %opts;
  
      if (defined $stdin_file) {
  	$stdin_fh = $self->_open_file('<', $stdin_file) or return
      }
      if (defined $stdout_file) {
  	$stdout_fh = $self->_open_file('>', $stdout_file) or return
      }
      if (defined $stderr_file) {
  	$stderr_fh = $self->_open_file('>', $stderr_file) or return
      }
  
      my ($rin, $win, $rout, $wout, $rerr, $werr);
  
      if ($stdinout_socket) {
          unless(socketpair $rin, $win, AF_UNIX, SOCK_STREAM, PF_UNSPEC) {
              $self->_set_error(OSSH_SLAVE_PIPE_FAILED, "socketpair failed: $!");
              return;
          }
          $wout = $rin;
      }
      else {
          if ($stdin_pipe) {
              ($rin, $win) = $self->_make_pipe or return;
          }
          elsif ($stdin_pty) {
              _load_module('IO::Pty');
              $win = IO::Pty->new;
              unless ($win) {
                  $self->_set_error(OSSH_SLAVE_PIPE_FAILED, "unable to allocate pseudo-tty: $!");
                  return;
              }
              $rin = $win->slave;
          }
          elsif (defined $stdin_fh) {
              $rin = $stdin_fh;
          }
          else {
              $rin = $self->{_default_stdin_fh}
          }
          _check_is_system_fh STDIN => $rin;
  
          if ($stdout_pipe) {
              ($rout, $wout) = $self->_make_pipe or return;
          }
          elsif ($stdout_pty) {
              $wout = $rin;
          }
          elsif (defined $stdout_fh) {
              $wout = $stdout_fh;
          }
          else {
              $wout = $self->{_default_stdout_fh};
          }
          _check_is_system_fh STDOUT => $wout;
      }
  
      unless ($stderr_to_stdout) {
  	if ($stderr_pipe) {
  	    ($rerr, $werr) = $self->_make_pipe or return;
  	}
  	elsif (defined $stderr_fh) {
  	    $werr = $stderr_fh;
  	}
  	else {
  	    $werr = $self->{_default_stderr_fh};
  	}
  	_check_is_system_fh STDERR => $werr;
      }
  
      push @ssh_opts, "-$ssh_flags" if length $ssh_flags;
  
      my @call = ( $tunnel         ? $self->_make_tunnel_call(\@ssh_opts, @args) :
                   $cmd eq 'ssh'   ? $self->_make_ssh_call(\@ssh_opts, @args)    :
  		 $cmd eq 'scp'   ? $self->_make_scp_call(\@ssh_opts, @args)    :
  		 $cmd eq 'rsync' ? $self->_make_rsync_call(\@ssh_opts, @args)  :
                   $cmd eq 'raw'   ? @args                                       :
  		 die "Internal error: bad _cmd protocol" );
  
      $debug and $debug & 16 and _debug_dump open_ex => \@call;
  
      my $pid = fork;
      unless ($pid) {
          unless (defined $pid) {
              $self->_set_error(OSSH_SLAVE_FAILED,
                                "unable to fork new ssh slave: $!");
              return;
          }
  
          setpgrp if $setpgrp;
  
          $stdin_discard  and (open $rin,  '<', '/dev/null' or POSIX::_exit(255));
          $stdout_discard and (open $wout, '>', '/dev/null' or POSIX::_exit(255));
          $stderr_discard and (open $werr, '>', '/dev/null' or POSIX::_exit(255));
  
          if ($stdinout_dpipe) {
              my $pid1 = fork;
              defined $pid1 or POSIX::_exit(255);
  
              unless ($pid1 xor $stdinout_dpipe_make_parent) {
                  eval { $self->_exec_dpipe($stdinout_dpipe, $win, $werr) };
                  POSIX::_exit(255);
              }
          }
  
          my $rin_fd  = _fileno_dup_over(0 => $rin);
          my $wout_fd = _fileno_dup_over(1 => $wout);
          my $werr_fd = _fileno_dup_over(2 => $werr);
  
          if (defined $rin_fd) {
              $win->make_slave_controlling_terminal if $stdin_pty;
  	    $rin_fd == 0 or POSIX::dup2($rin_fd, 0) or POSIX::_exit(255);
          }
  	if (defined $wout_fd) {
              $wout_fd == 1 or POSIX::dup2($wout_fd, 1) or POSIX::_exit(255);
          }
          if (defined $werr_fd) {
              $werr_fd == 2 or POSIX::dup2($werr_fd, 2) or POSIX::_exit(255);
          }
          elsif ($stderr_to_stdout) {
              POSIX::dup2(1, 2) or POSIX::_exit(255);
          }
          do { exec @call };
          POSIX::_exit(255);
      }
      $win->close_slave() if $close_slave_pty;
      undef $win if defined $stdinout_dpipe;
      wantarray ? ($win, $rout, $rerr, $pid) : $pid;
  }
  
  sub pipe_in {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      $self->wait_for_master or return;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      my $argument_encoding = $self->_delete_argument_encoding(\%opts);
      my @args = $self->_quote_args(\%opts, @_);
      _croak_bad_options %opts;
  
      $self->_encode_args($argument_encoding, @args) or return;
      my @call = $self->_make_ssh_call([], @args);
      $debug and $debug & 16 and _debug_dump pipe_in => @call;
      my $pid = open my $rin, '|-', @call;
      unless ($pid) {
          $self->_set_error(OSSH_SLAVE_FAILED,
                            "unable to fork new ssh slave: $!");
          return;
      }
      wantarray ? ($rin, $pid) : $rin;
  }
  
  sub pipe_out {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      $self->wait_for_master or return;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      my $argument_encoding = $self->_delete_argument_encoding(\%opts);
      my @args = $self->_quote_args(\%opts, @_);
      _croak_bad_options %opts;
  
      $self->_encode_args($argument_encoding, @args) or return;
      my @call = $self->_make_ssh_call([], @args);
      $debug and $debug & 16 and _debug_dump pipe_out => @call;
      my $pid = open my $rout, '-|', @call;
      unless ($pid) {
          $self->_set_error(OSSH_SLAVE_FAILED,
                            "unable to fork new ssh slave: $!");
          return;
      }
      wantarray ? ($rout, $pid) : $rout;
  }
  
  sub _find_encoding {
      my ($self, $encoding, $data) = @_;
      if (defined $encoding and $encoding ne 'bytes') {
  	_load_module('Encode');
          my $enc = Encode::find_encoding($encoding);
          unless (defined $enc) {
              $self->_set_error(OSSH_ENCODING_ERROR, "bad encoding '$encoding'");
              return
          }
          return $enc
      }
      return undef
  }
  
  sub _encode {
      my $self = shift;
      my $enc = shift;
      if (defined $enc and @_) {
          local ($@, $SIG{__DIE__});
          eval {
              for (@_) {
                  defined or next;
                  $_ = $enc->encode($_, Encode::FB_CROAK());
              }
          };
          $self->_check_eval_ok(OSSH_ENCODING_ERROR) or return undef;
      }
      1;
  }
  
  sub _encode_args {
      if (@_ > 2) {
          my $self = shift;
          my $encoding = shift;
  
          my $enc = $self->_find_encoding($encoding);
          if ($enc) {
              local $self->{_error_prefix} = [@{$self->{_error_prefix}}, "argument encoding failed"];
              $self->_encode($enc, @_);
          }
          return !$self->{_error};
      }
      1;
  }
  
  sub _decode {
      my $self = shift;
      my $enc = shift;
      local ($@, $SIG{__DIE__});
      eval {
          for (@_) {
              defined or next;
              $_ = $enc->decode($_, Encode::FB_CROAK());
          }
      };
      $self->_check_eval_ok(OSSH_ENCODING_ERROR);
  }
  
  my @retriable = (Errno::EINTR(), Errno::EAGAIN());
  push @retriable, Errno::EWOULDBLOCK() if Errno::EWOULDBLOCK() != Errno::EAGAIN();
  
  sub _io3 {
      my ($self, $out, $err, $in, $stdin_data, $timeout, $encoding, $keep_in_open) = @_;
      # $self->wait_for_master or return;
      my @data = _array_or_scalar_to_list $stdin_data;
      my ($cout, $cerr, $cin) = (defined($out), defined($err), defined($in));
      $timeout = $self->{_timeout} unless defined $timeout;
  
      my $has_input = grep { defined and length } @data;
      if ($cin and !$has_input) {
          close $in unless $keep_in_open;
          undef $cin;
      }
      elsif (!$cin and $has_input) {
          croak "remote input channel is not defined but data is available for sending"
      }
  
      my $enc = $self->_find_encoding($encoding);
      if ($enc and @data) {
          local $self->{_error_prefix} = [@{$self->{_error_prefix}}, "stdin data encoding failed"];
          $self->_encode($enc, @data) if $has_input;
          return if $self->{_error};
      }
  
      my $bout = '';
      my $berr = '';
      my ($fnoout, $fnoerr, $fnoin);
      local $SIG{PIPE} = 'IGNORE';
  
   MLOOP: while ($cout or $cerr or $cin) {
          $debug and $debug & 64 and _debug "io3 mloop, cin: " . ($cin || 0) .
              ", cout: " . ($cout || 0) . ", cerr: " . ($cerr || 0);
          my ($rv, $wv);
  
          if ($cout or $cerr) {
              $rv = '';
              if ($cout) {
                  $fnoout = fileno $out;
                  vec($rv, $fnoout, 1) = 1;
              }
              if ($cerr) {
                  $fnoerr = fileno $err;
                  vec($rv, $fnoerr, 1) = 1
              }
          }
  
          if ($cin) {
              $fnoin = fileno $in;
              $wv = '';
              vec($wv, $fnoin, 1) = 1;
          }
  
          my $recalc_vecs;
      FAST: until ($recalc_vecs) {
              $debug and $debug & 64 and
                  _debug "io3 fast, cin: " . ($cin || 0) .
                      ", cout: " . ($cout || 0) . ", cerr: " . ($cerr || 0);
              my ($rv1, $wv1) = ($rv, $wv);
              my $n = select ($rv1, $wv1, undef, $timeout);
              if ($n > 0) {
                  if ($cout and vec($rv1, $fnoout, 1)) {
                      my $offset = length $bout;
                      my $read = sysread($out, $bout, 20480, $offset);
                      if ($debug and $debug & 64) {
                          _debug "stdout, bytes read: ", $read, " at offset $offset";
                          $read and $debug & 128 and _hexdump substr $bout, $offset;
                      }
                      unless ($read or grep $! == $_, @retriable) {
                          close $out;
                          undef $cout;
                          $recalc_vecs = 1;
                      }
                  }
                  if ($cerr and vec($rv1, $fnoerr, 1)) {
                      my $read = sysread($err, $berr, 20480, length($berr));
                      $debug and $debug & 64 and _debug "stderr, bytes read: ", $read;
                      unless ($read or grep $! == $_, @retriable) {
                          close $err;
                          undef $cerr;
                          $recalc_vecs = 1;
                      }
                  }
                  if ($cin and vec($wv1, $fnoin, 1)) {
                      my $written = syswrite($in, $data[0], 20480);
                      if ($debug and $debug & 64) {
                          _debug "stdin, bytes written: ", $written;
                          $written and $debug & 128 and _hexdump substr $data[0], 0, $written;
                      }
                      if ($written) {
                          substr($data[0], 0, $written, '');
                          while (@data) {
                              next FAST
                                  if (defined $data[0] and length $data[0]);
                              shift @data;
                          }
                          # fallback when stdin queue is exhausted
                      }
                      elsif (grep $! == $_, @retriable) {
                          next FAST;
                      }
                      close $in unless $keep_in_open;
                      undef $cin;
                      $recalc_vecs = 1;
                  }
              }
              else {
                  next if $n < 0 and grep $! == $_, @retriable;
                  $self->_set_error(OSSH_SLAVE_TIMEOUT, 'ssh slave failed', 'timed out');
                  last MLOOP;
              }
          }
      }
      close $out if $cout;
      close $err if $cerr;
      close $in if $cin and not $keep_in_open;
  
      if ($enc) {
          local $self->{_error_prefix} = [@{$self->{_error_prefix}}, 'output decoding failed'];
          unless ($self->_decode($enc, $bout, $berr)) {
              undef $bout;
              undef $berr;
          }
      }
      $debug and $debug & 64 and _debug "leaving _io3()";
      return ($bout, $berr);
  }
  
  
  
  _sub_options spawn => qw(stderr_to_stdout stdin_discard stdin_fh stdin_file stdout_discard stdout_fh
                           stdout_file stderr_discard stderr_fh stderr_file stdinout_dpipe
                           stdinout_dpipe_make_parent quote_args quote_args_extended remote_shell
                           glob_quoting tty ssh_opts tunnel encoding argument_encoding forward_agent
                           forward_X11 setpgrp subsystem);
  sub spawn {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts =  (ref $_[0] eq 'HASH' ? %{shift()} : ());
      _croak_bad_options %opts;
  
      return scalar $self->open_ex(\%opts, @_);
  }
  
  _sub_options open2 => qw(stderr_to_stdout stderr_discard stderr_fh stderr_file quote_args quote_args_extended
                           remote_shell glob_quoting tty ssh_opts tunnel encoding argument_encoding forward_agent
                           forward_X11 setpgrp subsystem);
  sub open2 {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      _croak_bad_options %opts;
      _croak_scalar_context;
  
      my ($in, $out, undef, $pid) =
          $self->open_ex({ stdout_pipe => 1,
                           stdin_pipe => 1,
                           %opts }, @_) or return ();
      return ($in, $out, $pid);
  }
  
  _sub_options open2pty => qw(stderr_to_stdout stderr_discard stderr_fh stderr_file
                              quote_args quote_args_extended remote_shell glob_quoting tty
                              close_slave_pty ssh_opts encoding argument_encoding forward_agent
                              forward_X11 setpgrp subsystem);
  sub open2pty {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      _croak_bad_options %opts;
  
      my ($pty, undef, undef, $pid) =
          $self->open_ex({ stdout_pty => 1,
                           stdin_pty => 1,
  			 tty => 1,
                         %opts }, @_) or return ();
      wantarray ? ($pty, $pid) : $pty;
  }
  
  _sub_options open2socket => qw(stderr_to_stdout stderr_discard stderr_fh stderr_file
                                 quote_args quote_args_extended remote_shell glob_quoting tty
                                 ssh_opts tunnel encoding argument_encoding forward_agent
                                 forward_X11 setpgrp subsystem);
  sub open2socket {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      _croak_bad_options %opts;
  
      my ($socket, undef, undef, $pid) =
          $self->open_ex({ stdinout_socket => 1,
                           %opts }, @_) or return ();
      wantarray ? ($socket, $pid) : $socket;
  }
  
  _sub_options open3 => qw(quote_args quote_args_extended remote_shell glob_quoting tty ssh_opts
                           encoding argument_encoding forward_agent forward_X11 setpgrp subsystem);
  sub open3 {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      _croak_bad_options %opts;
      _croak_scalar_context;
  
      my ($in, $out, $err, $pid) =
          $self->open_ex({ stdout_pipe => 1,
                           stdin_pipe => 1,
                           stderr_pipe => 1,
  			 %opts },
                         @_) or return ();
      return ($in, $out, $err, $pid);
  }
  
  _sub_options open3pty => qw(quote_args quote_args_extended remote_shell glob_quoting tty close_slave_pty ssh_opts
                              encoding argument_encoding forward_agent forward_X11 setpgrp subsystem);
  sub open3pty {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      _croak_bad_options %opts;
      _croak_scalar_context;
  
      my ($pty, undef, $err, $pid) =
          $self->open_ex({ stdout_pty => 1,
                           stdin_pty => 1,
  			 tty => 1,
                           stderr_pipe => 1,
  			 %opts },
                         @_) or return ();
      return ($pty, $err, $pid);
  }
  
  _sub_options open3socket => qw(quote_args quote_args_extended remote_shell glob_quoting tty ssh_opts encoding
                                 argument_encoding forward_agent forward_X11 setpgrp subsystem);
  sub open3socket {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      _croak_bad_options %opts;
      _croak_scalar_context;
  
      my ($socket, undef, $err, $pid) =
          $self->open_ex({ stdinout_socket => 1,
                           stderr_pipe => 1,
  			 %opts }, @_) or return ();
      return ($socket, $err, $pid);
  }
  
  _sub_options system => qw(stdout_discard stdout_fh stdin_discard stdout_file stdin_fh stdin_file
                            quote_args quote_args_extended remote_shell glob_quoting
                            stderr_to_stdout stderr_discard stderr_fh stderr_file
                            stdinout_dpipe stdinout_dpipe_make_parent tty ssh_opts tunnel encoding
                            argument_encoding forward_agent forward_X11 setpgrp subsystem);
  sub system {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      my $stdin_data = delete $opts{stdin_data};
      my $timeout = delete $opts{timeout};
      my $async = delete $opts{async};
      my $stdin_keep_open = ($async ? undef : delete $opts{stdin_keep_open});
  
      _croak_bad_options %opts;
  
      $stdin_data = '' if $stdin_keep_open and not defined $stdin_data;
  
      my $stream_encoding;
      if (defined $stdin_data) {
          $opts{stdin_pipe} = 1;
          $stream_encoding = $self->_delete_stream_encoding(\%opts);
      }
  
      local $SIG{INT} = 'IGNORE';
      local $SIG{QUIT} = 'IGNORE';
      local $SIG{CHLD};
  
      my ($in, undef, undef, $pid) = $self->open_ex(\%opts, @_) or return undef;
  
      $self->_io3(undef, undef, $in, $stdin_data,
                  $timeout, $stream_encoding, $stdin_keep_open) if defined $stdin_data;
      return $pid if $async;
      $self->_waitpid($pid, $timeout);
  }
  
  _sub_options test => qw(stdout_discard stdout_fh stdin_discard stdout_file stdin_fh stdin_file
                          quote_args quote_args_extended remote_shell glob_quoting stderr_to_stdout
                          stderr_discard stderr_fh stderr_file stdinout_dpipe
                          stdinout_dpipe_make_parent tty ssh_opts timeout stdin_data stdin_keep_open
                          encoding stream_encoding argument_encoding forward_agent forward_X11
                          setpgrp subsystem);
  
  sub test {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      $opts{stdout_discard} = 1 unless grep defined($opts{$_}), qw(stdout_discard stdout_fh
                                                                   stdout_file stdinout_dpipe);
      $opts{stderr_discard} = 1 unless grep defined($opts{$_}), qw(stderr_discard stderr_fh
                                                                   stderr_file stderr_to_stdout);
      _croak_bad_options %opts;
  
      $self->system(\%opts, @_);
      my $error = $self->{_error};
      unless ($error) {
          return 1;
      }
      if ($error == OSSH_SLAVE_CMD_FAILED) {
          $self->_set_error(0);
          return 0;
      }
      return undef;
  }
  
  _sub_options capture => qw(stderr_to_stdout stderr_discard stderr_fh stderr_file stdin_discard
                             stdin_fh stdin_file quote_args quote_args_extended remote_shell
                             glob_quoting tty ssh_opts tunnel encoding argument_encoding forward_agent
                             forward_X11 setpgrp subsystem);
  sub capture {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      my $stdin_data = delete $opts{stdin_data};
      my $stdin_keep_open = delete $opts{stdin_keep_open};
      my $timeout = delete $opts{timeout};
      _croak_bad_options %opts;
  
      $stdin_data = '' if $stdin_keep_open and not defined $stdin_data;
  
      my $stream_encoding = $self->_delete_stream_encoding(\%opts);
      $opts{stdout_pipe} = 1;
      $opts{stdin_pipe} = 1 if defined $stdin_data;
  
      local $SIG{INT} = 'IGNORE';
      local $SIG{QUIT} = 'IGNORE';
      local $SIG{CHLD};
  
      my ($in, $out, undef, $pid) = $self->open_ex(\%opts, @_) or return ();
      my ($output) = $self->_io3($out, undef, $in, $stdin_data,
                                 $timeout, $stream_encoding, $stdin_keep_open);
      $self->_waitpid($pid, $timeout);
      if (wantarray) {
          my $pattern = quotemeta $/;
          return split /(?<=$pattern)/, $output;
      }
      $output
  }
  
  _sub_options capture2 => qw(stdin_discard stdin_fh stdin_file quote_args quote_args_extended
                              remote_shell glob_quoting tty ssh_opts encoding stream_encoding
                              argument_encoding forward_agent forward_X11 setpgrp subsystem);
  sub capture2 {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      my $stdin_data = delete $opts{stdin_data};
      my $stdin_keep_open = delete $opts{stdin_keep_open};
      my $timeout = delete $opts{timeout};
      _croak_bad_options %opts;
  
      $stdin_data = '' if $stdin_keep_open and not defined $stdin_data;
  
      my $stream_encoding = $self->_delete_stream_encoding(\%opts);
      $opts{stdout_pipe} = 1;
      $opts{stderr_pipe} = 1;
      $opts{stdin_pipe} = 1 if defined $stdin_data;
  
      local $SIG{INT} = 'IGNORE';
      local $SIG{QUIT} = 'IGNORE';
      local $SIG{CHLD};
  
      my ($in, $out, $err, $pid) = $self->open_ex( \%opts, @_) or return ();
      my @capture = $self->_io3($out, $err, $in, $stdin_data,
                                $timeout, $stream_encoding, $stdin_keep_open);
      $self->_waitpid($pid, $timeout);
      wantarray ? @capture : $capture[0];
  }
  
  _sub_options open_tunnel => qw(ssh_opts stderr_discard stderr_fh stderr_file
                                 encoding argument_encoding forward_agent setpgrp);
  sub open_tunnel {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      $opts{stderr_discard} = 1 unless grep defined $opts{$_}, qw(stderr_discard stderr_fh stderr_file);
      _croak_bad_options %opts;
      @_ == 2 or croak 'Usage: $ssh->open_tunnel(\%opts, $host, $port)';
      $opts{tunnel} = 1;
      $self->open2socket(\%opts, @_);
  }
  
  _sub_options capture_tunnel => qw(ssh_opts stderr_discard stderr_fh stderr_file stdin_discard
  				  stdin_fh stdin_file stdin_data timeout encoding stream_encoding
  				  argument_encoding forward_agent setpgrp);
  sub capture_tunnel {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      $opts{stderr_discard} = 1 unless grep defined $opts{$_}, qw(stderr_discard stderr_fh stderr_file);
      _croak_bad_options %opts;
      @_ == 2 or croak 'Usage: $ssh->capture_tunnel(\%opts, $host, $port)';
      $opts{tunnel} = 1;
      $self->capture(\%opts, @_);
  }
  
  sub _calling_method {
      my $method = (caller 2)[3];
      $method =~ s/.*:://;
      $method;
  }
  
  sub _scp_get_args {
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
  
      @_ > 0 or croak
  	'Usage: $ssh->' . _calling_method . '(\%opts, $remote_fn1, $remote_fn2, ..., $local_fn_or_dir)';
  
      my $glob = delete $opts{glob};
  
      my $target = (@_ > 1 ? pop @_ : '.');
      $target =~ m|^[^/]*:| and $target = "./$target";
  
      my $prefix = $self->{_host_squared};
      $prefix = "$self->{_user}\@$prefix" if defined $self->{_user};
  
      my $src = "$prefix:". join(" ", $self->_quote_args({quote_args => 1,
                                                          glob_quoting => $glob},
                                                         @_));
      ($self, \%opts, $target, $src);
  }
  
  sub scp_get {
      ${^TAINT} and &_catch_tainted_args;
      my ($self, $opts, $target, @src) = _scp_get_args @_;
      $self->_scp($opts, @src, $target);
  }
  
  sub rsync_get {
      ${^TAINT} and &_catch_tainted_args;
      my ($self, $opts, $target, @src) = _scp_get_args @_;
      $self->_rsync($opts, @src, $target);
  }
  
  sub _scp_put_args {
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
  
      @_ > 0 or croak
  	'Usage: $ssh->' . _calling_method . '(\%opts, $local_fn1, $local_fn2, ..., $remote_dir_or_fn)';
  
      my $glob = delete $opts{glob};
      my $glob_flags = ($glob ? delete $opts{glob_flags} || 0 : undef);
  
      my $prefix = $self->{_host_squared};
      $prefix = "$self->{_user}\@$prefix" if defined $self->{_user};
  
      my $remote_shell = delete $opts{remote_shell};
      my $target = $prefix . ':' . ( @_ > 1
                                     ? $self->_quote_args({quote_args => 1, remote_shell => $remote_shell}, pop(@_))
                                     : '');
  
      my @src = @_;
      if ($glob) {
  	require File::Glob;
  	@src = map File::Glob::bsd_glob($_, $glob_flags), @src;
  	unless (@src) {
  	    $self->_set_error(OSSH_SLAVE_FAILED,
  			      "given file name patterns did not match any file");
  	    return undef;
  	}
      }
      $_ = "./$_" for grep m|^[^/]*:|, @src;
  
      ($self, \%opts, $target, @src);
  }
  
  sub scp_put {
      ${^TAINT} and &_catch_tainted_args;
      my ($self, $opts, $target, @src) = _scp_put_args @_;
      return unless $self;
      $self->_scp($opts, @src, $target);
  }
  
  sub rsync_put {
      ${^TAINT} and &_catch_tainted_args;
      my ($self, $opts, $target, @src) = _scp_put_args @_;
      return unless $self;
      $self->_rsync($opts, @src, $target);
  }
  
  _sub_options _scp => qw(stderr_to_stdout stderr_discard stderr_fh
  			stderr_file stdout_discard stdout_fh
  			stdout_file encoding argument_encoding
                          forward_agent setpgrp);
  sub _scp {
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      my $quiet = delete $opts{quiet};
      $quiet = 1 unless defined $quiet;
      my $recursive = delete $opts{recursive};
      my $copy_attrs = delete $opts{copy_attrs};
      my $bwlimit = delete $opts{bwlimit};
      my $async = delete $opts{async};
      my $ssh_opts = delete $opts{ssh_opts};
      my $timeout = delete $opts{timeout};
      my $verbose = delete $opts{verbose};
      _croak_bad_options %opts;
  
      my @opts;
      @opts = @$ssh_opts if $ssh_opts;
      push @opts, '-q' if $quiet;
      push @opts, '-v' if $verbose;
      push @opts, '-r' if $recursive;
      push @opts, '-p' if $copy_attrs;
      push @opts, '-l', $bwlimit if $bwlimit;
  
      local $self->{_error_prefix} = [@{$self->{_error_prefix}}, 'scp failed'];
  
      my $pid = $self->open_ex({ %opts,
                                 _cmd => 'scp',
  			       ssh_opts => \@opts,
  			       quote_args => 0 },
  			     @_);
  
      return $pid if $async;
      $self->_waitpid($pid, $timeout);
  }
  
  my %rsync_opt_with_arg = map { $_ => 1 } qw(chmod suffix backup-dir rsync-path max-delete max-size min-size partial-dir
                                              timeout modify-window temp-dir compare-dest copy-dest link-dest compress-level
                                              skip-compress filter exclude exclude-from include include-from
                                              out-format log-file log-file-format bwlimit protocol iconv checksum-seed files-from);
  
  my %rsync_opt_forbidden = map { $_ => 1 } qw(rsh address port sockopts blocking-io password-file write-batch
                                              only-write-batch read-batch ipv4 ipv6 version help daemon config detach
                                              blocking-io protect-args list-only);
  
  $rsync_opt_forbidden{"no-$_"} = 1 for (keys %rsync_opt_with_arg, keys %rsync_opt_forbidden);
  
  my %rsync_error = (1, 'syntax or usage error',
  		   2, 'protocol incompatibility',
  		   3, 'errors selecting input/output files, dirs',
  		   4, 'requested action not supported: an attempt was made to manipulate 64-bit files on a platform '.
                        'that  cannot  support them; or an option was specified that is supported by the client and not '.
                        'by the server.',
  		   5, 'error starting client-server protocol',
  		   6, 'daemon unable to append to log-file',
  		   10, 'error in socket I/O',
  		   11, 'error in file I/O',
  		   12, 'error in rsync protocol data stream',
  		   13, 'errors with program diagnostics',
  		   14, 'error in IPC code',
  		   20, 'received SIGUSR1 or SIGINT',
  		   21, 'some error returned by waitpid()',
  		   22, 'error allocating core memory buffers',
  		   23, 'partial transfer due to error',
  		   24, 'partial transfer due to vanished source files',
  		   25, 'the --max-delete limit stopped deletions',
  		   30, 'timeout in data send/receive',
  		   35, 'timeout waiting for daemon connection');
  
  my %rsync_opt_open_ex = map { $_ => 1 } qw(stderr_to_stdout
  					   stderr_discard stderr_fh
  					   stderr_file stdout_discard
  					   stdout_fh stdout_file encoding
                                             argument_encoding);
  sub _rsync {
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      my $async = delete $opts{async};
      my $verbose = delete $opts{verbose};
      my $quiet = delete $opts{quiet};
      my $copy_attrs = delete $opts{copy_attrs};
      my $timeout = delete $opts{timeout};
      $quiet = 1 unless (defined $quiet or $verbose);
  
      my @opts = qw(--blocking-io) ;
      push @opts, '-q' if $quiet;
      push @opts, '-pt' if $copy_attrs;
      push @opts, '-' . ($verbose =~ /^\d+$/ ? 'v' x $verbose : 'v') if $verbose;
  
      my %opts_open_ex = ( _cmd => 'rsync',
  			 quote_args => 0 );
  
      for my $opt (keys %opts) {
  	my $value = $opts{$opt};
  	if (defined $value) {
  	    if ($rsync_opt_open_ex{$opt}) {
  		$opts_open_ex{$opt} = $value;
  	    }
  	    else {
  		my $opt1 = $opt;
  		$opt1 =~ tr/_/-/;
  		$rsync_opt_forbidden{$opt1} and croak "forbidden rsync option '$opt' used";
  		if ($rsync_opt_with_arg{$opt1}) {
  		    push @opts, "--$opt1=$_" for _array_or_scalar_to_list($value)
  		}
  		else {
  		    $value = !$value if $opt1 =~ s/^no-//;
  		    push @opts, ($value ? "--$opt1" : "--no-$opt1");
  		}
  	    }
  	}
      }
  
      local $self->{_error_prefix} = [@{$self->{_error_prefix}}, 'rsync failed'];
  
      my $pid = $self->open_ex(\%opts_open_ex, @opts, '--', @_);
      return $pid if $async;
      $self->_waitpid($pid, $timeout) and return 1;
  
      if ($self->{_error} == OSSH_SLAVE_CMD_FAILED and $?) {
  	my $err = ($? >> 8);
  	my $errstr = $rsync_error{$err};
  	$errstr = 'Unknown rsync error' unless defined $errstr;
  	my $signal = $? & 255;
  	my $signalstr = ($signal ? " (signal $signal)" : '');
  	$self->_set_error(OSSH_SLAVE_CMD_FAILED,
  			  "command exited with code $err$signalstr: $errstr");
      }
      return undef
  }
  
  _sub_options sftp => qw(autoflush timeout argument_encoding encoding block_size queue_size autodie
  			late_set_perm forward_agent setpgrp min_block_size read_ahead write_delay
  			dirty_cleanup remote_has_volumes autodisconnect more);
  
  sub sftp {
      ${^TAINT} and &_catch_tainted_args;
      @_ & 1 or croak 'Usage: $ssh->sftp(%sftp_opts)';
      _load_module('Net::SFTP::Foreign', '1.47');
      my ($self, %opts) = @_;
      my $stderr_fh = delete $opts{stderr_fh};
      my $stderr_discard = delete $opts{stderr_discard};
      my $fs_encoding = _first_defined(delete $opts{fs_encoding},
                                       $opts{argument_encoding},
                                       $opts{encoding},
                                       $self->{_default_argument_encoding});
      undef $fs_encoding if (defined $fs_encoding and $fs_encoding eq 'bytes');
      _croak_bad_options %opts;
      $opts{timeout} = $self->{_timeout} unless defined $opts{timeout};
      $self->wait_for_master or return undef;
      my ($in, $out, $pid) = $self->open2( { subsystem => 1,
  					   stderr_fh => $stderr_fh,
  					   stderr_discard => $stderr_discard },
  					 'sftp' )
  	or return undef;
  
      my $sftp = Net::SFTP::Foreign->new(transport => [$out, $in, $pid],
  				       dirty_cleanup => 0,
                                         fs_encoding => $fs_encoding,
  				       %opts);
      if ($sftp->error) {
  	$self->_or_set_error(OSSH_SLAVE_SFTP_FAILED, "unable to create SFTP client", $sftp->error);
  	return undef;
      }
      $sftp
  }
  
  _sub_options sshfs_import => qw(stderr_discard stderr_fh stderr_file
                                  ssh_opts argument_encoding sshfs_opts setpgrp);
  sub sshfs_import {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      @_ == 2 or croak 'Usage: $ssh->sshfs_import(\%opts, $remote, $local)';
      my ($from, $to) = @_;
      my @sshfs_opts = ( -o => 'slave',
                         _array_or_scalar_to_list delete $opts{sshfs_opts} );
      _croak_bad_options %opts;
  
      $opts{ssh_opts} = ['-s', _array_or_scalar_to_list delete $opts{ssh_opts}];
      $opts{stdinout_dpipe} = [$self->{_sshfs_cmd}, "$self->{_host_squared}:$from", $to, @sshfs_opts];
      $opts{stdinout_dpipe_make_parent} = 1;
      $self->spawn(\%opts, 'sftp');
  }
  
  _sub_options sshfs_export => qw(stderr_discard stderr_fh stderr_file
                                  ssh_opts argument_encoding sshfs_opts setpgrp);
  sub sshfs_export {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      @_ == 2 or croak 'Usage: $ssh->sshfs_export(\%opts, $local, $remote)';
      my ($from, $to) = @_;
      my @sshfs_opts = ( -o => 'slave',
                         _array_or_scalar_to_list delete $opts{sshfs_opts} );
      _croak_bad_options %opts;
      $opts{stdinout_dpipe} = $self->{_sftp_server_cmd};
  
      my $hostname = do {
          local ($@, $SIG{__DIE__});
          eval {
              require Sys::Hostname;
              Sys::Hostname::hostname();
          };
      };
      $hostname = 'remote' if (not defined $hostname   or
                               not length $hostname    or
                               $hostname=~/^localhost\b/);
      $self->spawn(\%opts, $self->{_sshfs_cmd}, "$hostname:$from", $to, @sshfs_opts);
  }
  
  sub object_remote {
      my $self = shift;
      _load_module('Object::Remote') or return;
      _load_module('Net::OpenSSH::ObjectRemote') or return;
      my $connector = Net::OpenSSH::ObjectRemote->new(net_openssh => $self);
      $connector->connect(@_);
  }
  
  sub any {
      my $self = shift;
      _load_module('Net::SSH::Any');
      Net::SSH::Any->new($self->{_host}, user => $self->{_user}, port => $self->{_port},
                         backend => 'Net_OpenSSH',
                         backend_opts => { Net_OpenSSH => { instance => $self } });
  }
  
  sub DESTROY {
      my $self = shift;
      $debug and $debug & 2 and _debug("DESTROY($self, pid: ", $self->{_pid}, ")");
      local ($SIG{__DIE__}, $@, $?, $!);
      $self->_disconnect;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Net::OpenSSH - Perl SSH client package implemented on top of OpenSSH
  
  =head1 SYNOPSIS
  
    use Net::OpenSSH;
  
    my $ssh = Net::OpenSSH->new($host);
    $ssh->error and
      die "Couldn't establish SSH connection: ". $ssh->error;
  
    $ssh->system("ls /tmp") or
      die "remote command failed: " . $ssh->error;
  
    my @ls = $ssh->capture("ls");
    $ssh->error and
      die "remote ls command failed: " . $ssh->error;
  
    my ($out, $err) = $ssh->capture2("find /root");
    $ssh->error and
      die "remote find command failed: " . $ssh->error;
  
    my ($rin, $pid) = $ssh->pipe_in("cat >/tmp/foo") or
      die "pipe_in method failed: " . $ssh->error;
  
    print $rin "hello\n";
    close $rin;
  
    my ($rout, $pid) = $ssh->pipe_out("cat /tmp/foo") or
      die "pipe_out method failed: " . $ssh->error;
  
    while (<$rout>) { print }
    close $rout;
  
    my ($in, $out ,$pid) = $ssh->open2("foo");
    my ($pty, $pid) = $ssh->open2pty("foo");
    my ($in, $out, $err, $pid) = $ssh->open3("foo");
    my ($pty, $err, $pid) = $ssh->open3pty("login");
  
    my $sftp = $ssh->sftp();
    $sftp->error and die "SFTP failed: " . $sftp->error;
  
  
  =head1 DESCRIPTION
  
  Net::OpenSSH is a secure shell client package implemented on top of
  OpenSSH binary client (C<ssh>).
  
  =head2 Under the hood
  
  This package is implemented around the multiplexing feature found in
  later versions of OpenSSH. That feature allows one to run several
  sessions over a single SSH connection (OpenSSH 4.1 was the first
  one to provide all the required functionality).
  
  When a new Net::OpenSSH object is created, the OpenSSH C<ssh> client
  is run in master mode, establishing a persistent (for the lifetime of
  the object) connection to the server.
  
  Then, every time a new operation is requested a new C<ssh> process is
  started in slave mode, effectively reusing the master SSH connection
  to send the request to the remote side.
  
  =head2 Net::OpenSSH Vs. Net::SSH::.* modules
  
  Why should you use Net::OpenSSH instead of any of the other Perl SSH
  clients available?
  
  Well, this is my (biased) opinion:
  
  L<Net::SSH::Perl|Net::SSH::Perl> is not well maintained nowadays
  (update: a new maintainer has stepped in so this situation could
  change!!!), requires a bunch of modules (some of them very difficult
  to install) to be acceptably efficient and has an API that is limited
  in some ways.
  
  L<Net::SSH2|Net::SSH2> is much better than Net::SSH::Perl, but not
  completely stable yet. It can be very difficult to install on some
  specific operating systems and its API is also limited, in the same
  way as L<Net::SSH::Perl|Net::SSH::Perl>.
  
  Using L<Net::SSH::Expect|Net::SSH::Expect>, in general, is a bad
  idea. Handling interaction with a shell via Expect in a generic way
  just can not be reliably done.
  
  Net::SSH is just a wrapper around any SSH binary commands available on
  the machine. It can be very slow as they establish a new SSH
  connection for every operation performed.
  
  In comparison, Net::OpenSSH is a pure perl module that does not have
  any mandatory dependencies (obviously, besides requiring OpenSSH
  binaries).
  
  Net::OpenSSH has a very perlish interface. Most operations are
  performed in a fashion very similar to that of the Perl builtins and
  common modules (e.g. L<IPC::Open2|IPC::Open2>).
  
  It is also very fast. The overhead introduced by launching a new ssh
  process for every operation is not appreciable (at least on my Linux
  box). The bottleneck is the latency intrinsic to the protocol, so
  Net::OpenSSH is probably as fast as an SSH client can be.
  
  Being based on OpenSSH is also an advantage: a proved, stable, secure
  (to paranoid levels), inseparably and well maintained implementation
  of the SSH protocol is used.
  
  On the other hand, Net::OpenSSH does not work on Windows, not even
  under Cygwin.
  
  Net::OpenSSH specifically requires the OpenSSH SSH client (AFAIK, the
  multiplexing feature is not available from any other SSH
  client). However, note that it will interact with any server software,
  not just servers running OpenSSH C<sshd>.
  
  For password authentication, L<IO::Pty|IO::Pty> has to be
  installed. Other modules and binaries are also required to implement
  specific functionality (for instance
  L<Net::SFTP::Foreign|Net::SFTP::Foreign>, L<Expect|Expect> or
  L<rsync(1)|rsync(1)>).
  
  Net::OpenSSH and Net::SSH2 do not support version 1 of the SSH
  protocol.
  
  =head1 API
  
  =head2 Optional arguments
  
  Almost all methods in this package accept as first argument an
  optional reference to a hash containing parameters (C<\%opts>). For
  instance, these two method calls are equivalent:
  
    my $out1 = $ssh->capture(@cmd);
    my $out2 = $ssh->capture({}, @cmd);
  
  =head2 Error handling
  
  Most methods return undef (or an empty list) to indicate failure.
  
  The L</error> method can always be used to explicitly check for
  errors. For instance:
  
    my ($output, $errput) = $ssh->capture2({timeout => 1}, "find /");
    $ssh->error and die "ssh failed: " . $ssh->error;
  
  =head2 Net::OpenSSH methods
  
  These are the methods provided by the package:
  
  =over 4
  
  =item Net::OpenSSH->new($host, %opts)
  
  Creates a new SSH master connection
  
  C<$host> can be a hostname or an IP address. It may also
  contain the name of the user, her password and the TCP port
  number where the server is listening:
  
     my $ssh1 = Net::OpenSSH->new('jack@foo.bar.com');
     my $ssh2 = Net::OpenSSH->new('jack:secret@foo.bar.com:10022');
     my $ssh3 = Net::OpenSSH->new('jsmith@2001:db8::1428:57ab'); # IPv6
  
  IPv6 addresses may optionally be enclosed in brackets:
  
     my $ssh4 = Net::OpenSSH->new('jsmith@[::1]:1022');
  
  This method always succeeds in returning a new object. Error checking
  has to be performed explicitly afterwards:
  
    my $ssh = Net::OpenSSH->new($host, %opts);
    $ssh->error and die "Can't ssh to $host: " . $ssh->error;
  
  If you have problems getting Net::OpenSSH to connect to the remote
  host read the troubleshooting chapter near the end of this document.
  
  Accepted options:
  
  =over 4
  
  =item user => $user_name
  
  Login name
  
  =item port => $port
  
  TCP port number where the server is running
  
  =item password => $password
  
  User given password for authentication.
  
  Note that using password authentication in automated scripts is a very
  bad idea. When possible, you should use public key authentication
  instead.
  
  =item passphrase => $passphrase
  
  X<passphrase>Uses given passphrase to open private key.
  
  =item key_path => $private_key_path
  
  Uses the key stored on the given file path for authentication.
  
  =item gateway => $gateway
  
  If the given argument is a gateway object as returned by
  L<Net::OpenSSH::Gateway/find_gateway> method, use it to connect to
  the remote host.
  
  If it is a hash reference, call the C<find_gateway> method first.
  
  For instance, the following code fragments are equivalent:
  
    my $gateway = Net::OpenSSH::Gateway->find_gateway(
            proxy => 'http://proxy.corporate.com');
    $ssh = Net::OpenSSH->new($host, gateway => $gateway);
  
  and
  
    $ssh = Net::OpenSSH->new($host,
            gateway => { proxy => 'http://proxy.corporate.com'});
  
  =item proxy_command => $proxy_command
  
  Use the given command to establish the connection to the remote host
  (see C<ProxyCommand> on L<ssh_config(5)>).
  
  =item batch_mode => 1
  
  Disables querying the user for password and passphrases.
  
  =item ctl_dir => $path
  
  Directory where the SSH master control socket will be created.
  
  This directory and its parents must be writable only by the current
  effective user or root, otherwise the connection will be aborted to
  avoid insecure operation.
  
  By default C<~/.libnet-openssh-perl> is used.
  
  =item ctl_path => $path
  
  Path to the SSH master control socket.
  
  Usually this option should be avoided as the module is able to pick an unused
  socket path by itself. An exception to that rule is when the C<external_master>
  feature is enabled.
  
  Note that the length of the path is usually limited to between 92 and 108 bytes,
  depending of the underlying operating system.
  
  =item ssh_cmd => $cmd
  
  Name or full path to OpenSSH C<ssh> binary. For instance:
  
    my $ssh = Net::OpenSSH->new($host, ssh_cmd => '/opt/OpenSSH/bin/ssh');
  
  =item scp_cmd => $cmd
  
  Name or full path to OpenSSH C<scp> binary.
  
  By default it is inferred from the C<ssh> one.
  
  =item rsync_cmd => $cmd
  
  Name or full path to C<rsync> binary. Defaults to C<rsync>.
  
  =item remote_shell => $name
  
  Name of the remote shell. Used to select the argument quoter backend.
  
  =item timeout => $timeout
  
  Maximum acceptable time that can elapse without network traffic or any
  other event happening on methods that are not immediate (for instance,
  when establishing the master SSH connection or inside methods
  C<capture>, C<system>, C<scp_get>, etc.).
  
  See also L</Timeouts>.
  
  =item kill_ssh_on_timeout => 1
  
  This option tells Net::OpenSSH to kill the local slave SSH process
  when some operation times out.
  
  See also L</Timeouts>.
  
  =item strict_mode => 0
  
  By default, the connection will be aborted if the path to the socket
  used for multiplexing is found to be non-secure (for instance, when
  any of the parent directories is writable by other users).
  
  This option can be used to disable that feature. Use with care!!!
  
  =item async => 1
  
  By default, the constructor waits until the multiplexing socket is
  available. That option can be used to defer the waiting until the
  socket is actually used.
  
  For instance, the following code connects to several remote machines
  in parallel:
  
    my (%ssh, %ls);
    # multiple connections are established in parallel:
    for my $host (@hosts) {
        $ssh{$host} = Net::OpenSSH->new($host, async => 1);
    }
    # then to run some command in all the hosts (sequentially):
    for my $host (@hosts) {
        $ssh{$host}->system('ls /');
    }
  
  =item connect => 0
  
  Do not launch the master SSH process yet.
  
  =item master_opts => [...]
  
  Additional options to pass to the C<ssh> command when establishing the
  master connection. For instance:
  
    my $ssh = Net::OpenSSH->new($host,
        master_opts => [-o => "ProxyCommand corkscrew httpproxy 8080 $host"]);
  
  =item default_ssh_opts => [...]
  
  Default slave SSH command line options for L</open_ex> and derived
  methods.
  
  For instance:
  
    my $ssh = Net::OpenSSH->new($host,
        default_ssh_opts => [-o => "ConnectionAttempts=0"]);
  
  =item forward_agent => 1
  
  Enables forwarding of the authentication agent.
  
  This option can not be used when passing a passphrase (via
  L</passphrase>) to unlock the login private key.
  
  Note that Net::OpenSSH will not run C<ssh-agent> for you. This has to
  be done ahead of time and the environment variable C<SSH_AUTH_SOCK>
  set pointing to the proper place.
  
  =item forward_X11 => 1
  
  Enables forwarding of the X11 protocol
  
  =item default_stdin_fh => $fh
  
  =item default_stdout_fh => $fh
  
  =item default_stderr_fh => $fh
  
  Default I/O streams for L</open_ex> and derived methods (currently, that
  means any method but L</pipe_in> and L</pipe_out> and I plan to remove
  those exceptions soon!).
  
  For instance:
  
    open my $stderr_fh, '>>', '/tmp/$host.err' or die ...;
    open my $stdout_fh, '>>', '/tmp/$host.log' or die ...;
  
    my $ssh = Net::OpenSSH->new($host, default_stderr_fh => $stderr_fh,
                                       default_stdout_fh => $stdout_fh);
    $ssh->error and die "SSH connection failed: " . $ssh->error;
  
    $ssh->scp_put("/foo/bar*", "/tmp")
      or die "scp failed: " . $ssh->error;
  
  =item default_stdin_file = $fn
  
  =item default_stdout_file = $fn
  
  =item default_stderr_file = $fn
  
  Opens the given file names and use them as the defaults.
  
  =item master_stdout_fh => $fh
  
  =item master_stderr_fh => $fh
  
  Redirect corresponding stdio streams of the master SSH process to
  given filehandles.
  
  =item master_stdout_discard => $bool
  
  =item master_stderr_discard => $bool
  
  Discard corresponding stdio streams.
  
  =item expand_vars => $bool
  
  Activates variable expansion inside command arguments and file paths.
  
  See L</"Variable expansion"> below.
  
  =item vars => \%vars
  
  Initial set of variables.
  
  =item external_master => 1
  
  Instead of launching a new OpenSSH client in master mode, the module
  tries to reuse an already existent one. C<ctl_path> must also be
  passed when this option is set. See also L</get_ctl_path>.
  
  Example:
  
    $ssh = Net::OpenSSH->new('foo', external_master => 1, ctl_path = $path);
  
  When C<external_master> is set, the hostname argument becomes optional
  (C<0.0.0.0> is passed to OpenSSH which does not use it at all).
  
  =item default_encoding => $encoding
  
  =item default_stream_encoding => $encoding
  
  =item default_argument_encoding => $encoding
  
  Set default encodings. See L</Data encoding>.
  
  =item password_prompt => $string
  
  =item password_prompt => $re
  
  By default, when using password authentication, the module expects the
  remote side to send a password prompt matching C</[?:]/>.
  
  This option can be used to override that default for the rare cases
  when a different prompt is used.
  
  Examples:
  
     password_prompt => ']'; # no need to escape ']'
     password_prompt => qr/[:?>]/;
  
  =item login_handler => \&custom_login_handler
  
  Some remote SSH server may require a custom login/authentication
  interaction not natively supported by Net::OpenSSH. In that cases, you
  can use this option to replace the default login logic.
  
  The callback will be invoked repeatedly as C<custom_login_handler($ssh,
  $pty, $data)> where C<$ssh> is the current Net::OpenSSH object, C<pty>
  a L<IO::Pty> object attached to the slave C<ssh> process tty and
  C<$data> a reference to an scalar you can use at will.
  
  The login handler must return 1 after the login process has completed
  successfully or 0 in case it still needs to do something else. If some
  error happens, it must die.
  
  Note, that blocking operations should not be performed inside the
  login handler (at least if you want the C<async> and C<timeout>
  features to work).
  
  See also the sample script C<login_handler.pl> in the C<examples>
  directory.
  
  Usage of this option is incompatible with the C<password> and
  C<passphrase> options, you will have to handle password or passphrases
  from the custom handler yourself.
  
  =item master_setpgrp => 1
  
  When this option is set, the master process is run as a different
  process group. As a consequence it will not die when the user presses
  Ctrl-C at the terminal.
  
  In order to allow the master SSH process to request any information
  from the user, the module may set it as the terminal controlling
  process while the connection is established (using
  L<POSIX/tcsetpgrp>). Afterwards, the terminal controlling process is
  reset.
  
  This feature is highly experimental. Report any problems you may find,
  please.
  
  =item master_pty_force => 1
  
  By default, Net::OpenSSH attaches the master SSH process to a pty only
  when some kind of interactive authentication is requested. If this
  flag is set a pty will be attached always.
  
  That allows to get better diagnostics for some kind of errors (as for
  instance, bad host keys) and also allows to retrieve the pty log using
  L<get_master_pty_log>.
  
  =back
  
  =item $ssh->error
  
  Returns the error condition for the last performed operation.
  
  The returned value is a dualvar as $! (see L<perlvar/"$!">) that
  renders an informative message when used in string context or an error
  number in numeric context (error codes appear in
  L<Net::OpenSSH::Constants|Net::OpenSSH::Constants>).
  
  =item $ssh->get_master_pty_log
  
  In order to handle password authentication or entering the passphrase
  for a private key, Net::OpenSSH may run the master SSH process attached
  to a pty.
  
  In that case and after a constructor call returns a connection failure
  error, this method can be called to retrieve the output captured at
  the pty (the log is discarded when the connection is established
  successfully).
  
  Any data consumed from the pty by custom login handlers will be
  missing from the the returned log.
  
  =item $ssh->get_user
  
  =item $ssh->get_host
  
  =item $ssh->get_port
  
  Return the corresponding SSH login parameters.
  
  =item $ssh->get_ctl_path
  
  X<get_ctl_path>Returns the path to the socket where the OpenSSH master
  process listens for new multiplexed connections.
  
  =item ($in, $out, $err, $pid) = $ssh->open_ex(\%opts, @cmd)
  
  X<open_ex>I<Note: this is a low level method which, probably, you do
  not need to use!>
  
  That method starts the command C<@cmd> on the remote machine creating
  new pipes for the IO channels as specified on the C<%opts> hash.
  
  If C<@cmd> is omitted, the remote user shell is run.
  
  Returns four values, the first three (C<$in>, C<$out> and C<$err>)
  correspond to the local side of the pipes created (they can be undef)
  and the fourth (C<$pid>) to the PID of the new SSH slave process. An
  empty list is returned on failure.
  
  Note that C<waitpid> has to be used afterwards to reap the
  slave SSH process.
  
  Accepted options:
  
  =over 4
  
  =item stdin_pipe => 1
  
  Creates a new pipe and connects the reading side to the stdin stream
  of the remote process. The writing side is returned as the first
  value (C<$in>).
  
  =item stdin_pty => 1
  
  Similar to C<stdin_pipe>, but instead of a regular pipe it uses a
  pseudo-tty (pty).
  
  Note that on some operating systems (e.g. HP-UX, AIX), ttys are not
  reliable. They can overflow when large chunks are written or when data
  is written faster than it is read.
  
  =item stdin_fh => $fh
  
  Duplicates C<$fh> and uses it as the stdin stream of the remote process.
  
  =item stdin_file => $filename
  
  =item stdin_file => \@open_args
  
  Opens the file of the given name for reading and uses it as the remote
  process stdin stream.
  
  If an array reference is passed its contents are used as the arguments
  for the underlying open call. For instance:
  
    $ssh->system({stdin_file => ['-|', 'gzip -c -d file.gz']}, $rcmd);
  
  =item stdin_discard => 1
  
  Uses /dev/null as the remote process stdin stream.
  
  =item stdout_pipe => 1
  
  Creates a new pipe and connects the writing side to the stdout stream
  of the remote process. The reading side is returned as the second
  value (C<$out>).
  
  =item stdout_pty => 1
  
  Connects the stdout stream of the remote process to the
  pseudo-pty. This option requires C<stdin_pty> to be also set.
  
  =item stdout_fh => $fh
  
  Duplicates C<$fh> and uses it as the stdout stream of the remote
  process.
  
  =item stdout_file => $filename
  
  =item stdout_file => \@open_args
  
  Opens the file of the given filename and redirect stdout there.
  
  =item stdout_discard => 1
  
  Uses /dev/null as the remote process stdout stream.
  
  =item stdinout_socket => 1
  
  Creates a new socketpair, attaches the stdin an stdout streams of the
  slave SSH process to one end and returns the other as the first value
  (C<$in>) and undef for the second (C<$out>).
  
  Example:
  
    my ($socket, undef, undef, $pid) = $ssh->open_ex({stdinout_socket => 1},
                                                     '/bin/netcat $dest');
  
  See also L</open2socket>.
  
  =item stdinout_dpipe => $cmd
  
  =item stdinout_dpipe => \@cmd
  
  Runs the given command locally attaching its stdio streams to those of
  the remote SSH command. Conceptually it is equivalent to the
  L<dpipe(1)> shell command.
  
  =item stderr_pipe => 1
  
  Creates a new pipe and connects the writing side to the stderr stream
  of the remote process. The reading side is returned as the third
  value (C<$err>).
  
  Example:
  
    my $pid = $ssh->open_ex({stdinout_dpipe => 'vncviewer -stdio'},
                            x11vnc => '-inetd');
  
  =item stderr_fh => $fh
  
  Duplicates C<$fh> and uses it as the stderr stream of the remote process.
  
  =item stderr_file => $filename
  
  Opens the file of the given name and redirects stderr there.
  
  =item stderr_to_stdout => 1
  
  Makes stderr point to stdout.
  
  =item tty => $bool
  
  Tells C<ssh> to allocate a pseudo-tty for the remote process. By
  default, a tty is allocated if remote command stdin stream is attached
  to a tty.
  
  When this flag is set and stdin is not attached to a tty, the ssh
  master and slave processes may generate spurious warnings about failed
  tty operations. This is caused by a bug present in older versions of
  OpenSSH.
  
  =item close_slave_pty => 0
  
  When a pseudo pty is used for the stdin stream, the slave side is
  automatically closed on the parent process after forking the ssh
  command.
  
  This option disables that feature, so that the slave pty can be
  accessed on the parent process as C<$pty-E<gt>slave>. It will have to
  be explicitly closed (see L<IO::Pty|IO::Pty>)
  
  =item quote_args => $bool
  
  See L</"Shell quoting"> below.
  
  =item remote_shell => $shell
  
  Sets the remote shell. Allows one to change the argument quoting
  mechanism in a per-command fashion.
  
  This may be useful when interacting with a Windows machine where
  argument parsing may be done at the command level in custom ways.
  
  Example:
  
    $ssh->system({remote_shell => 'MSWin'}, echo => $line);
    $ssh->system({remote_shell => 'MSCmd,MSWin'}, type => $file);
  
  =item forward_agent => $bool
  
  Enables/disables forwarding of the authentication agent.
  
  This option can only be used when agent forwarding has been previously
  requested on the constructor.
  
  =item forward_X11 => $bool
  
  Enables/disables forwarding of the X11 protocol.
  
  This option can only be used when X11 forwarding has been previously
  requested on the constructor.
  
  =item ssh_opts => \@opts
  
  List of extra options for the C<ssh> command.
  
  This feature should be used with care, as the given options are not
  checked in any way by the module, and they could interfere with it.
  
  =item tunnel => $bool
  
  Instead of executing a command in the remote host, this option
  instruct Net::OpenSSH to create a TCP tunnel. The arguments become the
  target IP and port or the remote path for an Unix socket.
  
  Example:
  
    my ($in, $out, undef, $pid) = $ssh->open_ex({tunnel => 1}, $IP, $port);
    my ($in, $out, undef, $pid) = $ssh->open_ex({tunnel => 1}, $socket_path);
  
  See also L</Tunnels>.
  
  =item subsystem => $bool
  
  Request a connection to a SSH subsystem. The name of the subsystem
  must be passed as an argument, as in the following example:
  
    my $s = $ssh->open2socket({subsystem => 1}, 'netconf');
  
  =item encoding => $encoding
  
  =item argument_encoding => $encoding
  
  Set encodings. See L</Data encoding>.
  
  =back
  
  Usage example:
  
    # similar to IPC::Open2 open2 function:
    my ($in_pipe, $out_pipe, undef, $pid) =
        $ssh->open_ex( { stdin_pipe => 1,
                         stdout_pipe => 1 },
                       @cmd )
        or die "open_ex failed: " . $ssh->error;
    # do some IO through $in/$out
    # ...
    waitpid($pid);
  
  =item setpgrp => 1
  
  Calls C<setpgrp> after forking the child process. As a result it will
  not die when the user presses Ctrl+C at the console. See also
  L<perlfunc/setpgrp>.
  
  Using this option without also setting C<master_setpgrp> on the
  constructor call is mostly useless as the signal will be delivered to
  the master process and all the remote commands aborted.
  
  This feature is experimental.
  
  =item $ssh->system(\%opts, @cmd)
  
  Runs the command C<@cmd> on the remote machine.
  
  Returns true on success, undef otherwise.
  
  The error status is set to C<OSSH_SLAVE_CMD_FAILED> when the remote
  command exits with a non zero code (the code is available from C<$?>,
  see L<perlvar/"$?">).
  
  Example:
  
    $ssh->system('ls -R /')
      or die "ls failed: " . $ssh->error";
  
  As for C<system> builtin, C<SIGINT> and C<SIGQUIT> signals are
  blocked.  (see L<perlfunc/system>). Also, setting C<$SIG{CHLD}> to
  C<IGNORE> or to a custom signal handler will interfere with this
  method.
  
  Accepted options:
  
  =over 4
  
  =item stdin_data => $input
  
  =item stdin_data => \@input
  
  Sends the given data through the stdin stream to the remote
  process.
  
  For example, the following code creates a file on the remote side:
  
    $ssh->system({stdin_data => \@data}, "cat >/tmp/foo")
      or die "unable to write file: " . $ssh->error;
  
  =item timeout => $timeout
  
  The operation is aborted after C<$timeout> seconds elapsed without
  network activity.
  
  See also L</Timeouts>.
  
  =item async => 1
  
  Does not wait for the child process to exit. The PID of the new
  process is returned.
  
  Note that when this option is combined with C<stdin_data>, the given
  data will be transferred to the remote side before returning control
  to the caller.
  
  See also the L</spawn> method documentation below.
  
  =item stdin_fh => $fh
  
  =item stdin_discard => $bool
  
  =item stdout_fh => $fh
  
  =item stdout_discard => $bool
  
  =item stderr_fh => $fh
  
  =item stderr_discard => $bool
  
  =item stderr_to_stdout => $bool
  
  =item stdinout_dpipe => $cmd
  
  =item tty => $bool
  
  See the L</open_ex> method documentation for an explanation of these
  options.
  
  =item stdin_keep_open => $bool
  
  When C<stdin_data> is given, the module closes the stdin stream once
  all the data has been sent. Unfortunately, some SSH buggy servers fail
  to handle this event correctly and close the channel prematurely.
  
  As a workaround, when this flag is set the stdin is left open until
  the remote process terminates.
  
  =back
  
  =item $ok = $ssh->test(\%opts, @cmd);
  
  Runs the given command and returns its success/failure exit status as
  1 or 0 respectively. Returns undef when something goes wrong in the
  SSH layer.
  
  Error status is not set to OSSH_SLAVE_CMD_FAILED when the remote
  command exits with a non-zero code.
  
  By default this method discards the remote command C<stdout> and
  C<sterr> streams.
  
  Usage example:
  
    if ($ssh->test(ps => -C => $executable)) {
      say "$executable is running on remote machine"
    }
    else {
      die "something got wrong: ". $ssh->error if $ssh->error;
  
      say "$executable is not running on remote machine"
    }
  
  This method support the same set of options as C<system>, except
  C<async> and C<tunnel>.
  
  =item $output = $ssh->capture(\%opts, @cmd);
  
  =item @output = $ssh->capture(\%opts, @cmd);
  
  This method is conceptually equivalent to the perl backquote operator
  (e.g. C<`ls`>): it runs the command on the remote machine and captures
  its output.
  
  In scalar context returns the output as a scalar. In list context
  returns the output broken into lines (it honors C<$/>, see
  L<perlvar/"$/">).
  
  The exit status of the remote command is returned in C<$?>.
  
  When an error happens while capturing (for instance, the operation
  times out), the partial captured output will be returned. Error
  conditions have to be explicitly checked using the L</error>
  method. For instance:
  
    my $output = $ssh->capture({ timeout => 10 },
                               "echo hello; sleep 20; echo bye");
    $ssh->error and
        warn "operation didn't complete successfully: ". $ssh->error;
    print $output;
  
  Setting C<$SIG{CHLD}> to a custom signal handler or to C<IGNORE> will
  interfere with this method.
  
  Accepted options:
  
  =over 4
  
  =item stdin_data => $input
  
  =item stdin_data => \@input
  
  =item stdin_keep_open => $bool
  
  See the L</system> method documentation for an explanation of these
  options.
  
  =item timeout => $timeout
  
  See L</Timeouts>.
  
  =item stdin_fh => $fh
  
  =item stdin_discard => $bool
  
  =item stderr_fh => $fh
  
  =item stderr_discard => $bool
  
  =item stderr_to_stdout => $bool
  
  =item tty => $bool
  
  See the L</open_ex> method documentation for an explanation of these
  options.
  
  =back
  
  =item ($output, $errput) = $ssh->capture2(\%opts, @cmd)
  
  captures the output sent to both stdout and stderr by C<@cmd> on the
  remote machine.
  
  Setting C<$SIG{CHLD}> to a custom signal handler or to C<IGNORE> will
  also interfere with this method.
  
  The accepted options are:
  
  =over 4
  
  =item stdin_data => $input
  
  =item stdin_data => \@input
  
  =item stdin_keep_open => $bool
  
  See the L</system> method documentation for an explanation of these
  options.
  
  =item timeout => $timeout
  
  See L</Timeouts>.
  
  =item stdin_fh => $fh
  
  =item stdin_discard => $bool
  
  =item tty => $bool
  
  See the L</open_ex> method documentation for an explanation of these
  options.
  
  =back
  
  =item ($in, $pid) = $ssh->pipe_in(\%opts, @cmd)
  
  X<pipe_in>This method is similar to the following Perl C<open> call
  
    $pid = open $in, '|-', @cmd
  
  but running @cmd on the remote machine (see L<perlfunc/open>).
  
  No options are currently accepted.
  
  There is no need to perform a waitpid on the returned PID as it will
  be done automatically by perl when C<$in> is closed.
  
  Example:
  
    my ($in, $pid) = $ssh->pipe_in('cat >/tmp/fpp')
        or die "pipe_in failed: " . $ssh->error;
    print $in $_ for @data;
    close $in or die "close failed";
  
  =item ($out, $pid) = $ssh->pipe_out(\%opts, @cmd)
  
  X<pipe_out>Reciprocal to previous method, it is equivalent to
  
    $pid = open $out, '-|', @cmd
  
  running @cmd on the remote machine.
  
  No options are currently accepted.
  
  =item ($in, $out, $pid) = $ssh->open2(\%opts, @cmd)
  
  =item ($pty, $pid) = $ssh->open2pty(\%opts, @cmd)
  
  =item ($socket, $pid) = $ssh->open2socket(\%opts, @cmd)
  
  =item ($in, $out, $err, $pid) = $ssh->open3(\%opts, @cmd)
  
  =item ($pty, $err, $pid) = $ssh->open3pty(\%opts, @cmd)
  
  Shortcuts around L</open_ex> method.
  
  =item $pid = $ssh->spawn(\%opts, @_)
  
  X<spawn>Another L</open_ex> shortcut, it launches a new remote process
  in the background and returns the PID of the local slave SSH process.
  
  At some later point in your script, C<waitpid> should be called on the
  returned PID in order to reap the slave SSH process.
  
  For instance, you can run some command on several hosts in parallel
  with the following code:
  
    my %conn = map { $_ => Net::OpenSSH->new($_, async => 1) } @hosts;
    my @pid;
    for my $host (@hosts) {
        open my($fh), '>', "/tmp/out-$host.txt"
          or die "unable to create file: $!";
        push @pid, $conn{$host}->spawn({stdout_fh => $fh}, $cmd);
    }
  
    waitpid($_, 0) for @pid;
  
  Note that C<spawn> should not be used to start detached remote
  processes that may survive the local program (see also the L</FAQ>
  about running remote processes detached).
  
  =item ($socket, $pid) = $ssh->open_tunnel(\%opts, $dest_host, $port)
  
  =item ($socket, $pid) = $ssh->open_tunnel(\%opts, $socket_path)
  
  X<open_tunnel>Similar to L</open2socket>, but instead of running a
  command, it opens a TCP tunnel to the given address. See also
  L</Tunnels>.
  
  =item $out = $ssh->capture_tunnel(\%opts, $dest_host, $port)
  
  =item @out = $ssh->capture_tunnel(\%opts, $dest_host, $port)
  
  X<capture_tunnel>Similar to L</capture>, but instead of running a command, it opens a
  TCP tunnel.
  
  Example:
  
    $out = $ssh->capture_tunnel({stdin_data => join("\r\n",
                                                    "GET / HTTP/1.0",
                                                    "Host: www.perl.org",
                                                    "", "") },
                                'www.perl.org', 80)
  
  See also L</Tunnels>.
  
  =item $ssh->scp_get(\%opts, $remote1, $remote2,..., $local_dir_or_file)
  
  =item $ssh->scp_put(\%opts, $local, $local2,..., $remote_dir_or_file)
  
  These two methods are wrappers around the C<scp> command that allow
  transfers of files to/from the remote host using the existing SSH
  master connection.
  
  When transferring several files, the target argument must point to an
  existing directory. If only one file is to be transferred, the target
  argument can be a directory or a file name or can be omitted. For
  instance:
  
    $ssh->scp_get({glob => 1}, '/var/tmp/foo*', '/var/tmp/bar*', '/tmp');
    $ssh->scp_put('/etc/passwd');
  
  Both L</scp_get> and L</scp_put> methods return a true value when all
  the files are transferred correctly, otherwise they return undef.
  
  Accepted options:
  
  =over 4
  
  =item quiet => 0
  
  By default, C<scp> is called with the quiet flag C<-q> enabled in
  order to suppress progress information. This option allows one to
  re-enable the progress indication bar.
  
  =item verbose => 1
  
  Calls C<scp> with the C<-v> flag.
  
  =item recursive => 1
  
  Copies files and directories recursively.
  
  =item glob => 1
  
  Enables expansion of shell metacharacters in the sources list so that
  wildcards can be used to select files.
  
  =item glob_flags => $flags
  
  Second argument passed to L<File::Glob::bsd_glob|File::Glob/bsd_glob>
  function. Only available for L</scp_put> method.
  
  =item copy_attrs => 1
  
  Copies modification and access times and modes from the original
  files.
  
  =item bwlimit => $Kbits
  
  Limits the used bandwidth, specified in Kbit/s.
  
  =item timeout => $secs
  
  The transfer is aborted if the connection does not finish before the
  given timeout elapses. See also L</Timeouts>.
  
  =item async => 1
  
  Does not wait for the C<scp> command to finish. When this option is
  used, the method returns the PID of the child C<scp> process.
  
  For instance, it is possible to transfer files to several hosts in
  parallel as follows:
  
    use Errno;
    my (%pid, %ssh);
    for my $host (@hosts) {
      $ssh{$host} = Net::OpenSSH->new($host, async => 1);
    }
    for my $host (@hosts) {
      $pid{$host} = $ssh{$host}->scp_put({async => 1}, $local_fn, $remote_fn)
        or warn "scp_put to $host failed: " . $ssh{$host}->error . "\n";
    }
    for my $host (@hosts) {
      if (my $pid = $pid{$host}) {
        if (waitpid($pid, 0) > 0) {
          my $exit = ($? >> 8);
          $exit and warn "transfer of file to $host failed ($exit)\n";
        }
        else {
          redo if ($! == EINTR);
          warn "waitpid($pid) failed: $!\n";
        }
      }
    }
  
  =item stdout_fh => $fh
  
  =item stderr_fh => $fh
  
  =item stderr_to_stdout => 1
  
  These options are passed unchanged to method L</open_ex>, allowing
  capture of the output of the C<scp> program.
  
  Note that C<scp> will not generate progress reports unless its stdout
  stream is attached to a tty.
  
  =item ssh_opts => \@opts
  
  List of extra options for the C<ssh> command.
  
  This feature should be used with care, as the given options are not
  checked in any way by the module, and they could interfere with it.
  
  =back
  
  =item $ssh->rsync_get(\%opts, $remote1, $remote2,..., $local_dir_or_file)
  
  =item $ssh->rsync_put(\%opts, $local1, $local2,..., $remote_dir_or_file)
  
  These methods use C<rsync> over SSH to transfer files from/to the remote
  machine.
  
  They accept the same set of options as the C<scp> ones.
  
  Any unrecognized option will be passed as an argument to the C<rsync>
  command (see L<rsync(1)>). Underscores can be used instead of dashes
  in C<rsync> option names.
  
  For instance:
  
    $ssh->rsync_get({exclude => '*~',
                     verbose => 1,
                     safe_links => 1},
                    '/remote/dir', '/local/dir');
  
  =item $sftp = $ssh->sftp(%sftp_opts)
  
  X<Net_SFTP_Foreign>Creates a new L<Net::SFTP::Foreign|Net::SFTP::Foreign> object
  for SFTP interaction that runs through the ssh master connection.
  
  =item @call = $ssh->make_remote_command(\%opts, @cmd)
  
  =item $call = $ssh->make_remote_command(\%opts, @cmd)
  
  This method returns the arguments required to execute a command on the
  remote machine via SSH. For instance:
  
    my @call = $ssh->make_remote_command(ls => "/var/log");
    system @call;
  
  In scalar context, returns the arguments quoted and joined into one
  string:
  
    my $remote = $ssh->make_remote_comand("cd /tmp/ && tar xf -");
    system "tar cf - . | $remote";
  
  The options accepted are as follows:
  
  =over 4
  
  =item tty => $bool
  
  Enables/disables allocation of a tty on the remote side.
  
  =item forward_agent => $bool
  
  Enables/disables forwarding of authentication agent.
  
  This option can only be used when agent forwarding has been previously
  requested on the constructor.
  
  =item tunnel => 1
  
  Return a command to create a connection to some TCP server reachable
  from the remote host. In that case the arguments are the destination
  address and port. For instance:
  
    $cmd = $ssh->make_remote_command({tunnel => 1}, $host, $port);
  
  =item subsystem => 1
  
  Return a command for invoking a SSH subsystem (i.e. SFTP or
  netconf). In that case the only argument is the subsystem name.
  
  =back
  
  =item $ssh->wait_for_master($async)
  
  When the connection has been established by calling the constructor
  with the C<async> option, this call allows one to advance the process.
  
  If C<$async> is true, it will perform any work that can be done
  immediately without waiting (for instance, entering the password or
  checking for the existence of the multiplexing socket) and then
  return. If a false value is given, it will finalize the connection
  process and wait until the multiplexing socket is available.
  
  It returns a true value after the connection has been successfully
  established. False is returned if the connection process fails or if
  it has not yet completed (then, the L</error> method can be used to
  distinguish between both cases).
  
  From version 0.64 upwards, undef is returned when the master is still
  in an unstable state (login, killing, etc.) and 0 when it is in a
  stable state (running, stopped or gone).
  
  =item $ssh->check_master
  
  This method runs several checks to ensure that the master connection
  is still alive.
  
  =item $ssh->shell_quote(@args)
  
  Returns the list of arguments quoted so that they will be restored to
  their original form when parsed by the remote shell.
  
  In scalar context returns the list of arguments quoted and joined.
  
  Usually this task is done automatically by the module. See L</"Shell
  quoting"> below.
  
  This method can also be used as a class method.
  
  Example:
  
    my $quoted_args = Net::OpenSSH->shell_quote(@args);
    system('ssh', '--', $host, $quoted_args);
  
  =item $ssh->shell_quote_glob(@args)
  
  This method is like the previous C<shell_quote> but leaves wildcard
  characters unquoted.
  
  It can be used as a class method also.
  
  =item $ssh->set_expand_vars($bool)
  
  Enables/disables variable expansion feature (see L</"Variable
  expansion">).
  
  =item $ssh->get_expand_vars
  
  Returns current state of variable expansion feature.
  
  =item $ssh->set_var($name, $value)
  
  =item $ssh->get_var($name, $value)
  
  These methods allow one to change and to retrieve the value of the
  given name.
  
  =item $ssh->get_master_pid
  
  Returns the PID of the master SSH process
  
  =item $ssh->master_exited
  
  This methods allows one to tell the module that the master process has
  exited when we get its PID from some external wait or waitpid
  call. For instance:
  
    my $ssh = Net::OpenSSH->new('foo', async => 1);
  
    # create new processes
    # ...
  
    # rip them...
    my $master_pid = $ssh->master_pid;
    while ((my $pid = wait) > 0) {
      if ($pid == $master_pid) {
        $ssh->master_exited;
      }
    }
  
  If your program rips the master process and this method is not called,
  the OS could reassign the PID to a new unrelated process and the
  module would try to kill it at object destruction time.
  
  =item $ssh->disconnect($async)
  
  Shuts down the SSH connection.
  
  Usually, you don't need to call this method explicitly, but just let
  the Net::OpenSSH object go out of scope.
  
  If C<async> is true, it doesn't wait for the SSH connection to
  terminate. In that case, L</wait_for_master> must be called repeatedly
  until the shutdown sequence terminates (See the L</AnyEvent>
  integration section below).
  
  =item $ssh->restart($async)
  
  Restarts the SSH session closing any open connection and creating a
  new one. Any open channel would also be killed.
  
  Note that calling this method may request again the password or
  passphrase from the user.
  
  In asynchronous mode, this method requires the connection to be
  terminated before it gets called. Afterwards, C<wait_for_master>
  should be called repeaptly until the new connection is stablished.
  
    my $async = 1;
    $ssh->disconnect($async);
    while (1) {
      defined $ssh->wait_for_master($async) # returns 0 when the
                                            # disconnect process
                                            # finishes
        and last;
      do_something_else();
    }
    $ssh->restart($async);
    while (1) {
      defined $ssh->wait_for_master($async)
        and last;
      do_somethin_else();
    }
  
  
  =item $pid = $ssh->sshfs_import(\%opts, $remote_fs, $local_mnt_point)
  
  =item $pid = $ssh->sshfs_export(\%opts, $local_fs, $remote_mnt_point)
  
  These methods use L<sshfs(1)> to import or export a file system
  through the SSH connection.
  
  They return the C<$pid> of the C<sshfs> process or of the slave C<ssh>
  process used to proxy it. Killing that process unmounts the file
  system, though, it may be probably better to use L<fusermount(1)>.
  
  The options accepted are as follows:
  
  =over
  
  =item ssh_opts => \@ssh_opts
  
  Options passed to the slave C<ssh> process.
  
  =item sshfs_opts => \@sshfs_opts
  
  Options passed to the C<sshfs> command. For instance, to mount the file
  system in read-only mode:
  
    my $pid = $ssh->sshfs_export({sshfs_opts => [-o => 'ro']},
                                 "/", "/mnt/foo");
  
  =back
  
  Note that this command requires a recent version of C<sshfs> to work (at
  the time of writing, it requires the yet unreleased version available
  from the FUSE git repository!).
  
  See also the L<sshfs(1)> man page and the C<sshfs> and FUSE web sites
  at L<https://github.com/libfuse/sshfs> and
  L<https://github.com/libfuse/libfuse> respectively.
  
  =item $or = $ssh->object_remote(@args)
  
  X<Object_Remote>Returns an L<Object::Remote::Connection> instance
  running on top of the Net::OpenSSH connection.
  
  Example:
  
     my $or = $ssh->object_remote;
     my $hostname = Sys::Hostname->can::on($or, 'hostname');
     say $hostname->();
  
  See also L<Object::Remote>.
  
  =item $any = $ssh->any(%opts)
  
  X<Net_SSH_Any>Wraps the current object inside a Net::SSH::Any one.
  
  Example:
  
    my $any = $ssh->any;
    my $content = $any->scp_get_content("my-file.txt");
  
  =item $pid = $ssh->disown_master
  
  Under normal operation Net::OpenSSH controls the life-time of the
  master C<ssh> process and when the object is destroyed the master
  process and any connection running over it are terminated.
  
  In some (rare) cases, it is desirable to let the master process and
  all the running connections survive. Calling this method does just
  that, it tells Net::OpenSSH object that the master process is not its
  own anymore.
  
  The return value is the PID of the master process.
  
  Note also that disowning the master process does not affect the
  operation of the module in any other regard.
  
  For instance:
  
    # See examples/sshfs_mount.pl for a working program
    my $ssh = Net::OpenSSH->new($host);
    my $sshfs_pid = $ssh->sshfs_import("/home/foo", "my-remote-home");
    $ssh->disown_master;
    $ssh->stop; # tells the master to stop accepting requests
    exit(0);
  
  =back
  
  =head2 Shell quoting
  
  By default, when invoking remote commands, this module tries to mimic
  perl C<system> builtin in regard to argument processing. Quoting
  L<perlfunc/system>:
  
    Argument processing varies depending on the number of arguments.  If
    there is more than one argument in LIST, or if LIST is an array with
    more than one value, starts the program given by the first element
    of the list with arguments given by the rest of the list.  If there
    is only one scalar argument, the argument is checked for shell
    metacharacters, and if there are any, the entire argument is passed
    to the system's command shell for parsing (this is "/bin/sh -c" on
    Unix platforms, but varies on other platforms).
  
  Take for example Net::OpenSSH L</system> method:
  
    $ssh->system("ls -l *");
    $ssh->system('ls', '-l', '/');
  
  The first call passes the argument unchanged to ssh and it is executed
  in the remote side through the shell which interprets metacharacters.
  
  The second call escapes any shell metacharacters so that, effectively,
  it is equivalent to calling the command directly and not through the
  shell.
  
  Under the hood, as the Secure Shell protocol does not provide for this
  mode of operation and always spawns a new shell where it runs the
  given command, Net::OpenSSH quotes any shell metacharacters in the
  command list.
  
  All the methods that invoke a remote command (system, open_ex, etc.)
  accept the option C<quote_args> that allows one to force/disable shell
  quoting.
  
  For instance:
  
    $ssh->system({quote_args => 1}, "/path with spaces/bin/foo");
  
  will correctly handle the spaces in the program path.
  
  The shell quoting mechanism implements some extensions (for instance,
  performing redirections to /dev/null on the remote side) that can be
  disabled with the option C<quote_args_extended>:
  
    $ssh->system({ stderr_discard => 1,
                   quote_args => 1, quote_args_extended => 0 },
                 @cmd);
  
  The option C<quote_args> can also be used to disable quoting when more
  than one argument is passed. For instance, to get some pattern
  expanded by the remote shell:
  
    $ssh->system({quote_args => 0}, 'ls', '-l', "/tmp/files_*.dat");
  
  The method C<shell_quote> can be used to selectively quote some
  arguments and leave others untouched:
  
    $ssh->system({quote_args => 0},
                 $ssh->shell_quote('ls', '-l'),
                 "/tmp/files_*.dat");
  
  When the glob option is set in C<scp> and C<rsync> file transfer
  methods, an alternative quoting method which knows about file
  wildcards and passes them unquoted is used. The set of wildcards
  recognized currently is the one supported by L<bash(1)>.
  
  Another way to selectively use quote globing or fully disable quoting
  for some specific arguments is to pass them as scalar references or
  double scalar references respectively. In practice, that means
  prepending them with one or two backslashes. For instance:
  
    # quote the last argument for globing:
    $ssh->system('ls', '-l', \'/tmp/my files/filed_*dat');
  
    # append a redirection to the remote command
    $ssh->system('ls', '-lR', \\'>/tmp/ls-lR.txt');
  
    # expand remote shell variables and glob in the same command:
    $ssh->system('tar', 'czf', \\'$HOME/out.tgz', \'/var/log/server.*.log');
  
  As shell quoting is a tricky matter, I expect bugs to appear in this
  area. You can see how C<ssh> is called, and the quoting used setting
  the following debug flag:
  
    $Net::OpenSSH::debug |= 16;
  
  By default, the module assumes the remote shell is some variant of a
  POSIX or Bourne shell (C<bash>, C<dash>, C<ksh>, etc.). If this is not
  the case, the construction option C<remote_shell> can be used to
  select an alternative quoting mechanism.
  
  For instance:
  
    $ssh = Net::OpenSSH->new($host, remote_shell => 'csh');
    $ssh->system(echo => "hard\n to\n  quote\n   argument!");
  
  Currently there are quoters available for POSIX (Bourne) compatible
  shells, C<csh> and the two Windows variants C<MSWin> (for servers
  using L<Win32::CreateProcess>, see
  L<Net::OpenSSH::ShellQuoter::MSWin>) and C<MSCmd> (for servers using
  C<cmd.exe>, see L<Net::OpenSSH::ShellQuoter::MSCmd>).
  
  In any case, you can always do the quoting yourself and pass the
  quoted remote command as a single string:
  
    # for VMS
    $ssh->system('DIR/SIZE NFOO::USERS:[JSMITH.DOCS]*.TXT;0');
  
  Note that the current quoting mechanism does not handle possible
  aliases defined by the remote shell. In that case, to force execution
  of the command instead of the alias, the full path to the command must
  be used.
  
  =head2 Timeouts
  
  In order to stop remote processes when they timeout, the ideal approach
  would be to send them signals through the SSH connection as specified
  by the protocol standard.
  
  Unfortunately OpenSSH does not implement that feature so Net::OpenSSH
  has to use other imperfect approaches:
  
  =over 4
  
  =item * close slave I/O streams
  
  Closing the STDIN and STDOUT streams of the unresponsive remote
  process will effectively deliver a SIGPIPE when it tries to access any
  of them.
  
  Remote processes may not access STDIN or STDOUT and even then,
  Net::OpenSSH can only close these channels when it is capturing them,
  so this approach does not always work.
  
  =item * killing the local SSH slave process
  
  This action may leave the remote process running, creating a remote
  orphan so Net::OpenSSH does not use it unless the construction option
  C<kill_ssh_on_timeout> is set.
  
  =back
  
  Luckily, future versions of OpenSSH will support signaling remote
  processes via the mux channel.
  
  =head2 Variable expansion
  
  The variable expansion feature allows one to define variables that are
  expanded automatically inside command arguments and file paths.
  
  This feature is disabled by default. It is intended to be used with
  L<Net::OpenSSH::Parallel|Net::OpenSSH::Parallel> and other similar
  modules.
  
  Variables are delimited by a pair of percent signs (C<%>), for
  instance C<%HOST%>. Also, two consecutive percent signs are replaced
  by a single one.
  
  The special variables C<HOST>, C<USER> and C<PORT> are maintained
  internally by the module and take the obvious values.
  
  Variable expansion is performed before shell quoting (see L</"Shell
  quoting">).
  
  Some usage example:
  
    my $ssh = Net::OpenSSH->new('server.foo.com', expand_vars => 1);
    $ssh->set_var(ID => 42);
    $ssh->system("ls >/tmp/ls.out-%HOST%-%ID%");
  
  will redirect the output of the C<ls> command to
  C</tmp/ls.out-server.foo.com-42> on the remote host.
  
  =head2 Tunnels
  
  Besides running commands on the remote host, Net::OpenSSH also allows
  one to tunnel TCP connections to remote machines reachable from the
  SSH server.
  
  That feature is made available through the C<tunnel> option of the
  L</open_ex> method, and also through wrapper methods L</open_tunnel>
  and L</capture_tunnel> and most others where it makes sense.
  
  Example:
  
    $ssh->system({tunnel => 1,
                  stdin_data => "GET / HTTP/1.0\r\n\r\n",
                  stdout_file => "/tmp/$server.res"},
                 $server, 80)
        or die "unable to retrieve page: " . $ssh->error;
  
  or capturing the output of several requests in parallel:
  
    my @pids;
    for (@servers) {
      my $pid = $ssh->spawn({tunnel => 1,
                             stdin_file => "/tmp/request.req",
                             stdout_file => "/tmp/$_.res"},
                            $_, 80);
      if ($pid) {
        push @pids, $pid;
      }
      else {
        warn "unable to spawn tunnel process to $_: " . $ssh->error;
      }
    }
    waitpid ($_, 0) for (@pids);
  
  Under the hood, in order to create a tunnel, a new C<ssh> process is
  spawned with the option C<-W${address}:${port}> (available from
  OpenSSH 5.4 and upwards) making it redirect its stdio streams to the
  remote given address. Unlike when C<ssh> C<-L> options is used to
  create tunnels, no TCP port is opened on the local machine at any time
  so this is a perfectly secure operation.
  
  The PID of the new process is returned by the named methods. It must
  be reaped once the pipe or socket handlers for the local side of the
  tunnel have been closed.
  
  OpenSSH 5.4 or later is required for the tunnels functionality to
  work. Also, note that tunnel forwarding may be administratively
  forbidden at the server side (see L<sshd(8)> and L<sshd_config(5)> or
  the documentation provided by your SSH server vendor).
  
  =head3 Tunnels targeting UNIX sockets
  
  When connecting to hosts running a recent version of OpenSSH sshd, it
  is also possible to open connections targeting Unix sockets.
  
  For instance:
  
    my $response = $ssh->capture({tunnel => 1, stdin_data => $request },
                                 "/tmp/socket-foo");
  
  Currently, this feature requires a patched OpenSSH ssh client. The
  patch is available as
  C<patches/openssh-fwd-stdio-to-streamlocal-1.patch>.
  
  =head3 Port forwarding
  
  L<Net::OpenSSH> does not offer direct support for handling port
  forwardings between server and client. But that can be done easily
  anyway passing custom SSH options to its methods.
  
  For instance, tunnel creation options can be passed to the constructor:
  
    my $ssh = Net::OpenSSH->new(...
                      master_opts => -Llocalhost:1234:localhost:3306');
  
  The port forwardings can also be changed for a running SSH connection
  using a Control command:
  
      # setting up a tunnel:
      $ssh->system({ssh_opts => ['-O','forward',
                                 '-L127.0.0.1:12345:127.0.0.1:3306']});
  
      # canceling it:
      $ssh->system({ssh_opts => ['-O', 'cancel',
                                 '-L127.0.0.1:12345:127.0.0.1:3306']});
  
  =head2 Data encoding
  
  Net::OpenSSH has some support for transparently converting the data send
  or received from the remote server to Perl internal unicode
  representation.
  
  The methods supporting that feature are those that move data from/to
  Perl data structures (e.g. C<capture>, C<capture2>, C<capture_tunnel>
  and methods supporting the C<stdin_data> option). Data accessed through
  pipes, sockets or redirections is not affected by the encoding options.
  
  It is also possible to set the encoding of the command and arguments
  passed to the remote server on the command line.
  
  By default, if no encoding option is given on the constructor or on the
  method calls, Net::OpenSSH will not perform any encoding transformation,
  effectively processing the data as C<latin1>.
  
  When data can not be converted between the Perl internal
  representation and the selected encoding inside some Net::OpenSSH
  method, it will fail with an C<OSSH_ENCODING_ERROR> error.
  
  The supported encoding options are as follows:
  
  =over 4
  
  =item stream_encoding => $encoding
  
  sets the encoding of the data send and received on capture methods.
  
  =item argument_encoding => $encoding
  
  sets the encoding of the command line arguments
  
  =item encoding => $encoding
  
  sets both C<argument_encoding> and C<stream_encoding>.
  
  =back
  
  The constructor also accepts C<default_encoding>,
  C<default_stream_encoding> and C<default_argument_encoding> that set the
  defaults.
  
  =head2 Diverting C<new>
  
  When a code ref is installed at C<$Net::OpenSSH::FACTORY>, calls to new
  will be diverted through it.
  
  That feature can be used to transparently implement connection
  caching, for instance:
  
    my $old_factory = $Net::OpenSSH::FACTORY;
    my %cache;
  
    sub factory {
      my ($class, %opts) = @_;
      my $signature = join("\0", $class, map { $_ => $opts{$_} }, sort keys %opts);
      my $old = $cache{signature};
      return $old if ($old and $old->error != OSSH_MASTER_FAILED);
      local $Net::OpenSSH::FACTORY = $old_factory;
      $cache{$signature} = $class->new(%opts);
    }
  
    $Net::OpenSSH::FACTORY = \&factory;
  
  ... and I am sure it can be abused in several other ways!
  
  
  =head1 3rd PARTY MODULE INTEGRATION
  
  =head2 Expect
  
  Sometimes you would like to use L<Expect> to control some program
  running in the remote host. You can do it as follows:
  
    my ($pty, $pid) = $ssh->open2pty(@cmd)
        or die "unable to run remote command @cmd";
    my $expect = Expect->init($pty);
  
  Then, you will be able to use the new Expect object in C<$expect> as
  usual.
  
  =head2 Net::Telnet
  
  This example is adapted from L<Net::Telnet> documentation:
  
    my ($pty, $pid) = $ssh->open2pty({stderr_to_stdout => 1})
      or die "unable to start remote shell: " . $ssh->error;
    my $telnet = Net::Telnet->new(-fhopen => $pty,
                                  -prompt => '/.*\$ $/',
                                  -telnetmode => 0,
                                  -cmd_remove_mode => 1,
                                  -output_record_separator => "\r");
  
    $telnet->waitfor(-match => $telnet->prompt,
                     -errmode => "return")
      or die "login failed: " . $telnet->lastline;
  
    my @lines = $telnet->cmd("who");
  
    ...
  
    $telnet->close;
    waitpid($pid, 0);
  
  =head2 mod_perl and mod_perl2
  
  L<mod_perl> and L<mod_perl2> tie STDIN and STDOUT to objects that are
  not backed up by real file descriptors at the operating system
  level. Net::OpenSSH will fail if any of these handles is used
  explicitly or implicitly when calling some remote command.
  
  The work-around is to redirect them to C</dev/null> or to some file:
  
    open my $def_in, '<', '/dev/null' or die "unable to open /dev/null";
    my $ssh = Net::OpenSSH->new($host,
                                default_stdin_fh => $def_in);
  
    my $out = $ssh->capture($cmd1);
    $ssh->system({stdout_discard => 1}, $cmd2);
    $ssh->system({stdout_to_file => '/tmp/output'}, $cmd3);
  
  Also, note that from a security stand point, running C<ssh> from
  inside the web server process is not a great idea. An attacker
  exploiting some Apache bug would be able to access the SSH keys and
  passwords and gain unlimited access to the remote systems.
  
  If you can, use a queue (as L<TheSchwartz|TheSchwartz>) or any other
  mechanism to execute the ssh commands from another process running
  under a different user account.
  
  At a minimum, ensure that C<~www-data/.ssh> (or similar) is not
  accessible through the web server!
  
  =head2 Net::SFTP::Foreign
  
  See L<method C<sftp>|/Net_SFTP_Foreign>.
  
  =head2 Net::SSH::Any
  
  See L<method C<any>|/Net_SSH_Any>.
  
  =head2 Object::Remote
  
  See L<method C<object_remote>|/Object_Remote>.
  
  =head2 AnyEvent (and similar frameworks)
  
  X<AnyEvent>Net::OpenSSH provides all the functionality required to be
  integrated inside event oriented programming framework such as
  L<AnyEvent> or L<IO::Async> in the following way:
  
  =over 4
  
  =item 1. Create a disconnected Net::OpenSSH object:
  
      my $ssh = Net::OpenSSH->new($host, async => 1, ...);
  
  =item 2. Let the object connect to the remote host:
  
  Use a timer to call the C<wait_for_master> method in async mode
  repeatedly until it returns a true value indicating success.
  
  Also, the object error state needs to be checked after every call in
  order to detect failed connections. For instance:
  
    my $ssh = Net::OpenSSH->new(..., async => 1);
    my $w;
    $w = AE::timer 0.1, 0.1, sub {
      if ($ssh->wait_for_master(1)) {
        # the connection has been established!
        # remote commands can be run now
        undef $w;
        on_ssh_success(...);
      }
      elsif ($ssh->error) {
        # connection can not be established
        undef $w;
        on_ssh_failure(...);
      }
    }
  
  =item 3. Use the event framework to launch the remote processes:
  
  Call Net::OpenSSH C<make_remote_command> to construct commands which
  can be run using the framework regular facilities for launching external
  commands.
  
  Error checking should also be performed at this point because the SSH
  connection could be broken.
  
  For instance:
  
    if (defined(my $cmd = $ssh->make_remote_command(echo => 'hello!')) {
      AnyEvent::Util::run_cmd($cmd, %run_cmd_opts);
    }
    else {
      # something went wrong!
    }
  
  Alternatively, any of the C<open*> methods provided by Net::OpenSSH
  could also be used to launch remote commands.
  
  =item 4. When finished, disconnect asynchronously
  
  After initiating an asynchronous disconnect with C<disconnect(1)>,
  repeatedly call C<wait_for_master> until you get a defined but false
  value:
  
    $ssh->disconnect(1);
  
    my $w; $w = AE::timer 0.1, 0.1, sub {
      my $res = $ssh->wait_for_master(1);
  
      if (defined $res && !$res) {
        undef $w;
        undef $ssh;
      }
    };
  
  Be careful not to let the C<$ssh> object go out of scope until the
  disconnection has finished, otherwise its destructor will wait and
  block your program until the disconnection has completed.
  
  =back
  
  =head2 Other modules
  
  CPAN contains several modules that rely on SSH to perform their duties
  as for example L<IPC::PerlSSH|IPC::PerlSSH> or
  L<GRID::Machine|GRID::Machine>.
  
  Often, it is possible to instruct them to go through a Net::OpenSSH
  multiplexed connection employing some available constructor
  option. For instance:
  
    use Net::OpenSSH;
    use IPC::PerlIPC;
    my $ssh = Net::OpenSSH->new(...);
    $ssh->error and die "unable to connect to remote host: " . $ssh->error;
    my @cmd = $ssh->make_remote_command('/usr/bin/perl');
    my $ipc = IPC::PerlSSH->new(Command => \@cmd);
    my @r = $ipc->eval('...');
  
  or...
  
    use GRID::Machine;
    ...
    my @cmd = $ssh->make_remote_command('/usr/bin/perl');
    my $grid = GRID::Machine->new(command => \@cmd);
    my $r = $grid->eval('print "hello world!\n"');
  
  In other cases, some kind of plugin mechanism is provided by the 3rd
  party modules to allow for different transports. The method C<open2>
  may be used to create a pair of pipes for transport in these cases.
  
  =head1 TROUBLESHOOTING
  
  Usually, Net::OpenSSH works out of the box, but when it fails, some
  users have a hard time finding the cause of the problem. This mini
  troubleshooting guide should help you to find and solve it.
  
  =over 4
  
  =item 1 - check the error message
  
  Add in your script, after the Net::OpenSSH constructor call, an error
  check:
  
    $ssh = Net::OpenSSH->new(...);
    $ssh->error and die "SSH connection failed: " . $ssh->error;
  
  The error message will tell what has gone wrong.
  
  =item 2 - Check the connection parameters
  
  Believe it or not, passing bad parameters to Net::OpenSSH turns to be
  one of the top causes of failures so check that you are using the
  right parameters.
  
  Specifically, if you are obtaining them from the outside, ensure that
  they don't have extra spaces or new lines attached (do you need to
  C<chomp>?).
  
  Passwords and URIs may contain C<$> or C<@> characters. If you have
  then hardcoded in your script, check that those are quoted properly
  (and BTW, use C<strict>).
  
  =item 3 - OpenSSH version
  
  Ensure that you have a version of C<ssh> recent enough:
  
    $ ssh -V
    OpenSSH_5.1p1 Debian-5, OpenSSL 0.9.8g 19 Oct 2007
  
  OpenSSH version 4.1 was the first to support the multiplexing feature
  and is the minimal required by the module to work. I advise you to use
  the latest OpenSSH (currently 7.5).
  
  The C<ssh_cmd> constructor option lets you select the C<ssh> binary to
  use. For instance:
  
    $ssh = Net::OpenSSH->new($host,
                             ssh_cmd => "/opt/OpenSSH/5.8/bin/ssh")
  
  Some hardware vendors (e.g. Sun, err... Oracle) include custom
  versions of OpenSSH bundled with the operating system. In principle,
  Net::OpenSSH should work with these SSH clients as long as they are
  derived from some version of OpenSSH recent enough. Anyway, my advise
  is to use the real OpenSSH software if you can!
  
  =item 4 - run ssh from the command line
  
  Check you can connect to the remote host using the same parameters you
  are passing to Net::OpenSSH. In particular, ensure that you are
  running C<ssh> as the same local user.
  
  If you are running your script from a web server, the user
  would probably be C<www>, C<apache> or something alike.
  
  Common problems are:
  
  =over 4
  
  =item *
  
  Remote host public key not present in known_hosts file.
  
  The SSH protocol uses public keys to identify the remote hosts so that
  they can not be supplanted by some malicious third parties.
  
  For OpenSSH, usually the server public key is stored in
  C</etc/ssh/ssh_host_dsa_key.pub> or in
  C</etc/ssh/ssh_host_rsa_key.pub> and that key should be copied into the
  C<~/.ssh/known_hosts> file in the local machine (other SSH
  implementations may use other file locations).
  
  Maintaining the server keys when several hosts and clients are
  involved may be somewhat inconvenient, so most SSH clients, by
  default, when a new connection is established to a host whose key is
  not in the C<known_hosts> file, show the key and ask the user if he
  wants the key copied there.
  
  =item *
  
  Wrong remote host public key in known_hosts file.
  
  This is another common problem that happens when some server is
  replaced or reinstalled from scratch and its public key changes
  becoming different to that installed on the C<known_hosts> file.
  
  The easiest way to solve that problem is to remove the old key from
  the C<known_hosts> file by hand using any editor and then to connect
  to the server replying C<yes> when asked to save the new key.
  
  =item *
  
  Wrong permissions for the C<~/.ssh> directory or its contents.
  
  OpenSSH client performs several checks on the access permissions of
  the C<~/.ssh> directory and its contents and refuses to use them when
  misconfigured. See the FILES section from the L<ssh(1)> man page.
  
  =item *
  
  Incorrect settings for password or public key authentication.
  
  Check that you are using the right password or that the user public
  key is correctly installed on the server.
  
  =back
  
  =item 5 - security checks on the multiplexing socket
  
  Net::OpenSSH performs some security checks on the directory where the
  multiplexing socket is going to be placed to ensure that it can not be
  accessed by other users.
  
  The default location for the multiplexing socket is under
  C<~/.libnet-openssh-perl>. It can be changed using the C<ctl_dir> and
  C<ctl_path> constructor arguments.
  
  The requirements for that directory and all its parents are:
  
  =over 4
  
  =item *
  
  They have to be owned by the user executing the script or by root
  
  =item *
  
  Their permission masks must be 0755 or more restrictive, so nobody
  else has permissions to perform write operations on them.
  
  =back
  
  The constructor option C<strict_mode> disables these security checks,
  but you should not use it unless you understand its implications.
  
  =item 6 - file system must support sockets
  
  Some file systems (as for instance FAT or AFS) do not support placing
  sockets inside them.
  
  Ensure that the C<ctl_dir> path does not lay into one of those file
  systems.
  
  =back
  
  =head1 DEBUGGING
  
  Debugging of Net::OpenSSH internals is controlled through the variable
  C<$Net::OpenSSH::debug>. Every bit of this variable activates
  debugging of some subsystem as follows:
  
  =over 4
  
  =item bit 1 - errors
  
  Dumps changes on the internal object attribute where errors are stored.
  
  =item bit 2 - ctl_path
  
  Dumps information about ctl_path calculation and the tests performed
  on that directory in order to decide if it is secure to place the
  multiplexing socket inside.
  
  =item bit 4 - connecting
  
  Dumps information about the establishment of new master connections.
  
  =item bit 8 - commands and arguments
  
  Dumps the command and arguments for every system/exec call.
  
  =item bit 16 - command execution
  
  Dumps information about the progress of command execution.
  
  =item bit 32 - destruction
  
  Dumps information about the destruction of Net::OpenSSH objects and
  the termination of the SSH master processes.
  
  =item bit 64 - IO loop
  
  Dumps information about the progress of the IO loop on capture
  operations.
  
  =item bit 128 - IO hexdumps
  
  Generates hexdumps of the information that travels through the SSH
  streams inside capture operations.
  
  =item bit 512 - OS tracing of the master process
  
  Use the module L<Net::OpenSSH::OSTracer> to trace the SSH master
  process at the OS level.
  
  =back
  
  For instance, in order to activate all the debugging flags, you can
  use:
  
    $Net::OpenSSH::debug = ~0;
  
  Note that the meaning of the flags and the information generated is
  only intended for debugging of the module and may change without
  notice between releases.
  
  If you are using password authentication, enabling debugging for
  L<IO::Tty> may also show interesting information:
  
      $IO::Tty::DEBUG = 1;
  
  Finally, by default debugging output is sent to C<STDERR>. You can
  override it pointing C<$Net::OpenSSH::debug_fh> to a different file
  handle. For instance:
  
    BEGIN {
      open my $out, '>', '/tmp/debug.txt' or warn $!;
      $Net::OpenSSH::debug_fh = $out;
      $Net::OpenSSH::debug = -1;
    }
  
  =head1 SECURITY
  
  B<Q>: Is this module secure?
  
  B<A>: Well, it tries to be!
  
  From a security standpoint the aim of this module is to be as secure
  as OpenSSH, your operating system, your shell and in general your
  environment allow it to be.
  
  It does not take any shortcut just to make your life easier if that
  means lowering the security level (for instance, disabling
  C<StrictHostKeyChecking> by default).
  
  In code supporting features that are not just proxied to OpenSSH,
  the module tries to keep the same standards of security as OpenSSH
  (for instance, checking directory and file permissions when placing
  the multiplexing socket).
  
  On the other hand, and keeping with OpenSSH philosophy, the module
  lets you disable most (all?) of those security measures. But just
  because it lets you do it it doesn't mean it is a good idea to do
  so!!!
  
  If you are a novice programmer or SSH user, and googling you have just
  found some flag that you don't understand but that seems to magically
  solve your connection problems... well, believe me, it is probably a
  bad idea to use it. Ask somebody how really knows first!
  
  Just to make thinks clear, if your code contains any of the keywords
  from the (non-exclusive) list below and you don't know why, you are
  probably wrecking the security of the SSH protocol:
  
    strict_mode
    StrictHostKeyChecking
    UserKnownHostsFile
  
  Other considerations related to security you may like to know are as
  follows:
  
  =over 4
  
  =item Taint mode
  
  The module supports working in taint mode.
  
  If you are in an exposed environment, you should probably enable it
  for your script in order to catch any unchecked command for being
  executed in the remote side.
  
  =item Web environments
  
  It is a bad idea to establish SSH connections from your webserver
  because if it becomes compromised in any way, the attacker would be
  able to use the credentials from your script to connect to the remote
  host and do anything he wishes there.
  
  =item Command quoting
  
  The module can quote commands and arguments for you in a flexible
  and powerful way.
  
  This is a feature you should use as it reduces the possibility of some
  attacker being able to inject and run arbitrary commands on the remote
  machine (and even for scripts that are not exposed it is always
  advisable to enable argument quoting).
  
  Having said that, take into consideration that argument-quoting is
  just a hack to emulate the invoke-without-a-shell feature of Perl
  builtins such as C<system> and alike. There may be bugs(*) on the
  quoting code, your particular shell may have different quoting rules
  with unhandled corner cases or whatever. If your script is exposed to
  the outside, you should check your inputs and restrict what you accept
  as valid.
  
  [* even if this is one of the parts of the module more intensively
  tested!]
  
  =item Shellshock
  
  (see L<Shellshock|http://en.wikipedia.org/wiki/Shellshock_%28software_bug%29>)
  
  When executing local commands, the module always avoids calling the
  shell so in this way it is not affected by Shellshock.
  
  Unfortunately, some commands (C<scp>, C<rsync> and C<ssh> when the
  C<ProxyCommand> option is used) invoke other commands under the hood
  using the user shell. That opens the door to local Shellshock
  exploitation.
  
  On the remote side invocation of the shell is unavoidable due to the
  protocol design.
  
  By default, SSH does not forward environment variables but some Linux
  distributions explicitly change the default OpenSSH configuration to
  enable forwarding and acceptance of some specific ones (for instance
  C<LANG> and C<LC_*> on Debian and derivatives, Fedora does alike) and
  this also opens the door to Shellshock exploitation.
  
  Note that the shell used to invoke commands is not C</bin/sh> but the
  user shell as configured in C</etc/passwd>, PAM or whatever
  authentication subsystem is used by the local or remote operating
  system. Debian users, don't think you are not affected because
  your C</bin/sh> points to C<dash>!
  
  =back
  
  =head1 FAQ
  
  Frequent questions about the module:
  
  =over
  
  =item Connecting to switches, routers, etc.
  
  B<Q>: I can not get the method C<system>, C<capture>, etc., to work
  when connecting to some router, switch, etc. What I am doing wrong?
  
  B<A>: Roughly, the SSH protocol allows for two modes of operation:
  command mode and interactive mode.
  
  Command mode is designed to run single commands on the remote host. It
  opens a SSH channel between both hosts, asks the remote computer to
  run some given command and when it finishes, the channel is closed. It
  is what you get, for instance, when you run something as...
  
    $ ssh my.unix.box cat foo.txt
  
  ... and it is also the way Net::OpenSSH runs commands on the remote
  host.
  
  Interactive mode launches a shell on the remote hosts with its stdio
  streams redirected to the local ones so that the user can
  transparently interact with it.
  
  Some devices (as probably the one you are using) do not run an
  standard, general purpose shell (e.g. C<bash>, C<csh> or C<ksh>) but
  some custom program specially targeted and limited to the task of
  configuring the device.
  
  Usually, the SSH server running on these devices does not support
  command mode. It unconditionally attaches the restricted shell to any
  incoming SSH connection and waits for the user to enter commands
  through the redirected stdin stream.
  
  The only way to work-around this limitation is to make your script
  talk to the restricted shell (1-open a new SSH session, 2-wait for the
  shell prompt, 3-send a command, 4-read the output until you get to the
  shell prompt again, repeat from 3). The best tool for this task is
  probably L<Expect>, used alone or combined with Net::OpenSSH (see
  L</Expect>).
  
  There are some devices that support command mode but that only accept
  one command per connection. In that cases, using L<Expect> is also
  probably the best option.
  
  Nowadays, there is a new player, L<Net::CLI::Interact> that may be
  more suitable than Expect, and L<Net::Appliance::Session> for working
  specifically with network devices.
  
  =item Connection fails
  
  B<Q>: I am unable to make the module connect to the remote host...
  
  B<A>: Have you read the troubleshooting section? (see
  L</TROUBLESHOOTING>).
  
  =item Disable StrictHostKeyChecking
  
  B<Q>: Why is C<ssh> not run with C<StrictHostKeyChecking=no>?
  
  B<A>: Using C<StrictHostKeyChecking=no> relaxes the default security
  level of SSH and it will be relatively easy to end with a
  misconfigured SSH (for instance, when C<known_hosts> is unwritable)
  that could be forged to connect to a bad host in order to perform
  man-in-the-middle attacks, etc.
  
  I advice you to do not use that option unless you fully understand its
  implications from a security point of view.
  
  If you want to use it anyway, past it to the constructor:
  
    $ssh = Net::OpenSSH->new($host,
             master_opts => [-o => "StrictHostKeyChecking=no"],
             ...);
  
  =item child process STDIN/STDOUT/STDERR is not a real system file
  handle
  
  B<Q>: Calls to C<system>, C<capture>, etc. fail with the previous
  error, what's happening?
  
  B<A>: The reported stdio stream is closed or is not attached to a real
  file handle (e.g. it is a tied handle). Redirect it to C</dev/null> or
  to a real file:
  
    my $out = $ssh->capture({stdin_discard => 1, stderr_to_stdout => 1},
                            $cmd);
  
  See also the L<mod_perl> entry above.
  
  =item Solaris (and AIX and probably others)
  
  B<Q>: I was trying Net::OpenSSH on Solaris and seem to be running into
  an issue...
  
  B<A>: The SSH client bundled with Solaris is an early fork of OpenSSH
  that does not provide the multiplexing functionality required by
  Net::OpenSSH. You will have to install the OpenSSH client.
  
  Precompiled packages are available from Sun Freeware
  (L<http://www.sunfreeware.com>). There, select your OS version an CPU
  architecture, download the OpenSSH package and its dependencies and
  install them. Note that you do B<not> need to configure Solaris to use
  the OpenSSH server C<sshd>.
  
  Ensure that OpenSSH client is in your path before the system C<ssh> or
  alternatively, you can hardcode the full path into your scripts
  as follows:
  
    $ssh = Net::OpenSSH->new($host,
                             ssh_cmd => '/usr/local/bin/ssh');
  
  AIX and probably some other unixen, also bundle SSH clients lacking
  the multiplexing functionality and require installation of the real
  OpenSSH.
  
  =item Can not change working directory
  
  B<Q>: I want to run some command inside a given remote directory but I
  am unable to change the working directory. For instance:
  
    $ssh->system('cd /home/foo/bin');
    $ssh->systen('ls');
  
  does not list the contents of C</home/foo/bin>.
  
  What am I doing wrong?
  
  B<A>: Net::OpenSSH (and, for that matter, all the SSH modules
  available from CPAN but L<Net::SSH::Expect>) run every command in a
  new session so most shell builtins that are run for its side effects
  become useless (e.g. C<cd>, C<export>, C<ulimit>, C<umask>, etc.,
  usually, you can list them running C<help> from the shell).
  
  A work around is to combine several commands in one, for instance:
  
    $ssh->system('cd /home/foo/bin && ls');
  
  Note the use of the shell C<&&> operator instead of C<;> in order to
  abort the command as soon as any of the subcommands fail.
  
  Also, several commands can be combined into one while still using the
  multi-argument quoting feature as follows:
  
    $ssh->system(@cmd1, \\'&&', @cmd2, \\'&&', @cmd3, ...);
  
  =item Running detached remote processes
  
  B<Q>: I need to be able to ssh into several machines from my script,
  launch a process to run in the background there, and then return
  immediately while the remote programs keep running...
  
  B<A>: If the remote systems run some Unix/Linux variant, the right
  approach is to use L<nohup(1)> that will disconnect the remote process
  from the stdio streams and to ask the shell to run the command on the
  background. For instance:
  
    $ssh->system("nohup $long_running_command &");
  
  Also, it may be possible to demonize the remote program. If it is
  written in Perl you can use L<App::Daemon> for that (actually, there
  are several CPAN modules that provided that kind of functionality).
  
  In any case, note that you should not use L</spawn> for that.
  
  =item MaxSessions server limit reached
  
  B<Q>: I created an C<$ssh> object and then fork a lot children
  processes which use this object. When the children number is bigger
  than C<MaxSessions> as defined in sshd configuration (defaults to 10),
  trying to fork new remote commands will prompt the user for the
  password.
  
  B<A>: When the slave SSH client gets a response from the remote
  servers saying that the maximum number of sessions for the current
  connection has been reached, it fall backs to open a new direct
  connection without going through the multiplexing socket.
  
  To stop that for happening, the following hack can be used:
  
    $ssh = Net::OpenSSH->new(host,
        default_ssh_opts => ['-oConnectionAttempts=0'],
        ...);
  
  =item Running remote commands with sudo
  
  B<Q>: How can I run remote commands using C<sudo> to become root first?
  
  B<A>: The simplest way is to tell C<sudo> to read the password from
  stdin with the C<-S> flag and to do not use cached credentials
  with the C<-k> flag. You may also like to use the C<-p> flag to tell
  C<sudo> to print an empty prompt. For instance:
  
    my @out = $ssh->capture({ stdin_data => "$sudo_passwd\n" },
                            'sudo', '-Sk',
                            '-p', '',
                            '--',
                            @cmd);
  
  If the version of sudo installed on the remote host does not support
  the C<-S> flag (it tells sudo to read the password from its STDIN
  stream), you can do it as follows:
  
    my @out = $ssh->capture({ tty => 1,
                              stdin_data => "$sudo_passwd\n" },
                            'sudo', '-k',
                            '-p', '',
                            '--',
                            @cmd);
  
  This may generate an spurious and harmless warning from the SSH master
  connection (because we are requesting allocation of a tty on the
  remote side and locally we are attaching it to a regular pair of
  pipes).
  
  If for whatever reason the methods described above fail, you can
  always revert to using Expect to talk to the remote C<sudo>. See the
  C<examples/expect.pl> script from this module distribution.
  
  =back
  
  =head1 SEE ALSO
  
  OpenSSH client documentation L<ssh(1)>, L<ssh_config(5)>, the project
  web L<http://www.openssh.org> and its FAQ
  L<http://www.openbsd.org/openssh/faq.html>. L<scp(1)> and
  L<rsync(1)>. The OpenSSH Wikibook
  L<http://en.wikibooks.org/wiki/OpenSSH>.
  
  L<Net::OpenSSH::Gateway> for detailed instruction about how to get
  this module to connect to hosts through proxies and other SSH gateway
  servers.
  
  Core perl documentation L<perlipc>, L<perlfunc/open>,
  L<perlfunc/waitpid>.
  
  L<IO::Pty|IO::Pty> to known how to use the pseudo tty objects returned
  by several methods on this package.
  
  L<Net::SFTP::Foreign|Net::SFTP::Foreign> provides a compatible SFTP
  implementation.
  
  L<Expect|Expect> can be used to interact with commands run through
  this module on the remote machine (see also the C<expect.pl> and
  <autosudo.pl> scripts in the examples directory).
  
  L<SSH::OpenSSH::Parallel> is an advanced scheduler that allows one to run
  commands in remote hosts in parallel. It is obviously based on
  Net::OpenSSH.
  
  L<SSH::Batch|SSH::Batch> allows one to run remote commands in parallel in
  a cluster. It is build on top on C<Net::OpenSSH> also.
  
  Other Perl SSH clients: L<Net::SSH::Perl|Net::SSH::Perl>,
  L<Net::SSH2|Net::SSH2>, L<Net::SSH|Net::SSH>,
  L<Net::SSH::Expect|Net::SSH::Expect>, L<Net::SCP|Net::SCP>,
  L<Net::SSH::Mechanize|Net::SSH::Mechanize>.
  
  L<Net::OpenSSH::Compat> is a package offering a set of compatibility
  layers for other SSH modules on top of Net::OpenSSH.
  
  L<IPC::PerlSSH|IPC::PerlSSH>, L<GRID::Machine|GRID::Machine> allow
  execution of Perl code in remote machines through SSH.
  
  L<SSH::RPC|SSH::RPC> implements an RPC mechanism on top of SSH using
  Net::OpenSSH to handle the connections.
  
  L<Net::CLI::Interact> allows one to interact with remote shells
  and other services. It is specially suited for interaction with
  network equipment. The phrasebook approach it uses is very clever. You
  may also like to check the L<other
  modules|https://metacpan.org/author/OLIVER> from its author, Oliver
  Gorwits.
  
  =head1 BUGS AND SUPPORT
  
  =head2 Experimental features
  
  Support for the C<restart> feature is experimental.
  
  L<Object::Remote> integration is highly experimental.
  
  Support for tunnels targeting Unix sockets is highly experimental.
  
  Support for the C<setpgrp> feature is highly experimental.
  
  Support for the gateway feature is highly experimental and mostly
  stalled.
  
  Support for taint mode is experimental.
  
  =head2 Known issues
  
  Net::OpenSSH does not work on Windows. OpenSSH multiplexing feature
  requires passing file handles through sockets, something that is not
  supported by any version of Windows.
  
  It does not work on VMS either... well, probably, it does not work on
  anything not resembling a modern Linux/Unix OS.
  
  Old versions of OpenSSH C<ssh> may leave stdio streams in non-blocking
  mode. That can result on failures when writing to C<STDOUT> or
  C<STDERR> after using the module. In order to work-around this issue,
  Perl L<perlfunc/fcntl> can be used to unset the non-blocking flag:
  
    use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);
    my $flags = fcntl(STDOUT, F_GETFL, 0);
    fcntl(STDOUT, F_SETFL, $flags & ~O_NONBLOCK);
  
  =head2 Reporting bugs and asking for help
  
  To report bugs send an email to the address that appear below or use
  the CPAN bug tracking system at L<http://rt.cpan.org>.
  
  B<Post questions related to how to use the module in PerlMonks>
  L<http://perlmonks.org/>, you will probably get faster responses than
  if you address me directly and I visit PerlMonks quite often, so I
  will see your question anyway.
  
  =head2 Commercial support
  
  Commercial support, professional services and custom software
  development around this module are available through my current
  company. Drop me an email with a rough description of your
  requirements and we will get back to you ASAP.
  
  =head2 My wishlist
  
  If you like this module and you are feeling generous, take a look at
  my Amazon Wish List: L<http://amzn.com/w/1WU1P6IR5QZ42>.
  
  Also consider contributing to the OpenSSH project this module builds
  upon: L<http://www.openssh.org/donations.html>.
  
  =head1 TODO
  
  - Tests for C<scp_*>, C<rsync_*> and C<sftp> methods
  
  - Make L</pipe_in> and L</pipe_out> methods L</open_ex> based
  
  - C<auto_discard_streams> feature for mod_perl2 and similar environments
  
  - Refactor open_ex support for multiple commands, maybe just keeping
    tunnel, ssh and raw
  
  Send your feature requests, ideas or any feedback, please!
  
  =head1 CONTRIBUTING CODE
  
  The source code of this module is hosted at GitHub:
  L<http://github.com/salva/p5-Net-OpenSSH>.
  
  Code contributions to the module are welcome but you should obey the
  following rules:
  
  =over 4
  
  =item Only Perl 5.8.4 required
  
  Yes, that's pretty old, but Net::OpenSSH is intended to be also used
  by system administrators that sometimes have to struggle with old
  systems. The reason to pick 5.8.4 is that it has been the default perl
  on Solaris for a long time.
  
  =item Avoid the "All the world's a Linux PC" syndrome
  
  The module should work on any (barely) sane Unix or Linux operating
  system. Specially, it should not be assumed that the over-featured GNU
  utilities and toolchain are available.
  
  =item Dependencies are optional
  
  In order to make the module very easy to install, no mandatory
  dependencies on other CPAN modules are allowed.
  
  Optional modules, that are loaded only on demand, are acceptable when
  they are used for adding new functionality (as it is done, for
  instance, with L<IO::Pty>).
  
  Glue code for integration with 3rd party modules is also allowed (as
  it is done with L<Expect>).
  
  Usage of language extension modules and alike is not acceptable.
  
  =item Tests should be lax
  
  We don't want false negatives when testing. In case of doubt tests
  should succeed.
  
  Also, in case of tests invoking some external program, it should be
  checked that the external program is available and that it works as
  expected or otherwise skip those tests.
  
  =item Backward compatibility
  
  Nowadays Net::OpenSSH is quite stable and there are lots of scripts
  out there using it that we don't want to break, so, keeping the API
  backward compatible is a top priority.
  
  Probably only security issues could now justify a backward
  incompatible change.
  
  =item Follow my coding style
  
  Look at the rest of the code.
  
  I let Emacs do the formatting for me using cperl-mode PerlStyle.
  
  =item Talk to me
  
  Before making a large change or implementing a new feature get in
  touch with me.
  
  I may have my own ideas about how things should be done. It is better
  if you know them before hand, otherwise, you risk getting your patch
  rejected.
  
  =back
  
  Well, actually you should know that I am quite good at rejecting
  patches but it is not my fault!
  
  Most of the patches I get are broken in some way: they don't follow
  the main module principles, sometimes the author didn't get the full
  picture and solved the issue in a short-sighted way, etc.
  
  In any case, you should not be discouraged to contribute. Even if your
  patch is not applied directly, seeing how it solves your requirements
  or, in the case of bugs, the underlying problem analysis may be very
  useful and help me to do it... my way.
  
  I always welcome documentation corrections and improvements.
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008-2020 by Salvador FandiE<ntilde>o
  (sfandino@yahoo.com)
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.10.0 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
NET_OPENSSH

$fatpacked{"Net/OpenSSH/ConnectionCache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_CONNECTIONCACHE';
  package Net::OpenSSH::ConnectionCache;
  
  use strict;
  use warnings;
  
  use Net::OpenSSH;
  use Net::OpenSSH::Constants qw(:error);
  
  use Data::Dumper;
  use Scalar::Util qw(weaken);
  
  our $MAX_SIZE = 20;
  our %cache;
  
  sub _factory {
      my $class = shift;
      my %opts = @_;
      my $dump = Data::Dumper->new([\%opts], ['s']);
      $dump->Indent(0);
      $dump->Sortkeys(1);
      $dump->Deepcopy(1);
      my $signature = $dump->Dump;
      my $ssh = $cache{$signature};
      if ($ssh and $ssh->error != OSSH_MASTER_FAILED) {
          if ($opts{async} or $ssh->wait_for_master) {
              return $cache{$signature} = $ssh;
          }
      }
      if ($MAX_SIZE <= keys %cache) {
          for (keys %cache) {
              $ssh = $cache{$_};
              $ssh or $ssh->error != OSSH_MASTER_FAILED or delete $cache{$_}
          }
          for (keys %cache) {
              last if ($MAX_SIZE <= keys %cache);
              weaken $cache{$_};
              if (defined $cache{$_}) {
                  $cache{$_} = $cache{$_}; # unweaken
              }
              else {
                  delete $cache{$_};
              }
          }
      }
      local $Net::OpenSSH::FACTORY;
      $cache{$signature} = $class->new(@_);
  }
  
  $Net::OpenSSH::FACTORY = \&_factory;
  
  sub clean_cache { %cache = () }
  
  END { %cache = () }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Net::OpenSSH::ConnectionCache - cache and reuse SSH connections transparently
  
  =head1 SYNOPSIS
  
    use Net::OpenSSH;
    use Net::OpenSSH::ConnectionCache;
  
    for (1..10) {
      my $ssh = Net::OpenSSH->new($host);
      $ssh->system("$cmd $_");
    }
  
  =head1 DESCRIPTION
  
  This module installs a C<$Net::OpenSSH::FACTORY> hook implementing a
  SSH connection caching scheme.
  
  C<$Net::OpenSSH::ConnectionCache::MAX_SIZE> controls the cache
  size. Once as many connections are allocated, the module will try to
  free any of them before allocating a new one.
  
  The function C<clean_cache> makes the module forget (and close) all
  the cached connections:
  
    Net::OpenSSH::ConnectionCache::clean_cache();
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2011, 2014 by Salvador FandiE<ntilde>o
  (sfandino@yahoo.com)
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.10.0 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
NET_OPENSSH_CONNECTIONCACHE

$fatpacked{"Net/OpenSSH/Constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_CONSTANTS';
  package Net::OpenSSH::Constants;
  
  our $VERSION = '0.51_07';
  
  use strict;
  use warnings;
  use Carp;
  use Scalar::Util ();
  
  require Exporter;
  our @ISA = qw(Exporter);
  our %EXPORT_TAGS = (error => [], _state => []);
  
  my %error = ( OSSH_MASTER_FAILED => 1,
                OSSH_SLAVE_FAILED => 2,
                OSSH_SLAVE_PIPE_FAILED => 3,
  	      OSSH_SLAVE_TIMEOUT => 4,
  	      OSSH_SLAVE_CMD_FAILED => 5,
  	      OSSH_SLAVE_SFTP_FAILED => 6,
                OSSH_ENCODING_ERROR => 7
              );
  
  for my $key (keys %error) {
      no strict 'refs';
      my $value = $error{$key};
      *{$key} = sub () { $value };
      push @{$EXPORT_TAGS{error}}, $key
  }
  
  my @states = qw(_STATE_START
                  _STATE_LOGIN
                  _STATE_AWAITING_MUX
                  _STATE_RUNNING
                  _STATE_KILLING
                  _STATE_GONE
                  _STATE_STOPPED);
  
  my $last_value;
  for my $state (@states) {
      no strict 'refs';
      my $value = Scalar::Util::dualvar(++$last_value, $state);
      *{$state} = sub () { $value };
      push @{$EXPORT_TAGS{_state}}, $state
  }
  
  our @EXPORT_OK = map { @{$EXPORT_TAGS{$_}} } keys %EXPORT_TAGS;
  $EXPORT_TAGS{all} = [@EXPORT_OK];
  
  1;
  
  __END__
  
  =head1 NAME
  
  Net::OpenSSH::Constants - Constant definitions for Net::OpenSSH
  
  =head1 SYNOPSIS
  
    use Net::OpenSSH::Constants qw(:error);
  
  =head1 DESCRIPTION
  
  This module exports the following constants:
  
  =over 4
  
  =item :error
  
    OSSH_MASTER_FAILED - some error related to the master SSH connection happened
    OSSH_SLAVE_FAILED - some error related to a slave SSH connection happened
    OSSH_SLAVE_PIPE_FAILED - unable to create pipe to communicate with slave process
    OSSH_SLAVE_TIMEOUT - slave process timeout
    OSSH_SLAVE_CMD_FAILED - child process exited with a non zero status
    OSSH_SLAVE_SFTP_FAILED - creation of SFTP client failed
    OSSH_ENCODING_ERROR - some error related to the encoding/decoding of strings happened
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008, 2009 by Salvador FandiE<ntilde>o (sfandino@yahoo.com)
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.10.0 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
NET_OPENSSH_CONSTANTS

$fatpacked{"Net/OpenSSH/ModuleLoader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_MODULELOADER';
  package Net::OpenSSH::ModuleLoader;
  
  use strict;
  use warnings;
  use Carp;
  
  our %loaded_module;
  
  use Exporter qw(import);
  our @EXPORT = qw(_load_module);
  
  sub _load_module {
      my ($module, $version) = @_;
      $loaded_module{$module} ||= do {
          my $err;
          do {
              local ($@, $SIG{__DIE__});
              my $ok = eval "require $module; 1";
              $err = $@;
              $ok;
          } or croak "unable to load Perl module $module: $err";
      };
      if (defined $version) {
          my $mv = do {
              local ($@, $SIG{__DIE__});
              eval "\$${module}::VERSION";
          } || 0;
  	(my $mv1 = $mv) =~ s/_\d*$//;
  	croak "$module version $version required, $mv is available"
  	    if $mv1 < $version;
      }
      1
  }
  
  1;
NET_OPENSSH_MODULELOADER

$fatpacked{"Net/OpenSSH/OSTracer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_OSTRACER';
  package Net::OpenSSH::OSTracer;
  
  our $VERSION = '0.65_06';
  
  use strict;
  use warnings;
  
  use POSIX;
  
  our $cmd;
  our $type;
  our $output;
  our $sudo;
  our $delay;
  
  our @EXTRA_ARGS;
  
  my %type_by_os = (linux   => 'strace',
                    openbsd => 'ktrace',
                    freebsd => 'ktrace',
                    netbsd  => 'ktrace',
                    bsd     => 'ktrace',
                    'hp-ux' => 'tusc',
                    aix     => 'truss',
                    solaris => 'truss');
  
  sub trace {
      my $class = shift;
      my ($cmd, $type) = ($cmd, $type); # copy globals
  
  
      if (not defined $type) {
          my $os = lc $^O;
          if ( defined $cmd and $cmd =~ /([sk]trace|k?truss|tusc)$/) {
              $type = $1;
          }
          elsif ($os =~ /(linux|openbsd|freebsd|netbsd|bsd|hp-ux|aix|solaris)/) {
              $type = $type_by_os{$1};
          }
          else {
              Net::OpenSSH::_debug("unable to determine tracer type for OS $os");
              return;
          }
      }
  
      my $output1 = (defined $output ? $output : "/tmp/net_openssh_master") . ".$$";
      my $file = "$output1.$type";
      my $err = "$output1.txt";
  
      $cmd = $type unless defined $cmd;
  
      my @args;
      if ($type eq 'strace') {
          @args = (-o => $file, -p => $$, -s => 1024, '-fx');
      }
      elsif ($type eq 'ktruss') {
          @args = (-o => $file, -p => $$, -m => 1024, '-d');
      }
      elsif ($type eq 'ktrace') {
          @args = (-f => $file, -p => $$, '-id');
      }
      elsif ($type eq 'tusc') {
          @args = (-o => $file, -b => 1024, '-fa', $$)
      }
      elsif ($type eq 'truss') {
          @args = (-o => $file, -faep => $$);
      }
      else {
          Net::OpenSSH::_debug("tracer type $type not supported");
          return
      }
  
      my @cmd = (defined $sudo ? ($sudo, '-A', $cmd) : $cmd);
  
      my $pid = fork;
      unless ($pid) {
          unless (defined $pid) {
              Net::OpenSSH::_debug("unable to launch tracer, fork failed: $!");
              return;
          }
          my ($in, $out);
          if (open $in, '</dev/null'      and
              open $out, '>', $err        and
              POSIX::dup2(fileno $in, 0)  and
              POSIX::dup2(fileno $out, 1) and
              POSIX::dup2(fileno $out, 2)) {
              exec (@cmd, @EXTRA_ARGS, @args);
          }
          else {
              eval { Net::OpenSSH::_debug("Unable to redirect tracer IO: $!") };
          }
          POSIX::_exit(1);
      }
      sleep (defined $delay ? $delay : 1); # wait for the tracer to come up
      Net::OpenSSH::_debug("tracer attached, ssh pid: $$, tracer pid: $pid");
      1;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Net::OpenSSH::OSTracer - trace ssh master process at the OS level
  
  =head1 SYNOPSIS
  
      use Net::OpenSSH;
      $Net::OpenSSH::debug |= 512;
  
      Net::OpenSSH->new($host)->system("echo hello world");
  
      system "less /tmp/net_openssh_master.*.strace";
  
  =head1 DESCRIPTION
  
  This is a Net::OpenSSH helper module that allows you to trace the
  master C<ssh> process at the operating system level using the proper
  utility available in your system (e.g., C<strace>, C<truss>,
  C<ktruss>, C<tusc>, etc.).
  
  This feature can be used when debugging your programs or to report
  bugs on the module.
  
  It is enabled setting the flag 512 on the C<$Net::OpenSSH::debug> variable:
  
    $Net::OpenSSH::debug |= 512;
  
  By default the output files of the tracer are saved as
  C</tmp/net_openssh_master.$pid.$tracer_type>.
  
  Also, the output send by the tracer to stdout/stderr is saved as
  C</tmp/net_openssh_master.$pid.txt>.
  
  The module can be configured through the following global variables:
  
  =over 4
  
  =item $Net::OpenSSH::OSTracer::type
  
  By default, the module decides which tracer to use in base to the
  operating system name. This variable allows one to select a different
  tracer.
  
  Currently accepted types are: C<strace> (Linux), C<ktrace> (*BSD),
  C<tusc> (HP-UX) and C<truss> (Solaris and AIX).
  
  =item $Net::OpenSSH::OSTracer::cmd
  
  Command to execute for tracing the C<ssh> process.
  
  By default, it infers it from the tracer type selected.
  
  =item $Net::OpenSSH::OSTracer::output
  
  Basename for the destination file. The PID of the C<ssh> process and
  the tracer type will be appended.
  
  =item $Net::OpenSSH::OSTracer::sudo
  
  This variable can be used to request the tracer to be run with C<sudo>
  (some operating systems as for example Ubuntu, do not allow one to
  attach tracers, even to your own processes, unless you do it as root).
  
  The variable has to be set with the path of the C<sudo> binary. For
  instance:
  
    $Net::OpenSSH::OSTracer::sudo = '/usr/bin/sudo';
  
  If you need to pass a password to C<sudo>, set the environment
  variable C<SUDO_ASKPASS>. For instance:
  
    SUDO_ASKPASS=/usr/bin/ssh-askpass
  
  =item $Net::OpenSSH::OSTracer::delay
  
  This variable can be used to delay the C<ssh> execution so that the
  tracer can attach the process first. This is specially handy when
  using C<sudo> with a password.
  
  =back
  
  =head1 BUGS
  
  This module has not been tested under all the operating systems is
  says to support.
  
  If you find any problem, just report it, please!
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2012 by Salvador FandiE<ntilde>o
  (sfandino@yahoo.com)
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.10.0 or,
  at your option, any later version of Perl 5 you may have available.
  
  
  =cut
NET_OPENSSH_OSTRACER

$fatpacked{"Net/OpenSSH/ObjectRemote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_OBJECTREMOTE';
  package Net::OpenSSH::ObjectRemote;
  
  use strict;
  use warnings;
  
  use Moo;
  
  with 'Object::Remote::Role::Connector::PerlInterpreter';
  
  has net_openssh => (is => 'ro', required => 1);
  
  sub final_perl_command {
      my $self = shift;
      my $perl_command = $self->perl_command;
      [ $self->net_openssh->make_remote_command(@$perl_command) ];
  }
  
  1;
NET_OPENSSH_OBJECTREMOTE

$fatpacked{"Net/OpenSSH/SSH.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_SSH';
  package Net::OpenSSH::SSH;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Net::OpenSSH::SSH - Perl SSH client package implemented on top of OpenSSH
  
  =head1 DESCRIPTION
  
  Use the real thing: L<Net::OpenSSH>.
  
  This namespace is used so that the module gets indexed under the
  C<SSH> tag on popular CPAN search engines such as
  L<http://metacpan.org> and L<http://search.cpan.org>.
  
  =cut
NET_OPENSSH_SSH

$fatpacked{"Net/OpenSSH/ShellQuoter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_SHELLQUOTER';
  package Net::OpenSSH::ShellQuoter;
  
  use strict;
  use warnings;
  use Carp;
  
  use Net::OpenSSH::ModuleLoader;
  
  my %alias = (bash  => 'POSIX',
               sh    => 'POSIX',
               ksh   => 'POSIX',
               ash   => 'POSIX',
               dash  => 'POSIX',
               pdksh => 'POSIX',
               mksh  => 'POSIX',
               lksh  => 'POSIX',
               zsh   => 'POSIX',
               fizsh => 'POSIX',
               posh  => 'POSIX',
               fish  => 'fish',
               tcsh  => 'csh');
  
  sub quoter {
      my ($class, $shell) = @_;
      $shell = 'POSIX' unless defined $shell;
      return $shell if ref $shell;
      if ($shell =~ /,/) {
          require Net::OpenSSH::ShellQuoter::Chain;
          return Net::OpenSSH::ShellQuoter::Chain->chain(split /\s*,\s*/, $shell);
      }
      else {
          $shell = $alias{$shell} if defined $alias{$shell};
          $shell =~ /^\w+$/ or croak "bad quoting style $shell";
          my $impl = "Net::OpenSSH::ShellQuoter::$shell";
          _load_module($impl);
          return $impl->new;
      }
  }
  
  1;
NET_OPENSSH_SHELLQUOTER

$fatpacked{"Net/OpenSSH/ShellQuoter/Chain.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_SHELLQUOTER_CHAIN';
  package Net::OpenSSH::ShellQuoter::Chain;
  
  use strict;
  use warnings;
  
  use Net::OpenSSH::ShellQuoter;
  
  sub chain {
      my $class = shift;
      my @quoters = map Net::OpenSSH::ShellQuoter->quoter($_), reverse @_;
      my $self = \@quoters;
      bless $self, $class;
      $self;
  }
  
  sub quote {
      my ($self, $arg) = @_;
      $arg = $_->quote($arg) for @$self;
      $arg;
  }
  
  sub quote_glob {
      my ($self, $arg) = @_;
      if (@$self) {
          $arg = $self->[0]->quote_glob($arg);
          $arg = $self->[$_]->quote($arg) for 1..$#$self;
      }
      $arg
  }
  
  sub shell_fragments {
      my $self = shift;
      @$self or return (wantarray ? () : '');
      $self->[-1]->shell_fragments(@_)
  }
  
  
  1;
NET_OPENSSH_SHELLQUOTER_CHAIN

$fatpacked{"Net/OpenSSH/ShellQuoter/MSCmd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_SHELLQUOTER_MSCMD';
  package Net::OpenSSH::ShellQuoter::MSCmd;
  
  use strict;
  use warnings;
  use Carp;
  
  sub new { shift() }
  
  sub quote {
      shift;
      my $arg = shift;
      if ($arg =~ /[\r\n\0]/) {
          croak "can't quote newlines to pass through MS cmd.exe";
      }
      $arg =~ s/([()%!^"<>&|])/^$1/g;
      $arg;
  }
  
  *quote_glob = \&quote;
  
  my %fragments = ( stdin_discard             => '<NUL:',
                    stdout_discard            => '>NUL:',
                    stderr_discard            => '2>NUL:',
                    stdout_and_stderr_discard => '>NUL: 2>&1',
                    stderr_to_stdout          => '2>&1' );
  
  sub shell_fragments {
      shift;
      my @f = grep defined, @fragments{@_};
      wantarray ? @f : join(' ', @f);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Net::OpenSSH::ShellQuoter::MSCmd - Quoter for Windows cmd.exe
  
  =head1 DESCRIPTION
  
  This quoter is intended for interaction with SSH servers running on
  Windows which invoke the requested commands through the C<cmd.exe> shell.
  
  Because of C<cmd.exe> not doing wildcard expansion (on Windows this
  task is left to the final command), glob quoting just quotes
  everything.
  
  Some Windows servers use C<Win32::CreateProcess> to run the C<cmd.exe>
  shell which runs the requested command. In that case, both the C<MSCmd>
  and C<MSWin> quoters have to be chained (and BTW, order matters):
  
     $ssh = Net::OpenSSH->new(...,
                              remote_shell => 'MSCmd,MSWin');
  
  Actually, C<cmd.exe> may require not quoting at all when the requested
  command is a builtin (for instance, C<echo>).
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008-2014 by Salvador FandiE<ntilde>o
  (sfandino@yahoo.com)
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.10.0 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
NET_OPENSSH_SHELLQUOTER_MSCMD

$fatpacked{"Net/OpenSSH/ShellQuoter/MSWin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_SHELLQUOTER_MSWIN';
  package Net::OpenSSH::ShellQuoter::MSWin;
  
  use strict;
  use warnings;
  use Carp;
  
  sub new { shift() }
  
  sub quote {
      shift;
      my $arg = shift;
      if ($arg eq '') {
          return '""';
      }
      if ($arg =~ /[ \t\n\x0b"]/) {
          $arg =~ s{(\\+)(?="|\z)}{$1$1}g;
          $arg =~ s{"}{\\"}g;
          return qq("$arg");
      }
      return $arg;
  }
  
  *quote_glob = \&quote;
  
  sub shell_fragments { wantarray ? () : '' }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Net::OpenSSH::ShellQuoter::MSWin - Quoter for Win32::CreateProcess
  
  =head1 DESCRIPTION
  
  This quoter is intended for interaction with SSH servers running on
  Windows which use the C<Win32::CreateProcess> system call to launch the
  requested command.
  
  Because of C<Win32::CreateProcess> not doing wildcard expansion, glob
  quoting just quotes everything.
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008-2014 by Salvador FandiE<ntilde>o
  (sfandino@yahoo.com)
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.10.0 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
NET_OPENSSH_SHELLQUOTER_MSWIN

$fatpacked{"Net/OpenSSH/ShellQuoter/POSIX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_SHELLQUOTER_POSIX';
  package Net::OpenSSH::ShellQuoter::POSIX;
  
  use strict;
  use warnings;
  use Carp;
  
  sub new { __PACKAGE__ }
  
  my $noquote_class = '.\\w/\\-@,:';
  my $glob_class    = '*?\\[\\],\\{\\}:!^~';
  
  sub quote {
      shift;
      my $quoted = join '',
          map { ( m|\A'\z|                  ? "\\'"    :
                  m|\A'|                    ? "\"$_\"" :
                  m|\A[$noquote_class]+\z|o ? $_       :
                                            "'$_'"   )
            } split /('+)/, $_[0];
      length $quoted ? $quoted : "''";
  }
  
  
  sub quote_glob {
      shift;
      my $arg = shift;
      my @parts;
      while ((pos $arg ||0) < length $arg) {
          if ($arg =~ m|\G('+)|gc) {
              push @parts, (length($1) > 1 ? "\"$1\"" : "\\'");
          }
          elsif ($arg =~ m|\G([$noquote_class$glob_class]+)|gco) {
              push @parts, $1;
          }
          elsif ($arg =~ m|\G(\\[$glob_class\\])|gco) {
              push @parts, $1;
          }
          elsif ($arg =~ m|\G\\|gc) {
              push @parts, '\\\\'
          }
          elsif ($arg =~ m|\G([^$glob_class\\']+)|gco) {
              push @parts, "'$1'";
          }
          else {
              require Data::Dumper;
              $arg =~ m|\G(.+)|gc;
              die "Internal error: unquotable string:\n". Data::Dumper::Dumper($1) ."\n";
          }
      }
      my $quoted = join('', @parts);
      length $quoted ? $quoted : "''";
  }
  
  my %fragments = ( stdin_discard             => '</dev/null',
                    stdout_discard            => '>/dev/null',
                    stderr_discard            => '2>/dev/null',
                    stdout_and_stderr_discard => '>/dev/null 2>&1',
                    stderr_to_stdout          => '2>&1' );
  
  sub shell_fragments {
      shift;
      my @f = grep defined, @fragments{@_};
      wantarray ? @f : join(' ', @f);
  }
  
  1;
NET_OPENSSH_SHELLQUOTER_POSIX

$fatpacked{"Net/OpenSSH/ShellQuoter/csh.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_SHELLQUOTER_CSH';
  package Net::OpenSSH::ShellQuoter::csh;
  
  use strict;
  use warnings;
  use Carp;
  
  # Fixme: copied from POSIX
  
  sub new { __PACKAGE__ }
  
  my $noquote_class = q(.\\w/\\-@,:);
  my $glob_class    = q(*?\\[\\],{}:!^~);
  my $escape_inside_single_quotes_class  = q(\!\n);
  
  sub _single_quote {
      my $arg = shift;
      $arg =~ s/([$escape_inside_single_quotes_class])/\\$1/go;
      "'$arg'"
  }
  
  sub quote {
      shift;
      my $quoted = join '',
          map { ( m|\A'\z|                  ? "\\'"             :
                  m|\A'|                    ? "\"$_\""          :
                  m|\A[$noquote_class]*\z|o ? $_                :
                                              _single_quote($_) )
            } split /(')/o, $_[0];
      length $quoted ? $quoted : "''";
  }
  
  
  sub quote_glob {
      shift;
      my $arg = shift;
      my @parts;
      while ((pos $arg ||0) < length $arg) {
          if ($arg =~ m|\G('+)|gc) {
              push @parts, (length($1) > 1 ? "\"$1\"" : "\\'");
          }
          elsif ($arg =~ m|\G([$noquote_class$glob_class]+)|gco) {
              push @parts, $1;
          }
          elsif ($arg =~ m|\G(\\[$glob_class\\])|gco) {
              push @parts, $1;
          }
          elsif ($arg =~ m|\G([^$glob_class\\']+)|gco) {
              push @parts, _single_quote($1);
          }
          else {
              require Data::Dumper;
              $arg =~ m|\G(.+)|gc;
              die "Internal error: unquotable string:\n". Data::Dumper::Dumper($1) ."\n";
          }
      }
      my $quoted = join('', @parts);
      length $quoted ? $quoted : "''";
  }
  
  my %fragments = ( stdin_discard             => '</dev/null',
                    stdout_discard            => '>/dev/null',
                    stdout_and_stderr_discard => '>&/dev/null' );
  
  sub shell_fragments {
      shift;
      my @f = grep defined, @fragments{@_};
      wantarray ? @f : join(' ', @f);
  }
  
  1;
NET_OPENSSH_SHELLQUOTER_CSH

$fatpacked{"Net/OpenSSH/ShellQuoter/fish.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_SHELLQUOTER_FISH';
  package Net::OpenSSH::ShellQuoter::fish;
  
  use strict;
  use warnings;
  use Carp;
  
  sub new { __PACKAGE__ }
  
  my $noquote_class = '.\\w/\\-@,:';
  my $glob_class    = '*?\\[\\],\\{\\}:!^~';
  
  sub quote {
      my $quoted = $_[1];
      return $quoted if $quoted =~ /\A[$noquote_class]+\z/o;
      $quoted =~ s/([\'\\])/\\$1/g;
      "'$quoted'"
  }
  
  sub quote_glob {
      shift;
      my $arg = shift;
      my @parts;
      while ((pos $arg || 0) < length $arg) {
          if ($arg =~ m|\G('+)|gc) {
              push @parts, (length($1) > 1 ? "\"$1\"" : "\\'");
          }
          elsif ($arg =~ m|\G([$noquote_class$glob_class]+)|gco) {
              push @parts, $1;
          }
          elsif ($arg =~ m|\G(\\[$glob_class\\])|gco) {
              push @parts, $1;
          }
          elsif ($arg =~ m|\G\\|gc) {
              push @parts, '\\\\'
          }
          elsif ($arg =~ m|\G([^$glob_class\\']+)|gco) {
              push @parts, "'$1'";
          }
          else {
              require Data::Dumper;
              $arg =~ m|\G(.+)|gc;
              die "Internal error: unquotable string:\n". Data::Dumper::Dumper($1) ."\n";
          }
      }
      my $quoted = join('', @parts);
      length $quoted ? $quoted : "''";
  }
  
  my %fragments = ( stdin_discard             => '</dev/null',
                    stdout_discard            => '>/dev/null',
                    stderr_discard            => '2>/dev/null',
                    stdout_and_stderr_discard => '>/dev/null 2>&1',
                    stderr_to_stdout          => '2>&1' );
  
  sub shell_fragments {
      shift;
      my @f = grep defined, @fragments{@_};
      wantarray ? @f : join(' ', @f);
  }
  
  1;
NET_OPENSSH_SHELLQUOTER_FISH

$fatpacked{"Parser/MGC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARSER_MGC';
  #  You may distribute under the terms of either the GNU General Public License
  #  or the Artistic License (the same terms as Perl itself)
  #
  #  (C) Paul Evans, 2010-2021 -- leonerd@leonerd.org.uk
  
  package Parser::MGC 0.19;
  
  use v5.14;
  use warnings;
  
  use Carp;
  use Feature::Compat::Try;
  
  use File::Slurp::Tiny qw( read_file );
  use Scalar::Util qw( blessed );
  
  =head1 NAME
  
  C<Parser::MGC> - build simple recursive-descent parsers
  
  =head1 SYNOPSIS
  
     package My::Grammar::Parser;
     use base qw( Parser::MGC );
  
     sub parse
     {
        my $self = shift;
  
        $self->sequence_of( sub {
           $self->any_of(
              sub { $self->token_int },
              sub { $self->token_string },
              sub { \$self->token_ident },
              sub { $self->scope_of( "(", \&parse, ")" ) }
           );
        } );
     }
  
     my $parser = My::Grammar::Parser->new;
  
     my $tree = $parser->from_file( $ARGV[0] );
  
     ...
  
  =head1 DESCRIPTION
  
  This base class provides a low-level framework for building recursive-descent
  parsers that consume a given input string from left to right, returning a
  parse structure. It takes its name from the C<m//gc> regexps used to implement
  the token parsing behaviour.
  
  It provides a number of token-parsing methods, which each extract a
  grammatical token from the string. It also provides wrapping methods that can
  be used to build up a possibly-recursive grammar structure, by applying a
  structure around other parts of parsing code.
  
  =head2 Backtracking
  
  Each method, both token and structural, atomically either consumes a prefix of
  the string and returns its result, or fails and consumes nothing. This makes
  it simple to implement grammars that require backtracking.
  
  Several structure-forming methods have some form of "optional" behaviour; they
  can optionally consume some amount of input or take some particular choice,
  but if the code invoked inside that subsequently fails, the structure can
  backtrack and take some different behaviour. This is usually what is required
  when testing whether the structure of the input string matches some part of
  the grammar that is optional, or has multiple choices.
  
  However, once the choice of grammar has been made, it is often useful to be
  able to fix on that one choice, thus making subsequent failures propagate up
  rather than taking that alternative behaviour. Control of this backtracking
  is given by the C<commit> method; and careful use of this method is one of the
  key advantages that C<Parser::MGC> has over more simple parsing using single
  regexps alone.
  
  =cut
  
  =head1 CONSTRUCTOR
  
  =cut
  
  =head2 new
  
     $parser = Parser::MGC->new( %args )
  
  Returns a new instance of a C<Parser::MGC> object. This must be called on a
  subclass that provides method of the name provided as C<toplevel>, by default
  called C<parse>.
  
  Takes the following named arguments
  
  =over 8
  
  =item toplevel => STRING
  
  Name of the toplevel method to use to start the parse from. If not supplied,
  will try to use a method called C<parse>.
  
  =item patterns => HASH
  
  Keys in this hash should map to quoted regexp (C<qr//>) references, to
  override the default patterns used to match tokens. See C<PATTERNS> below
  
  =item accept_0o_oct => BOOL
  
  If true, the C<token_int> method will also accept integers with a C<0o> prefix
  as octal.
  
  =back
  
  =cut
  
  =head1 PATTERNS
  
  The following pattern names are recognised. They may be passed to the
  constructor in the C<patterns> hash, or provided as a class method under the
  name C<pattern_I<name>>.
  
  =over 4
  
  =item * ws
  
  Pattern used to skip whitespace between tokens. Defaults to C</[\s\n\t]+/>
  
  =item * comment
  
  Pattern used to skip comments between tokens. Undefined by default.
  
  =item * int
  
  Pattern used to parse an integer by C<token_int>. Defaults to
  C</-?(?:0x[[:xdigit:]]+|[[:digit:]]+)/>. If C<accept_0o_oct> is given, then
  this will be expanded to match C</0o[0-7]+/> as well.
  
  =item * float
  
  Pattern used to parse a floating-point number by C<token_float>. Defaults to
  C</-?(?:\d*\.\d+|\d+\.)(?:e-?\d+)?|-?\d+e-?\d+/i>.
  
  =item * ident
  
  Pattern used to parse an identifier by C<token_ident>. Defaults to
  C</[[:alpha:]_]\w*/>
  
  =item * string_delim
  
  Pattern used to delimit a string by C<token_string>. Defaults to C</["']/>.
  
  =back
  
  =cut
  
  my @patterns = qw(
     ws
     comment
     int
     float
     ident
     string_delim
  );
  
  use constant pattern_ws      => qr/[\s\n\t]+/;
  use constant pattern_comment => undef;
  use constant pattern_int     => qr/-?(?:0x[[:xdigit:]]+|[[:digit:]]+)/;
  use constant pattern_float   => qr/-?(?:\d*\.\d+|\d+\.)(?:e-?\d+)?|-?\d+e-?\d+/i;
  use constant pattern_ident   => qr/[[:alpha:]_]\w*/;
  use constant pattern_string_delim => qr/["']/;
  
  sub new
  {
     my $class = shift;
     my %args = @_;
  
     my $toplevel = $args{toplevel} || "parse";
  
     $class->can( $toplevel ) or
        croak "Expected to be a subclass that can ->$toplevel";
  
     my $self = bless {
        toplevel => $toplevel,
        patterns => {},
        scope_level => 0,
     }, $class;
  
     $self->{patterns}{$_} = $args{patterns}{$_} || $self->${\"pattern_$_"} for @patterns;
  
     if( $args{accept_0o_oct} ) {
        $self->{patterns}{int} = qr/0o[0-7]+|$self->{patterns}{int}/;
     }
  
     if( defined $self->{patterns}{comment} ) {
        $self->{patterns}{_skip} = qr/$self->{patterns}{ws}|$self->{patterns}{comment}/;
     }
     else {
        $self->{patterns}{_skip} = $self->{patterns}{ws};
     }
  
     return $self;
  }
  
  =head1 METHODS
  
  =cut
  
  =head2 from_string
  
     $result = $parser->from_string( $str )
  
  Parse the given literal string and return the result from the toplevel method.
  
  =cut
  
  sub from_string
  {
     my $self = shift;
     my ( $str ) = @_;
  
     $self->{str} = $str;
  
     pos $self->{str} = 0;
  
     my $toplevel = $self->{toplevel};
     my $result = $self->$toplevel;
  
     $self->at_eos or
        $self->fail( "Expected end of input" );
  
     return $result;
  }
  
  =head2 from_file
  
     $result = $parser->from_file( $file, %opts )
  
  Parse the given file, which may be a pathname in a string, or an opened IO
  handle, and return the result from the toplevel method.
  
  The following options are recognised:
  
  =over 8
  
  =item binmode => STRING
  
  If set, applies the given binmode to the filehandle before reading. Typically
  this can be used to set the encoding of the file.
  
     $parser->from_file( $file, binmode => ":encoding(UTF-8)" )
  
  =back
  
  =cut
  
  sub from_file
  {
     my $self = shift;
     my ( $file, %opts ) = @_;
  
     defined $file or croak "Expected a filename to ->from_file";
  
     $self->{filename} = $file;
  
     $self->from_string( ref $file ?
        do { local $/; binmode $file, $opts{binmode} if $opts{binmode}; <$file> } :
        ( read_file $file, binmode => $opts{binmode} ) );
  }
  
  =head2 from_reader
  
     $result = $parser->from_reader( \&reader )
  
  I<Since version 0.05.>
  
  Parse the input which is read by the C<reader> function. This function will be
  called in scalar context to generate portions of string to parse, being passed
  the C<$parser> object. The function should return C<undef> when it has no more
  string to return.
  
     $reader->( $parser )
  
  Note that because it is not generally possible to detect exactly when more
  input may be required due to failed regexp parsing, the reader function is
  only invoked during searching for skippable whitespace. This makes it suitable
  for reading lines of a file in the common case where lines are considered as
  skippable whitespace, or for reading lines of input interactively from a
  user. It cannot be used in all cases (for example, reading fixed-size buffers
  from a file) because two successive invocations may split a single token
  across the buffer boundaries, and cause parse failures.
  
  =cut
  
  sub from_reader
  {
     my $self = shift;
     my ( $reader ) = @_;
  
     local $self->{reader} = $reader;
  
     $self->{str} = "";
     pos $self->{str} = 0;
  
     my $result = $self->parse;
  
     $self->at_eos or
        $self->fail( "Expected end of input" );
  
     return $result;
  }
  
  =head2 pos
  
     $pos = $parser->pos
  
  I<Since version 0.09.>
  
  Returns the current parse position, as a character offset from the beginning
  of the file or string.
  
  =cut
  
  sub pos
  {
     my $self = shift;
     return pos $self->{str};
  }
  
  =head2 take
  
     $str = $parser->take( $len )
  
  I<Since version 0.16.>
  
  Returns the next C<$len> characters directly from the input, prior to any
  whitespace or comment skipping. This does I<not> take account of any
  end-of-scope marker that may be pending. It is intended for use by parsers of
  partially-binary protocols, or other situations in which it would be incorrect
  for the end-of-scope marker to take effect at this time.
  
  =cut
  
  sub take
  {
     my $self = shift;
     my ( $len ) = @_;
  
     my $start = pos( $self->{str} );
  
     pos( $self->{str} ) += $len;
  
     return substr( $self->{str}, $start, $len );
  }
  
  =head2 where
  
     ( $lineno, $col, $text ) = $parser->where
  
  Returns the current parse position, as a line and column number, and
  the entire current line of text. The first line is numbered 1, and the first
  column is numbered 0.
  
  =cut
  
  sub where
  {
     my $self = shift;
     my ( $pos ) = @_;
  
     defined $pos or $pos = pos $self->{str};
  
     my $str = $self->{str};
  
     my $sol = $pos;
     $sol-- if $sol > 0 and substr( $str, $sol, 1 ) =~ m/^[\r\n]$/;
     $sol-- while $sol > 0 and substr( $str, $sol-1, 1 ) !~ m/^[\r\n]$/;
  
     my $eol = $pos;
     $eol++ while $eol < length($str) and substr( $str, $eol, 1 ) !~ m/^[\r\n]$/;
  
     my $line = substr( $str, $sol, $eol - $sol );
  
     my $col = $pos - $sol;
     my $lineno = ( () = substr( $str, 0, $pos ) =~ m/\n/g ) + 1;
  
     return ( $lineno, $col, $line );
  }
  
  =head2 fail
  
  =head2 fail_from
  
     $parser->fail( $message )
  
     $parser->fail_from( $pos, $message )
  
  I<C<fail_from> since version 0.09.>
  
  Aborts the current parse attempt with the given message string. The failure
  message will include the line and column position, and the line of input that
  failed at the current parse position (C<fail>), or a position earlier obtained
  using the C<pos> method (C<fail_from>).
  
  This failure will propagate up to the inner-most structure parsing method that
  has not been committed; or will cause the entire parser to fail if there are
  no further options to take.
  
  =cut
  
  sub fail
  {
     my $self = shift;
     my ( $message ) = @_;
     $self->fail_from( $self->pos, $message );
  }
  
  sub fail_from
  {
     my $self = shift;
     my ( $pos, $message ) = @_;
     die Parser::MGC::Failure->new( $message, $self, $pos );
  }
  
  sub _isa_failure { blessed $_[0] and $_[0]->isa( "Parser::MGC::Failure" ) }
  
  =head2 at_eos
  
     $eos = $parser->at_eos
  
  Returns true if the input string is at the end of the string.
  
  =cut
  
  sub at_eos
  {
     my $self = shift;
  
     # Save pos() before skipping ws so we don't break the substring_before method
     my $pos = pos $self->{str};
  
     $self->skip_ws;
  
     my $at_eos;
     if( pos( $self->{str} ) >= length $self->{str} ) {
        $at_eos = 1;
     }
     elsif( defined $self->{endofscope} ) {
        $at_eos = $self->{str} =~ m/\G$self->{endofscope}/;
     }
     else {
        $at_eos = 0;
     }
  
     pos( $self->{str} ) = $pos;
  
     return $at_eos;
  }
  
  =head2 scope_level
  
     $level = $parser->scope_level
  
  I<Since version 0.05.>
  
  Returns the number of nested C<scope_of> calls that have been made.
  
  =cut
  
  sub scope_level
  {
     my $self = shift;
     return $self->{scope_level};
  }
  
  =head1 STRUCTURE-FORMING METHODS
  
  The following methods may be used to build a grammatical structure out of the
  defined basic token-parsing methods. Each takes at least one code reference,
  which will be passed the actual C<$parser> object as its first argument.
  
  Anywhere that a code reference is expected also permits a plain string giving
  the name of a method to invoke. This is sufficient in many simple cases, such
  as
  
     $self->any_of(
        'token_int',
        'token_string',
        ...
     );
  
  =cut
  
  =head2 maybe
  
     $ret = $parser->maybe( $code )
  
  Attempts to execute the given C<$code> in scalar context, and returns what it
  returned, accepting that it might fail. C<$code> may either be a CODE
  reference or a method name given as a string.
  
  If the code fails (either by calling C<fail> itself, or by propagating a
  failure from another method it invoked) before it has invoked C<commit>, then
  none of the input string will be consumed; the current parsing position will
  be restored. C<undef> will be returned in this case.
  
  If it calls C<commit> then any subsequent failure will be propagated to the
  caller, rather than returning C<undef>.
  
  This may be considered to be similar to the C<?> regexp qualifier.
  
     sub parse_declaration
     {
        my $self = shift;
  
        [ $self->parse_type,
          $self->token_ident,
          $self->maybe( sub {
             $self->expect( "=" );
             $self->parse_expression
          } ),
        ];
     }
  
  =cut
  
  sub maybe
  {
     my $self = shift;
     my ( $code ) = @_;
  
     my $pos = pos $self->{str};
  
     my $committed = 0;
     local $self->{committer} = sub { $committed++ };
  
     try {
        return $self->$code;
     }
     catch ( $e ) {
        pos($self->{str}) = $pos;
  
        die $e if $committed or not _isa_failure( $e );
        return undef;
     }
  }
  
  =head2 scope_of
  
     $ret = $parser->scope_of( $start, $code, $stop )
  
  Expects to find the C<$start> pattern, then attempts to execute the given
  C<$code>, then expects to find the C<$stop> pattern. Returns whatever the
  code returned. C<$code> may either be a CODE reference of a method name given
  as a string.
  
  While the code is being executed, the C<$stop> pattern will be used by the
  token parsing methods as an end-of-scope marker; causing them to raise a
  failure if called at the end of a scope.
  
     sub parse_block
     {
        my $self = shift;
  
        $self->scope_of( "{", 'parse_statements', "}" );
     }
  
  If the C<$start> pattern is undefined, it is presumed the caller has already
  checked for this. This is useful when the stop pattern needs to be calculated
  based on the start pattern.
  
     sub parse_bracketed
     {
        my $self = shift;
  
        my $delim = $self->expect( qr/[\(\[\<\{]/ );
        $delim =~ tr/([<{/)]>}/;
  
        $self->scope_of( undef, 'parse_body', $delim );
     }
  
  This method does not have any optional parts to it; any failures are
  immediately propagated to the caller.
  
  =cut
  
  sub scope_of
  {
     my $self = shift;
     $self->_scope_of( 0, @_ );
  }
  
  sub _scope_of
  {
     my $self = shift;
     my ( $commit_if_started, $start, $code, $stop ) = @_;
  
     ref $stop or $stop = qr/\Q$stop/;
  
     $self->expect( $start ) if defined $start;
  
     $self->commit if $commit_if_started;
  
     local $self->{endofscope} = $stop;
     local $self->{scope_level} = $self->{scope_level} + 1;
  
     my $ret = $self->$code;
  
     $self->expect( $stop );
  
     return $ret;
  }
  
  =head2 committed_scope_of
  
     $ret = $parser->committed_scope_of( $start, $code, $stop )
  
  I<Since version 0.16.>
  
  A variant of L</scope_of> that calls L</commit> after a successful match of
  the start pattern. This is usually what you want if using C<scope_of> from
  within an C<any_of> choice, if no other alternative following this one could
  possibly match if the start pattern has.
  
  =cut
  
  sub committed_scope_of
  {
     my $self = shift;
     $self->_scope_of( 1, @_ );
  }
  
  =head2 list_of
  
     $ret = $parser->list_of( $sep, $code )
  
  Expects to find a list of instances of something parsed by C<$code>,
  separated by the C<$sep> pattern. Returns an ARRAY ref containing a list of
  the return values from the C<$code>. A single trailing delimiter is allowed,
  and does not affect the return value. C<$code> may either be a CODE reference
  or a method name given as a string. It is called in list context, and whatever
  values it returns are appended to the eventual result - similar to perl's
  C<map>.
  
  This method does not consider it an error if the returned list is empty; that
  is, that the scope ended before any item instances were parsed from it.
  
     sub parse_numbers
     {
        my $self = shift;
  
        $self->list_of( ",", 'token_int' );
     }
  
  If the code fails (either by invoking C<fail> itself, or by propagating a
  failure from another method it invoked) before it has invoked C<commit> on a
  particular item, then the item is aborted and the parsing position will be
  restored to the beginning of that failed item. The list of results from
  previous successful attempts will be returned.
  
  If it calls C<commit> within an item then any subsequent failure for that item
  will cause the entire C<list_of> to fail, propagating that to the caller.
  
  =cut
  
  sub list_of
  {
     my $self = shift;
     my ( $sep, $code ) = @_;
  
     ref $sep or $sep = qr/\Q$sep/ if defined $sep;
  
     my $committed;
     local $self->{committer} = sub { $committed++ };
  
     my @ret;
  
     while( !$self->at_eos ) {
        $committed = 0;
        my $pos = pos $self->{str};
  
        try {
           push @ret, $self->$code;
           next;
        }
        catch ( $e ) {
           pos($self->{str}) = $pos;
           die $e if $committed or not _isa_failure( $e );
  
           last;
        }
     }
     continue {
        if( defined $sep ) {
           $self->skip_ws;
           $self->{str} =~ m/\G$sep/gc or last;
        }
     }
  
     return \@ret;
  }
  
  =head2 sequence_of
  
     $ret = $parser->sequence_of( $code )
  
  A shortcut for calling C<list_of> with an empty string as separator; expects
  to find at least one instance of something parsed by C<$code>, separated only
  by skipped whitespace.
  
  This may be considered to be similar to the C<+> or C<*> regexp qualifiers.
  
     sub parse_statements
     {
        my $self = shift;
  
        $self->sequence_of( 'parse_statement' );
     }
  
  The interaction of failures in the code and the C<commit> method is identical
  to that of C<list_of>.
  
  =cut
  
  sub sequence_of
  {
     my $self = shift;
     my ( $code ) = @_;
  
     $self->list_of( undef, $code );
  }
  
  =head2 any_of
  
     $ret = $parser->any_of( @codes )
  
  I<Since version 0.06.>
  
  Expects that one of the given code instances can parse something from the
  input, returning what it returned. Each code instance may indicate a failure
  to parse by calling the C<fail> method or otherwise propagating a failure.
  Each code instance may either be a CODE reference or a method name given as a
  string.
  
  This may be considered to be similar to the C<|> regexp operator for forming
  alternations of possible parse trees.
  
     sub parse_statement
     {
        my $self = shift;
  
        $self->any_of(
           sub { $self->parse_declaration; $self->expect(";") },
           sub { $self->parse_expression; $self->expect(";") },
           sub { $self->parse_block },
        );
     }
  
  If the code for a given choice fails (either by invoking C<fail> itself, or by
  propagating a failure from another method it invoked) before it has invoked
  C<commit> itself, then the parsing position restored and the next choice will
  be attempted.
  
  If it calls C<commit> then any subsequent failure for that choice will cause
  the entire C<any_of> to fail, propagating that to the caller and no further
  choices will be attempted.
  
  If none of the choices match then a simple failure message is printed:
  
     Found nothing parseable
  
  As this is unlikely to be helpful to users, a better message can be provided
  by the final choice instead. Don't forget to C<commit> before printing the
  failure message, or it won't count.
  
     $self->any_of(
        'token_int',
        'token_string',
        ...,
  
        sub { $self->commit; $self->fail( "Expected an int or string" ) }
     );
  
  =cut
  
  sub any_of
  {
     my $self = shift;
  
     while( @_ ) {
        my $code = shift;
        my $pos = pos $self->{str};
  
        my $committed = 0;
        local $self->{committer} = sub { $committed++ };
  
        try {
           return $self->$code;
        }
        catch ( $e ) {
           pos( $self->{str} ) = $pos;
  
           die $e if $committed or not _isa_failure( $e );
        }
     }
  
     $self->fail( "Found nothing parseable" );
  }
  
  sub one_of {
     croak "Parser::MGC->one_of is deprecated; use ->any_of instead";
  }
  
  =head2 commit
  
     $parser->commit
  
  Calling this method will cancel the backtracking behaviour of the innermost
  C<maybe>, C<list_of>, C<sequence_of>, or C<any_of> structure forming method.
  That is, if later code then calls C<fail>, the exception will be propagated
  out of C<maybe>, no further list items will be attempted by C<list_of> or
  C<sequence_of>, and no further code blocks will be attempted by C<any_of>.
  
  Typically this will be called once the grammatical structure alter has been
  determined, ensuring that any further failures are raised as real exceptions,
  rather than by attempting other alternatives.
  
   sub parse_statement
   {
      my $self = shift;
  
      $self->any_of(
         ...
         sub {
            $self->scope_of( "{",
               sub { $self->commit; $self->parse_statements; },
            "}" ),
         },
      );
   }
  
  Though in this common pattern, L</committed_scope_of> may be used instead.
  
  =cut
  
  sub commit
  {
     my $self = shift;
     if( $self->{committer} ) {
        $self->{committer}->();
     }
     else {
        croak "Cannot commit except within a backtrack-able structure";
     }
  }
  
  =head1 TOKEN PARSING METHODS
  
  The following methods attempt to consume some part of the input string, to be
  used as part of the parsing process.
  
  =cut
  
  sub skip_ws
  {
     my $self = shift;
  
     my $pattern = $self->{patterns}{_skip};
  
     {
        1 while $self->{str} =~ m/\G$pattern/gc;
  
        return if pos( $self->{str} ) < length $self->{str};
  
        return unless $self->{reader};
  
        my $more = $self->{reader}->( $self );
        if( defined $more ) {
           my $pos = pos( $self->{str} );
           $self->{str} .= $more;
           pos( $self->{str} ) = $pos;
  
           redo;
        }
  
        undef $self->{reader};
        return;
     }
  }
  
  =head2 expect
  
     $str = $parser->expect( $literal )
  
     $str = $parser->expect( qr/pattern/ )
  
     @groups = $parser->expect( qr/pattern/ )
  
  Expects to find a literal string or regexp pattern match, and consumes it.
  In scalar context, this method returns the string that was captured. In list
  context it returns the matching substring and the contents of any subgroups
  contained in the pattern.
  
  This method will raise a parse error (by calling C<fail>) if the regexp fails
  to match. Note that if the pattern could match an empty string (such as for
  example C<qr/\d*/>), the pattern will always match, even if it has to match an
  empty string. This method will not consider a failure if the regexp matches
  with zero-width.
  
  =head2 maybe_expect
  
     $str = $parser->maybe_expect( ... )
  
     @groups = $parser->maybe_expect( ... )
  
  I<Since version 0.10.>
  
  A convenient shortcut equivalent to calling C<expect> within C<maybe>, but
  implemented more efficiently, avoiding the exception-handling set up by
  C<maybe>. Returns C<undef> or an empty list if the match fails.
  
  =cut
  
  sub maybe_expect
  {
     my $self = shift;
     my ( $expect ) = @_;
  
     ref $expect or $expect = qr/\Q$expect/;
  
     $self->skip_ws;
     $self->{str} =~ m/\G$expect/gc or return;
  
     return substr( $self->{str}, $-[0], $+[0]-$-[0] ) if !wantarray;
     return map { defined $-[$_] ? substr( $self->{str}, $-[$_], $+[$_]-$-[$_] ) : undef } 0 .. $#+;
  }
  
  sub expect
  {
     my $self = shift;
     my ( $expect ) = @_;
  
     ref $expect or $expect = qr/\Q$expect/;
  
     if( wantarray ) {
        my @ret = $self->maybe_expect( $expect ) or
           $self->fail( "Expected $expect" );
        return @ret;
     }
     else {
        defined( my $ret = $self->maybe_expect( $expect ) ) or
           $self->fail( "Expected $expect" );
        return $ret;
     }
  }
  
  =head2 substring_before
  
     $str = $parser->substring_before( $literal )
  
     $str = $parser->substring_before( qr/pattern/ )
  
  I<Since version 0.06.>
  
  Expects to possibly find a literal string or regexp pattern match. If it finds
  such, consume all the input text before but excluding this match, and return
  it. If it fails to find a match before the end of the current scope, consumes
  all the input text until the end of scope and return it.
  
  This method does not consume the part of input that matches, only the text
  before it. It is not considered a failure if the substring before this match
  is empty. If a non-empty match is required, use the C<fail> method:
  
     sub token_nonempty_part
     {
        my $self = shift;
  
        my $str = $parser->substring_before( "," );
        length $str or $self->fail( "Expected a string fragment before ," );
  
        return $str;
     }
  
  Note that unlike most of the other token parsing methods, this method does not
  consume either leading or trailing whitespace around the substring. It is
  expected that this method would be used as part a parser to read quoted
  strings, or similar cases where whitespace should be preserved.
  
  =cut
  
  sub substring_before
  {
     my $self = shift;
     my ( $expect ) = @_;
  
     ref $expect or $expect = qr/\Q$expect/;
  
     my $endre = ( defined $self->{endofscope} ) ?
        qr/$expect|$self->{endofscope}/ :
        $expect;
  
     # NO skip_ws
  
     my $start = pos $self->{str};
     my $end;
     if( $self->{str} =~ m/\G(?s:.*?)($endre)/ ) {
        $end = $-[1];
     }
     else {
        $end = length $self->{str};
     }
  
     return $self->take( $end - $start );
  }
  
  =head2 generic_token
  
     $val = $parser->generic_token( $name, $re, $convert )
  
  I<Since version 0.08.>
  
  Expects to find a token matching the precompiled regexp C<$re>. If provided,
  the C<$convert> CODE reference can be used to convert the string into a more
  convenient form. C<$name> is used in the failure message if the pattern fails
  to match.
  
  If provided, the C<$convert> function will be passed the parser and the
  matching substring; the value it returns is returned from C<generic_token>.
  
     $convert->( $parser, $substr )
  
  If not provided, the substring will be returned as it stands.
  
  This method is mostly provided for subclasses to define their own token types.
  For example:
  
     sub token_hex
     {
        my $self = shift;
        $self->generic_token( hex => qr/[0-9A-F]{2}h/, sub { hex $_[1] } );
     }
  
  =cut
  
  sub generic_token
  {
     my $self = shift;
     my ( $name, $re, $convert ) = @_;
  
     $self->fail( "Expected $name" ) if $self->at_eos;
  
     $self->skip_ws;
     $self->{str} =~ m/\G$re/gc or
        $self->fail( "Expected $name" );
  
     my $match = substr( $self->{str}, $-[0], $+[0] - $-[0] );
  
     return $convert ? $convert->( $self, $match ) : $match;
  }
  
  sub _token_generic
  {
     my $self = shift;
     my %args = @_;
  
     my $name    = $args{name};
     my $re      = $args{pattern} ? $self->{patterns}{ $args{pattern} } : $args{re};
     my $convert = $args{convert};
  
     $self->generic_token( $name, $re, $convert );
  }
  
  =head2 token_int
  
     $int = $parser->token_int
  
  Expects to find an integer in decimal, octal or hexadecimal notation, and
  consumes it. Negative integers, preceeded by C<->, are also recognised.
  
  =cut
  
  sub token_int
  {
     my $self = shift;
     $self->_token_generic(
        name => "int",
  
        pattern => "int",
        convert => sub {
           my $int = $_[1];
           my $sign = ( $int =~ s/^-// ) ? -1 : 1;
  
           $int =~ s/^0o/0/;
  
           return $sign * oct $int if $int =~ m/^0/;
           return $sign * $int;
        },
     );
  }
  
  =head2 token_float
  
     $float = $parser->token_float
  
  I<Since version 0.04.>
  
  Expects to find a number expressed in floating-point notation; a sequence of
  digits possibly prefixed by C<->, possibly containing a decimal point,
  possibly followed by an exponent specified by C<e> followed by an integer. The
  numerical value is then returned.
  
  =cut
  
  sub token_float
  {
     my $self = shift;
     $self->_token_generic(
        name => "float",
  
        pattern => "float",
        convert => sub { $_[1] + 0 },
     );
  }
  
  =head2 token_number
  
     $number = $parser->token_number
  
  I<Since version 0.09.>
  
  Expects to find a number expressed in either of the above forms.
  
  =cut
  
  sub token_number
  {
     my $self = shift;
     $self->any_of( \&token_float, \&token_int );
  }
  
  =head2 token_string
  
     $str = $parser->token_string
  
  Expects to find a quoted string, and consumes it. The string should be quoted
  using C<"> or C<'> quote marks.
  
  The content of the quoted string can contain character escapes similar to
  those accepted by C or Perl. Specifically, the following forms are recognised:
  
     \a               Bell ("alert")
     \b               Backspace
     \e               Escape
     \f               Form feed
     \n               Newline
     \r               Return
     \t               Horizontal Tab
     \0, \012         Octal character
     \x34, \x{5678}   Hexadecimal character
  
  C's C<\v> for vertical tab is not supported as it is rarely used in practice
  and it collides with Perl's C<\v> regexp escape. Perl's C<\c> for forming other
  control characters is also not supported.
  
  =cut
  
  my %escapes = (
     a => "\a",
     b => "\b",
     e => "\e",
     f => "\f",
     n => "\n",
     r => "\r",
     t => "\t",
  );
  
  sub token_string
  {
     my $self = shift;
  
     $self->fail( "Expected string" ) if $self->at_eos;
  
     my $pos = pos $self->{str};
  
     $self->skip_ws;
     $self->{str} =~ m/\G($self->{patterns}{string_delim})/gc or
        $self->fail( "Expected string delimiter" );
  
     my $delim = $1;
  
     $self->{str} =~ m/
        \G(
           (?:
              \\[0-7]{1,3}     # octal escape
             |\\x[0-9A-F]{2}   # 2-digit hex escape
             |\\x\{[0-9A-F]+\} # {}-delimited hex escape
             |\\.              # symbolic escape
             |[^\\$delim]+     # plain chunk
           )*?
        )$delim/gcix or
           pos($self->{str}) = $pos, $self->fail( "Expected contents of string" );
  
     my $string = $1;
  
     $string =~ s<\\(?:([0-7]{1,3})|x([0-9A-F]{2})|x\{([0-9A-F]+)\}|(.))>
                 [defined $1 ? chr oct $1 :
                  defined $2 ? chr hex $2 :
                  defined $3 ? chr hex $3 :
                               exists $escapes{$4} ? $escapes{$4} : $4]egi;
  
     return $string;
  }
  
  =head2 token_ident
  
     $ident = $parser->token_ident
  
  Expects to find an identifier, and consumes it.
  
  =cut
  
  sub token_ident
  {
     my $self = shift;
     $self->_token_generic(
        name => "ident",
  
        pattern => "ident",
     );
  }
  
  =head2 token_kw
  
     $keyword = $parser->token_kw( @keywords )
  
  Expects to find a keyword, and consumes it. A keyword is defined as an
  identifier which is exactly one of the literal values passed in.
  
  =cut
  
  sub token_kw
  {
     my $self = shift;
     my @acceptable = @_;
  
     $self->skip_ws;
  
     my $pos = pos $self->{str};
  
     defined( my $kw = $self->token_ident ) or
        return undef;
  
     grep { $_ eq $kw } @acceptable or
        pos($self->{str}) = $pos, $self->fail( "Expected any of ".join( ", ", @acceptable ) );
  
     return $kw;
  }
  
  package # hide from indexer
     Parser::MGC::Failure;
  
  sub new
  {
     my $class = shift;
     my $self = bless {}, $class;
     @{$self}{qw( message parser pos )} = @_;
     return $self;
  }
  
  use overload '""' => "STRING";
  sub STRING
  {
     my $self = shift;
  
     my $parser = $self->{parser};
     my ( $linenum, $col, $text ) = $parser->where( $self->{pos} );
  
     # Column number only counts characters. There may be tabs in there.
     # Rather than trying to calculate the visual column number, just print the
     # indentation as it stands.
  
     my $indent = substr( $text, 0, $col );
     $indent =~ s/[^ \t]/ /g; # blank out all the non-whitespace
  
     my $filename = $parser->{filename};
     my $in_file = ( defined $filename and !ref $filename )
                      ? "in $filename " : "";
  
     return "$self->{message} ${in_file}on line $linenum at:\n" . 
            "$text\n" . 
            "$indent^\n";
  }
  
  # Provide fallback operators for cmp, eq, etc...
  use overload fallback => 1;
  
  =head1 EXAMPLES
  
  =head2 Accumulating Results Using Variables
  
  Although the structure-forming methods all return a value, obtained from their
  nested parsing code, it can sometimes be more convenient to use a variable to
  accumulate a result in instead. For example, consider the following parser
  method, designed to parse a set of C<name: "value"> assignments, such as might
  be found in a configuration file, or YAML/JSON-style mapping value.
  
     sub parse_dict
     {
        my $self = shift;
  
        my %ret;
        $self->list_of( ",", sub {
           my $key = $self->token_ident;
           exists $ret{$key} and $self->fail( "Already have a mapping for '$key'" );
  
           $self->expect( ":" );
  
           $ret{$key} = $self->parse_value;
        } );
  
        return \%ret
     }
  
  Instead of using the return value from C<list_of>, this method accumulates
  values in the C<%ret> hash, eventually returning a reference to it as its
  result. Because of this, it can perform some error checking while it parses;
  namely, rejecting duplicate keys.
  
  =head1 TODO
  
  =over 4
  
  =item *
  
  Make unescaping of string constants more customisable. Possibly consider
  instead a C<parse_string_generic> using a loop over C<substring_before>.
  
  =item *
  
  Easy ability for subclasses to define more token types as methods. Perhaps
  provide a class method such as
  
     __PACKAGE__->has_token( hex => qr/[0-9A-F]+/i, sub { hex $_[1] } );
  
  =item *
  
  Investigate how well C<from_reader> can cope with buffer splitting across
  other tokens than simply skippable whitespace
  
  =back
  
  =head1 AUTHOR
  
  Paul Evans <leonerd@leonerd.org.uk>
  
  =cut
  
  0x55AA;
PARSER_MGC

$fatpacked{"Parser/MGC/Examples/EvaluateExpression.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARSER_MGC_EXAMPLES_EVALUATEEXPRESSION';
  package Parser::MGC::Examples::EvaluateExpression;
  
  =head1 NAME
  
  C<Parser::MGC::Examples::EvaluateExpression> - an example parser to evaluate simple numerical expressions
  
  =head1 DESCRIPTION
  
  This evaluator-parser takes simple mathematical expressions involving the four
  basic arithmetic operators (+, -, *, /) applied to integers, and returns the
  numerical result. It handles operator precedence, with * and / having a higher
  level than + and -, and copes with parentheses.
  
  Operator precedence is implemented by using two different parsing functions to
  handle the two different precedence levels.
  
  =cut
  
  =head2 Boilerplate
  
  We start off by declaring a package and subclassing L<Parser::MGC>.
  
     package ExprParser;
     use base qw( Parser::MGC );
  
     use strict;
     use warnings;
  
  =head2 parse
  
  The topmost parsing function, C<parse>, handles the outermost level of
  operator precedence, the + and - operators. It first parses a single term from
  the input by callling C<parse_term> to obtain its value.
  
  It then uses the C<any_of> structure-forming method to look for either a + or -
  operator which would indicate another term will follow it. If it finds either
  of these, it parses the next term from after the operator by another call to
  C<parse_term> and then adds or subtracts the value of it from the running
  total.
  
  The C<any_of> call itself is used as the conditional expression of a C<while>
  loop, to ensure it gets called multiple times. Whenever another term has been
  parsed, the body function returns a true value, to indicate that the while
  loop should be invoked again. Only when there are no more + or - operators,
  indicating no more terms, does the body return false, causing the while loop
  to stop.
  
  This continues until there are no more + or - operators, when the overall
  total value is returned to the caller.
  
  =cut
  
  =pod
  
     sub parse
     {
        my $self = shift;
  
        my $val = $self->parse_term
  
        1 while $self->any_of(
           sub { $self->expect( "+" ); $val += $self->parse_term; 1 },
           sub { $self->expect( "-" ); $val -= $self->parse_term; 1 },
           sub { 0 },
        );
  
        return $val;
     }
  
  =cut
  
  =pod
  
  This function recognises input matching the following EBNF grammar:
  
     EXPR = TERM { ( '+' | '-' ) TERM };
  
  =cut
  
  =head2 parse_term
  
  Called by C<parse>, the next function is C<parse_term> which has a similar
  structure. This function implements the next level of operator precedence, of
  the * and / operators. In a similar fashion to the previous function, this one
  parses a single factor from the input by calling C<parse_factor>, and then
  looks for * or / operators, multiplying or dividing the value by the next
  factor it expects to find after those. This continues until there are no more
  * or / operators, when the overall product is returned.
  
  =cut
  
  =pod
  
     sub parse_term
     {
        my $self = shift;
  
        my $val = $self->parse_factor;
  
        1 while $self->any_of(
           sub { $self->expect( "*" ); $val *= $self->parse_factor; 1 },
           sub { $self->expect( "/" ); $val /= $self->parse_factor; 1 },
           sub { 0 },
        );
  
        return $val;
     }
  
  =cut
  
  =pod
  
  This function recognises input matching the following EBNF grammar:
  
     TERM = FACTOR { ( '*' | '/' ) FACTOR };
  
  =cut
  
  =head2 parse_factor
  
  Finally, the innermost C<parse_factor> function is called by C<parse_term> to
  parse out the actual numerical values. This is also the point at which the
  grammar can recurse, recognising a parenthesized expression. It uses an
  C<any_of> with two alternative function bodies, to cover these two cases.
  
  The first case, to handle a parenthesized sub-expression, consists of a call
  to C<scope_of>. This call would expect to find a C<(> symbol to indicate the
  parenthesized expression. If it finds one, it will recurse back to the
  toplevel C<parse> method to obtain its value, then expects the final C<)>
  symbol. The value of this factor is then the value of the sub-expression
  contained within the parentheses.
  
  If the first case fails, because it does not find that leading C<(> symbol,
  the second case is attempted instead. This handles an actual integer constant.
  This case is simply a call to the C<token_int> method of the underlying class,
  which recognises various string forms of integer constants, returning their
  numerical value.
  
  =cut
  
  =pod
  
     sub parse_factor
     {
        my $self = shift;
  
        $self->any_of(
           sub { $self->scope_of( "(", sub { $self->parse }, ")" ) },
           sub { $self->token_int },
        );
     }
  
  =cut
  
  =pod
  
  This function recognises input matching the following EBNF grammar:
  
     FACTOR = '(' EXPR ')'
            | integer
  
  =cut
  
  =head1 EXAMPLES OF OPERATION
  
  =head2 A single integer
  
  The simplest form of operation of this parser is when it is given a single
  integer value as its input; for example C<"15">.
  
   INPUT:    15
   POSITION: ^
  
  The outermost call to C<parse> will call C<parse_term>, which in turn calls
  C<parse_factor>.
  
   INPUT:    15
   POSITION  ^
   CALLS:    parse
              => parse_term
               => parse_factor
  
  The C<any_of> inside C<parse_factor> will first attempt to find a
  parenthesized sub-expression by using C<scope_of>, but this will fail because
  it does not start with an open parenthesis symbol. The C<any_of> will then
  attempt the second case, calling C<token_int> which will succeed at obtaining
  an integer value from the input stream, consuming it by advancing the stream
  position. The value of 15 is then returned by C<parse_factor> back to
  C<parse_term> where it is stored in the C<$val> lexical.
  
   INPUT:    15
   POSITION:   ^
   CALLS:    parse
              => parse_term -- $val = 15
  
  At this point, the C<any_of> inside C<parse_term> will attempt to find a * or
  / operator, but both will fail because there is none, causing the final
  alternative function to be invoked, which stops the C<while> loop executing.
  The value of 15 is then returned to the outer caller, C<parse>. A similar
  process happens there, where it fails to find a + or - operator, and thus the
  final value of 15 is returned as the result of the entire parsing operation.
  
   INPUT:    15
   OUTPUT:   15
  
  =head2 A simple sum of two integers
  
  Next lets consider a case that actually requires some real parsing, such as an
  expression requesting the sum of two values; C<"6 + 9">.
  
   INPUT:    6 + 9
   POSITION: ^
  
  This parsing operation starts the same as the previous; with C<parse> calling
  C<parse_term> which in turn calls C<parse_factor>.
  
   INPUT:    6 + 9
   POSITION: ^
   CALLS:    parse
              => parse_term
               => parse_factor
  
  As before, the C<any_of> inside C<parse_factor> first attempts and fails to
  find a parenthesized sub-expression and so tries C<token_int> instead. As
  before this obtains an integer value from the stream and advances the
  position. This value is again returned to C<parse_term>. As before, the
  C<any_of> attempts but fails to find a * or / operator so the value gets
  returned to C<parse> to be stored in C<$val>.
  
   INPUT:    6 + 9
   POSITION:  ^
   CALLS:    parse -- $val = 6
  
  This time, the C<any_of> in the outer C<parse> method attempts to find a +
  operator and succeeds, because there is one at the next position in the
  stream. This causes the first case to continue, making another call to
  C<parse_term>.
  
   INPUT:    6 + 9
   POSITION:    ^
   CALLS:    parse -- $val = 6
              => parse_term
  
  This call to C<parse_term> proceeds much like the first, eventually returning
  the value 9 by consuming it from the input stream. This value is added to
  C<$val> by the code inside the C<any_of> call.
  
   INPUT:    6 + 9
   POSITION:      ^
   CALLS:    parse -- $val = 15
  
  C<parse> then calls C<any_of> a second time, which attempts to find another
  operator. This time there is none, so it returns false, which stops the
  C<while> loop and the value is returned as the final result of the operation.
  
   INPUT:    6 + 9
   OUTPUT:   15
  
  =head2 Operator precedence
  
  The two kinds of operators (+ and - vs * and /) are split across two different
  method calls to allow them to implement precedence; to say that some of the
  operators bind more tightly than others. Those operators that are implemented
  in more inwardly-nested functions bind tighter than the ones implemented
  further out.
  
  To see this in operation consider an expression that mixes the two kinds of
  operators, such as C<"15 - 2 * 3">
  
   INPUT:    15 - 2 * 3
   POSITION: ^
  
  The parsing operation starts by calling down from C<parse> all the way to
  C<token_int> which extracts the first integer, 15, from the stream and returns
  it all the way up to C<parse> as before:
  
   INPUT:    15 - 2 * 3
   POSITION:   ^
   CALLS:    parse -- $val = 15
  
  As before, the C<parse> function looks for a * or - operator by its C<any_of>
  test, and finds this time the - operator, which then causes it to call
  C<parse_term> to parse its value:
  
   INPUT:    15 - 2 * 3
   POSITION:     ^
   CALLS:    parse -- $val = 15
              => parse_term
  
  Again, C<parse_term> starts by calling C<parse_factor> which extracts the next
  integer from the stream and returns it. C<parse_factor> temporarily stores
  that in its own C<$val> lexical (which remember, is a lexical variable local
  to that call, so is distinct from the one in C<parse>).
  
   INPUT:    15 - 2 * 3
   POSITION:       ^
   CALLS:    parse -- $val = 15
              => parse_term -- $val = 2
  
  This time, when C<parse_term> attempts its own C<any_of> test to look for a *
  or / operator, it manages to find one. By a process similar to the way that
  the outer C<parse> method forms a sum of terms, C<parse_term> forms a product
  of factors by calling down to C<parse_factor> and accumulating the result.
  Here it will call C<parse_factor> again, which returns the value 3. This gets
  multiplied into C<$var>.
  
   INPUT:    15 - 2 * 3
   POSITION:           ^
   CALLS:    parse -- $val = 15
              => parse_term -- $val = 6
  
  C<parse_term> will try again to look for a * or / operator, but this time
  fails to find one, and so returns its final result, 6, back to C<parse>, which
  then subtracts it from its own C<$val>.
  
   INPUT:    15 - 2 * 3
   POSITION:           ^
   CALLS:    parse -- $val = 9
  
  The outer C<parse> call similarly fails to find any more + or - operators and
  so returns the final result of the parsing operation.
  
   INPUT:    15 - 2 * 3
   OUTPUT:   9
  
  By implementing the * and / operators separately in a different piece of logic
  inside the one that implements the + and - operators, we have ensured that
  they operate more greedily. That is, that they bind tighter, consuming their
  values first, before the outer + and - operators. This is the way that
  operator precedence is implemented.
  
  =head2 Parentheses
  
  This grammar, like many others, provides a way for expressions to override the
  usual operator precedence by supplying a sub-expression in parentheses. The
  expression inside those parentheses is parsed in the usual way, and then its
  result stands in place of the entire parenthesized part, overriding whatever
  rules might have governed the order between those operators inside it and
  those outside.
  
  In this parser we implement this as a recursive call, where one possibility
  of the innermost part (the C<parse_factor> function or the C<FACTOR> EBNF
  rule) is to recurse back to the outermost thing, inside parentheses. This
  example examines what happens to the input string C<"(15 - 2) * 3">.
  
   INPUT:    (15 - 2) * 3
   POSITION: ^
  
  As with all the other examples the parsing operation starts by C<parse>
  calling C<parse_term> which calls C<parse_factor>. This time, the first case
  within the C<any_of> in C<parse_factor> does successfully manage to find an
  open parenthesis, so consumes it. It then stores the close parenthesis pattern
  as the end-of-scope marker, and makes a recursive call back to the parse
  method again.
  
   INPUT:    (15 - 2) * 3
   POSITION:  ^
   CALLS:    parse
              => parse_term
               => parse_factor
                => parse                 EOS = ")"
  
  The operation of the inner call to C<parse> proceeds much like the first few
  examples, calling down through C<parse_term> to C<parse_factor> to obtain
  the 15.
  
   INPUT:    (15 - 2) * 3
   POSITION:    ^
   CALLS:    parse
              => parse_term
               => parse_factor
                => parse -- $val = 15    EOS = ")"
  
  Similar to previous examples, this then finds the - operator, and parses
  another term to subtract from it.
  
   INPUT:    (15 - 2) * 3
   POSITION:        ^
   CALLS:    parse
              => parse_term
               => parse_factor
                => parse -- $val = 13    EOS = ")"
  
  At this point, the C<any_of> test in the inner call to C<parse> tries again to
  look for a + or - operator, and this time fails because it believes it is at
  the end of the input. It isn't really at the end of the string, of course, but
  it believes it to be at the end because of the "end-of-scope" pattern that the
  call to C<scope_of> established. This pretends that the input has finished
  whenever the next part of the input matches the end-of-scope pattern.
  
  Because this inner call to C<parse> now believes it has got to the end of its
  input, it returns its final answer back to the caller, which in this case was
  the C<scope_of> call that C<parse_factor> made. As the C<scope_of> call
  returns, it consumes the input matching the end-of-scope pattern. This return
  value is then stored by C<parse_term>.
  
   INPUT:    (15 - 2) * 3
   POSITION:         ^
   CALLS:    parse
              => parse_term -- $val = 13
  
  At this point, C<parse_term> proceeds as before, finding and extracting the *
  operator and calling C<parse_factor> a second time, multiplying them together
  and returning that to the outer C<parse> call.
  
   INPUT:    (15 - 2) * 3
   POSITION:             ^
   CALLS:    parse -- $val = 39
  
  At this point C<parse> fails to extract any more operators because it is at
  the (real) end of input, so returns the final answer.
  
   INPUT:    (15 - 2) * 3
   OUTPUT:   39
PARSER_MGC_EXAMPLES_EVALUATEEXPRESSION

$fatpacked{"Schedule/Cron.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SCHEDULE_CRON';
  #!/usr/bin/perl -w
  
  =head1 NAME
  
  Cron - cron-like scheduler for Perl subroutines
  
  =head1 SYNOPSIS
  
    use Schedule::Cron;
  
    # Subroutines to be called
    sub dispatcher { 
      print "ID:   ",shift,"\n"; 
      print "Args: ","@_","\n";
    }
  
    sub check_links { 
      # do something... 
    }
  
    # Create new object with default dispatcher
    my $cron = new Schedule::Cron(\&dispatcher);
  
    # Load a crontab file
    $cron->load_crontab("/var/spool/cron/perl");
  
    # Add dynamically  crontab entries
    $cron->add_entry("3 4  * * *",ROTATE => "apache","sendmail");
    $cron->add_entry("0 11 * * Mon-Fri",\&check_links);
  
    # Run scheduler 
    $cron->run(detach=>1);
                     
  
  =head1 DESCRIPTION
  
  This module provides a simple but complete cron like scheduler.  I.e this
  module can be used for periodically executing Perl subroutines.  The dates and
  parameters for the subroutines to be called are specified with a format known
  as crontab entry (see L<"METHODS">, C<add_entry()> and L<crontab(5)>)
  
  The philosophy behind C<Schedule::Cron> is to call subroutines periodically
  from within one single Perl program instead of letting C<cron> trigger several
  (possibly different) Perl scripts. Everything under one roof.  Furthermore,
  C<Schedule::Cron> provides mechanism to create crontab entries dynamically,
  which isn't that easy with C<cron>.
  
  C<Schedule::Cron> knows about all extensions (well, at least all extensions I'm
  aware of, i.e those of the so called "Vixie" cron) for crontab entries like
  ranges including 'steps', specification of month and days of the week by name,
  or coexistence of lists and ranges in the same field.  It even supports a bit
  more (like lists and ranges with symbolic names).
  
  =head1 METHODS
  
  =over 4
  
  =cut
  
  #'
  
  package Schedule::Cron;
  
  use Time::ParseDate;
  use Data::Dumper;
  
  use strict;
  use vars qw($VERSION  $DEBUG);
  use subs qw(dbg);
  
  my $HAS_POSIX;
  
  BEGIN {
    eval { 
      require POSIX;
      import POSIX ":sys_wait_h";
    };
    $HAS_POSIX = $@ ? 0 : 1;
  }
  
  
  $VERSION = "1.01";
  
  our $DEBUG = 0;
  my %STARTEDCHILD = ();
  
  my @WDAYS = qw(
                   Sunday
                   Monday
                   Tuesday
                   Wednesday
                   Thursday
                   Friday
                   Saturday
                   Sunday
                  );
  
  my @ALPHACONV = (
                   { },
                   { },
                   { },
                   { qw(jan 1 feb 2 mar 3 apr 4 may 5 jun 6 jul 7 aug 8
                        sep 9 oct 10 nov 11 dec 12) },
                   { qw(sun 0 mon 1 tue 2 wed 3 thu 4 fri 5 sat 6)},
                   {  }
                  );
  my @RANGES = ( 
                [ 0,59 ],
                [ 0,23 ],
                [ 0,31 ],
                [ 0,12 ],
                [ 0,7  ],
                [ 0,59 ]
               );
  
  my @LOWMAP = ( 
                {},
                {},
                { 0 => 1},
                { 0 => 1},
                { 7 => 0},
                {},
               );
  
  
  # Currently, there are two ways for reaping. One, which only waits explicitely
  # on PIDs it forked on its own, and one which waits on all PIDs (even on those
  # it doesn't forked itself). The later has been proved to work on Win32 with
  # the 64 threads limit (RT #56926), but not when one creates forks on ones
  # one. The specific reaper works for RT #55741.
  
  # It tend to use the specific one, if it also resolves RT #56926. Both are left
  # here for reference until a decision has been done for 1.01
  
  sub REAPER {
      &_reaper_all();
  }
  
  # Specific reaper
  sub _reaper_specific {
      local ($!,%!);
      if ($HAS_POSIX)
      {
          foreach my $pid (keys %STARTEDCHILD) {
              if ($STARTEDCHILD{$pid}) {
                  my $res = $HAS_POSIX ? waitpid($pid, WNOHANG) : waitpid($pid,0);
                  if ($res > 0) {
                      # We reaped a truly running process
                      $STARTEDCHILD{$pid} = 0;
                      dbg "Reaped child $res" if $DEBUG;
                  }
              }
          }
      } 
      else
      {
          my $waitedpid = 0;
          while($waitedpid != -1) {
              $waitedpid = wait;
          }
      }
  }
  
  # Catch all reaper
  sub _reaper_all {
      local ($!,%!);
      my $kid;
      do 
      {
          # Only on POSIX systems the wait will return immediately 
          # if there are no finished child processes. Simple 'wait'
          # waits blocking on childs.
          $kid = $HAS_POSIX ? waitpid(-1, WNOHANG) : wait;
          print "Kid: $kid\n";
          if ($kid != 0 && $kid != -1 && defined $STARTEDCHILD{$kid}) 
          {
              # We don't delete the hash entry here to avoid an issue
              # when modifyinga global hash from multiple threads
              $STARTEDCHILD{$kid} = 0;
              dbg "Reaped child $kid" if $DEBUG;
          }
      } while ($kid != 0 && $kid != -1);
  
      # Note to myself: Is the %STARTEDCHILD hash really necessary if we use -1
      # for waiting (i.e. for waiting on any child ?). In the current
      # implementation, %STARTEDCHILD is not used at all. It would be only 
      # needed if we iterate over it to wait on pids specifically.
  }
  
  # Cleaning is done in extra method called from the main 
  # process in order to avoid event handlers modifying this
  # global hash which can lead to memory errors.
  # See RT #55741 for more details on this.
  # This method is called in strategic places.
  sub _cleanup_process_list 
  {
      my ($self, $cfg) = @_;
      
      # Cleanup processes even on those systems, where the SIGCHLD is not 
      # propagated. Only do this for POSIX, otherwise this call would block 
      # until all child processes would have been finished.
      # See RT #56926 for more details.
  
      # Do not cleanup if nofork because jobs that fork will do their own reaping.
      &REAPER() if $HAS_POSIX && !$cfg->{nofork};
  
      # Delete entries from this global hash only from within the main
      # thread/process. Hence, this method must not be called from within 
      # a signalhandler    
      for my $k (keys %STARTEDCHILD) 
      {
          delete $STARTEDCHILD{$k} unless $STARTEDCHILD{$k};
      }
  }
  
  =item $cron = new Schedule::Cron($dispatcher,[extra args])
  
  Creates a new C<Cron> object.  C<$dispatcher> is a reference to a subroutine,
  which will be called by default.  C<$dispatcher> will be invoked with the
  arguments parameter provided in the crontab entry if no other subroutine is
  specified. This can be either a single argument containing the argument
  parameter literally has string (default behavior) or a list of arguments when
  using the C<eval> option described below.
  
  The date specifications must be either provided via a crontab like file or
  added explicitly with C<add_entry()> (L<"add_entry">).
  
  I<extra_args> can be a hash or hash reference for additional arguments.  The
  following parameters are recognized:
  
  =over
  
  =item file => <crontab>  
  
  
  Load the crontab entries from <crontab>
  
  =item eval =>  1
  
  Eval the argument parameter in a crontab entry before calling the subroutine
  (instead of literally calling the dispatcher with the argument parameter as
  string)
  
  =item nofork => 1
  
  Don't fork when starting the scheduler. Instead, the jobs are executed within
  current process. In your executed jobs, you have full access to the global
  variables of your script and hence might influence other jobs running at a
  different time. This behaviour is fundamentally different to the 'fork' mode,
  where each jobs gets its own process and hence a B<copy> of the process space,
  independent of each other job and the main process. This is due to the nature
  of the  C<fork> system call. 
  
  =item nostatus =>  1
  
  Do not update status in $0.  Set this if you don't want ps to reveal the internals
  of your application, including job argument lists.  Default is 0 (update status).
  
  =item skip => 1
  
  Skip any pending jobs whose time has passed. This option is only useful in
  combination with C<nofork> where a job might block the execution of the
  following jobs for quite some time. By default, any pending job is executed
  even if its scheduled execution time has already passed. With this option set
  to true all pending which would have been started in the meantime are skipped. 
  
  =item catch => 1
  
  Catch any exception raised by a job. This is especially useful in combination with
  the C<nofork> option to avoid stopping the main process when a job raises an
  exception (dies).
  
  =item after_job => \&after_sub
  
  Call a subroutine after a job has been run. The first argument is the return
  value of the dispatched job, the reminding arguments are the arguments with
  which the dispatched job has been called.
  
  Example:
  
     my $cron = new Schedule::Cron(..., after_job => sub {
            my ($ret,@args) = @_;
            print "Return value: ",$ret," - job arguments: (",join ":",@args,")\n";
     });
  
  =item log => \&log_sub
  
  Install a logging subroutine. The given subroutine is called for several events
  during the lifetime of a job. This method is called with two arguments: A log
  level of 0 (info),1 (warning) or 2 (error) depending on the importance of the
  message and the message itself.
  
  For example, you could use I<Log4perl> (L<http://log4perl.sf.net>) for logging
  purposes for example like in the following code snippet:
  
     use Log::Log4perl;
     use Log::Log4perl::Level;
  
     my $log_method = sub {
        my ($level,$msg) = @_;
        my $DBG_MAP = { 0 => $INFO, 1 => $WARN, 2 => $ERROR };
  
        my $logger = Log::Log4perl->get_logger("My::Package");
        $logger->log($DBG_MAP->{$level},$msg);
     }
    
     my $cron = new Schedule::Cron(.... , log => $log_method);
  
  =item loglevel => <-1,0,1,2>
  
  Restricts logging to the specified severity level or below.  Use 0 to have all
  messages generated, 1 for only warnings and errors and 2 for errors only.
  Default is 0 (all messages).  A loglevel of -1 (debug) will include job
  argument lists (also in $0) in the job start message logged with a level of 0
  or above. You may have security concerns with this. Unless you are debugging,
  use 0 or higher. A value larger than 2 will disable logging completely.
  
  Although you can filter in your log routine, generating the messages can be
  expensive, for example if you pass arguments pointing to large hashes.  Specifying
  a loglevel avoids formatting data that your routine would discard.
  
  =item processprefix => <name>
  
  Cron::Schedule sets the process' name (i.e. C<$0>) to contain some informative
  messages like when the next job executes or with which arguments a job is
  called. By default, the prefix for this labels is C<Schedule::Cron>. With this
  option you can set it to something different. You can e.g. use C<$0> to include
  the original process name.  You can inhibit this with the C<nostatus> option, and
  prevent the argument display by setting C<loglevel> to zero or higher.
  
  =item sleep => \&hook
  
  If specified, &hook will be called instead of sleep(), with the time to sleep
  in seconds as first argument and the Schedule::Cron object as second.  This hook
  allows you to use select() instead of sleep, so that you can handle IO, for
  example job requests from a network connection.
  
  e.g.
  
    $cron->run( { sleep => \&sleep_hook, nofork => 1 } );
  
    sub sleep_hook {
      my ($time, $cron) = @_;
  
      my ($rin, $win, $ein) = ('','','');
      my ($rout, $wout, $eout);
      vec($rin, fileno(STDIN), 1) = 1;
      my ($nfound, $ttg) = select($rout=$rin, $wout=$win, $eout=$ein, $time);
      if ($nfound) {
  	   handle_io($rout, $wout, $eout);
      }
      return;
  }
  
  =back
  
  =cut
  
  sub new 
  {
      my $class = shift;
      my $dispatcher = shift || die "No dispatching sub provided";
      die "Dispatcher not a ref to a subroutine" unless ref($dispatcher) eq "CODE";
      my $cfg = ref($_[0]) eq "HASH" ? $_[0] : {  @_ };
      $cfg->{processprefix} = "Schedule::Cron" unless $cfg->{processprefix};
      my $self = { 
                  cfg => $cfg,
                  dispatcher => $dispatcher,
                  queue => [ ],
                  map => { }
               };
      bless $self,(ref($class) || $class);
      
      $self->load_crontab if $cfg->{file};
      $self;
  }
  
  =item $cron->load_crontab($file)
  
  =item $cron->load_crontab(file=>$file,[eval=>1])
  
  Loads and parses the crontab file C<$file>. The entries found in this file will
  be B<added> to the current time table with C<$cron-E<gt>add_entry>.
  
  The format of the file consists of cron commands containing of lines with at
  least 5 columns, whereas the first 5 columns specify the date.  The rest of the
  line (i.e columns 6 and greater) contains the argument with which the
  dispatcher subroutine will be called.  By default, the dispatcher will be
  called with one single string argument containing the rest of the line
  literally.  Alternatively, if you call this method with the optional argument
  C<eval=E<gt>1> (you must then use the second format shown above), the rest of
  the line will be evaled before used as argument for the dispatcher.
  
  For the format of the first 5 columns, please see L<"add_entry">.
  
  Blank lines and lines starting with a C<#> will be ignored. 
  
  There's no way to specify another subroutine within the crontab file.  All
  calls will be made to the dispatcher provided at construction time.
  
  If    you   want    to    start   up    fresh,    you   should    call
  C<$cron-E<gt>clean_timetable()> before.
  
  Example of a crontab fiqw(le:)
  
     # The following line runs on every Monday at 2:34 am
     34 2 * * Mon  "make_stats"
     # The next line should be best read in with an eval=>1 argument
     *  * 1 1 *    { NEW_YEAR => '1',HEADACHE => 'on' }
  
  =cut
  
  #'
  
  sub load_crontab 
  {
    my $self = shift;
    my $cfg = shift;
  
    if ($cfg) 
    {
        if (@_) 
        {
            $cfg = ref($cfg) eq "HASH" ? $cfg : { $cfg,@_ };
        } 
        elsif (!ref($cfg)) 
        {
            my $new_cfg = { };
            $new_cfg->{file} = $cfg;
            $cfg = $new_cfg;
        }
    }
    
    my $file = $cfg->{file} || $self->{cfg}->{file} || die "No filename provided";
    my $eval = $cfg->{eval} || $self->{cfg}->{eval};
    
    open(F,$file) || die "Cannot open schedule $file : $!";
    my $line = 0;
    while (<F>) 
    {
        $line++;
        # Strip off trailing comments and ignore empty 
        # or pure comments lines:
        s/#.*$//;
        next if /^$/;
        next if /^$/;
        next if /^\s*#/;
        chomp;
        s/\s*(.*)\s*$/$1/;
        my ($min,$hour,$dmon,$month,$dweek,$rest) = split (/\s+/,$_,6);
        
        my $time = [ $min,$hour,$dmon,$month,$dweek ];
  
        # Try to check, whether an optional 6th column specifying seconds 
        # exists: 
        my $args;
        if ($rest)
        {
            my ($col6,$more_args) = split(/\s+/,$rest,2);
            if ($col6 =~ /^[\d\-\*\,\/]+$/)
            {
                push @$time,$col6;
                dbg "M: $more_args";
                $args = $more_args;
            }
            else
            {
                $args = $rest;
            }
        }
        $self->add_entry($time,{ 'args' => $args, 'eval' => $eval});
    }
    close F;
  }
  
  =item $cron->add_entry($timespec,[arguments])
  
  Adds a new entry to the list of scheduled cron jobs.
  
  B<Time and Date specification>
  
  C<$timespec> is the specification of the scheduled time in crontab format
  (L<crontab(5)>) which contains five mandatory time and date fields and an
  optional 6th column. C<$timespec> can be either a plain string, which contains
  a whitespace separated time and date specification.  Alternatively,
  C<$timespec> can be a reference to an array containing the five elements for
  the date fields.
  
  The time and date fields are (taken mostly from L<crontab(5)>, "Vixie" cron): 
  
     field          values
     =====          ======
     minute         0-59
     hour           0-23
     day of month   1-31 
     month          1-12 (or as names)
     day of week    0-7 (0 or 7 is Sunday, or as names)
     seconds        0-59 (optional)
  
   A field may be an asterisk (*), which always stands for
   ``first-last''.
  
   Ranges of numbers are  allowed.  Ranges are two numbers
   separated  with  a  hyphen.   The  specified  range  is
   inclusive.   For example, 8-11  for an  ``hours'' entry
   specifies execution at hours 8, 9, 10 and 11.
  
   Lists  are allowed.   A list  is a  set of  numbers (or
   ranges)  separated by  commas.   Examples: ``1,2,5,9'',
   ``0-4,8-12''.
  
   Step  values can  be used  in conjunction  with ranges.
   Following a range with ``/<number>'' specifies skips of
   the  numbers value  through the  range.   For example,
   ``0-23/2'' can  be used in  the hours field  to specify
   command execution every  other hour (the alternative in
   the V7 standard is ``0,2,4,6,8,10,12,14,16,18,20,22'').
   Steps are  also permitted after an asterisk,  so if you
   want to say ``every two hours'', just use ``*/2''.
  
   Names can also  be used for the ``month''  and ``day of
   week''  fields.  Use  the  first three  letters of  the
   particular day or month (case doesn't matter).
  
   Note: The day of a command's execution can be specified
         by two fields  -- day of month, and  day of week.
         If both fields are restricted (ie, aren't *), the
         command will be run when either field matches the
         current  time.  For  example, ``30  4 1,15  * 5''
         would cause a command to be run at 4:30 am on the
         1st and 15th of each month, plus every Friday
  
  Examples:
  
   "8  0 * * *"         ==> 8 minutes after midnight, every day
   "5 11 * * Sat,Sun"   ==> at 11:05 on each Saturday and Sunday
   "0-59/5 * * * *"     ==> every five minutes
   "42 12 3 Feb Sat"    ==> at 12:42 on 3rd of February and on 
                            each Saturday in February
   "32 11 * * * 0-30/2" ==> 11:32:00, 11:32:02, ... 11:32:30 every 
                            day
  
  In addition, ranges or lists of names are allowed. 
  
  An optional sixth column can be used to specify the seconds within the
  minute. If not present, it is implicitely set to "0".
  
  B<Command specification>
  
  The subroutine to be executed when the the C<$timespec> matches can be
  specified in several ways.
  
  First, if the optional C<arguments> are lacking, the default dispatching
  subroutine provided at construction time will be called without arguments.
  
  If the second parameter to this method is a reference to a subroutine, this
  subroutine will be used instead of the dispatcher.
  
  Any additional parameters will be given as arguments to the subroutine to be
  executed.  You can also specify a reference to an array instead of a list of
  parameters.
  
  You can also use a named parameter list provided as an hashref.  The named
  parameters recognized are:
  
  =over
  
  =item subroutine      
  
  =item sub 
  
  Reference to subroutine to be executed
  
  =item arguments
  
  =item args
  
  Reference to array containing arguments to be use when calling the subroutine
  
  =item eval
  
  If true, use the evaled string provided with the C<arguments> parameter.  The
  evaluation will take place immediately (not when the subroutine is going to be
  called)
  
  =back
  
  Examples:
  
     $cron->add_entry("* * * * *");
     $cron->add_entry("* * * * *","doit");
     $cron->add_entry("* * * * *",\&dispatch,"first",2,"third");
     $cron->add_entry("* * * * *",{'subroutine' => \&dispatch,
                                   'arguments'  => [ "first",2,"third" ]});
     $cron->add_entry("* * * * *",{'subroutine' => \&dispatch,
                                   'arguments'  => '[ "first",2,"third" ]',
                                   'eval'       => 1});
  
  =cut 
  
  sub add_entry 
  { 
      my $self = shift;
      my $time = shift;
      my $args = shift || []; 
      my $dispatch;
      
      #  dbg "Args: ",Dumper($time,$args);
      
      if (ref($args) eq "HASH") 
      {
          my $cfg = $args;
          $args = undef;
          $dispatch = $cfg->{subroutine} || $cfg->{sub};
          $args = $cfg->{arguments} || $cfg->{args} || [];
          if ($cfg->{eval} && $cfg) 
          {
              die "You have to provide a simple scalar if using eval" if (ref($args));
              my $orig_args = $args;
              dbg "Evaled args ",Dumper($args) if $DEBUG;
              $args = [ eval $args ];
              die "Cannot evaluate args (\"$orig_args\")"
                if $@;
          }
      } 
      elsif (ref($args) eq "CODE") 
      {
          $dispatch = $args;
          $args = shift || [];
      }
      if (ref($args) ne "ARRAY") 
      {
          $args = [ $args,@_ ];
      }
  
      $dispatch ||= $self->{dispatcher};
  
  
      my $time_array = ref($time) ? $time : [ split(/\s+/,$time) ];
      die "Invalid number of columns in time entry (5 or 6)\n"
        if ($#$time_array != 4 && $#$time_array !=5);
      $time = join ' ',@$time_array;
  
      #  dbg "Adding ",Dumper($time);
      push @{$self->{time_table}},
      {
       time => $time,
       dispatcher => $dispatch,
       args => $args
      };
      
      $self->{entries_changed} = 1;
      #  dbg "Added Args ",Dumper($self->{args});
      
      my $index = $#{$self->{time_table}};
      my $id = $args->[0];
      $self->{map}->{$id} = $index if $id;
      
      return $#{$self->{time_table}};
  }
  
  =item @entries = $cron->list_entries()
  
  Return a list of cron entries. Each entry is a hash reference of the following
  form:
  
    $entry = { 
               time => $timespec,
               dispatch => $dispatcher,
               args => $args_ref
             }
  
  Here C<$timespec> is the specified time in crontab format as provided to
  C<add_entry>, C<$dispatcher> is a reference to the dispatcher for this entry
  and C<$args_ref> is a reference to an array holding additional arguments (which
  can be an empty array reference). For further explanation of this arguments
  refer to the documentation of the method C<add_entry>.
  
  The order index of each entry can be used within C<update_entry>, C<get_entry>
  and C<delete_entry>. But be aware, when you are deleting an entry, that you
  have to refetch the list, since the order will have changed.
  
  Note that these entries are returned by value and were opbtained from the
  internal list by a deep copy. I.e. you are free to modify it, but this won't
  influence the original entries. Instead use C<update_entry> if you need to
  modify an exisiting crontab entry.
  
  =cut
  
  sub list_entries
  {
      my ($self) = shift;
      
      my @ret;
      foreach my $entry (@{$self->{time_table}})
      {
          # Deep copy $entry
          push @ret,$self->_deep_copy_entry($entry);
      }
      return @ret;
  }
  
  
  =item $entry = $cron->get_entry($idx)
  
  Get a single entry. C<$entry> is either a hashref with the possible keys
  C<time>, C<dispatch> and C<args> (see C<list_entries()>) or undef if no entry
  with the given index C<$idx> exists.
  
  =cut
  
  sub get_entry
  {
      my ($self,$idx) = @_;
  
      my $entry = $self->{time_table}->[$idx];
      if ($entry)
      {
          return $self->_deep_copy_entry($entry);
      }
      else
      {
          return undef;
      }
  }
  
  =item $cron->delete_entry($idx)
  
  Delete the entry at index C<$idx>. Returns the deleted entry on success,
  C<undef> otherwise.
  
  =cut
  
  sub delete_entry
  {
      my ($self,$idx) = @_;
  
      if ($idx <= $#{$self->{time_table}})
      {
          $self->{entries_changed} = 1;
  
          # Remove entry from $self->{map} which 
          # remembers the index in the timetable by name (==id)
          # and update all larger indexes appropriately
          # Fix for #54692
          my $map = $self->{map};
          foreach my $key (keys %{$map}) {
              if ($map->{$key} > $idx) {
                  $map->{$key}--;
              } elsif ($map->{$key} == $idx) {
                  delete $map->{$key};
              }
          }
          return splice @{$self->{time_table}},$idx,1;
      }
      else
      {
          return undef;
      }
  }
  
  =item $cron->update_entry($idx,$entry)
  
  Updates the entry with index C<$idx>. C<$entry> is a hash ref as descibed in
  C<list_entries()> and must contain at least a value C<$entry-E<gt>{time}>. If no
  C<$entry-E<gt>{dispatcher}> is given, then the default dispatcher is used.  This
  method returns the old entry on success, C<undef> otherwise.
  
  =cut 
  
  sub update_entry
  {
      my ($self,$idx,$entry) = @_;
  
      die "No update entry given" unless $entry;
      die "No time specification given" unless $entry->{time};
      
      if ($idx <= $#{$self->{time_table}})
      {
          my $new_entry = $self->_deep_copy_entry($entry);
          $new_entry->{dispatcher} = $self->{dispatcher} 
            unless $new_entry->{dispatcher};
          $new_entry->{args} = []
            unless $new_entry->{args};
          return splice @{$self->{time_table}},$idx,1,$new_entry;
      }
      else
      {
          return undef;
      }
  }
  
  =item $cron->run([options])
  
  This method starts the scheduler.
  
  When called without options, this method will never return and executes the
  scheduled subroutine calls as needed.
  
  Alternatively, you can detach the main scheduler loop from the current process
  (daemon mode). In this case, the pid of the forked scheduler process will be
  returned.
  
  The C<options> parameter specifies the running mode of C<Schedule::Cron>.  It
  can be either a plain list which will be interpreted as a hash or it can be a
  reference to a hash. The following named parameters (keys of the provided hash)
  are recognized:
  
  =over
  
  =item detach    
  
  If set to a true value the scheduler process is detached from the current
  process (UNIX only).
  
  =item pid_file  
  
  If running in daemon mode, name the optional file, in which the process id of
  the scheduler process should be written. By default, no PID File will be
  created.
  
  =item nofork, skip, catch, log, loglevel, nostatus, sleep
  
  See C<new()> for a description of these configuration parameters, which can be
  provided here as well. Note, that the options given here overrides those of the
  constructor.
  
  =back
  
  
  Examples:
  
     # Start  scheduler, detach  from current  process and
     # write  the  PID  of  the forked  scheduler  to  the
     # specified file
     $cron->run(detach=>1,pid_file=>"/var/run/scheduler.pid");
  
     # Start scheduler and wait forever.
     $cron->run();
  
  =cut
  
  sub run 
  { 
      my $self = shift;
      my $cfg = ref($_[0]) eq "HASH" ? $_[0] : {  @_ };
      $cfg = { %{$self->{cfg}}, %$cfg }; # Merge in global config;
  
      my $log = $cfg->{log};
      my $loglevel = $cfg->{loglevel};
      $loglevel = 0 unless defined $loglevel;
      my $sleeper = $cfg->{sleep};
  
      $self->_rebuild_queue;
      delete $self->{entries_changed};
      die "Nothing in schedule queue" unless @{$self->{queue}};
      
      # Install reaper now.
      unless ($cfg->{nofork}) {
          my $old_child_handler = $SIG{'CHLD'};
          $SIG{'CHLD'} = sub {
              &REAPER();
              if ($old_child_handler && ref $old_child_handler eq 'CODE')
              {
                  &$old_child_handler();
              }
          };
      }
      
      my $mainloop = sub { 
        MAIN:
          while (42)          
          {
              unless (@{$self->{queue}}) # Queue length
              { 
                  # Last job deleted itself, or we were run with no entries.
                  # We can't return, so throw an exception - perhaps somone will catch.
                  die "No more jobs to run\n";
              }
              my ($index,$time) = @{shift @{$self->{queue}}};
              my $now = time;
              my $sleep = 0;
              if ($time < $now)
              {
                  if ($cfg->{skip})
                  {
                      $log->(0,"Schedule::Cron - Skipping job $index")
                        if $log && $loglevel <= 0;
                      $self->_update_queue($index);
                      next;
                  }
                  # At least a safety airbag
                  $sleep = 1;
              }
              else
              {
                  $sleep = $time - $now;
              }
              $0 = $self->_get_process_prefix()." MainLoop - next: ".scalar(localtime($time)) unless $cfg->{nostatus};
              if (!$time) {
                  die "Internal: No time found, self: ",$self->{queue},"\n" unless $time;
              }
  
              dbg "R: sleep = $sleep | ",scalar(localtime($time))," (",scalar(localtime($now)),")" if $DEBUG;
  
              while ($sleep > 0) 
              {
                  if ($sleeper) 
                  {
                      $sleeper->($sleep,$self);
                      if ($self->{entries_changed})
                      {
                          $self->_rebuild_queue;
                          delete $self->{entries_changed};
                          redo MAIN;
                      }
                  } else {
                      sleep($sleep);
                  }
                  $sleep = $time - time;
              }
  
              $self->_execute($index,$cfg);
              $self->_cleanup_process_list($cfg);
  
              if ($self->{entries_changed}) {
                 dbg "rebuilding queue" if $DEBUG;
                 $self->_rebuild_queue;
                 delete $self->{entries_changed};
              } else {
                 $self->_update_queue($index);
              }
          } 
      };
  
      if ($cfg->{detach}) 
      {
          defined(my $pid = fork) or die "Can't fork: $!";
          if ($pid) 
          {
              # Parent:
              if ($cfg->{pid_file}) 
              {
                  if (open(P,">".$cfg->{pid_file})) 
                  {
                      print P $pid,"\n";
                      close P;
                  } 
                  else 
                  {
                      warn "Warning: Cannot open ",$cfg->{pid_file}," : $!\n";
                  }
                  
              }
              return $pid;
          } 
          else 
          {
              # Child:
              # Try to detach from terminal:
              chdir '/';
              open STDIN, '/dev/null' or die "Can't read /dev/null: $!";
              open STDOUT, '>/dev/null' or die "Can't write to /dev/null: $!";
              
              eval { require POSIX; };
              if ($@) 
              {
                  #      if (1) {
                  if (open(T,"/dev/tty")) 
                  {
                      dbg "No setsid found, trying ioctl() (Error: $@)";
                      eval { require 'ioctl.ph'; };
                      if ($@) 
                      {
                          eval { require 'sys/ioctl.ph'; };
                          if ($@) 
                          {
                              die "No 'ioctl.ph'. Probably you have to run h2ph (Error: $@)";
                          }
                      }
                      my $notty = &TIOCNOTTY;
                      die "No TIOCNOTTY !" if $@ || !$notty;
                      ioctl(T,$notty,0) || die "Cannot issue ioctl(..,TIOCNOTTY) : $!";
                      close(T);
                  };
              } 
              else 
              {
                  &POSIX::setsid() || die "Can't start a new session: $!";
              }
              open STDERR, '>&STDOUT' or die "Can't dup stdout: $!";
              
              $0 = $self->_get_process_prefix()." MainLoop" unless $cfg->{nostatus};
              &$mainloop();
          }
      } 
      else 
      {
          &$mainloop(); 
      }
  }
  
  
  =item $cron->clean_timetable()
  
  Remove all scheduled entries
  
  =cut
  
  sub clean_timetable 
  { 
      my $self = shift;
      $self->{entries_changed} = 1;
      $self->{time_table} = [];
  }
  
  
  =item $cron->check_entry($id)
  
  Check, whether the given ID is already registered in the timetable. 
  A ID is the first argument in the argument parameter of the 
  a crontab entry.
  
  Returns (one of) the index in the  timetable (can be 0, too) if the ID
  could be found or C<undef> otherwise.
  
  Example:
  
     $cron->add_entry("* * * * *","ROTATE");
     .
     .
     defined($cron->check_entry("ROTATE")) || die "No ROTATE entry !"
  
  =cut 
  
  sub check_entry 
  { 
      my $self = shift;
      my $id = shift;
      return $self->{map}->{$id};
  }
  
  
  =item $cron->get_next_execution_time($cron_entry,[$ref_time])
  
  Well, this is mostly an internal method, but it might be useful on 
  its own. 
  
  The purpose of this method is to calculate the next execution time
  from a specified crontab entry
  
  Parameters:
  
  =over
  
  =item $cron_entry  
  
  The crontab entry as specified in L<"add_entry">
  
  =item $ref_time    
  
  The reference time for which the next time should be searched which matches
  C<$cron_entry>. By default, take the current time
  
  =back
  
  This method returns the number of epoch-seconds of the next matched 
  date for C<$cron_entry>.
  
  Since I suspect, that this calculation of the next execution time might
  fail in some circumstances (bugs are lurking everywhere ;-) an
  additional interactive method C<bug()> is provided for checking
  crontab entries against your expected output. Refer to the
  top-level README for additional usage information for this method.
  
  =cut
  
  sub get_next_execution_time 
  { 
    my $self = shift;
    my $cron_entry = shift;
    my $time = shift;
    
    $cron_entry = [ split /\s+/,$cron_entry ] unless ref($cron_entry);
  
    # Expand and check entry:
    # =======================
    die "Exactly 5 or 6 columns has to be specified for a crontab entry ! (not ",
      scalar(@$cron_entry),")"
        if ($#$cron_entry != 4 && $#$cron_entry != 5);
    
    my @expanded;
    my $w;
    
    for my $i (0..$#$cron_entry) 
    {
        my @e = split /,/,$cron_entry->[$i];
        my @res;
        my $t;
        while (defined($t = shift @e)) {
            # Subst "*/5" -> "0-59/5"
            $t =~ s|^\*(/.+)$|$RANGES[$i][0]."-".$RANGES[$i][1].$1|e; 
            
            if ($t =~ m|^([^-]+)-([^-/]+)(/(.*))?$|) 
            {
                my ($low,$high,$step) = ($1,$2,$4);
                $step = 1 unless $step;
                if ($low !~ /^(\d+)/) 
                {
                    $low = $ALPHACONV[$i]{lc $low};
                }
                if ($high !~ /^(\d+)/) 
                {
                    $high = $ALPHACONV[$i]{lc $high};
                }
                if (! defined($low) || !defined($high) ||  $low > $high || $step !~ /^\d+$/) 
                {
                    die "Invalid cronentry '",$cron_entry->[$i],"'";
                }
                my $j;
                for ($j = $low; $j <= $high; $j += $step) 
                {
                    push @e,$j;
                }
            } 
            else 
            {
                $t = $ALPHACONV[$i]{lc $t} if $t !~ /^(\d+|\*)$/;
                $t = $LOWMAP[$i]{$t} if exists($LOWMAP[$i]{$t});
                
                die "Invalid cronentry '",$cron_entry->[$i],"'" 
                  if (!defined($t) || ($t ne '*' && ($t < $RANGES[$i][0] || $t > $RANGES[$i][1])));
                push @res,$t;
            }
        }
        push @expanded, ($#res == 0 && $res[0] eq '*') ? [ "*" ] : [ sort {$a <=> $b} @res];
    }
    
    # Check for strange bug
    $self->_verify_expanded_cron_entry($cron_entry,\@expanded);
  
    # Calculating time:
    # =================
    my $now = $time || time;
  
    if ($expanded[2]->[0] ne '*' && $expanded[4]->[0] ne '*') 
    {
        # Special check for which time is lower (Month-day or Week-day spec):
        my @bak = @{$expanded[4]};
        $expanded[4] = [ '*' ];
        my $t1 = $self->_calc_time($now,\@expanded);
        $expanded[4] = \@bak;
        $expanded[2] = [ '*' ];
        my $t2 = $self->_calc_time($now,\@expanded);
        dbg "MDay : ",scalar(localtime($t1))," -- WDay : ",scalar(localtime($t2)) if $DEBUG;
        return $t1 < $t2 ? $t1 : $t2;
    } 
    else 
    {
        # No conflicts possible:
        return $self->_calc_time($now,\@expanded);
    }
  }
  
  # ==================================================
  # PRIVATE METHODS:
  # ==================================================
  
  # Build up executing queue and delete any
  # existing entries
  sub _rebuild_queue 
  { 
      my $self = shift;
      $self->{queue} = [ ];
      #  dbg "TT: ",$#{$self->{time_table}};
      for my $id (0..$#{$self->{time_table}}) 
      {
          $self->_update_queue($id);
      }
  }
  
  # deeply copy an entry in the time table
  sub _deep_copy_entry
  {
      my ($self,$entry) = @_;
  
      my $args = [ @{$entry->{args}} ];
      my $copied_entry = { %$entry };
      $copied_entry->{args} = $args;
      return $copied_entry;
  }
  
  # Execute a subroutine whose time has come
  sub _execute 
  { 
    my $self = shift;
    my $index = shift;
    my $cfg = shift || $self->{cfg};
    my $entry = $self->get_entry($index) 
      || die "Internal: No entry with index $index found in ",Dumper([$self->list_entries()]);
  
    my $pid;
  
  
    my $log = $cfg->{log};
    my $loglevel = $cfg->{loglevel} || 0;
  
    unless ($cfg->{nofork})
    {
        if ($pid = fork)
        {
            # Parent
            $log->(0,"Schedule::Cron - Forking child PID $pid") if $log && $loglevel <= 0;
            # Register PID
            $STARTEDCHILD{$pid} = 1;
            return;
        } 
    }
    
    # Child
    my $dispatch = $entry->{dispatcher};
    die "No subroutine provided with $dispatch" 
      unless ref($dispatch) eq "CODE";
    my $args = $entry->{args};
    
    my @args = ();
    if (defined($args) && defined($args->[0])) 
    {
        push @args,@$args;
    }
  
  
    if ($log && $loglevel <= 0 || !$cfg->{nofork} && !$cfg->{nostatus}) {
        my $args_label = (@args && $loglevel <= -1) ? " with (".join(",",$self->_format_args(@args)).")" : "";
        $0 = $self->_get_process_prefix()." Dispatched job $index$args_label"
          unless $cfg->{nofork} || $cfg->{nostatus};
        $log->(0,"Schedule::Cron - Starting job $index$args_label")
          if $log && $loglevel <= 0;
    }
    my $dispatch_result;
    if ($cfg->{catch})
    {
        # Evaluate dispatcher
        eval
        {
            $dispatch_result = &$dispatch(@args);
        };
        if ($@)
        {
            $log->(2,"Schedule::Cron - Error within job $index: $@")
              if $log && $loglevel <= 2;
        }
    }
    else
    {
        # Let dispatcher die if needed.
        $dispatch_result = &$dispatch(@args);
    }
    
    if($cfg->{after_job}) {
        my $job = $cfg->{after_job};
        if (ref($job) eq "CODE") {
            eval
            {
                &$job($dispatch_result,@args);
            };
            if ($@)
            {
                $log->(2,"Schedule::Cron - Error while calling after_job callback with retval = $dispatch_result: $@")
                  if $log && $loglevel <= 2;
            }
        } else {
            $log->(2,"Schedule::Cron - Invalid after_job callback, it's not a code ref (but ",$job,")")
              if $log && $loglevel <= 2;
        }
    }
  
    $log->(0,"Schedule::Cron - Finished job $index") if $log && $loglevel <= 0;
    exit unless $cfg->{nofork};
  }
  
  # Udate the scheduler queue with a new entry
  sub _update_queue 
  { 
      my $self = shift;
      my $index = shift;
      my $entry = $self->get_entry($index);
      
      my $new_time = $self->get_next_execution_time($entry->{time});
      # Check, whether next execution time is *smaller* than the current time.
      # This can happen during DST backflip:
      my $now = time;
      if ($new_time <= $now) {
          dbg "Adjusting time calculation because of DST back flip (new_time - now = ",$new_time - $now,")" if $DEBUG;
          # We are adding hours as long as our target time is in the future
          while ($new_time <= $now) {
              $new_time += 3600;
          }
      }
  
      dbg "Updating Queue: ",scalar(localtime($new_time)) if $DEBUG;
      $self->{queue} = [ sort { $a->[1] <=> $b->[1] } @{$self->{queue}},[$index,$new_time] ];
      #  dbg "Queue now: ",Dumper($self->{queue});
  }
  
  
  # The heart of the module.
  # calulate the next concrete date
  # for execution from a crontab entry
  sub _calc_time 
  { 
      my $self = shift;
      my $now = shift;
      my $expanded = shift;
  
      my $offset = ($expanded->[5] ? 1 : 60);
      my ($now_sec,$now_min,$now_hour,$now_mday,$now_mon,$now_wday,$now_year) = 
        (localtime($now+$offset))[0,1,2,3,4,6,5];
      $now_mon++; 
      $now_year += 1900;
  
      # Notes on variables set:
      # $now_... : the current date, fixed at call time
      # $dest_...: date used for backtracking. At the end, it contains
      #            the desired lowest matching date
  
      my ($dest_mon,$dest_mday,$dest_wday,$dest_hour,$dest_min,$dest_sec,$dest_year) = 
        ($now_mon,$now_mday,$now_wday,$now_hour,$now_min,$now_sec,$now_year);
  
      # dbg Dumper($expanded);
  
      # Airbag...
      while ($dest_year <= $now_year + 1) 
      { 
          dbg "Parsing $dest_hour:$dest_min:$dest_sec $dest_year/$dest_mon/$dest_mday" if $DEBUG;
          
          # Check month:
          if ($expanded->[3]->[0] ne '*') 
          {
              unless (defined ($dest_mon = $self->_get_nearest($dest_mon,$expanded->[3]))) 
              {
                  $dest_mon = $expanded->[3]->[0];
                  $dest_year++;
              } 
          } 
    
          # Check for day of month:
          if ($expanded->[2]->[0] ne '*') 
          {           
              if ($dest_mon != $now_mon) 
              {      
                  $dest_mday = $expanded->[2]->[0];
              } 
              else 
              {
                  unless (defined ($dest_mday = $self->_get_nearest($dest_mday,$expanded->[2]))) 
                  {
                      # Next day matched is within the next month. ==> redo it
                      $dest_mday = $expanded->[2]->[0];
                      $dest_mon++;
                      if ($dest_mon > 12) 
                      {
                          $dest_mon = 1;
                          $dest_year++;
                      }
                      dbg "Backtrack mday: $dest_mday/$dest_mon/$dest_year" if $DEBUG;
                      next;
                  }
              }
          } 
          else 
          {
              $dest_mday = ($dest_mon == $now_mon ? $dest_mday : 1);
          }
    
          # Check for day of week:
          if ($expanded->[4]->[0] ne '*') 
          {
              $dest_wday = $self->_get_nearest($dest_wday,$expanded->[4]);
              $dest_wday = $expanded->[4]->[0] unless $dest_wday;
      
              my ($mon,$mday,$year);
              #      dbg "M: $dest_mon MD: $dest_mday WD: $dest_wday Y:$dest_year";
              $dest_mday = 1 if $dest_mon != $now_mon;
              my $t = parsedate(sprintf("%4.4d/%2.2d/%2.2d",$dest_year,$dest_mon,$dest_mday));
              ($mon,$mday,$year) =  
                (localtime(parsedate("$WDAYS[$dest_wday]",PREFER_FUTURE=>1,NOW=>$t-1)))[4,3,5]; 
              $mon++;
              $year += 1900;
              
              dbg "Calculated $mday/$mon/$year for weekday ",$WDAYS[$dest_wday] if $DEBUG;
              if ($mon != $dest_mon || $year != $dest_year) {
                  dbg "backtracking" if $DEBUG;
                  $dest_mon = $mon;
                  $dest_year = $year;
                  $dest_mday = 1;
                  $dest_wday = (localtime(parsedate(sprintf("%4.4d/%2.2d/%2.2d",
                                                            $dest_year,$dest_mon,$dest_mday))))[6];
                  next;
              }
              
              $dest_mday = $mday;
          } 
          else 
          {
              unless ($dest_mday) 
              {
                  $dest_mday = ($dest_mon == $now_mon ? $dest_mday : 1);
              }
          }
  
    
          # Check for hour
          if ($expanded->[1]->[0] ne '*') 
          {
              if ($dest_mday != $now_mday || $dest_mon != $now_mon || $dest_year != $now_year) 
              {
                  $dest_hour = $expanded->[1]->[0];
              } 
              else 
              {
                  #dbg "Checking for next hour $dest_hour";
                  unless (defined ($dest_hour = $self->_get_nearest($dest_hour,$expanded->[1]))) 
                  {
                      # Hour to match is at the next day ==> redo it
                      $dest_hour = $expanded->[1]->[0];
                      my $t = parsedate(sprintf("%2.2d:%2.2d:%2.2d %4.4d/%2.2d/%2.2d",
                                                $dest_hour,$dest_min,$dest_sec,$dest_year,$dest_mon,$dest_mday));
                      ($dest_mday,$dest_mon,$dest_year,$dest_wday) = 
                        (localtime(parsedate("+ 1 day",NOW=>$t)))[3,4,5,6];
                      $dest_mon++; 
                      $dest_year += 1900;
                      next; 
                  }
              }
          } 
          else 
          {
              $dest_hour = ($dest_mday == $now_mday ? $dest_hour : 0);
          }
          # Check for minute
          if ($expanded->[0]->[0] ne '*') 
          {
              if ($dest_hour != $now_hour || $dest_mday != $now_mday || $dest_mon != $dest_mon || $dest_year != $now_year) 
              {
                  $dest_min = $expanded->[0]->[0];
              } 
              else 
              {
                  unless (defined ($dest_min = $self->_get_nearest($dest_min,$expanded->[0]))) 
                  {
                      # Minute to match is at the next hour ==> redo it
                      $dest_min = $expanded->[0]->[0];
                      my $t = parsedate(sprintf("%2.2d:%2.2d:%2.2d %4.4d/%2.2d/%2.2d",
                                                $dest_hour,$dest_min,$dest_sec,$dest_year,$dest_mon,$dest_mday));
                      ($dest_hour,$dest_mday,$dest_mon,$dest_year,$dest_wday) = 
                        (localtime(parsedate(" + 1 hour",NOW=>$t)))  [2,3,4,5,6];
                      $dest_mon++;
                      $dest_year += 1900;
                      next;
                  }
              }
          } 
          else 
          {
              if ($dest_hour != $now_hour ||
                  $dest_mday != $now_mday ||
                  $dest_year != $now_year) {
                  $dest_min = 0;
              } 
          }
          # Check for seconds
          if ($expanded->[5])
          {
              if ($expanded->[5]->[0] ne '*')
              {
                  if ($dest_min != $now_min) 
                  {
                      $dest_sec = $expanded->[5]->[0];
                  } 
                  else 
                  {
                      unless (defined ($dest_sec = $self->_get_nearest($dest_sec,$expanded->[5]))) 
                      {
                          # Second to match is at the next minute ==> redo it
                          $dest_sec = $expanded->[5]->[0];
                          my $t = parsedate(sprintf("%2.2d:%2.2d:%2.2d %4.4d/%2.2d/%2.2d",
                                                    $dest_hour,$dest_min,$dest_sec,
                                                    $dest_year,$dest_mon,$dest_mday));
                          ($dest_min,$dest_hour,$dest_mday,$dest_mon,$dest_year,$dest_wday) = 
                            (localtime(parsedate(" + 1 minute",NOW=>$t)))  [1,2,3,4,5,6];
                          $dest_mon++;
                          $dest_year += 1900;
                          next;
                      }
                  }
              } 
              else 
              {
                  $dest_sec = ($dest_min == $now_min ? $dest_sec : 0);
              }
          }
          else
          {
              $dest_sec = 0;
          }
          
          # We did it !!
          my $date = sprintf("%2.2d:%2.2d:%2.2d %4.4d/%2.2d/%2.2d",
                             $dest_hour,$dest_min,$dest_sec,$dest_year,$dest_mon,$dest_mday);
          dbg "Next execution time: $date ",$WDAYS[$dest_wday] if $DEBUG;
          my $result = parsedate($date, VALIDATE => 1);
          # Check for a valid date
          if ($result)
          {
              # Valid date... return it!
              return $result;
          }
          else
          {
              # Invalid date i.e. (02/30/2008). Retry it with another, possibly
              # valid date            
              my $t = parsedate($date); # print scalar(localtime($t)),"\n";
              ($dest_hour,$dest_mday,$dest_mon,$dest_year,$dest_wday) =
                (localtime(parsedate(" + 1 second",NOW=>$t)))  [2,3,4,5,6];
              $dest_mon++;
              $dest_year += 1900;
              next;
          }
      }
  
      # Die with an error because we couldnt find a next execution entry
      my $dumper = new Data::Dumper($expanded);
      $dumper->Terse(1);
      $dumper->Indent(0);
  
      die "No suitable next execution time found for ",$dumper->Dump(),", now == ",scalar(localtime($now)),"\n";
  }
  
  # get next entry in list or 
  # undef if is the highest entry found
  sub _get_nearest 
  { 
    my $self = shift;
    my $x = shift;
    my $to_check = shift;
    foreach my $i (0 .. $#$to_check) 
    {
        if ($$to_check[$i] >= $x) 
        {
            return $$to_check[$i] ;
        }
    }
    return undef;
  }
  
  
  # prepare a list of object for pretty printing e.g. in the process list
  sub _format_args {
      my $self = shift;
      my @args = @_;
      my $dumper = new Data::Dumper(\@args);
      $dumper->Terse(1);
      $dumper->Maxdepth(2);
      $dumper->Indent(0);
      return $dumper->Dump();
  }
  
  # get the prefix to use when setting $0
  sub _get_process_prefix { 
      my $self = shift;
      my $prefix = $self->{cfg}->{processprefix} || "Schedule::Cron";
      return $prefix;
  }
  
  # our very own debugging routine
  # ('guess everybody has its own style ;-)
  # Callers check $DEBUG on the critical path to save the computes
  # used to produce expensive arguments.  Omitting those would be
  # functionally correct, but rather wasteful.
  sub dbg  
  {
    if ($DEBUG) 
    {
        my $args = join('',@_) || "";
        my $caller = (caller(1))[0];
        my $line = (caller(0))[2];
        $caller ||= $0;
        if (length $caller > 22) 
        {
            $caller = substr($caller,0,10)."..".substr($caller,-10,10);
        }
        print STDERR sprintf ("%02d:%02d:%02d [%22.22s %4.4s]  %s\n",
                              (localtime)[2,1,0],$caller,$line,$args);
    }
  }
  
  # Helper method for reporting bugs concerning calculation
  # of execution bug:
  *bug = \&report_exectime_bug;   # Shortcut
  sub report_exectime_bug 
  {
    my $self = shift;
    my $endless = shift;
    my $time = time;
    my $inp;
    my $now = $self->_time_as_string($time);
    my $email;
  
    do 
    {
        while (1) 
        {
            $inp = $self->_get_input("Reference time\n(default: $now)  : ");
            if ($inp) 
            {
                parsedate($inp) || (print "Couldn't parse \"$inp\"\n",next);
                $now = $inp;
            }
            last;
        }
        my $now_time = parsedate($now);
      
        my ($next_time,$next);
        my @entries;
        while (1) 
        {
            $inp = $self->_get_input("Crontab time (5 columns)            : ");
            @entries = split (/\s+/,$inp);
            if (@entries != 5) 
            {
                print "Invalid crontab entry \"$inp\"\n";
                next;
            }
            eval 
            { 
                local $SIG{ALRM} = sub {  die "TIMEOUT" };
                alarm(60);
                $next_time = Schedule::Cron->get_next_execution_time(\@entries,$now_time);
                alarm(0);
            };
            if ($@) 
            {
                alarm(0);
                if ($@ eq "TIMEOUT") 
                {
                    $next_time = -1;
                } else 
                {
                    print "Invalid crontab entry \"$inp\" ($@)\n";
                    next;
                }
            }
          
            if ($next_time > 0) 
            {
                $next = $self->_time_as_string($next_time);
            } else 
            {
                $next = "Run into infinite loop !!";
            }
            last;
        }
      
        my ($expected,$expected_time);
        while (1) 
        {
            $inp = $self->_get_input("Expected time                       : ");
            unless ($expected_time = parsedate($inp)) 
            {
                print "Couldn't parse \"$inp\"\n";
                next;
            } 
            $expected = $self->_time_as_string($expected_time);
            last;
        }
      
        # Print out bug report:
        if ($expected eq $next) 
        {
            print "\nHmm, seems that everything's ok, or ?\n\n";
            print "Calculated time: ",$next,"\n";
            print "Expected time  : ",$expected,"\n";
        } else 
        {
            print <<EOT;
  Congratulation, you hit a bug. 
  
  EOT
            $email = $self->_get_input("Your E-Mail Address (if available)  : ") 
              unless defined($email);
            $email = "" unless defined($email);
        
            print "\n","=" x 80,"\n";
            print <<EOT;
  Please report the following lines
  to roland\@cpan.org
  
  EOT
            print "# ","-" x 78,"\n";
            print "Reftime: ",$now,"\n";
            print "# Reported by : ",$email,"\n" if $email;
            printf "%8s %8s %8s %8s %8s         %s\n",@entries,$expected;
            print "# Calculated  : \n";
            printf "# %8s %8s %8s %8s %8s         %s\n",@entries,$next;
            unless ($endless) 
            {
                require Config;
                my $vers = `uname -r 2>/dev/null` || $Config::Config{'osvers'} ;
                chomp $vers;
                my $osname = `uname -s 2>/dev/null` || $Config::Config{'osname'};
                chomp $osname;
                print "# OS: $osname ($vers)\n";
                print "# Perl-Version: $]\n";
                print "# Time::ParseDate-Version: ",$Time::ParseDate::VERSION,"\n";
            }
            print "# ","-" x 78,"\n";
        }
      
        print "\n","=" x 80,"\n";
    } while ($endless);
  }
  
  my ($input_initialized,$term);
  sub _get_input 
  { 
    my $self = shift;
    my $prompt = shift;
    use vars qw($term);
  
    unless (defined($input_initialized)) 
    {
        eval { require Term::ReadLine; };
      
        $input_initialized = $@ ? 0 : 1;
        if ($input_initialized) 
        {
            $term = new Term::ReadLine;
            $term->ornaments(0);
        }
    }
    
    unless ($input_initialized) 
    {
        print $prompt;
        my $inp = <STDIN>;
        chomp $inp;
        return $inp;
    } 
    else 
    {
        chomp $prompt;
        my @prompt = split /\n/s,$prompt;
        if ($#prompt > 0)
        {
            print join "\n",@prompt[0..$#prompt-1],"\n";
        }
        my $inp = $term->readline($prompt[$#prompt]);
        return $inp;
    }
  }
  
  sub _time_as_string 
  { 
    my $self = shift;
    my $time = shift; 
  
    my ($min,$hour,$mday,$month,$year,$wday) = (localtime($time))[1..6];
    $month++;
    $year += 1900;
    $wday = $WDAYS[$wday];
    return sprintf("%2.2d:%2.2d %2.2d/%2.2d/%4.4d %s",
                   $hour,$min,$mday,$month,$year,$wday);
  }
  
  
  # As reported by RT Ticket #24712 sometimes, 
  # the expanded version of the cron entry is flaky.
  # However, this occurs only very rarely and randomly. 
  # So, we need to provide good diagnostics when this 
  # happens
  sub _verify_expanded_cron_entry {
      my $self = shift;
      my $original = shift;
      my $entry = shift;
      die "Internal: Not an array ref. Orig: ",Dumper($original), ", expanded: ",Dumper($entry)," (self = ",Dumper($self),")"
        unless ref($entry) eq "ARRAY";
      
      for my $i (0 .. $#{$entry}) {
          die "Internal: Part $i of entry is not an array ref. Original: ",
            Dumper($original),", expanded: ",Dumper($entry)," (self=",Dumper($self),")",
              unless ref($entry->[$i]) eq "ARRAY";
      }    
  }
  
  =back
  
  =head1 DST ISSUES
  
  Daylight saving occurs typically twice a year: In the first switch, one hour is
  skipped. Any job which which triggers in this skipped hour will be fired in the
  next hour. So, when the DST switch goes from 2:00 to 3:00 a job which is
  scheduled for 2:43 will be executed at 3:43.
  
  For the reverse backwards switch later in the year, the behaviour is
  undefined. Two possible behaviours can occur: For jobs triggered in short
  intervals, where the next execution time would fire in the extra hour as well,
  the job could be executed again or skipped in this extra hour. Currently,
  running C<Schedule::Cron> in C<MET> would skip the extra job, in C<PST8PDT> it
  would execute a second time. The reason is the way how L<Time::ParseDate>
  calculates epoch times for dates given like C<02:50:00 2009/10/25>. Should it
  return the seconds since 1970 for this time happening 'first', or for this time
  in the extra hour ? As it turns out, L<Time::ParseDate> returns the epoch time
  of the first occurence for C<PST8PDT> and for C<MET> it returns the second
  occurence. Unfortunately, there is no way to specify I<which> entry
  L<Time::ParseDate> should pick (until now). Of course, after all, this is
  obviously not L<Time::ParseDate>'s fault, since a simple date specification
  within the DST backswitch period B<is> ambigious. However, it would be nice if
  the parsing behaviour of L<Time::ParseDate> would be consistent across time
  zones (a ticket has be raised for fixing this). Then L<Schedule::Cron>'s
  behaviour within a DST backward switch would be consistent as well.
  
  Since changing the internal algorithm which worked now for over ten years would
  be too risky and I don't see any simple solution for this right now, it is
  likely that this I<undefined> behaviour will exist for some time. Maybe some
  hero is coming along and will fix this, but this is probably not me ;-)
  
  Sorry for that.
  
  =head1 LICENSE
  
  Copyright 1999-2011 Roland Huss.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  ... roland
  
  =cut
  
  1;
  
  
  
  
SCHEDULE_CRON

$fatpacked{"Time/CTime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TIME_CTIME';
  package Time::CTime;
  
  
  require 5.000;
  
  use Time::Timezone;
  use Time::CTime;
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(ctime asctime strftime);
  @EXPORT_OK = qw(asctime_n ctime_n @DoW @MoY @DayOfWeek @MonthOfYear);
  
  use strict;
  
  # constants
  use vars qw(@DoW @DayOfWeek @MoY @MonthOfYear %strftime_conversion $VERSION);
  use vars qw($template $sec $min $hour $mday $mon $year $wday $yday $isdst);
  
  $VERSION = 2011.0505;
  
  CONFIG: {
      @DoW = 	   qw(Sun Mon Tue Wed Thu Fri Sat);
      @DayOfWeek =   qw(Sunday Monday Tuesday Wednesday Thursday Friday Saturday);
      @MoY = 	   qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
      @MonthOfYear = qw(January February March April May June 
  		      July August September October November December);
    
      %strftime_conversion = (
  	'%',	sub { '%' },
  	'a',	sub { $DoW[$wday] },
  	'A',	sub { $DayOfWeek[$wday] },
  	'b',	sub { $MoY[$mon] },
  	'B',	sub { $MonthOfYear[$mon] },
  	'c',	sub { asctime_n($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst, "") },
  	'd',	sub { sprintf("%02d", $mday); },
  	'D',	sub { sprintf("%02d/%02d/%02d", $mon+1, $mday, $year%100) },
  	'e',	sub { sprintf("%2d", $mday); },
  	'f',	sub { fracprintf ("%3.3f", $sec); },
  	'F',	sub { fracprintf ("%6.6f", $sec); },
  	'h',	sub { $MoY[$mon] },
  	'H',	sub { sprintf("%02d", $hour) },
  	'I',	sub { sprintf("%02d", $hour % 12 || 12) },
  	'j',	sub { sprintf("%03d", $yday + 1) },
  	'k',	sub { sprintf("%2d", $hour); },
  	'l',	sub { sprintf("%2d", $hour % 12 || 12) },
  	'm',	sub { sprintf("%02d", $mon+1); },
  	'M',	sub { sprintf("%02d", $min) },
  	'n',	sub { "\n" },
  	'o',	sub { sprintf("%d%s", $mday, (($mday < 20 && $mday > 3) ? 'th' : ($mday%10 == 1 ? "st" : ($mday%10 == 2 ? "nd" : ($mday%10 == 3 ? "rd" : "th"))))) },
  	'p',	sub { $hour > 11 ? "PM" : "AM" },
  	'r',	sub { sprintf("%02d:%02d:%02d %s", $hour % 12 || 12, $min, $sec, $hour > 11 ? 'PM' : 'AM') },
  	'R',	sub { sprintf("%02d:%02d", $hour, $min) },
  	'S',	sub { sprintf("%02d", $sec) },
  	't',	sub { "\t" },
  	'T',	sub { sprintf("%02d:%02d:%02d", $hour, $min, $sec) },
  	'U',	sub { wkyr(0, $wday, $yday) },
  	'v',	sub { sprintf("%2d-%s-%4d", $mday, $MoY[$mon], $year+1900) },
  	'w',	sub { $wday },
  	'W',	sub { wkyr(1, $wday, $yday) },
  	'y',	sub { sprintf("%02d",$year%100) },
  	'Y',	sub { $year + 1900 },
  	'x',	sub { sprintf("%02d/%02d/%02d", $mon + 1, $mday, $year%100) },
  	'X',	sub { sprintf("%02d:%02d:%02d", $hour, $min, $sec) },
  	'Z',	sub { &tz2zone(undef,undef,$isdst) }
  	# z sprintf("%+03d%02d", $offset / 3600, ($offset % 3600)/60);
      );
  
  
  }
  
  sub fracprintf {
      my($t,$s) = @_;
      my($p) = sprintf($t, $s-int($s));
      $p=~s/^0+//;
      $p;
  }
  
  sub asctime_n {
      my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst, $TZname) = @_;
      ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst, $TZname) = localtime($sec) unless defined $min;
      $year += 1900;
      $TZname .= ' ' 
  	if $TZname;
      sprintf("%s %s %2d %2d:%02d:%02d %s%4d",
  	  $DoW[$wday], $MoY[$mon], $mday, $hour, $min, $sec, $TZname, $year);
  }
  
  sub asctime
  {
      return asctime_n(@_)."\n";
  }
  
  # is this formula right?
  sub wkyr {
      my($wstart, $wday, $yday) = @_;
      $wday = ($wday + 7 - $wstart) % 7;
      return int(($yday - $wday + 13) / 7 - 1);
  }
  
  # ctime($time)
  
  sub ctime {
      my($time) = @_;
      asctime(localtime($time), &tz2zone(undef,$time));
  }
  
  sub ctime_n {
      my($time) = @_;
      asctime_n(localtime($time), &tz2zone(undef,$time));
  }
  
  # strftime($template, @time_struct)
  #
  # Does not support locales
  
  sub strftime {			
      local ($template, $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = @_;
  
      undef $@;
      $template =~ s/%([%aAbBcdDefFhHIjklmMnopQrRStTUvwWxXyYZ])/&{$Time::CTime::strftime_conversion{$1}}()/egs;
      die $@ if $@;
      return $template;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Time::CTime -- format times ala POSIX asctime
  
  =head1 SYNOPSIS
  
  	use Time::CTime
   	print ctime(time);
  	print asctime(localtime(time));
  	print strftime(template, localtime(time)); 
  
  =head2 strftime conversions
  
  	%%	PERCENT
  	%a	day of the week abbr
  	%A	day of the week
  	%b	month abbr
  	%B 	month
  	%c 	ctime format: Sat Nov 19 21:05:57 1994
  	%d 	DD
  	%D 	MM/DD/YY
  	%e 	numeric day of the month
  	%f 	floating point seconds (milliseconds): .314
  	%F 	floating point seconds (microseconds): .314159
  	%h 	month abbr
  	%H 	hour, 24 hour clock, leading 0's)
  	%I 	hour, 12 hour clock, leading 0's)
  	%j 	day of the year
  	%k 	hour
  	%l 	hour, 12 hour clock
  	%m 	month number, starting with 1, leading 0's
  	%M 	minute, leading 0's
  	%n 	NEWLINE
  	%o	ornate day of month -- "1st", "2nd", "25th", etc.
  	%p 	AM or PM 
  	%r 	time format: 09:05:57 PM
  	%R 	time format: 21:05
  	%S 	seconds, leading 0's
  	%t 	TAB
  	%T 	time format: 21:05:57
  	%U 	week number, Sunday as first day of week
  	%v	DD-Mon-Year
  	%w 	day of the week, numerically, Sunday == 0
  	%W 	week number, Monday as first day of week
  	%x 	date format: 11/19/94
  	%X 	time format: 21:05:57
  	%y	year (2 digits)
  	%Y	year (4 digits)
  	%Z 	timezone in ascii. eg: PST
  
  =head1 DESCRIPTION
  
  This module provides routines to format dates.  They correspond 
  to the libc routines.  &strftime() supports a pretty good set of
  conversions -- more than most C libraries.
   
  strftime supports a pretty good set of conversions.  
  
  The POSIX module has very similar functionality.  You should consider
  using it instead if you do not have allergic reactions to system 
  libraries.
  
  =head1 GENESIS
  
  Written by David Muir Sharnoff <muir@idiom.org>.
  
  The starting point for this package was a posting by 
  Paul Foley <paul@ascent.com> 
  
  =head1 LICENSE
  
  Copyright (C) 1996-2010 David Muir Sharnoff.  
  Copyright (C) 2011 Google, Inc.  
  License hereby
  granted for anyone to use, modify or redistribute this module at
  their own risk.  Please feed useful changes back to cpan@dave.sharnoff.org.
  
TIME_CTIME

$fatpacked{"Time/DaysInMonth.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TIME_DAYSINMONTH';
  package Time::DaysInMonth;
  
  use Carp;
  
  require 5.000;
  
  @ISA = qw(Exporter);
  @EXPORT = qw(days_in is_leap);
  @EXPORT_OK = qw(%mltable);
  
  use strict;
  
  use vars qw($VERSION %mltable);
  
  $VERSION = 99.1117;
  
  CONFIG:	{
  	%mltable = qw(
  		 1	31
  		 3	31
  		 4	30
  		 5	31
  		 6	30
  		 7	31
  		 8	31
  		 9	30
  		10	31
  		11	30
  		12	31);
  }
  
  sub days_in
  {
  	# Month is 1..12
  	my ($year, $month) = @_;
  	return $mltable{$month+0} unless $month == 2;
  	return 28 unless &is_leap($year);
  	return 29;
  }
  
  sub is_leap
  {
  	my ($year) = @_;
  	return 0 unless $year % 4 == 0;
  	return 1 unless $year % 100 == 0;
  	return 0 unless $year % 400 == 0;
  	return 1;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Time::DaysInMonth -- simply report the number of days in a month
  
  =head1 SYNOPSIS
  
  	use Time::DaysInMonth;
  	$days = days_in($year, $month_1_to_12);
  	$leapyear = is_leap($year);
  
  =head1 DESCRIPTION
  
  DaysInMonth is simply a package to report the number of days in
  a month.  That's all it does.  Really!
  
  =head1 AUTHOR
  
  David Muir Sharnoff <muir@idiom.org>
  
  =head1 BUGS
  
  This only deals with the "modern" calendar.  Look elsewhere for 
  historical time and date support.
  
  =head1 LICENSE
  
  Copyright (C) 1996-1999 David Muir Sharnoff.  License hereby
  granted for anyone to use, modify or redistribute this module at
  their own risk.  Please feed useful changes back to muir@idiom.org.
  
TIME_DAYSINMONTH

$fatpacked{"Time/JulianDay.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TIME_JULIANDAY';
  package Time::JulianDay;
  
  require 5.000;
  
  use Carp;
  use Time::Timezone;
  
  @ISA = qw(Exporter);
  @EXPORT = qw(julian_day inverse_julian_day day_of_week 
  	jd_secondsgm jd_secondslocal 
  	jd_timegm jd_timelocal 
  	gm_julian_day local_julian_day 
  	);
  @EXPORT_OK = qw($brit_jd);
  
  use strict;
  use integer;
  
  # constants
  use vars qw($brit_jd $jd_epoch $jd_epoch_remainder $VERSION);
  
  $VERSION = 2011.0505;
  
  # calculate the julian day, given $year, $month and $day
  sub julian_day
  {
      my($year, $month, $day) = @_;
      my($tmp);
  
      use Carp;
  #    confess() unless defined $day;
  
      $tmp = $day - 32075
        + 1461 * ( $year + 4800 - ( 14 - $month ) / 12 )/4
        + 367 * ( $month - 2 + ( ( 14 - $month ) / 12 ) * 12 ) / 12
        - 3 * ( ( $year + 4900 - ( 14 - $month ) / 12 ) / 100 ) / 4
        ;
  
      return($tmp);
  
  }
  
  sub gm_julian_day
  {
      my($secs) = @_;
      my($sec, $min, $hour, $mon, $year, $day, $month);
      ($sec, $min, $hour, $day, $mon, $year) = gmtime($secs);
      $month = $mon + 1;
      $year += 1900;
      return julian_day($year, $month, $day)
  }
  
  sub local_julian_day
  {
      my($secs) = @_;
      my($sec, $min, $hour, $mon, $year, $day, $month);
      ($sec, $min, $hour, $day, $mon, $year) = localtime($secs);
      $month = $mon + 1;
      $year += 1900;
      return julian_day($year, $month, $day)
  }
  
  sub day_of_week
  {
  	my ($jd) = @_;
          return (($jd + 1) % 7);       # calculate weekday (0=Sun,6=Sat)
  }
  
  
  # The following defines the first day that the Gregorian calendar was used
  # in the British Empire (Sep 14, 1752).  The previous day was Sep 2, 1752
  # by the Julian Calendar.  The year began at March 25th before this date.
  
  $brit_jd = 2361222;
  
  # Usage:  ($year,$month,$day) = &inverse_julian_day($julian_day)
  sub inverse_julian_day
  {
          my($jd) = @_;
          my($jdate_tmp);
          my($m,$d,$y);
  
          carp("warning: julian date $jd pre-dates British use of Gregorian calendar\n")
                  if ($jd < $brit_jd);
  
          $jdate_tmp = $jd - 1721119;
          $y = (4 * $jdate_tmp - 1)/146097;
          $jdate_tmp = 4 * $jdate_tmp - 1 - 146097 * $y;
          $d = $jdate_tmp/4;
          $jdate_tmp = (4 * $d + 3)/1461;
          $d = 4 * $d + 3 - 1461 * $jdate_tmp;
          $d = ($d + 4)/4;
          $m = (5 * $d - 3)/153;
          $d = 5 * $d - 3 - 153 * $m;
          $d = ($d + 5) / 5;
          $y = 100 * $y + $jdate_tmp;
          if($m < 10) {
                  $m += 3;
          } else {
                  $m -= 9;
                  ++$y;
          }
          return ($y, $m, $d);
  }
  
  {
  	my($sec, $min, $hour, $day, $mon, $year) = gmtime(0);
  	$year += 1900;
  	if ($year == 1970 && $mon == 0 && $day == 1) {
  		# standard unix time format
  		$jd_epoch = 2440588;
  	} else {
  		$jd_epoch = julian_day($year, $mon+1, $day);
  	}
  	$jd_epoch_remainder = $hour*3600 + $min*60 + $sec;
  }
  
  sub jd_secondsgm
  {
  	my($jd, $hr, $min, $sec) = @_;
  
  	my($r) =  (($jd - $jd_epoch) * 86400 
  		+ $hr * 3600 + $min * 60 
  		- $jd_epoch_remainder);
  
  	no integer;
  	return ($r + $sec);
  	use integer;
  }
  
  sub jd_secondslocal
  {
  	my($jd, $hr, $min, $sec) = @_;
  	my $jds = jd_secondsgm($jd, $hr, $min, $sec);
  	return $jds - tz_local_offset($jds);
  }
  
  # this uses a 0-11 month to correctly reverse localtime()
  sub jd_timelocal
  {
  	my ($sec,$min,$hours,$mday,$mon,$year) = @_;
  	$year += 1900 unless $year > 1000;
  	my $jd = julian_day($year, $mon+1, $mday);
  	my $jds = jd_secondsgm($jd, $hours, $min, $sec);
  	return $jds - tz_local_offset($jds);
  }
  
  # this uses a 0-11 month to correctly reverse gmtime()
  sub jd_timegm
  {
  	my ($sec,$min,$hours,$mday,$mon,$year) = @_;
  	$year += 1900 unless $year > 1000;
  	my $jd = julian_day($year, $mon+1, $mday);
  	return jd_secondsgm($jd, $hours, $min, $sec);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Time::JulianDay -- Julian calendar manipulations
  
  =head1 SYNOPSIS
  
  	use Time::JulianDay
  
  	$jd = julian_day($year, $month_1_to_12, $day)
  	$jd = local_julian_day($seconds_since_1970);
  	$jd = gm_julian_day($seconds_since_1970);
  	($year, $month_1_to_12, $day) = inverse_julian_day($jd)
  	$dow = day_of_week($jd) 
  
  	print (Sun,Mon,Tue,Wed,Thu,Fri,Sat)[$dow];
  
  	$seconds_since_jan_1_1970 = jd_secondslocal($jd, $hour, $min, $sec)
  	$seconds_since_jan_1_1970 = jd_secondsgm($jd, $hour, $min, $sec)
  	$seconds_since_jan_1_1970 = jd_timelocal($sec,$min,$hours,$mday,$month_0_to_11,$year)
  	$seconds_since_jan_1_1970 = jd_timegm($sec,$min,$hours,$mday,$month_0_to_11,$year)
  
  =head1 DESCRIPTION
  
  JulianDay is a package that manipulates dates as number of days since 
  some time a long time ago.  It's easy to add and subtract time
  using julian days...  
  
  The day_of_week returned by day_of_week() is 0 for Sunday, and 6 for
  Saturday and everything else is in between.
  
  =head1 ERRATA
  
  Time::JulianDay is not a correct implementation.  There are two
  problems.  The first problem is that Time::JulianDay only works
  with integers.  Julian Day can be fractional to represent time
  within a day.  If you call inverse_julian_day() with a non-integer
  time, it will often give you an incorrect result.
  
  The second problem is that Julian Days start at noon rather than
  midnight.  The julian_day() function returns results that are too
  large by 0.5.
  
  What to do about these problems is currently open for debate.  I'm
  tempted to leave the current functions alone and add a second set
  with more accurate behavior.
  
  There is another implementation in Astro::Time that may be more accurate.
  
  =head1 GENESIS
  
  Written by David Muir Sharnoff <cpan@dave.sharnoff.org> with help from
  previous work by 
  Kurt Jaeger aka PI <zrzr0111@helpdesk.rus.uni-stuttgart.de>
   	based on postings from: Ian Miller <ian_m@cix.compulink.co.uk>;
  Gary Puckering <garyp%cognos.uucp@uunet.uu.net>
  	based on Collected Algorithms of the ACM ?;
  and the unknown-to-me author of Time::Local.
  
  =head1 LICENSE
  
  Copyright (C) 1996-1999 David Muir Sharnoff.  License hereby
  granted for anyone to use, modify or redistribute this module at
  their own risk.  Please feed useful changes back to cpan@dave.sharnoff.org.
  
TIME_JULIANDAY

$fatpacked{"Time/ParseDate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TIME_PARSEDATE';
  package Time::ParseDate;
  
  require 5.000;
  
  use Carp;
  use Time::Timezone;
  use Time::JulianDay;
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(parsedate);
  @EXPORT_OK = qw(pd_raw %mtable %umult %wdays);
  
  use strict;
  #use diagnostics;
  
  # constants
  use vars qw(%mtable %umult %wdays $VERSION);
  
  $VERSION = 2015.1030;
  
  # globals
  use vars qw($debug); 
  
  # dynamically-scoped
  use vars qw($parse);
  
  my %mtable;
  my %umult;
  my %wdays;
  my $y2k;
  
  CONFIG:	{
  
  	%mtable = qw(
  		Jan 1	Jan. 1	January 1
  		Feb 2	Feb. 2	February 2
  		Mar 3	Mar. 3	March 3
  		Apr 4	Apr. 4	April 4
  		May 5 
  		Jun 6	Jun. 6	June 6 
  		Jul 7	Jul. 7	July 7 
  		Aug 8	Aug. 8	August 8 
  		Sep 9	Sep. 9	September 9 Sept 9
  		Oct 10	Oct. 10	October 10 
  		Nov 11	Nov. 11	November 11 
  		Dec 12	Dec. 12	December 12 );
  	%umult = qw(
  		sec 1 second 1
  		min 60 minute 60
  		hour 3600
  		day 86400
  		week 604800 
  		fortnight 1209600);
  	%wdays = qw(
  		sun 0 sunday 0
  		mon 1 monday 1
  		tue 2 tuesday 2
  		wed 3 wednesday 3
  		thu 4 thursday 4
  		fri 5 friday 5
  		sat 6 saturday 6
  		);
  
  	$y2k = 946684800; # turn of the century
  }
  
  my $break = qr{(?:\s+|\Z|\b(?![-:.,/]\d))};
  
  sub parsedate
  {
  	my ($t, %options) = @_;
  
  	my ($y, $m, $d);	# year, month - 1..12, day
  	my ($H, $M, $S);	# hour, minute, second
  	my $tz;		 	# timezone
  	my $tzo;		# timezone offset
  	my ($rd, $rs);		# relative days, relative seconds
  
  	my $rel; 		# time&|date is relative
  
  	my $isspec;
  	my $now = defined($options{NOW}) ? $options{NOW} : time;
  	my $passes = 0;
  	my $uk = defined($options{UK}) ? $options{UK} : 0;
  
  	local $parse = '';  # will be dynamically scoped.
  
  	if ($t =~ s#^   ([ \d]\d) 
  			/ (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)
  			/ (\d\d\d\d)
  			: (\d\d)
  			: (\d\d)
  			: (\d\d)
  			(?:
  			 [ ]
  			 ([-+] \d\d\d\d)
  			  (?: \("?(?:(?:[A-Z]{1,4}[TCW56])|IDLE)\))?
  			 )?
  			 $break
  			##xi) { #"emacs
  		# [ \d]/Mon/yyyy:hh:mm:ss [-+]\d\d\d\d
  		# This is the format for www server logging.
  
  		($d, $m, $y, $H, $M, $S, $tzo) = ($1, $mtable{"\u\L$2"}, $3, $4, $5, $6, $7 ? &mkoff($7) : ($tzo || undef));
  		$parse .= " ".__LINE__ if $debug;
  	} elsif ($t =~ s#^(\d\d)/(\d\d)/(\d\d)\.(\d\d)\:(\d\d)($break)##) {
  		# yy/mm/dd.hh:mm
  		# I support this format because it's used by wbak/rbak
  		# on Apollo Domain OS.  Silly, but historical.
  
  		($y, $m, $d, $H, $M, $S) = ($1, $2, $3, $4, $5, 0);
  		$parse .= " ".__LINE__ if $debug;
  	} else {
  		while(1) {
  			if (! defined $m and ! defined $rd and ! defined $y
  				and ! ($passes == 0 and $options{'TIMEFIRST'}))
  			{
  				# no month defined.
  				if (&parse_date_only(\$t, \$y, \$m, \$d, $uk)) {
  					$parse .= " ".__LINE__ if $debug;
  					next;
  				}
  			}
  			if (! defined $H and ! defined $rs) {
  				if (&parse_time_only(\$t, \$H, \$M, \$S, 
  					\$tz, %options)) 
  				{
  					$parse .= " ".__LINE__ if $debug;
  					next;
  				}
  			}
  			next if $passes == 0 and $options{'TIMEFIRST'};
  			if (! defined $y) {
  				if (&parse_year_only(\$t, \$y, $now, %options)) {
  					$parse .= " ".__LINE__ if $debug;
  					next;
  				}
  			}
  			if (! defined $tz and ! defined $tzo and ! defined $rs 
  				and (defined $m or defined $H)) 
  			{
  				if (&parse_tz_only(\$t, \$tz, \$tzo)) {
  					$parse .= " ".__LINE__ if $debug;
  					next;
  				}
  			}
  			if (! defined $H and ! defined $rs) {
  				if (&parse_time_offset(\$t, \$rs, %options)) {
  					$rel = 1;
  					$parse .= " ".__LINE__ if $debug;
  					next;
  				}
  			}
  			if (! defined $m and ! defined $rd and ! defined $y) {
  				if (&parse_date_offset(\$t, $now, \$y, 
  					\$m, \$d, \$rd, \$rs, %options)) 
  				{
  					$rel = 1;
  					$parse .= " ".__LINE__ if $debug;
  					next;
  				}
  			}
  			if (defined $M or defined $rd) {
  				if ($t =~ s/^\s*(?:at|\@|\+)($break)//x) {
  					$rel = 1;
  					$parse .= " ".__LINE__ if $debug;
  					next;
  				}
  			}
  			last;
  		} continue {
  			$passes++;
  			&debug_display($tz, $tzo, $H, $M, $S, $m, $d, $y, $rs, $rd, $rel, $passes, $parse, $t) if $debug;
  
  		}
  
  		if ($passes == 0) {
  			print "nothing matched\n" if $debug;
  			return (undef, "no match on time/date") 
  				if wantarray();
  			return undef;
  		}
  	}
  
  	&debug_display($tz, $tzo, $H, $M, $S, $m, $d, $y, $rs, $rd, $rel, $passes, $parse, $t) if $debug;
  
  	$t =~ s/^\s+//;
  
  	if ($t ne '') {
  		# we didn't manage to eat the string
  		print "NOT WHOLE\n" if $debug;
  		if ($options{WHOLE}) {
  			return (undef, "characters left over after parse")
  				if wantarray();
  			return undef 
  		}
  	}
  
  	# define a date if there isn't one already
  
  	if (! defined $y and ! defined $m and ! defined $rd) {
  		print "no date defined, trying to find one." if $debug;
  		if (defined $rs or defined $H) {
  			# we do have a time.
  			if ($options{DATE_REQUIRED}) {
  				return (undef, "no date specified")
  					if wantarray();
  				return undef;
  			}
  			if (defined $rs) {
  				print "simple offset: $rs\n" if $debug;
  				my $rv = $now + $rs;
  				return ($rv, $t) if wantarray();
  				return $rv;
  			}
  			$rd = 0;
  		} else {
  			print "no time either!\n" if $debug;
  			return (undef, "no time specified")
  				if wantarray();
  			return undef;
  		}
  	}
  
  	if ($options{TIME_REQUIRED} && ! defined($rs) 
  		&& ! defined($H) && ! defined($rd))
  	{
  		return (undef, "no time found")
  			if wantarray();
  		return undef;
  	}
  
  	my $secs;
  	my $jd;
  
  	if (defined $rd) {
  		if (defined $rs || ! (defined($H) || defined($M) || defined($S))) {
  			print "fully relative\n" if $debug;
  			my ($j, $in, $it);
  			my $definedrs = defined($rs) ? $rs : 0;
  			my ($isdst_now, $isdst_then);
  			my $r = $now + $rd * 86400 + $definedrs;
  			#
  			# It's possible that there was a timezone shift 
  			# during the time specified.  If so, keep the
  			# hours the "same".
  			#
  			$isdst_now = (localtime($r))[8];
  			$isdst_then = (localtime($now))[8];
  			if (($isdst_now == $isdst_then) || $options{GMT})
  			{
  				return ($r, $t) if wantarray();
  				return $r 
  			}
  				
  			print "localtime changed DST during time period!\n" if $debug;
  		}
  
  		print "relative date\n" if $debug;
  		$jd = $options{GMT}
  			? gm_julian_day($now)
  			: local_julian_day($now);
  		print "jd($now) = $jd\n" if $debug;
  		$jd += $rd;
  	} else {
  		unless (defined $y) {
  			if ($options{PREFER_PAST}) {
  				my ($day, $mon011);
  				($day, $mon011, $y) = (&righttime($now))[3,4,5];
  
  				print "calc year -past $day-$d $mon011-$m $y\n" if $debug;
  				$y -= 1 if ($mon011+1 < $m) || 
  					(($mon011+1 == $m) && ($day < $d));
  			} elsif ($options{PREFER_FUTURE}) {
  				print "calc year -future\n" if $debug;
  				my ($day, $mon011);
  				($day, $mon011, $y) = (&righttime($now))[3,4,5];
  				$y += 1 if ($mon011 >= $m) || 
  					(($mon011+1 == $m) && ($day > $d));
  			} else {
  				print "calc year -this\n" if $debug;
  				$y = (localtime($now))[5];
  			}
  			$y += 1900;
  		}
  
  		$y = expand_two_digit_year($y, $now, %options)
  			if $y < 100;
  
  		if ($options{VALIDATE}) {
  			require Time::DaysInMonth;
  			my $dim = Time::DaysInMonth::days_in($y, $m);
  			if ($y < 1000 or $m < 1 or $d < 1 
  				or $y > 9999 or $m > 12 or $d > $dim)
  			{
  				return (undef, "illegal YMD: $y, $m, $d")
  					if wantarray();
  				return undef;
  			}
  		}
  		$jd = julian_day($y, $m, $d);
  		print "jd($y, $m, $d) = $jd\n" if $debug;
  	}
  
  	# put time into HMS
  
  	if (! defined($H)) {
  		if (defined($rd) || defined($rs)) {
  			($S, $M, $H) = &righttime($now, %options);
  			print "HMS set to $H $M $S\n" if $debug;
  		} 
  	}
  
  	my $carry;
  
  	print "before ", (defined($rs) ? "$rs" : ""),
  		    " $jd $H $M $S\n" 
  		if $debug;
  	#
  	# add in relative seconds.  Do it this way because we want to
  	# preserve the localtime across DST changes.
  	#
  
  	$S = 0 unless $S; # -w
  	$M = 0 unless $M; # -w
  	$H = 0 unless $H; # -w
  
  	if ($options{VALIDATE} and
  		($S < 0 or $M < 0 or $H < 0 or $S > 59 or $M > 59 or $H > 23)) 
  	{
  		return (undef, "illegal HMS: $H, $M, $S") if wantarray();
  		return undef;
  	}
  
  	$S += $rs if defined $rs;
  	$carry = int($S / 60) - ($S < 0 && $S % 60 && 1);
  	$S -= $carry * 60;
  	$M += $carry;
  	$carry = int($M / 60) - ($M < 0 && $M % 60 && 1);
  	$M %= 60;
  	$H += $carry;
  	$carry = int($H / 24) - ($H < 0 && $H % 24 && 1);
  	$H %= 24;
  	$jd += $carry;
  
  	print "after rs  $jd $H $M $S\n" if $debug;
  
  	$secs = jd_secondsgm($jd, $H, $M, $S);
  	print "jd_secondsgm($jd, $H, $M, $S) = $secs\n" if $debug;
  
  	# 
  	# If we see something link 3pm CST then and we want to end
  	# up with a GMT seconds, then we convert the 3pm to GMT and
  	# subtract in the offset for CST.  We subtract because we
  	# are converting from CST to GMT.
  	#
  	my $tzadj;
  	if ($tz) {
  		$tzadj = tz_offset($tz, $secs);
  		if (defined $tzadj) {
  			print "adjusting secs for $tz: $tzadj\n" if $debug;
  			$tzadj = tz_offset($tz, $secs-$tzadj);
  			$secs -= $tzadj;
  		} else {
  			print "unknown timezone: $tz\n" if $debug;
  			undef $secs;
  			undef $t;
  		}
  	} elsif (defined $tzo) {
  		print "adjusting time for offset: $tzo\n" if $debug;
  		$secs -= $tzo;
  	} else {
  		unless ($options{GMT}) {
  			if ($options{ZONE}) {
  				$tzadj = tz_offset($options{ZONE}, $secs) || 0;
  				$tzadj = tz_offset($options{ZONE}, $secs-$tzadj);
  				unless (defined($tzadj)) {
  					return (undef, "could not convert '$options{ZONE}' to time offset")
  						if wantarray();
  					return undef;
  				}
  				print "adjusting secs for $options{ZONE}: $tzadj\n" if $debug;
  				$secs -= $tzadj;
  			} else {
  				$tzadj = tz_local_offset($secs);
  				print "adjusting secs for local offset: $tzadj\n" if $debug;
  				# 
  				# Just in case we are very close to a time
  				# change...
  				#
  				$tzadj = tz_local_offset($secs-$tzadj);
  				$secs -= $tzadj;
  			}
  		}
  	}
  
  	print "returning $secs.\n" if $debug;
  
  	return ($secs, $t) if wantarray();
  	return $secs;
  }
  
  
  sub mkoff
  {
  	my($offset) = @_;
  
  	if (defined $offset and $offset =~ s#^([-+])(\d\d):?(\d\d)$##) {
  		return ($1 eq '+' ? 
  			  3600 * $2  + 60 * $3
  			: -3600 * $2 + -60 * $3 );
  	}
  	return undef;
  }
  
  sub parse_tz_only
  {
  	my($tr, $tz, $tzo) = @_;
  
  	$$tr =~ s#^\s+##;
  	my $o;
  
  	if ($$tr =~ s#^
  			([-+]\d\d:?\d\d)
  			\s+
  			\(
  				"?
  				(?:
  					(?:
  						[A-Z]{1,4}[TCW56]
  					)
  					|
  					IDLE
  				)
  			\)
  			$break
  			##x) { #"emacs
  		$$tzo = &mkoff($1);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^GMT\s*([-+]\d{1,2})($break)##x) {
  		$o = $1;
  		if ($o < 24 and $o !~ /^0/) {
  			# probably hours.
  			printf "adjusted at %d. ($o 00)\n", __LINE__ if $debug;
  			$o = "${o}00";
  		}
  		$o =~ s/\b(\d\d\d)/0$1/;
  		$$tzo = &mkoff($o);
  		printf "matched at %d. ($$tzo, $o)\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^(?:GMT\s*)?([-+]\d\d:?\d\d)($break)##x) {
  		$o = $1;
  		$$tzo = &mkoff($o);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^"?((?:[A-Z]{1,4}[TCW56])|IDLE)$break##x) { #"
  		$$tz = $1;
  		$$tz .= " DST" 
  			if $$tz eq 'MET' && $$tr =~ s#^DST$break##x;
  		printf "matched at %d: '$$tz'.\n", __LINE__ if $debug;
  		return 1;
  	}
  	return 0;
  }
  
  sub parse_date_only
  {
  	my ($tr, $yr, $mr, $dr, $uk) = @_;
  
  	$$tr =~ s#^\s+##;
  
  	if ($$tr =~ s#^(\d\d\d\d)([-./])(\d\d?)\2(\d\d?)(T|$break)##) {
  		# yyyy/mm/dd
  
  		($$yr, $$mr, $$dr) = ($1, $3, $4);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^(\d\d?)([-./])(\d\d?)\2(\d\d\d\d?)($break)##) {
  		# mm/dd/yyyy - is this safe?  No.
  		# -- or dd/mm/yyyy! If $1>12, then it's unambiguous.
  		# Otherwise check option UK for UK style date.
  		if ($uk || $1>12) {
  		  ($$yr, $$mr, $$dr) = ($4, $3, $1);
  		} else {
  		  ($$yr, $$mr, $$dr) = ($4, $1, $3);
  		}
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^(\d\d\d\d)/(\d\d?)$break##x) {
  		# yyyy/mm
  
  		($$yr, $$mr, $$dr) = ($1, $2, 1);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^(?xi)
  			(?:
  				(?:Mon|Monday|Tue|Tuesday|Wed|Wednesday|
  					Thu|Thursday|Fri|Friday|
  					Sat|Saturday|Sun|Sunday),?
  				\s+
  			)?
  			(\d\d?)
  			(\s+ | - | \. | /)
  			(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\.?
  			(?:
  				\2
  				(\d\d (?:\d\d)? )
  			)?
  			$break
  			##) {
  		# [Dow,] dd Mon [yy[yy]]
  		($$yr, $$mr, $$dr) = ($4, $mtable{"\u\L$3"}, $1);
  
  		printf "%d: %s - %s - %s\n", __LINE__, $1, $2, $3 if $debug;
  		print "y undef\n" if ($debug && ! defined($$yr));
  		return 1;
  	} elsif ($$tr =~ s#^(?xi)
  			(?:
  				(?:Mon|Monday|Tue|Tuesday|Wed|Wednesday|
  					Thu|Thursday|Fri|Friday|
  					Sat|Saturday|Sun|Sunday),?
  				\s+
  			)?
  			(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\.?
  			((\s)+ | - | \. | /)
  				
  			(\d\d?)
  			,?
  			(?:
  				(?: \2|\3+)
  				(\d\d (?: \d\d)?)
  			)?
  			$break
  			##) {
  		# [Dow,] Mon dd [yyyy]
  		# [Dow,] Mon d, [yy]
  		($$yr, $$mr, $$dr) = ($5, $mtable{"\u\L$1"}, $4);
  		printf "%d: %s - %s - %s\n", __LINE__, $1, $2, $4 if $debug;
  		print "y undef\n" if ($debug && ! defined($$yr));
  		return 1;
  	} elsif ($$tr =~ s#^(?xi)
  			(January|Jan\.?|February|Feb\.?|March|Mar\.?|April|Apr\.?|May|
  			    June|Jun\.?|July|Jul\.?|August|Aug\.?|September|Sep\.?|
  			    October|Oct\.?|November|Nov\.?|December|Dec\.?)
  			\s+
  			(\d+)
  			(?:st|nd|rd|th)?
  			\,?
  			(?: 
  				\s+
  				(?:
  					(\d\d\d\d)
  					|(?:\' (\d\d))
  				)
  			)?
  			$break
  			##) {
  		# Month day{st,nd,rd,th}, 'yy
  		# Month day{st,nd,rd,th}, year
  		# Month day, year
  		# Mon. day, year
  		($$yr, $$mr, $$dr) = ($3 || $4, $mtable{"\u\L$1"}, $2);
  		printf "%d: %s - %s - %s - %s\n", __LINE__, $1, $2, $3, $4 if $debug;
  		print "y undef\n" if ($debug && ! defined($$yr));
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^(\d\d?)([-/.])(\d\d?)\2(\d\d?)($break)##x) {
  		if ($1 > 31 || (!$uk && $1 > 12 && $4 < 32)) {
  			# yy/mm/dd
  			($$yr, $$mr, $$dr) = ($1, $3, $4);
  		} elsif ($1 > 12 || $uk) {
  			# dd/mm/yy
  			($$yr, $$mr, $$dr) = ($4, $3, $1);
  		} else {
  			# mm/dd/yy
  			($$yr, $$mr, $$dr) = ($4, $1, $3);
  		}
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^(\d\d?)/(\d\d?)($break)##x) {
  		if ($1 > 31 || (!$uk && $1 > 12)) {
  			# yy/mm
  			($$yr, $$mr, $$dr) = ($1, $2, 1);
  		} elsif ($2 > 31 || ($uk && $2 > 12)) {
  			# mm/yy
  			($$yr, $$mr, $$dr) = ($2, $1, 1);
  		} elsif ($1 > 12 || $uk) {
  			# dd/mm
  			($$mr, $$dr) = ($2, $1);
  		} else {
  			# mm/dd
  			($$mr, $$dr) = ($1, $2);
  		}
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^(\d\d)(\d\d)(\d\d)($break)##x) {
  		if ($1 > 31 || (!$uk && $1 > 12)) {
  			# YYMMDD
  			($$yr, $$mr, $$dr) = ($1, $2, $3);
  		} elsif ($1 > 12 || $uk) {
  			# DDMMYY
  			($$yr, $$mr, $$dr) = ($3, $2, $1);
  		} else {
  			# MMDDYY
  			($$yr, $$mr, $$dr) = ($3, $1, $2);
  		}
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^(?xi)
  			(\d{1,2})
  			(\s+ | - | \. | /)
  			(January|Jan\.?|February|Feb\.?|March|Mar\.?|April|Apr\.?|May|
  			    June|Jun\.?|July|Jul\.?|August|Aug\.?|September|Sep\.?|
  			    October|Oct\.?|November|Nov\.?|December|Dec\.?)
  			(?:
  				\2
  				(
  					\d\d
  					(?:\d\d)?
  				)
  			)
  			$break
  			##) {
  		# dd Month [yr]
  		($$yr, $$mr, $$dr) = ($4, $mtable{"\u\L$3"}, $1);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^(?xi)
  			(\d+)
  			(?:st|nd|rd|th)?
  			\s+
  			(January|Jan\.?|February|Feb\.?|March|Mar\.?|April|Apr\.?|May|
  			    June|Jun\.?|July|Jul\.?|August|Aug\.?|September|Sep\.?|
  			    October|Oct\.?|November|Nov\.?|December|Dec\.?)
  			(?: 
  				\,?
  				\s+
  				(\d\d\d\d)
  			)?
  			$break
  			##) {
  		# day{st,nd,rd,th}, Month year
  		($$yr, $$mr, $$dr) = ($3, $mtable{"\u\L$2"}, $1);
  		printf "%d: %s - %s - %s - %s\n", __LINE__, $1, $2, $3, $4 if $debug;
  		print "y undef\n" if ($debug && ! defined($$yr));
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	}
  	return 0;
  }
  
  sub parse_time_only
  {
  	my ($tr, $hr, $mr, $sr, $tzr, %options) = @_;
  
  	$$tr =~ s#^\s+##;
  
  	if ($$tr =~ s!^(?x)
  			(?:
  				(?:
  					([012]\d)		(?# $1)
  					(?:
  						([0-5]\d) 	(?# $2)
  						(?:
  						    ([0-5]\d)	(?# $3)
  						)?
  					)
  					\s*
  					([apAP][mM])?  		(?# $4)
  				) | (?:
  					(\d{1,2}) 		(?# $5)
  					(?:
  						\:
  						(\d\d)		(?# $6)
  						(?:
  							\:
  							(\d\d)	(?# $7)
  								(
  									(?# don't barf on database sub-second timings)
  									[:.,]
  									\d+
  								)?	(?# $8)
  						)?
  					)
  					\s*
  					([apAP][mM])?		(?# $9)
  				) | (?:
  					(\d{1,2})		(?# $10)
  					([apAP][mM])		(?# ${11})
  				)
  			)
  			(?:
  				\s+
  				"?
  				(				(?# ${12})
  					(?: [A-Z]{1,4}[TCW56] )
  					|
  					IDLE
  				)	
  			)?
  			$break
  			!!) { #"emacs
  		# HH[[:]MM[:SS]]meridian [zone] 
  		my $ampm;
  		$$hr = $1 || $5 || $10 || 0; # 10 is undef, but 5 is defined..
  		$$mr = $2 || $6 || 0;
  		$$sr = $3 || $7 || 0;
  		if (defined($8) && exists($options{SUBSECOND}) && $options{SUBSECOND}) {
  			my($frac) = $8;
  			substr($frac,0,1) = '.';
  			$$sr += $frac;
  		}
  		print "S = $$sr\n" if $debug;
  		$ampm = $4 || $9 || $11 || '';
  		$$tzr = $12;
  		$$hr += 12 if $ampm and "\U$ampm" eq "PM" && $$hr != 12;
  		$$hr = 0 if $$hr == 12 && "\U$ampm" eq "AM";
  		printf "matched at %d, rem = %s.\n", __LINE__, $$tr if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^noon$break##ix) {
  		# noon
  		($$hr, $$mr, $$sr) = (12, 0, 0);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^midnight$break##ix) {
  		# midnight
  		($$hr, $$mr, $$sr) = (0, 0, 0);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	}
  	return 0;
  }
  
  sub parse_time_offset
  {
  	my ($tr, $rsr, %options) = @_;
  
  	$$tr =~ s/^\s+//;
  
  	return 0 if $options{NO_RELATIVE};
  
  	if ($$tr =~ s{^(?xi)					
  			(?:
  				(-)				(?# 1)
  				|
  				[+]
  			)?
  			\s*
  			(?:
  				(\d+(?:\.\d+)?) 		(?# 2)
  				| 		
  				(?:(\d+)\s+(\d+)/(\d+))		(?# 3 4/5)
  			)
  			\s*
  			(sec|second|min|minute|hour)s?		(?# 6)
  			(
  				\s+
  				ago				(?# 7)
  			)?
  			$break
  			}{}) {
  		# count units
  		$$rsr = 0 unless defined $$rsr;
  		return 0 if defined($5) && $5 == 0;
  		my $num = defined($2)
  			? $2
  			: $3 + $4/$5;
  		$num = -$num if $1;
  		$$rsr += $umult{"\L$6"} * $num;
  
  		$$rsr = -$$rsr if $7 ||
  			$$tr =~ /\b(day|mon|month|year)s?\s*ago\b/;
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} 
  	return 0;
  }
  
  #
  # What to you do with a date that has a two-digit year?
  # There's not much that can be done except make a guess.
  #
  # Some example situations to handle:
  #
  #	now		year 
  #
  #	1999		01
  #	1999		71
  #	2010		71
  #	2110		09
  #
  
  sub expand_two_digit_year
  {
  	my ($yr, $now, %options) = @_;
  
  	return $yr if $yr > 100;
  
  	my ($y) = (&righttime($now, %options))[5];
  	$y += 1900;
  	my $century = int($y / 100) * 100;
  	my $within = $y % 100;
  
  	my $r = $yr + $century;
  
  	if ($options{PREFER_PAST}) {
  		if ($yr > $within) {
  			$r = $yr + $century - 100;
  		}
  	} elsif ($options{PREFER_FUTURE}) {
  		# being strict here would be silly
  		if ($yr < $within-20) {
  			# it's 2019 and the date is '08'
  			$r = $yr + $century + 100;
  		}
  	} elsif ($options{UNAMBIGUOUS}) {
  		# we really shouldn't guess
  		return undef;
  	} else {
  		# prefer the current century in most cases
  
  		if ($within > 80 && $within - $yr > 60) {
  			$r = $yr + $century + 100;
  		}
  
  		if ($within < 30 && $yr - $within > 59) {
  			$r = $yr + $century - 100;
  		}
  	}
  	print "two digit year '$yr' expanded into $r\n" if $debug;
  	return $r;
  }
  
  
  sub calc 
  {
  	my ($rsr, $yr, $mr, $dr, $rdr, $now, $units, $count, %options) = @_;
  
  	confess unless $units;
  	$units = "\L$units";
  	print "calc based on $units\n" if $debug;
  
  	if ($units eq 'day') {
  		$$rdr = $count;
  	} elsif ($units eq 'week') {
  		$$rdr = $count * 7;
  	} elsif ($umult{$units}) {
  		$$rsr = $count * $umult{$units};
  	} elsif ($units eq 'mon' || $units eq 'month') {
  		($$yr, $$mr, $$dr) = &monthoff($now, $count, %options);
  		$$rsr = 0 unless $$rsr;
  	} elsif ($units eq 'year') {
  		($$yr, $$mr, $$dr) = &monthoff($now, $count * 12, %options);
  		$$rsr = 0 unless $$rsr;
  	} else {
  		carp "interal error";
  	}
  	print "calced rsr $$rsr rdr $$rdr, yr $$yr mr $$mr dr $$dr.\n" if $debug;
  }
  
  sub monthoff
  {
  	my ($now, $months, %options) = @_;
  
  	# months are 0..11
  	my ($d, $m11, $y) = (&righttime($now, %options)) [ 3,4,5 ] ;
  
  	$y += 1900;
  
  	print "m11 = $m11 + $months, y = $y\n" if $debug;
  
  	$m11 += $months;
  
  	print "m11 = $m11, y = $y\n" if $debug;
  	if ($m11 > 11 || $m11 < 0) {
  		$y -= 1 if $m11 < 0 && ($m11 % 12 != 0);
  		$y += int($m11/12);
  
  		# this is required to work around a bug in perl 5.003
  		no integer;
  		$m11 %= 12;
  	}
  	print "m11 = $m11, y = $y\n" if $debug;
  
  	# 
  	# What is "1 month from January 31st?"  
  	# I think the answer is February 28th most years.
  	#
  	# Similarly, what is one year from February 29th, 1980?
  	# I think it's February 28th, 1981.
  	#
  	# If you disagree, change the following code.
  	#
  	if ($d > 30 or ($d > 28 && $m11 == 1)) {
  		require Time::DaysInMonth;
  		my $dim = Time::DaysInMonth::days_in($y, $m11+1);
  		print "dim($y,$m11+1)= $dim\n" if $debug;
  		$d = $dim if $d > $dim;
  	}
  	return ($y, $m11+1, $d);
  }
  
  sub righttime
  {
  	my ($time, %options) = @_;
  	if ($options{GMT}) {
  		return gmtime($time);
  	} else {
  		return localtime($time);
  	}
  }
  
  sub parse_year_only
  {
  	my ($tr, $yr, $now, %options) = @_;
  
  	$$tr =~ s#^\s+##;
  
  	if ($$tr =~ s#^(\d\d\d\d)$break##) {
  		$$yr = $1;
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#\'(\d\d)$break##) {
  		$$yr = expand_two_digit_year($1, $now, %options);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	}
  	return 0;
  }
  
  sub parse_date_offset
  {
  	my ($tr, $now, $yr, $mr, $dr, $rdr, $rsr, %options) = @_;
  
  	return 0 if $options{NO_RELATIVE};
  
  	# now - current seconds_since_epoch
  	# yr - year return
  	# mr - month return
  	# dr - day return
  	# rdr - relative day return
  	# rsr - relative second return
  
  	my $j;
  	my $wday = (&righttime($now, %options))[6];
  
  	$$tr =~ s#^\s+##;
  
  	if ($$tr =~ s#^(?xi)
  			\s*
  			(\d+)
  			\s*
  			(day|week|month|year)s?
  			(
  				\s+
  				ago
  			)?
  			$break
  			##) {
  		my $amt = $1 + 0;
  		my $units = $2;
  		$amt = -$amt if $3 ||
  			$$tr =~ m#\b(sec|second|min|minute|hour)s?\s*ago\b#;
  		&calc($rsr, $yr, $mr, $dr, $rdr, $now, $units, 
  			$amt, %options);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^(?xi)
  			(?:
  				(?:
  					now
  					\s+
  				)?
  				(\+ | \-)
  				\s*
  			)?
  			(\d+)
  			\s*
  			(day|week|month|year)s?
  			$break
  			##) {
  		my $one = $1 || '';
  		my $two = $2 || '';
  		my $amt = "$one$two"+0;
  		&calc($rsr, $yr, $mr, $dr, $rdr, $now, $3, 
  			$amt, %options);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^(?xi)
  			(Mon|Tue|Wed|Thu|Fri|Sat|Sun|Monday|Tuesday
  				|Wednesday|Thursday|Friday|Saturday|Sunday)
  			\s+
  			after
  			\s+
  			next
  			$break
  			##) {
  		# Dow "after next"
  		$$rdr = $wdays{"\L$1"} - $wday + ( $wdays{"\L$1"} > $wday ? 7 : 14);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^(?xi)
  			(Mon|Tue|Wed|Thu|Fri|Sat|Sun|Monday|Tuesday
  				|Wednesday|Thursday|Friday|Saturday|Sunday)
  			\s+
  			before
  			\s+
  			last
  			$break
  			##) {
  		# Dow "before last"
  		$$rdr = $wdays{"\L$1"} - $wday - ( $wdays{"\L$1"} < $wday ? 7 : 14);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^(?xi)
  			next\s+
  			(Mon|Tue|Wed|Thu|Fri|Sat|Sun|Monday|Tuesday
  				|Wednesday|Thursday|Friday|Saturday|Sunday)
  			$break
  			##) {
  		# "next" Dow
  		$$rdr = $wdays{"\L$1"} - $wday 
  				+ ( $wdays{"\L$1"} > $wday ? 0 : 7);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^(?xi)
  			last\s+
  			(Mon|Tue|Wed|Thu|Fri|Sat|Sun|Monday|Tuesday
  				|Wednesday|Thursday|Friday|Saturday|Sunday)
  			$break##) {
  		# "last" Dow
  		printf "c %d - %d + ( %d < %d ? 0 : -7 \n", $wdays{"\L$1"},  $wday,  $wdays{"\L$1"}, $wday if $debug;
  		$$rdr = $wdays{"\L$1"} - $wday + ( $wdays{"\L$1"} < $wday ? 0 : -7);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($options{PREFER_PAST} and $$tr =~ s#^(?xi)
  			(Mon|Tue|Wed|Thu|Fri|Sat|Sun|Monday|Tuesday
  				|Wednesday|Thursday|Friday|Saturday|Sunday)
  			$break##) {
  		# Dow
  		printf "c %d - %d + ( %d < %d ? 0 : -7 \n", $wdays{"\L$1"},  $wday,  $wdays{"\L$1"}, $wday if $debug;
  		$$rdr = $wdays{"\L$1"} - $wday + ( $wdays{"\L$1"} < $wday ? 0 : -7);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($options{PREFER_FUTURE} and $$tr =~ s#^(?xi)
  			(Mon|Tue|Wed|Thu|Fri|Sat|Sun|Monday|Tuesday
  				|Wednesday|Thursday|Friday|Saturday|Sunday)
  			$break
  			##) {
  		# Dow
  		$$rdr = $wdays{"\L$1"} - $wday 
  				+ ( $wdays{"\L$1"} > $wday ? 0 : 7);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^today$break##xi) {
  		# today
  		$$rdr = 0;
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^tomorrow$break##xi) {
  		$$rdr = 1;
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^yesterday$break##xi) {
  		$$rdr = -1;
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^last\s+(week|month|year)$break##xi) {
  		&calc($rsr, $yr, $mr, $dr, $rdr, $now, $1, -1, %options);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^next\s+(week|month|year)$break##xi) {
  		&calc($rsr, $yr, $mr, $dr, $rdr, $now, $1, 1, %options);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^now $break##x) {
  		$$rdr = 0;
  		return 1;
  	}
  	return 0;
  }
  
  sub debug_display
  {
  	my ($tz, $tzo, $H, $M, $S, $m, $d, $y, $rs, $rd, $rel, $passes, $parse, $t) = @_;
  	print "---------<<\n";
  	print defined($tz) ? "tz: $tz.\n" : "no tz\n";
  	print defined($tzo) ? "tzo: $tzo.\n" : "no tzo\n";
  	print "HMS: ";
  	print defined($H) ? "$H, " : "no H, ";
  	print defined($M) ? "$M, " : "no M, ";
  	print defined($S) ? "$S\n" : "no S.\n";
  	print "mdy: ";
  	print defined($m) ? "$m, " : "no m, ";
  	print defined($d) ? "$d, " : "no d, ";
  	print defined($y) ? "$y\n" : "no y.\n";
  	print defined($rs) ? "rs: $rs.\n" : "no rs\n";
  	print defined($rd) ? "rd: $rd.\n" : "no rd\n";
  	print $rel ? "relative\n" : "not relative\n";
  	print "passes: $passes\n";
  	print "parse:$parse\n";
  	print "t: $t.\n";
  	print "--------->>\n";
  }
  1;
  
  __END__
  
  =head1 NAME
  
  Time::ParseDate -- date parsing both relative and absolute
  
  =head1 SYNOPSIS
  
  	use Time::ParseDate;
  	$seconds_since_jan1_1970 = parsedate("12/11/94 2pm", NO_RELATIVE => 1)
  	$seconds_since_jan1_1970 = parsedate("12/11/94 2pm", %options)
  
  =head1 OPTIONS
  
  Date parsing can also use options.  The options are as follows:
  
  	FUZZY	-> it's okay not to parse the entire date string
  	NOW	-> the "current" time for relative times (defaults to time())
  	ZONE	-> local timezone (defaults to $ENV{TZ})
  	WHOLE	-> the whole input string must be parsed
  	GMT	-> input time is assumed to be GMT, not localtime
  	UK	-> prefer UK style dates (dd/mm over mm/dd)
  	DATE_REQUIRED -> do not default the date
  	TIME_REQUIRED -> do not default the time
  	NO_RELATIVE -> input time is not relative to NOW
  	TIMEFIRST -> try parsing time before date [not default]
  	PREFER_PAST -> when year or day of week is ambiguous, assume past
  	PREFER_FUTURE -> when year or day of week is ambiguous, assume future
  	SUBSECOND -> parse fraction seconds
  	VALIDATE -> only accept normal values for HHMMSS, YYMMDD.  Otherwise
  		days like -1 might give the last day of the previous month.
  
  =head1 DATE FORMATS RECOGNIZED
  
  =head2 Absolute date formats
  
  	Dow, dd Mon yy
  	Dow, dd Mon yyyy
  	Dow, dd Mon
  	dd Mon yy
  	dd Mon yyyy
  	Month day{st,nd,rd,th}, year
  	Month day{st,nd,rd,th}
  	Mon dd yyyy
  	yyyy/mm/dd
  	yyyy-mm-dd	(usually the best date specification syntax)
  	yyyy/mm
  	mm/dd/yy
  	mm/dd/yyyy
  	mm/yy
  	yy/mm      (only if year > 12, or > 31 if UK)
  	yy/mm/dd   (only if year > 12 and day < 32, or year > 31 if UK)
  	dd/mm/yy   (only if UK, or an invalid mm/dd/yy or yy/mm/dd)
  	dd/mm/yyyy (only if UK, or an invalid mm/dd/yyyy)
  	dd/mm      (only if UK, or an invalid mm/dd)
  
  =head2 Relative date formats:
  
  	count "days"
  	count "weeks"
  	count "months"
  	count "years"
  	Dow "after next"
  	Dow "before last"
  	Dow 			(requires PREFER_PAST or PREFER_FUTURE)
  	"next" Dow
  	"tomorrow"
  	"today"
  	"yesterday"
  	"last" dow
  	"last week"
  	"now"
  	"now" "+" count units
  	"now" "-" count units
  	"+" count units		
  	"-" count units
  	count units "ago"
  
  =head2 Absolute time formats:
  
  	hh:mm:ss[.ddd] 
  	hh:mm 
  	hh:mm[AP]M
  	hh[AP]M
  	hhmmss[[AP]M] 
  	"noon"
  	"midnight"
  
  =head2 Relative time formats:
  
  	count "minutes"		(count can be franctional "1.5" or "1 1/2")
  	count "seconds"
  	count "hours"
  	"+" count units
  	"+" count
  	"-" count units
  	"-" count
  	count units "ago"
  
  =head2 Timezone formats:
  
  	[+-]dddd
  	GMT[+-]d+
  	[+-]dddd (TZN)
  	TZN
  
  =head2 Special formats:
  
  	[ d]d/Mon/yyyy:hh:mm:ss [[+-]dddd]
  	yy/mm/dd.hh:mm
  
  =head1 DESCRIPTION
  
  This module recognizes the above date/time formats.   Usually a
  date and a time are specified.  There are numerous options for 
  controlling what is recognized and what is not.
  
  The return code is always the time in seconds since January 1st, 1970
  or undef if it was unable to parse the time.
  
  If a timezone is specified it must be after the time.  Year specifications
  can be tacked onto the end of absolute times.
  
  If C<parsedate()> is called from array context, then it will return two
  elements.  On successful parses, it will return the seconds and what 
  remains of its input string.  On unsuccessful parses, it will return
  C<undef> and an error string.
  
  =head1 EXAMPLES
  
  	$seconds = parsedate("Mon Jan  2 04:24:27 1995");
  	$seconds = parsedate("Tue Apr 4 00:22:12 PDT 1995");
  	$seconds = parsedate("04.04.95 00:22", ZONE => PDT);
  	$seconds = parsedate("Jan 1 1999 11:23:34.578", SUBSECOND => 1);
  	$seconds = parsedate("122212 950404", ZONE => PDT, TIMEFIRST => 1);
  	$seconds = parsedate("+3 secs", NOW => 796978800);
  	$seconds = parsedate("2 months", NOW => 796720932);
  	$seconds = parsedate("last Tuesday");
  	$seconds = parsedate("Sunday before last");
  
  	($seconds, $remaining) = parsedate("today is the day");
  	($seconds, $error) = parsedate("today is", WHOLE=>1);
  
  =head1 LICENSE
  
  Copyright (C) 1996-2010 David Muir Sharnoff.  
  Copyright (C) 2011 Google, Inc.  
  License hereby
  granted for anyone to use, modify or redistribute this module at
  their own risk.  Please feed useful changes back to cpan@dave.sharnoff.org.
  
TIME_PARSEDATE

$fatpacked{"Time/Timezone.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TIME_TIMEZONE';
  package Time::Timezone;
  
  require 5.002;
  
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(tz2zone tz_local_offset tz_offset tz_name);
  @EXPORT_OK = qw();
  
  use Carp;
  use strict;
  
  # Parts stolen from code by Paul Foley <paul@ascent.com>
  
  use vars qw($VERSION);
  
  $VERSION = 2015.0925;
  
  sub tz2zone
  {
  	my($TZ, $time, $isdst) = @_;
  
  	use vars qw(%tzn_cache);
  
  	$TZ = defined($ENV{'TZ'}) ? ( $ENV{'TZ'} ? $ENV{'TZ'} : 'GMT' ) : ''
  	    unless $TZ;
  
  	# Hack to deal with 'PST8PDT' format of TZ
  	# Note that this can't deal with all the esoteric forms, but it
  	# does recognize the most common: [:]STDoff[DST[off][,rule]]
  
  	if (! defined $isdst) {
  		my $j;
  		$time = time() unless defined $time;
  		($j, $j, $j, $j, $j, $j, $j, $j, $isdst) = localtime($time);
  	}
  
  	if (defined $tzn_cache{$TZ}->[$isdst]) {
  		return $tzn_cache{$TZ}->[$isdst];
  	}
        
  	if ($TZ =~ /^
  		    ( [^:\d+\-,] {3,} )
  		    ( [+-] ?
  		      \d {1,2}
  		      ( : \d {1,2} ) {0,2} 
  		    )
  		    ( [^\d+\-,] {3,} )?
  		    /x
  	    ) {
  		$TZ = $isdst ? $4 : $1;
  		$tzn_cache{$TZ} = [ $1, $4 ];
  	} else {
  		$tzn_cache{$TZ} = [ $TZ, $TZ ];
  	}
  	return $TZ;
  }
  
  sub tz_local_offset
  {
  	my ($time) = @_;
  
  	$time = time() unless defined $time;
  
      return &calc_off($time);
  }
  
  sub calc_off
  {
  	my ($time) = @_;
  
  	my (@l) = localtime($time);
  	my (@g) = gmtime($time);
  
  	my $off;
  
  	$off =	   $l[0] - $g[0]
  		+ ($l[1] - $g[1]) * 60
  		+ ($l[2] - $g[2]) * 3600;
  
  	# subscript 7 is yday.
  
  	if ($l[7] == $g[7]) {
  		# done
  	} elsif ($l[7] == $g[7] + 1) {
  		$off += 86400;
  	} elsif ($l[7] == $g[7] - 1) {
  		$off -= 86400;
  	} elsif ($l[7] < $g[7]) {
  		# crossed over a year boundary!
  		# localtime is beginning of year, gmt is end
  		# therefore local is ahead
  		$off += 86400;
  	} else {
  		$off -= 86400;
  	}
  
  	return $off;
  }
  
  # constants
  # The rest of the file originally comes from Graham Barr <bodg@tiuk.ti.com> 
  #
  # Some references:
  #  http://www.weltzeituhr.com/laender/zeitzonen_e.shtml
  #  http://www.worldtimezone.com/wtz-names/timezonenames.html
  #  http://www.timegenie.com/timezones.php
  
  CONFIG: {
  	use vars qw(%dstZone %zoneOff %dstZoneOff %Zone);
  
  	%dstZone = (
  	    "brst" =>	-2*3600,	 # Brazil Summer Time (East Daylight)
  	    "adt"  =>	-3*3600,	 # Atlantic Daylight   
  	    "edt"  =>	-4*3600,	 # Eastern Daylight
  	    "cdt"  =>	-5*3600,	 # Central Daylight
  	    "mdt"  =>	-6*3600,	 # Mountain Daylight
  	    "pdt"  =>	-7*3600,	 # Pacific Daylight
  	    "ydt"  =>	-8*3600,	 # Yukon Daylight
  	    "hdt"  =>	-9*3600,	 # Hawaii Daylight
  	    "bst"  =>	+1*3600,	 # British Summer   
  	    "mest" =>	+2*3600,	 # Middle European Summer   
  	    "met dst" => +2*3600,	 # Middle European Summer   
  	    "sst"  =>	+2*3600,	 # Swedish Summer
  	    "fst"  =>	+2*3600,	 # French Summer
  	    "eest" =>	+3*3600,	 # Eastern European Summer
  	    "cest" =>	+2*3600,	 # Central European Daylight
  	    "wadt" =>	+8*3600,	 # West Australian Daylight
  	    "kdt"  =>  +10*3600,	 # Korean Daylight
  	#   "cadt" =>  +10*3600+1800,	 # Central Australian Daylight
  	    "eadt" =>  +11*3600,	 # Eastern Australian Daylight
  	    "nzdt" =>  +13*3600,	 # New Zealand Daylight	  
  	);
  
  	# not included due to ambiguity:
  	#	IST     Indian Standard Time            +5.5
  	#		Ireland Standard Time           0
  	#		Israel Standard Time            +2
  	#	IDT     Ireland Daylight Time           +1
  	#		Israel Daylight Time            +3
  	#	AMST    Amazon Standard Time /          -3
  	#		Armenia Standard Time           +8
  	#	BST	Brazil Standard			-3
  
  	%Zone = (
  	    "gmt"	=>   0,		 # Greenwich Mean
  	    "ut"	=>   0,		 # Universal (Coordinated)
  	    "utc"	=>   0,
  	    "wet"	=>   0,		 # Western European
  	    "wat"	=>  -1*3600,	 # West Africa
  	    "azost"	=>  -1*3600,	 # Azores Standard Time
  	    "cvt"	=>  -1*3600,	 # Cape Verde Time
  	    "at"	=>  -2*3600,	 # Azores
  	    "fnt"	=>  -2*3600,	 # Brazil Time (Extreme East - Fernando Noronha)
  	    "ndt" 	=>  -2*3600-1800,# Newfoundland Daylight   
  	    "art"	=>  -3*3600,	 # Argentina Time
  	# For completeness.  BST is also British Summer, and GST is also Guam Standard.
  	#   "gst"	=>  -3*3600,	 # Greenland Standard
  	    "nft"	=>  -3*3600-1800,# Newfoundland
  	#   "nst"	=>  -3*3600-1800,# Newfoundland Standard
  	    "mnt"	=>  -4*3600,	 # Brazil Time (West Standard - Manaus)
  	    "ewt"	=>  -4*3600,	 # U.S. Eastern War Time
  	    "ast"	=>  -4*3600,	 # Atlantic Standard
  	    "bot"	=>  -4*3600,	 # Bolivia Time
  	    "vet"	=>  -4*3600,	 # Venezuela Time
  	    "est"	=>  -5*3600,	 # Eastern Standard
  	    "cot"	=>  -5*3600,	 # Colombia Time
  	    "act"	=>  -5*3600,	 # Brazil Time (Extreme West - Acre)
  	    "pet"	=>  -5*3600,	 # Peru Time
  	    "cst"	=>  -6*3600,	 # Central Standard
  	    "cest"	=>  +2*3600,	 # Central European Summer
  	    "mst"	=>  -7*3600,	 # Mountain Standard
  	    "pst"	=>  -8*3600,	 # Pacific Standard
  	    "yst"	=>  -9*3600,	 # Yukon Standard
  	    "hst"	=> -10*3600,	 # Hawaii Standard
  	    "cat"	=> -10*3600,	 # Central Alaska
  	    "ahst"	=> -10*3600,	 # Alaska-Hawaii Standard
  	    "taht"	=> -10*3600,	 # Tahiti Time
  	    "nt"	=> -11*3600,	 # Nome
  	    "idlw"	=> -12*3600,	 # International Date Line West
  	    "cet"	=>  +1*3600,	 # Central European
  	    "mez"	=>  +1*3600,	 # Central European (German)
  	    "met"	=>  +1*3600,	 # Middle European
  	    "mewt"	=>  +1*3600,	 # Middle European Winter
  	    "swt"	=>  +1*3600,	 # Swedish Winter
  	    "set"	=>  +1*3600,	 # Seychelles
  	    "fwt"	=>  +1*3600,	 # French Winter
  	    "west"	=>  +1*3600,	 # Western Europe Summer Time
  	    "eet"	=>  +2*3600,	 # Eastern Europe, USSR Zone 1
  	    "ukr"	=>  +2*3600,	 # Ukraine
  	    "sast"	=>  +2*3600,	 # South Africa Standard Time
  	    "bt"	=>  +3*3600,	 # Baghdad, USSR Zone 2
  	    "eat"	=>  +3*3600,	 # East Africa Time
  	#   "it"	=>  +3*3600+1800,# Iran
  	    "irst"	=>  +3*3600+1800,# Iran Standard Time
  	    "zp4"	=>  +4*3600,	 # USSR Zone 3
  	    "msd"	=>  +4*3600,	 # Moscow Daylight Time
  	    "sct"	=>  +4*3600,	 # Seychelles Time
  	    "zp5"	=>  +5*3600,	 # USSR Zone 4
  	    "azst"	=>  +5*3600,	 # Azerbaijan Summer Time
  	    "mvt"	=>  +5*3600,	 # Maldives Time
  	    "uzt"	=>  +5*3600,	 # Uzbekistan Time
  	    "ist"	=>  +5*3600+1800,# Indian Standard
  	    "zp6"	=>  +6*3600,	 # USSR Zone 5
  	    "lkt"	=>  +6*3600,	 # Sri Lanka Time
  	    "pkst"	=>  +6*3600,	 # Pakistan Summer Time
  	    "yekst"	=>  +6*3600,	 # Yekaterinburg Summer Time
  	# For completeness.  NST is also Newfoundland Stanard, and SST is also Swedish Summer.
  	#   "nst"	=>  +6*3600+1800,# North Sumatra
  	#   "sst"	=>  +7*3600,	 # South Sumatra, USSR Zone 6
  	    "wast"	=>  +7*3600,	 # West Australian Standard
  	    "ict"	=>  +7*3600,	 # Indochina Time
  	    "wit"	=>  +7*3600,	 # Western Indonesia Time
  	#   "jt"	=>  +7*3600+1800,# Java (3pm in Cronusland!)
  	    "cct"	=>  +8*3600,	 # China Coast, USSR Zone 7
  	    "wst"	=>  +8*3600,	 # West Australian Standard
  	    "hkt"	=>  +8*3600,	 # Hong Kong
  	    "bnt"	=>  +8*3600,	 # Brunei Darussalam Time
  	    "cit"	=>  +8*3600,	 # Central Indonesia Time
  	    "myt"	=>  +8*3600,	 # Malaysia Time
  	    "pht"	=>  +8*3600,	 # Philippines Time
  	    "sgt"	=>  +8*3600,	 # Singapore Time
  	    "jst"	=>  +9*3600,	 # Japan Standard, USSR Zone 8
  	    "kst"	=>  +9*3600,	 # Korean Standard
  	#   "cast"	=>  +9*3600+1800,# Central Australian Standard
  	    "east"	=> +10*3600,	 # Eastern Australian Standard
  	    "gst"	=> +10*3600,	 # Guam Standard, USSR Zone 9
  	    "nct"	=> +11*3600,	 # New Caledonia Time
  	    "nzt"	=> +12*3600,	 # New Zealand
  	    "nzst"	=> +12*3600,	 # New Zealand Standard
  	    "fjt"	=> +12*3600,	 # Fiji Time
  	    "idle"	=> +12*3600,	 # International Date Line East
  	);
  
  	%zoneOff = reverse(%Zone);
  	%dstZoneOff = reverse(%dstZone);
  
  	# Preferences
  
  	$zoneOff{0}	  = 'gmt';
  	$dstZoneOff{3600} = 'bst';
  
  }
  
  sub tz_offset
  {
  	my ($zone, $time) = @_;
  
  	return &tz_local_offset() unless($zone);
  
  	$time = time() unless defined $time;
  	my(@l) = localtime($time);
  	my $dst = $l[8];
  
  	$zone = lc $zone;
  
  	if ($zone =~ /^([\-\+]\d{3,4})$/) {
  		my $sign = $1 < 0 ? -1 : 1 ;
  		my $v = abs(0 + $1);
  		return $sign * 60 * (int($v / 100) * 60 + ($v % 100));
  	} elsif (exists $dstZone{$zone} && ($dst || !exists $Zone{$zone})) {
  		return $dstZone{$zone};
  	} elsif(exists $Zone{$zone}) {
  		return $Zone{$zone};
  	}
  	undef;
  }
  
  sub tz_name
  {
  	my ($off, $time) = @_;
  
  	$time = time() unless defined $time;
  	my(@l) = localtime($time);
  	my $dst = $l[8];
  
  	if (exists $dstZoneOff{$off} && ($dst || !exists $zoneOff{$off})) {
  		return $dstZoneOff{$off};
  	} elsif (exists $zoneOff{$off}) {
  		return $zoneOff{$off};
  	}
  	sprintf("%+05d", int($off / 60) * 100 + $off % 60);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Time::Timezone -- miscellaneous timezone manipulations routines
  
  =head1 SYNOPSIS
  
  	use Time::Timezone;
  	print tz2zone();
  	print tz2zone($ENV{'TZ'});
  	print tz2zone($ENV{'TZ'}, time());
  	print tz2zone($ENV{'TZ'}, undef, $isdst);
  	$offset = tz_local_offset();
  	$offset = tz_offset($TZ);
  
  =head1 DESCRIPTION
  
  This is a collection of miscellaneous timezone manipulation routines.
  
  C<tz2zone()> parses the TZ environment variable and returns a timezone
  string suitable for inclusion in L<date>-like output.  It optionally takes
  a timezone string, a time, and a is-dst flag.
  
  C<tz_local_offset()> determines the offset from GMT time in seconds.  It
  only does the calculation once.
  
  C<tz_offset()> determines the offset from GMT in seconds of a specified
  timezone.  
  
  C<tz_name()> determines the name of the timezone based on its offset
  
  =head1 AUTHORS
  
  Graham Barr <bodg@tiuk.ti.com>
  David Muir Sharnoff <muir@idiom.org>
  Paul Foley <paul@ascent.com>
  
  =head1 LICENSE
  
  David Muir Sharnoff disclaims any copyright and puts his contribution
  to this module in the public domain.
  
TIME_TIMEZONE

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny; # git description: v0.30-11-g1b81d0a
  use 5.006;
  # ABSTRACT: Minimal try/catch with proper preservation of $@
  
  our $VERSION = '0.31';
  
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  our @EXPORT = our @EXPORT_OK = qw(try catch finally);
  
  use Carp;
  $Carp::Internal{+__PACKAGE__}++;
  
  BEGIN {
    my $su = $INC{'Sub/Util.pm'} && defined &Sub::Util::set_subname;
    my $sn = $INC{'Sub/Name.pm'} && eval { Sub::Name->VERSION(0.08) };
    unless ($su || $sn) {
      $su = eval { require Sub::Util; } && defined &Sub::Util::set_subname;
      unless ($su) {
        $sn = eval { require Sub::Name; Sub::Name->VERSION(0.08) };
      }
    }
  
    *_subname = $su ? \&Sub::Util::set_subname
              : $sn ? \&Sub::Name::subname
              : sub { $_[1] };
    *_HAS_SUBNAME = ($su || $sn) ? sub(){1} : sub(){0};
  }
  
  my %_finally_guards;
  
  # Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
  # Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
  # context & not a scalar one
  
  sub try (&;@) {
    my ( $try, @code_refs ) = @_;
  
    # we need to save this here, the eval block will be in scalar context due
    # to $failed
    my $wantarray = wantarray;
  
    # work around perl bug by explicitly initializing these, due to the likelyhood
    # this will be used in global destruction (perl rt#119311)
    my ( $catch, @finally ) = ();
  
    # find labeled blocks in the argument list.
    # catch and finally tag the blocks by blessing a scalar reference to them.
    foreach my $code_ref (@code_refs) {
  
      if ( ref($code_ref) eq 'Try::Tiny::Catch' ) {
        croak 'A try() may not be followed by multiple catch() blocks'
          if $catch;
        $catch = ${$code_ref};
      } elsif ( ref($code_ref) eq 'Try::Tiny::Finally' ) {
        push @finally, ${$code_ref};
      } else {
        croak(
          'try() encountered an unexpected argument ('
        . ( defined $code_ref ? $code_ref : 'undef' )
        . ') - perhaps a missing semi-colon before or'
        );
      }
    }
  
    # FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
    # not perfect, but we could provide a list of additional errors for
    # $catch->();
  
    # name the blocks if we have Sub::Name installed
    _subname(caller().'::try {...} ' => $try)
      if _HAS_SUBNAME;
  
    # set up scope guards to invoke the finally blocks at the end.
    # this should really be a function scope lexical variable instead of
    # file scope + local but that causes issues with perls < 5.20 due to
    # perl rt#119311
    local $_finally_guards{guards} = [
      map Try::Tiny::ScopeGuard->_new($_),
      @finally
    ];
  
    # save the value of $@ so we can set $@ back to it in the beginning of the eval
    # and restore $@ after the eval finishes
    my $prev_error = $@;
  
    my ( @ret, $error );
  
    # failed will be true if the eval dies, because 1 will not be returned
    # from the eval body
    my $failed = not eval {
      $@ = $prev_error;
  
      # evaluate the try block in the correct context
      if ( $wantarray ) {
        @ret = $try->();
      } elsif ( defined $wantarray ) {
        $ret[0] = $try->();
      } else {
        $try->();
      };
  
      return 1; # properly set $failed to false
    };
  
    # preserve the current error and reset the original value of $@
    $error = $@;
    $@ = $prev_error;
  
    # at this point $failed contains a true value if the eval died, even if some
    # destructor overwrote $@ as the eval was unwinding.
    if ( $failed ) {
      # pass $error to the finally blocks
      push @$_, $error for @{$_finally_guards{guards}};
  
      # if we got an error, invoke the catch block.
      if ( $catch ) {
        # This works like given($error), but is backwards compatible and
        # sets $_ in the dynamic scope for the body of C<$catch>
        for ($error) {
          return $catch->($error);
        }
  
        # in case when() was used without an explicit return, the C<for>
        # loop will be aborted and there's no useful return value
      }
  
      return;
    } else {
      # no failure, $@ is back to what it was, everything is fine
      return $wantarray ? @ret : $ret[0];
    }
  }
  
  sub catch (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare catch()' unless wantarray;
  
    _subname(caller().'::catch {...} ' => $block)
      if _HAS_SUBNAME;
    return (
      bless(\$block, 'Try::Tiny::Catch'),
      @rest,
    );
  }
  
  sub finally (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare finally()' unless wantarray;
  
    _subname(caller().'::finally {...} ' => $block)
      if _HAS_SUBNAME;
    return (
      bless(\$block, 'Try::Tiny::Finally'),
      @rest,
    );
  }
  
  {
    package # hide from PAUSE
      Try::Tiny::ScopeGuard;
  
    use constant UNSTABLE_DOLLARAT => ("$]" < '5.013002') ? 1 : 0;
  
    sub _new {
      shift;
      bless [ @_ ];
    }
  
    sub DESTROY {
      my ($code, @args) = @{ $_[0] };
  
      local $@ if UNSTABLE_DOLLARAT;
      eval {
        $code->(@args);
        1;
      } or do {
        warn
          "Execution of finally() block $code resulted in an exception, which "
        . '*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. '
        . 'Your program will continue as if this event never took place. '
        . "Original exception text follows:\n\n"
        . (defined $@ ? $@ : '$@ left undefined...')
        . "\n"
        ;
      }
    }
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Try::Tiny - Minimal try/catch with proper preservation of $@
  
  =head1 VERSION
  
  version 0.31
  
  =head1 SYNOPSIS
  
  You can use Try::Tiny's C<try> and C<catch> to expect and handle exceptional
  conditions, avoiding quirks in Perl and common mistakes:
  
    # handle errors with a catch handler
    try {
      die "foo";
    } catch {
      warn "caught error: $_"; # not $@
    };
  
  You can also use it like a standalone C<eval> to catch and ignore any error
  conditions.  Obviously, this is an extreme measure not to be undertaken
  lightly:
  
    # just silence errors
    try {
      die "foo";
    };
  
  =head1 DESCRIPTION
  
  This module provides bare bones C<try>/C<catch>/C<finally> statements that are designed to
  minimize common mistakes with eval blocks, and NOTHING else.
  
  This is unlike L<TryCatch> which provides a nice syntax and avoids adding
  another call stack layer, and supports calling C<return> from the C<try> block to
  return from the parent subroutine. These extra features come at a cost of a few
  dependencies, namely L<Devel::Declare> and L<Scope::Upper> which are
  occasionally problematic, and the additional catch filtering uses L<Moose>
  type constraints which may not be desirable either.
  
  The main focus of this module is to provide simple and reliable error handling
  for those having a hard time installing L<TryCatch>, but who still want to
  write correct C<eval> blocks without 5 lines of boilerplate each time.
  
  It's designed to work as correctly as possible in light of the various
  pathological edge cases (see L</BACKGROUND>) and to be compatible with any style
  of error values (simple strings, references, objects, overloaded objects, etc).
  
  If the C<try> block dies, it returns the value of the last statement executed in
  the C<catch> block, if there is one. Otherwise, it returns C<undef> in scalar
  context or the empty list in list context. The following examples all
  assign C<"bar"> to C<$x>:
  
    my $x = try { die "foo" } catch { "bar" };
    my $x = try { die "foo" } || "bar";
    my $x = (try { die "foo" }) // "bar";
  
    my $x = eval { die "foo" } || "bar";
  
  You can add C<finally> blocks, yielding the following:
  
    my $x;
    try { die 'foo' } finally { $x = 'bar' };
    try { die 'foo' } catch { warn "Got a die: $_" } finally { $x = 'bar' };
  
  C<finally> blocks are always executed making them suitable for cleanup code
  which cannot be handled using local.  You can add as many C<finally> blocks to a
  given C<try> block as you like.
  
  Note that adding a C<finally> block without a preceding C<catch> block
  suppresses any errors. This behaviour is consistent with using a standalone
  C<eval>, but it is not consistent with C<try>/C<finally> patterns found in
  other programming languages, such as Java, Python, Javascript or C#. If you
  learned the C<try>/C<finally> pattern from one of these languages, watch out for
  this.
  
  =head1 EXPORTS
  
  All functions are exported by default using L<Exporter>.
  
  If you need to rename the C<try>, C<catch> or C<finally> keyword consider using
  L<Sub::Import> to get L<Sub::Exporter>'s flexibility.
  
  =over 4
  
  =item try (&;@)
  
  Takes one mandatory C<try> subroutine, an optional C<catch> subroutine and C<finally>
  subroutine.
  
  The mandatory subroutine is evaluated in the context of an C<eval> block.
  
  If no error occurred the value from the first block is returned, preserving
  list/scalar context.
  
  If there was an error and the second subroutine was given it will be invoked
  with the error in C<$_> (localized) and as that block's first and only
  argument.
  
  C<$@> does B<not> contain the error. Inside the C<catch> block it has the same
  value it had before the C<try> block was executed.
  
  Note that the error may be false, but if that happens the C<catch> block will
  still be invoked.
  
  Once all execution is finished then the C<finally> block, if given, will execute.
  
  =item catch (&;@)
  
  Intended to be used in the second argument position of C<try>.
  
  Returns a reference to the subroutine it was given but blessed as
  C<Try::Tiny::Catch> which allows try to decode correctly what to do
  with this code reference.
  
    catch { ... }
  
  Inside the C<catch> block the caught error is stored in C<$_>, while previous
  value of C<$@> is still available for use.  This value may or may not be
  meaningful depending on what happened before the C<try>, but it might be a good
  idea to preserve it in an error stack.
  
  For code that captures C<$@> when throwing new errors (i.e.
  L<Class::Throwable>), you'll need to do:
  
    local $@ = $_;
  
  =item finally (&;@)
  
    try     { ... }
    catch   { ... }
    finally { ... };
  
  Or
  
    try     { ... }
    finally { ... };
  
  Or even
  
    try     { ... }
    finally { ... }
    catch   { ... };
  
  Intended to be the second or third element of C<try>. C<finally> blocks are always
  executed in the event of a successful C<try> or if C<catch> is run. This allows
  you to locate cleanup code which cannot be done via C<local()> e.g. closing a file
  handle.
  
  When invoked, the C<finally> block is passed the error that was caught.  If no
  error was caught, it is passed nothing.  (Note that the C<finally> block does not
  localize C<$_> with the error, since unlike in a C<catch> block, there is no way
  to know if C<$_ == undef> implies that there were no errors.) In other words,
  the following code does just what you would expect:
  
    try {
      die_sometimes();
    } catch {
      # ...code run in case of error
    } finally {
      if (@_) {
        print "The try block died with: @_\n";
      } else {
        print "The try block ran without error.\n";
      }
    };
  
  B<You must always do your own error handling in the C<finally> block>. C<Try::Tiny> will
  not do anything about handling possible errors coming from code located in these
  blocks.
  
  Furthermore B<exceptions in C<finally> blocks are not trappable and are unable
  to influence the execution of your program>. This is due to limitation of
  C<DESTROY>-based scope guards, which C<finally> is implemented on top of. This
  may change in a future version of Try::Tiny.
  
  In the same way C<catch()> blesses the code reference this subroutine does the same
  except it bless them as C<Try::Tiny::Finally>.
  
  =back
  
  =head1 BACKGROUND
  
  There are a number of issues with C<eval>.
  
  =head2 Clobbering $@
  
  When you run an C<eval> block and it succeeds, C<$@> will be cleared, potentially
  clobbering an error that is currently being caught.
  
  This causes action at a distance, clearing previous errors your caller may have
  not yet handled.
  
  C<$@> must be properly localized before invoking C<eval> in order to avoid this
  issue.
  
  More specifically,
  L<before Perl version 5.14.0|perl5140delta/"Exception Handling">
  C<$@> was clobbered at the beginning of the C<eval>, which
  also made it impossible to capture the previous error before you die (for
  instance when making exception objects with error stacks).
  
  For this reason C<try> will actually set C<$@> to its previous value (the one
  available before entering the C<try> block) in the beginning of the C<eval>
  block.
  
  =head2 Localizing $@ silently masks errors
  
  Inside an C<eval> block, C<die> behaves sort of like:
  
    sub die {
      $@ = $_[0];
      return_undef_from_eval();
    }
  
  This means that if you were polite and localized C<$@> you can't die in that
  scope, or your error will be discarded (printing "Something's wrong" instead).
  
  The workaround is very ugly:
  
    my $error = do {
      local $@;
      eval { ... };
      $@;
    };
  
    ...
    die $error;
  
  =head2 $@ might not be a true value
  
  This code is wrong:
  
    if ( $@ ) {
      ...
    }
  
  because due to the previous caveats it may have been unset.
  
  C<$@> could also be an overloaded error object that evaluates to false, but
  that's asking for trouble anyway.
  
  The classic failure mode (fixed in L<Perl 5.14.0|perl5140delta/"Exception Handling">) is:
  
    sub Object::DESTROY {
      eval { ... }
    }
  
    eval {
      my $obj = Object->new;
  
      die "foo";
    };
  
    if ( $@ ) {
  
    }
  
  In this case since C<Object::DESTROY> is not localizing C<$@> but still uses
  C<eval>, it will set C<$@> to C<"">.
  
  The destructor is called when the stack is unwound, after C<die> sets C<$@> to
  C<"foo at Foo.pm line 42\n">, so by the time C<if ( $@ )> is evaluated it has
  been cleared by C<eval> in the destructor.
  
  The workaround for this is even uglier than the previous ones. Even though we
  can't save the value of C<$@> from code that doesn't localize, we can at least
  be sure the C<eval> was aborted due to an error:
  
    my $failed = not eval {
      ...
  
      return 1;
    };
  
  This is because an C<eval> that caught a C<die> will always return a false
  value.
  
  =head1 ALTERNATE SYNTAX
  
  Using Perl 5.10 you can use L<perlsyn/"Switch statements"> (but please don't,
  because that syntax has since been deprecated because there was too much
  unexpected magical behaviour).
  
  =for stopwords topicalizer
  
  The C<catch> block is invoked in a topicalizer context (like a C<given> block),
  but note that you can't return a useful value from C<catch> using the C<when>
  blocks without an explicit C<return>.
  
  This is somewhat similar to Perl 6's C<CATCH> blocks. You can use it to
  concisely match errors:
  
    try {
      require Foo;
    } catch {
      when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
      default { die $_ }
    };
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  C<@_> is not available within the C<try> block, so you need to copy your
  argument list. In case you want to work with argument values directly via C<@_>
  aliasing (i.e. allow C<$_[1] = "foo">), you need to pass C<@_> by reference:
  
    sub foo {
      my ( $self, @args ) = @_;
      try { $self->bar(@args) }
    }
  
  or
  
    sub bar_in_place {
      my $self = shift;
      my $args = \@_;
      try { $_ = $self->bar($_) for @$args }
    }
  
  =item *
  
  C<return> returns from the C<try> block, not from the parent sub (note that
  this is also how C<eval> works, but not how L<TryCatch> works):
  
    sub parent_sub {
      try {
        die;
      }
      catch {
        return;
      };
  
      say "this text WILL be displayed, even though an exception is thrown";
    }
  
  Instead, you should capture the return value:
  
    sub parent_sub {
      my $success = try {
        die;
        1;
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
    # OR
    sub parent_sub_with_catch {
      my $success = try {
        die;
        1;
      }
      catch {
        # do something with $_
        return undef; #see note
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
  
  Note that if you have a C<catch> block, it must return C<undef> for this to work,
  since if a C<catch> block exists, its return value is returned in place of C<undef>
  when an exception is thrown.
  
  =item *
  
  C<try> introduces another caller stack frame. L<Sub::Uplevel> is not used. L<Carp>
  will not report this when using full stack traces, though, because
  C<%Carp::Internal> is used. This lack of magic is considered a feature.
  
  =for stopwords unhygienically
  
  =item *
  
  The value of C<$_> in the C<catch> block is not guaranteed to be the value of
  the exception thrown (C<$@>) in the C<try> block.  There is no safe way to
  ensure this, since C<eval> may be used unhygienically in destructors.  The only
  guarantee is that the C<catch> will be called if an exception is thrown.
  
  =item *
  
  The return value of the C<catch> block is not ignored, so if testing the result
  of the expression for truth on success, be sure to return a false value from
  the C<catch> block:
  
    my $obj = try {
      MightFail->new;
    } catch {
      ...
  
      return; # avoid returning a true value;
    };
  
    return unless $obj;
  
  =item *
  
  C<$SIG{__DIE__}> is still in effect.
  
  Though it can be argued that C<$SIG{__DIE__}> should be disabled inside of
  C<eval> blocks, since it isn't people have grown to rely on it. Therefore in
  the interests of compatibility, C<try> does not disable C<$SIG{__DIE__}> for
  the scope of the error throwing code.
  
  =item *
  
  Lexical C<$_> may override the one set by C<catch>.
  
  For example Perl 5.10's C<given> form uses a lexical C<$_>, creating some
  confusing behavior:
  
    given ($foo) {
      when (...) {
        try {
          ...
        } catch {
          warn $_; # will print $foo, not the error
          warn $_[0]; # instead, get the error like this
        }
      }
    }
  
  Note that this behavior was changed once again in
  L<Perl5 version 18|https://metacpan.org/module/perldelta#given-now-aliases-the-global-_>.
  However, since the entirety of lexical C<$_> is now L<considered experimental
  |https://metacpan.org/module/perldelta#Lexical-_-is-now-experimental>, it
  is unclear whether the new version 18 behavior is final.
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<Syntax::Keyword::Try>
  
  Only available on perls >= 5.14, with a slightly different syntax (e.g. no trailing C<;> because
  it's actually a keyword, not a sub, but this means you can C<return> and C<next> within it). Use
  L<Feature::Compat::Try> to automatically switch to the native C<try> syntax in newer perls (when
  available). See also L<Try Catch Exception Handling|perlsyn/Try-Catch-Exception-Handling>.
  
  =item L<TryCatch>
  
  Much more feature complete, more convenient semantics, but at the cost of
  implementation complexity.
  
  =item L<autodie>
  
  Automatic error throwing for builtin functions and more. Also designed to
  work well with C<given>/C<when>.
  
  =item L<Throwable>
  
  A lightweight role for rolling your own exception classes.
  
  =item L<Error>
  
  Exception object implementation with a C<try> statement. Does not localize
  C<$@>.
  
  =item L<Exception::Class::TryCatch>
  
  Provides a C<catch> statement, but properly calling C<eval> is your
  responsibility.
  
  The C<try> keyword pushes C<$@> onto an error stack, avoiding some of the
  issues with C<$@>, but you still need to localize to prevent clobbering.
  
  =back
  
  =head1 LIGHTNING TALK
  
  I gave a lightning talk about this module, you can see the slides (Firefox
  only):
  
  L<http://web.archive.org/web/20100628040134/http://nothingmuch.woobling.org/talks/takahashi.xul>
  
  Or read the source:
  
  L<http://web.archive.org/web/20100305133605/http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
  
  =head1 SUPPORT
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=Try-Tiny>
  (or L<bug-Try-Tiny@rt.cpan.org|mailto:bug-Try-Tiny@rt.cpan.org>).
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =for stopwords Karen Etheridge Peter Rabbitson Ricardo Signes Mark Fowler Graham Knop Aristotle Pagaltzis Dagfinn Ilmari Mannsåker Lukas Mai Alex anaxagoras Andrew Yates awalker chromatic cm-perl David Lowe Glenn Hans Dieter Pearcey Jens Berthold Jonathan Yu Marc Mims Stosberg Pali Paul Howarth Rudolf Leermakers
  
  =over 4
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Peter Rabbitson <ribasushi@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =item *
  
  Mark Fowler <mark@twoshortplanks.com>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Aristotle Pagaltzis <pagaltzis@gmx.de>
  
  =item *
  
  Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>
  
  =item *
  
  Lukas Mai <l.mai@web.de>
  
  =item *
  
  Alex <alex@koban.(none)>
  
  =item *
  
  anaxagoras <walkeraj@gmail.com>
  
  =item *
  
  Andrew Yates <ayates@haddock.local>
  
  =item *
  
  awalker <awalker@sourcefire.com>
  
  =item *
  
  chromatic <chromatic@wgz.org>
  
  =item *
  
  cm-perl <cm-perl@users.noreply.github.com>
  
  =item *
  
  David Lowe <davidl@lokku.com>
  
  =item *
  
  Glenn Fowler <cebjyre@cpan.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Jens Berthold <jens@jebecs.de>
  
  =item *
  
  Jonathan Yu <JAWNSY@cpan.org>
  
  =item *
  
  Marc Mims <marc@questright.com>
  
  =item *
  
  Mark Stosberg <mark@stosberg.com>
  
  =item *
  
  Pali <pali@cpan.org>
  
  =item *
  
  Paul Howarth <paul@city-fan.org>
  
  =item *
  
  Rudolf Leermakers <rudolf@hatsuseno.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is Copyright (c) 2009 by יובל קוג'מן (Yuval Kogman).
  
  This is free software, licensed under:
  
    The MIT (X11) License
  
  =cut
TRY_TINY

$fatpacked{"Yabsm/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YABSM_BASE';
  #  Author:  Nicholas Hubbard
  #  WWW:     https://github.com/NicholasBHubbard/yabsm
  #  License: MIT
  
  #  The core module of Yabsm.
  #
  #  See t/Base.t for this modules tests.
  #
  #  The $config_ref variable that is passed all around this module is
  #  created by read_config() from the Yabsm::Config module. read_config()
  #  ensures that the config it produces is valid, so therefore functions
  #  in this library do not need to worry about edge cases caused by an
  #  erroneus config.
  #
  #  All the subroutines are annoted to communicate if the subroutine
  #  has a unit test in Base.t, and if the function is pure. If the
  #  function is pure it means it has no effects on any external state
  #  whether that be a global variable or the filesystem, and always
  #  produces the same output given the same input.
  #
  #  Just because a function doesn't have a unit test does not mean it
  #  has not been informally tested.
  #
  #  An error message prefixed with 'yabsm: internal error' is an error for a
  #  scenario that will only occur a bug is present.
  
  package Yabsm::Base;
  
  use strict;
  use warnings;
  use v5.16.3;
  
  use Net::OpenSSH;
  use Time::Piece;
  use Carp;
  use List::Util 1.33 qw(any);
  use File::Path qw(make_path); # make_path() behaves like 'mkdir --parents'
  
  sub do_snapshot { # No test. Is not pure.
  
      # Take a new $timeframe snapshot of $subvol and delete old snapshot(s).
      
      my $config_ref = shift // confess missing_arg();
      my $subvol     = shift // confess missing_arg();
      my $timeframe  = shift // confess missing_arg();
  
      take_new_snapshot($config_ref, $subvol, $timeframe);
      delete_old_snapshots($config_ref);
  
      return;
  }
  
  sub take_new_snapshot { # No test. Is not pure.
  
      # take a single $timeframe snapshot of $subvol. Used for yabsm's
      # 'take-snap' command.
  
      my $config_ref = shift // confess missing_arg();
      my $subvol     = shift // confess missing_arg();
      my $timeframe  = shift // confess missing_arg();
  
      my $mountpoint = $config_ref->{subvols}{$subvol}{mountpoint};
  
      my $snap_dir = local_yabsm_dir($config_ref, $subvol, $timeframe);
  
      my $snap_name = current_time_snapstring();
  
      make_path $snap_dir if not -d $snap_dir;
  
      system("btrfs subvol snapshot -r $mountpoint $snap_dir/$snap_name");
  
      return;
  }
  
  sub delete_old_snapshots { # No test. Is not pure.
      
      # delete old snapshot(s) based off $subvol's ${timeframe}_keep
      # setting defined in the users config. This function should be
      # called directly after take_new_snapshot().
  
      my $config_ref = shift // confess missing_arg();
      my $subvol     = shift // confess missing_arg();
      my $timeframe  = shift // confess missing_arg();
  
      my $existing_snaps_ref = all_snaps($config_ref, $subvol, $timeframe);
  
      my $num_snaps = scalar @$existing_snaps_ref;
  
      my $num_to_keep = $config_ref->{subvols}{$subvol}{"${timeframe}_keep"};
  
      # There is 1 more snapshot than should be kept because we just
      # took a snapshot.
      if ($num_snaps == $num_to_keep + 1) { 
  
  	# pop takes from the end of the array. This is the oldest snap
  	# because they are sorted newest to oldest.
  	my $oldest_snap = pop @$existing_snaps_ref;
  
  	system("btrfs subvol delete $oldest_snap");
  
  	return;
      }
  
      # We haven't reached the snapshot quota yet so don't delete anything.
      elsif ($num_snaps <= $num_to_keep) { return }
  
      # User changed their settings to keep less snapshots than they
      # were keeping prior. 
      else { 
  	
  	while ($num_snaps > $num_to_keep) {
  
  	    # pop mutates $existing_snaps_ref, and thus is not idempotent.
              my $oldest_snap = pop @$existing_snaps_ref;
              
  	    system("btrfs subvol delete $oldest_snap");
  
  	    $num_snaps--;
  	}
  
  	return;
      }
  }
  
  sub do_backup_bootstrap { # No test. Is not pure.
  
      # Determine if $backup is local or remote and dispatch the
      # corresponding do_backup_bootstrap_* subroutine.
  
      my $config_ref = shift // confess missing_arg();
      my $backup     = shift // confess missing_arg();
  
      if (is_local_backup($config_ref, $backup)) {
  	do_backup_bootstrap_local($config_ref, $backup);
      }
  
      elsif (is_remote_backup($config_ref, $backup)) {
  	do_backup_bootstrap_ssh($config_ref, $backup);
      }
  
      else {
  	confess "yabsm: internal error: no such user defined backup '$backup'";
      }
  
      return;
  }
  
  sub do_backup_bootstrap_local { # No test. Is not pure.
  
      # Perform bootstrap phase of a btrfs incremental backup. To
      # bootstrap a backup we create a new snapshot and place it in the
      # backups backup bootstrap dir and then then btrfs send/receive
      # the bootstrap snap.
  
      my $config_ref = shift // confess missing_arg();
      my $backup     = shift // confess missing_arg();
  
      my $boot_snap_dir = bootstrap_snap_dir($config_ref, $backup);
  
      # delete old bootstrap snap
      if (-d $boot_snap_dir) {
          system "btrfs subvol delete $_" for glob "$boot_snap_dir/*";
      }
      else {
          make_path $boot_snap_dir;
      }
  
      my $backup_dir = $config_ref->{backups}{$backup}{backup_dir};
  
      # if $backup_dir exists this cannot be the first time
      # bootstrapping so we need to delete the old bootstrap snap.
      if (-d $backup_dir) {
          system "btrfs subvol delete $_" for grep { $_ =~ /BOOTSTRAP-day/ } glob "$backup_dir/*";
      }
      else {
          make_path $backup_dir;
      }
  
      my $boot_snap = "$boot_snap_dir/BOOTSTRAP-" . current_time_snapstring();
  
      my $subvol = $config_ref->{backups}{$backup}{subvol};
  
      my $mountpoint = $config_ref->{subvols}{$subvol}{mountpoint};
  
      system("btrfs subvol snapshot -r $mountpoint $boot_snap");
  
      system("btrfs send $boot_snap | btrfs receive $backup_dir");
  
      return;
  }
  
  sub do_backup_bootstrap_ssh { # No test. Is not pure.
  
      # Perform bootstrap phase of a btrfs incremental backup. To
      # bootstrap a backup we create a new snapshot and place it in the
      # subvol being snapped's backup bootstrap dir (for example
      # /.snapshots/yabsm/home/backups/homeBackup/bootstrap-snap/), and
      # then btrfs send/receive the bootstrap snap over ssh.
  
      my $config_ref = shift // confess missing_arg();
      my $backup     = shift // confess missing_arg();
  
      ### LOCAL ###
  
      my $boot_snap_dir = bootstrap_snap_dir($config_ref, $backup);
  
      # if $boot_snap_dir exists this cannot be the first time bootstrapping
      if (-d $boot_snap_dir) {
          system "btrfs subvol delete $_" for glob "$boot_snap_dir/*";
      }
      else {
          make_path $boot_snap_dir;
      }
  
      my $subvol = $config_ref->{backups}{$backup}{subvol};
  
      my $mountpoint = $config_ref->{subvols}{$subvol}{mountpoint};
  
      my $boot_snap = "$boot_snap_dir/BOOTSTRAP-" . current_time_snapstring();
      
      system("btrfs subvol snapshot -r $mountpoint $boot_snap");
  
      ### REMOTE ###
      
      # setup local bootstrap snap
      my $ssh = new_ssh_connection($config_ref->{backups}{$backup}{host});
  
      my $backup_dir = $config_ref->{backups}{$backup}{backup_dir};
  
      # delete old remote bootstrap snap(s) if it exists
      $ssh->system( "ls -d $backup_dir/* "
                  . '| grep BOOTSTRAP-day '
                  . '| while read -r line; do sudo -n btrfs subvol delete "$line"; done'
                  );
  
      # send the bootstrap backup to remote host
      $ssh->system({stdin_file => ['-|', "btrfs send $boot_snap"]}
  		, "sudo -n btrfs receive $backup_dir"
  	        );
  
      return;
  }
  
  sub do_incremental_backup { # No test. Is not pure.
  
      # Determine if $backup is local or remote and dispatch the
      # corresponding do_incremental_backup_* subroutine. If $backup
      # has not been bootstrapped then instead perform the bootstrap
      # routine.
  
      my $config_ref = shift // confess missing_arg();
      my $backup     = shift // confess missing_arg();
  
      if (not has_bootstrap($config_ref, $backup)) {
          do_backup_bootstrap($config_ref, $backup)
      }
      
      elsif (is_local_backup($config_ref, $backup)) {
  	do_incremental_backup_local($config_ref, $backup);
      }
  
      elsif (is_remote_backup($config_ref, $backup)) {
  	do_incremental_backup_ssh($config_ref, $backup);
      }
  
      else {
  	confess "yabsm: internal error: no such defined backup '$backup'";
      }
  
      return;
  }
  
  sub do_incremental_backup_local { # No test. Is not pure.
  
      # Perform a single incremental btrfs backup of $backup. This
      # function will kill the program if the bootstrap phase has not
      # yet been completed.
  
      my $config_ref = shift // confess missing_arg();
      my $backup     = shift // confess missing_arg();
  
      if (not has_bootstrap($config_ref, $backup)) {
          confess "yabsm: internal error: backup '$backup' has not been bootstrapped";
      }
  
      # bootstrap dir should have exactly one snap
      my $boot_snap =
        [ glob bootstrap_snap_dir($config_ref, $backup) . '/*' ]->[0];
  
      my $backup_dir = $config_ref->{backups}{$backup}{backup_dir};
  
      my $subvol = $config_ref->{backups}{$backup}{subvol};
  
      my $mountpoint = $config_ref->{subvols}{$subvol}{mountpoint};
  
      my $tmp_dir = local_yabsm_dir($config_ref) . "/.tmp/$backup";
  
      make_path $tmp_dir if not -d $tmp_dir;
      
      my $tmp_snap = "$tmp_dir/" . current_time_snapstring();
      
      system("btrfs subvol snapshot -r $mountpoint $tmp_snap");
      
      system("btrfs send -p $boot_snap $tmp_snap | btrfs receive $backup_dir");
  
      system("btrfs subvol delete $tmp_snap");
  
      delete_old_backups_local($config_ref, $backup);
  
      return;
  }
  
  sub do_incremental_backup_ssh { # No test. Is not pure.
  
      # Perform a single incremental btrfs backup of $backup over ssh.
      # This function will kill the program if the bootstrap phase has
      # not yet been completed.
  
      my $config_ref = shift // confess missing_arg();
      my $backup     = shift // confess missing_arg();
  
      if (not has_bootstrap($config_ref, $backup)) {
          confess "yabsm: internal error: backup '$backup' has not been bootstrapped";
      }
  
      # bootstrap dir should have exactly one snap
      my $boot_snap =
        [glob bootstrap_snap_dir($config_ref, $backup) . '/*']->[0];
  
      # do incremental backup
  
      my $subvol = $config_ref->{backups}{$backup}{subvol};
  
      my $remote_backup_dir = $config_ref->{backups}{$backup}{backup_dir};
      
      my $remote_host = $config_ref->{backups}{$backup}{host};
  
      my $ssh = new_ssh_connection($remote_host);
  
      my $mountpoint = $config_ref->{subvols}{$subvol}{mountpoint};
      
      my $tmp_dir = local_yabsm_dir($config_ref) . "/.tmp/$backup";
  
      make_path $tmp_dir if not -d $tmp_dir;
  
      my $tmp_snap = "$tmp_dir/" . current_time_snapstring();
  	
      system("btrfs subvol snapshot -r $mountpoint $tmp_snap");
  	
      # send an incremental backup over ssh
      $ssh->system({stdin_file => ['-|', "btrfs send -p $boot_snap $tmp_snap"]}
  		                , "sudo -n btrfs receive $remote_backup_dir");
  	
      system("btrfs subvol delete $tmp_snap");
  	
      delete_old_backups_ssh($config_ref, $ssh, $backup);
  
      return;
  }
  
  sub delete_old_backups_local { # No test. Is not pure.
  
      # Delete old backup snapshot(s) based off $backup's
      # $keep setting defined in the users config. This
      # function should be called directly after do_backup_local().
  
      my $config_ref = shift // confess missing_arg();
      my $backup     = shift // confess missing_arg();
  
      my $backup_dir = $config_ref->{backups}{$backup}{backup_dir};
  
      my @existing_backups = all_backup_snaps($config_ref, $backup);
  
      my $num_backups = scalar @existing_backups;
  
      my $num_to_keep = $config_ref->{backups}{$backup}{keep};
  
      # There is 1 more backup than should be kept because we just
      # performed a backup.
      if ($num_backups == $num_to_keep + 1) {
  
  	# pop takes from the end of the array. This is the oldest backup
  	# because they are sorted newest to oldest.
  	my $oldest_backup = pop @existing_backups;
  
  	system("btrfs subvol delete $oldest_backup");
  
  	return;
      }
  
      # We haven't reached the backup quota yet so we don't delete anything.
      elsif ($num_backups <= $num_to_keep) { return } 
  
      # User changed their settings to keep less backups than they
      # were keeping prior. 
      else { 
  	
  	while ($num_backups > $num_to_keep) {
  	    
  	    # note that pop mutates existing_snaps
  	    my $oldest_backup = pop @existing_backups;
              
  	    system("btrfs subvol delete $oldest_backup");
  
  	    $num_backups--;
  	}
  
  	return;
      }
  }
  
  sub delete_old_backups_ssh { # No test. Is not pure.
  
      # Delete old backup snapshot(s) at the remote host connected to by
      # $ssh. We know how many backups to keep based off $backup's $keep
      # setting defined in the users config. This function should be
      # called directly after do_backup_ssh().
  
      my $config_ref = shift // confess missing_arg();
      my $ssh        = shift // confess missing_arg();
      my $backup     = shift // confess missing_arg();
  
      my $remote_backup_dir = $config_ref->{backups}{$backup}{backup_dir}; 
  
      my @existing_backups = all_backup_snaps($config_ref, $backup, $ssh);
  
      my $num_backups = scalar @existing_backups;
  
      my $num_to_keep = $config_ref->{backups}{$backup}{keep};
  
      # There is 1 more backup than should be kept because we just
      # performed a backup.
      if ($num_backups == $num_to_keep + 1) {
  
  	# pop takes from the end of the array. This is the oldest backup
  	# because they are sorted newest to oldest.
  	my $oldest_backup = pop @existing_backups;
  
  	$ssh->system("sudo -n btrfs subvol delete $oldest_backup");
  
  	return;
      }
  
      # We haven't reached the backup quota yet so we don't delete anything.
      elsif ($num_backups <= $num_to_keep) { return } 
  
      # User changed their settings to keep less backups than they
      # were keeping prior. 
      else { 
  	
  	while ($num_backups > $num_to_keep) {
  
  	    # note that pop mutates existing_snaps
  	    my $oldest_backup = pop @existing_backups;
              
  	    $ssh->system("sudo -n btrfs subvol delete $oldest_backup");
  
  	    $num_backups--;
  	} 
  
  	return;
      }
  }
  
  sub has_bootstrap { # No test. Is not pure.
  
      # True if $backup already has a bootstrap snapshot.
  
      my $config_ref = shift // confess missing_arg();
      my $backup     = shift // confess missing_arg();
  
      my $bootstrap_snap_dir = bootstrap_snap_dir($config_ref, $backup);
  
      return 0 if not -d $bootstrap_snap_dir;
  
      opendir(my $dh, $bootstrap_snap_dir) or
        confess "yabsm: internal error: can not open dir '$bootstrap_snap_dir'";
  
      my @snaps = grep { /^[^.]/ } readdir($dh);
  
      closedir $dh;
  
      if (@snaps) {
          return 1;
      }
      else {
          return 0;
      }
  }
  
  sub all_snaps { # No test. Is not pure.
  
      # Gather all snapshots (full paths) of $subject and return them
      # sorted from newest to oldest. $subject can be any user defined
      # subvol or backup. If $subject is a subvol it may make sense to
      # only want snapshots from certain timeframes which can be passed
      # as the >=3'rd arguments.
  
      my $config_ref = shift // confess missing_arg();
      my $subject    = shift // confess missing_arg();
      my @timeframes = @_;
  
      my @all_snaps = (); # return this
  
      if (is_subvol($config_ref, $subject)) {
          # default to all timeframes
          if (not @timeframes) {
              @timeframes = all_timeframes();
          }
      
          foreach my $tf (@timeframes) {
          
              my $snap_dir = local_yabsm_dir($config_ref, $subject, $tf);
          
              if (-d $snap_dir) {
                  push @all_snaps, glob "$snap_dir/*"; 
              }
          }
  
          @all_snaps = sort_snaps(\@all_snaps);
      }
  
      if (is_backup($config_ref, $subject)) {
          # all_backup_snaps returns snaps sorted
          @all_snaps = all_backup_snaps($config_ref, $subject);
      }
  
      return wantarray ? @all_snaps : \@all_snaps;
  }
  
  sub all_backup_snaps { # No test. Is not pure.
      
      # Gather all snapshots (full paths) of $backup and return them
      # sorted from newest to oldest. A Net::OpenSSH connection object
      # can be passed as an arg if $backup is a remote backup, otherwise
      # a new connection will be opened.
  
      my $config_ref = shift // confess missing_arg();
      my $backup     = shift // confess missing_arg();
  
      my @all_backups = ();
      
      if (is_remote_backup($config_ref, $backup)) {
          my $backup_dir = $config_ref->{backups}{$backup}{backup_dir};
          my $remote_host = $config_ref->{backups}{$backup}{host};
          my $ssh = shift // new_ssh_connection( $remote_host );
          @all_backups = sort_snaps([ map { chomp; $_ = "$backup_dir/$_" } grep { $_ !~ /BOOTSTRAP-day/ } $ssh->capture("ls $backup_dir") ]);
  
      }
  
      if (is_local_backup($config_ref, $backup)) {
          my $backup_dir = $config_ref->{backups}{$backup}{backup_dir};
          @all_backups = sort_snaps([ grep { $_ !~ /BOOTSTRAP-day/ } glob "$backup_dir/*" ]);
      }
  
      return wantarray ? @all_backups : \@all_backups;
  }
  
  sub local_yabsm_dir { # Has test. Is pure.
  
      # Return the local directory path to the/a yabsm directory. The
      # $subvol and $timeframe arguments are optional. Note that we do not
      # check check that $subvol and $timeframe are a valid subvol/timeframe.
  
      my $config_ref = shift // confess missing_arg();
      my $subvol     = shift; # optional
      my $timeframe  = shift; # optional
  
      my $yabsm_dir = $config_ref->{misc}{yabsm_dir};
  
      if (defined $subvol) {
  	$yabsm_dir .= "/$subvol";
  	if (defined $timeframe) { 
  	    $yabsm_dir .= "/$timeframe";
  	}
      }
  
      return $yabsm_dir;
  }
  
  sub bootstrap_snap_dir { # Has test. Is pure.
  
      # Return the path of the directory holding the bootstrap snapshot for
      # $backup. The bootstrap snapshot is used for btrfs incremental backups.
  
      my $config_ref = shift // confess missing_arg();
      my $backup     = shift // confess missing_arg();
  
      my $subvol = $config_ref->{backups}{$backup}{subvol};
  
      my $yabsm_root_dir = local_yabsm_dir($config_ref);
  
      return "$yabsm_root_dir/.cache/$subvol/backups/$backup/bootstrap-snap";
  }
  
  sub is_snapstring { # Has test. Is pure.
  
      # Return 1 iff $snapstring is a valid snapstring. Works on
      # absolute paths as well as plain snapstrings.
  
      my $snapstring = shift // confess missing_arg();
  
      return $snapstring =~ /day=\d{4}_\d{2}_\d{2},time=\d{2}:\d{2}$/;
  }
  
  sub current_time_snapstring { # No test. Is not pure.
      
      # Return a snapstring of the current time.
      
      my $t = localtime();
  
      return nums_to_snapstring($t->year, $t->mon, $t->mday, $t->hour, $t->min);
  }
  
  sub n_units_ago_snapstring { # Has test. Is not pure.
  
      # Return a snapstring of the time $n $unit's ago from the current
      # time. The unit can be minutes, hours or days.
     
      my $n    = shift // confess missing_arg();
      my $unit = shift // confess missing_arg();
  
      # Can add/subtract by seconds with Time::Piece objects.
  
      my $seconds_per_unit;
  
      if    ($unit =~ /^(minutes|mins|m)$/) { $seconds_per_unit = 60    }
      elsif ($unit =~ /^(hours|hrs|h)$/   ) { $seconds_per_unit = 3600  }
      elsif ($unit =~ /^(days|d)$/        ) { $seconds_per_unit = 86400 }
      else  { confess "yabsm: internal error: '$unit' is not a valid time unit" }
  
      my $current_time = current_time_snapstring();
  
      my $time_piece_obj = snapstring_to_time_piece_obj($current_time);
  
      $time_piece_obj -= ($n * $seconds_per_unit);
  
      return time_piece_obj_to_snapstring($time_piece_obj);
  }
  
  sub is_immediate { # Has test. Is pure.
  
      # An immediate is either a literal time or a relative time.
  
      my $imm = shift // confess missing_arg();
      
      return is_literal_time($imm) || is_relative_time($imm);
  }
  
  sub is_literal_time { # Has test. Is pure.
  
      # True if $lit_time is a valid literal time. Literal times can
      # come in one of 5 different forms which can be seen by the 5
      # regexps below.
  
      my $lit_time = shift // confess missing_arg();
  
      # yr-mon-day-hr:min
      my $re1 = qr/^\d{4}-\d{1,2}-\d{1,2}-\d{1,2}:\d{1,2}$/;
      # yr-mon-day
      my $re2 = qr/^\d{4}-\d{1,2}-\d{1,2}$/;
      # mon-day
      my $re3 = qr/^\d{1,2}-\d{1,2}$/;
      # mon-day-hr
      my $re4 = qr/^\d{1,2}-\d{1,2}-\d{1,2}$/;
      # mon-day-hr:min
      my $re5 = qr/^\d{1,2}-\d{1,2}-\d{1,2}:\d{1,2}$/;
      # day-hr:min
      my $re6 = qr/^\d{1,2}-\d{1,2}:\d{1,2}$/;
      # hr:min
      my $re7 = qr/^\d{1,2}:\d{1,2}$/;
  
      return $lit_time =~ /$re1|$re2|$re3|$re4|$re5|$re6|$re7/;
  }
  
  sub is_relative_time { # Has test. Is pure.
  
      # Relative times take the form of 'back-amount-unit'.
      # 'back' can be abbreviated to 'b'.
      # The amount field must be a whole number.
      # The unit field must be a time unit like 'minutes', 'hours', or 'days'.
  
      my $rel_time = shift // confess missing_arg();
  
      my ($back, $amount, $unit) = split '-', $rel_time, 3;
  
      return 0 if any { not defined } ($back, $amount, $unit);
  
      my $back_correct = $back =~ /^b(ack)?$/;
  
      my $amount_correct = $amount =~ /^\d+$/;
      
      my $unit_correct = any { $unit eq $_ } qw(minutes mins m hours hrs h days d);
      
      return $back_correct && $amount_correct && $unit_correct;
  }
  
  
  sub immediate_to_snapstring { # No test. Is pure. 
  
      # Resolve an immediate to a snapstring.
  
      my $imm = shift // confess missing_arg();
  
      if (is_literal_time($imm)) {
  	return literal_time_to_snapstring($imm);
      }
  
      if (is_relative_time($imm)) {
  	return relative_time_to_snapstring($imm);
      }
  
      # input should have already been cleansed. 
      confess "yabsm: internal error: '$imm' is not an immediate";
  }
  
  sub literal_time_to_snapstring { # Has test. Is pure.
  
      # Resolve a literal time to a snapstring.
  
      my $lit_time = shift // confess missing_arg();
  
      # literal time forms
      my $yr_mon_day_hr_min = qr/^(\d{4})-(\d{1,2})-(\d{1,2})-(\d{1,2}):(\d{1,2})$/;
      my $yr_mon_day        = qr/^(\d{4})-(\d{1,2})-(\d{1,2})$/;
      my $mon_day           = qr/^(\d{1,2})-(\d{1,2})$/;
      my $mon_day_hr        = qr/^(\d{1,2})-(\d{1,2})-(\d{1,2})$/;
      my $mon_day_hr_min    = qr/^(\d{1,2})-(\d{1,2})-(\d{1,2}):(\d{1,2})$/;
      my $day_hr_min        = qr/^(\d{1,2})-(\d{1,2}):(\d{1,2})$/;
      my $hr_min            = qr/^(\d{1,2}):(\d{1,2})$/;
  
      if ($lit_time =~ $yr_mon_day_hr_min) {
  	return nums_to_snapstring($1, $2, $3, $4, $5);
      }
  
      if ($lit_time =~ $yr_mon_day) {
  	return nums_to_snapstring($1, $2, $3, 0, 0);
      }
  
      if ($lit_time =~ $mon_day) {
  	my $t = localtime;
  	return nums_to_snapstring($t->year, $1, $2, 0, 0);
      }
  
      if ($lit_time =~ $mon_day_hr) {
  	my $t = localtime;
  	return nums_to_snapstring($t->year, $1, $2, $3, 0);
      }
  
      if ($lit_time =~ $mon_day_hr_min) {
  	my $t = localtime;
  	return nums_to_snapstring($t->year, $1, $2, $3, $4);
      }
  
      if ($lit_time =~ $day_hr_min) {
          my $t = localtime;
          return nums_to_snapstring($t->year, $t->mon, $1, $2, $3);
      }
      
      if ($lit_time =~ $hr_min) {
          my $t = localtime;
          return nums_to_snapstring($t->year, $t->mon, $t->mday, $1, $2);
      }
  
      # input should have already been cleansed. 
      confess "yabsm: internal error: '$lit_time' is not a valid literal time";
  }
  
  sub time_hour { # Has test. Is pure.
  
      # Takes a time of the form 'hh:mm' and returns the hour (hh).
  
      my $time = shift // Yabsm::Base::missing_arg();
  
      my ($hr, undef) = split ':', $time, 2;
  
      return $hr;
  }
  
  sub time_minute { # Has test. Is pure.
  
      # Takes a time of the form 'hh:mm' and returns the minute (hh).
  
      my $time = shift // Yabsm::Base::missing_arg();
  
      my (undef, $min) = split ':', $time, 2;
  
      return $min;
  }
  
  sub relative_time_to_snapstring { # Has test. Is not pure.
  
      # Resolve a relative time to a snapstring.
  
      my $rel_time = shift // confess missing_arg();
  
      my (undef, $amount, $unit) = split '-', $rel_time, 3;
  
      my $n_units_ago_snapstring = n_units_ago_snapstring($amount, $unit);
  
      return $n_units_ago_snapstring; 
  }
  
  sub snapstring_to_nums { # Has test. Is pure.
  
      # Take a snapshot name string and return an array containing in
      # order the year, month, day, hour, and minute. This works with
      # both a full path and just a snapshot name string.
  
      my $snap = shift // confess missing_arg();
  
      my @nums = $snap =~ /day=(\d{4})_(\d{2})_(\d{2}),time=(\d{2}):(\d{2})$/;
  
      return wantarray ? @nums : \@nums;
  }
  
  sub nums_to_snapstring { # Has test. Is pure.
  
      # Take 5 integer arguments representing in order the year, month,
      # day, hour, and minute and return the corresponding snapstring.
  
      my ($yr, $mon, $day, $hr, $min) = map { sprintf '%02d', $_ } @_;
  
      return "day=${yr}_${mon}_${day},time=${hr}:${min}";
  }
  
  sub snapstring_to_time_piece_obj { # Has test. Is pure.
  
      # Turn a snapshot name string into a Time::Peice object. This is
      # useful because we can do time arithmetic on these objects.
  
      my $snap = shift // confess missing_arg();
  
      my ($yr, $mon, $day, $hr, $min) = snapstring_to_nums($snap);
  
      return Time::Piece->strptime("$yr/$mon/$day/$hr/$min",'%Y/%m/%d/%H/%M');
  }
  
  sub time_piece_obj_to_snapstring { # Has test. Is pure.
  
      # Turn a Time::Piece object into a snapshot name string.
  
      my $time_piece_obj = shift // confess missing_arg();
  
      my $yr  = $time_piece_obj->year;
      my $mon = $time_piece_obj->mon;
      my $day = $time_piece_obj->mday;
      my $hr  = $time_piece_obj->hour;
      my $min = $time_piece_obj->min;
  
      return nums_to_snapstring($yr, $mon, $day, $hr, $min);
  }
  
  sub sort_snaps { # Has test. Is pure.
  
      # Return a sorted version of the inputted snapshot array ref.
      # The snapshots will be returned newest to oldest. Works with
      # plain snapstrings and full paths.
  
      my $snaps_ref = shift // confess missing_arg();
  
      my @sorted_snaps = sort { cmp_snaps($a, $b) } @$snaps_ref;
  
      return wantarray ? @sorted_snaps : \@sorted_snaps;
  }
  
  sub cmp_snaps { # Has test. Is pure.
  
      # Return -1 if $snap1 is newer than $snap2.
      # Return 1 if $snap1 is older than $snap2
      # Return 0 if $snap1 and $snap2 are the same. 
      # Works with both plain snapstrings and full paths.
  
      my $snap1 = shift // confess missing_arg();
      my $snap2 = shift // confess missing_arg();
  
      my @snap1_nums = snapstring_to_nums($snap1);
      my @snap2_nums = snapstring_to_nums($snap2);
  
      # lexicographic order
      for (my $i = 0; $i <= $#snap1_nums; $i++) {
  
  	return -1 if $snap1_nums[$i] > $snap2_nums[$i];
  	return 1  if $snap1_nums[$i] < $snap2_nums[$i];
      }
  
      # Must be the same
      return 0;
  }
  
  sub snap_closest_to { # Has test. Is pure.
  
      # Return the snapshot from $all_snaps_ref that is closest to
      # $target_snap. $all_snaps_ref should be sorted from newest to
      # oldest.
  
      my $all_snaps_ref = shift // confess missing_arg();
      my $target_snap   = shift // confess missing_arg();
  
      my $snap;
  
      for (my $i = 0; $i <= $#{ $all_snaps_ref }; $i++) {
  	
  	my $this_snap = $all_snaps_ref->[$i];
  
  	my $cmp = cmp_snaps($this_snap, $target_snap);
  	
  	# if $this_snap is the same as $target_snap
  	if ($cmp == 0) {
  	    $snap = $this_snap;
  	    last;
  	}
  
  	# if $this_snap is older than $target_snap
  	if ($cmp == 1) {
  	    if ($i == 0) { # No previous snap. This is as close as were getting.
  		$snap = $this_snap;
  	    }
  	    else {
  		my $prev_snap = $all_snaps_ref->[$i-1];
  		$snap = snap_closer($target_snap, $prev_snap, $this_snap);
  	    }
  	    last;
  	}
      }
  
      if (not defined $snap) {
  	$snap = oldest_snap($all_snaps_ref);
      }
      
      return $snap;
  }
  
  sub snap_closer { # Has test. Is pure.
  
      # Return either $snap1 or $snap2, depending on which is closer to
      # $target_snap. If they are equidistant return $snap1.
  
      my $target_snap = shift // confess missing_arg();
      my $snap1       = shift // confess missing_arg();
      my $snap2       = shift // confess missing_arg();
  
      my $target_epoch = snapstring_to_time_piece_obj($target_snap)->epoch;
      my $snap1_epoch  = snapstring_to_time_piece_obj($snap1)->epoch;
      my $snap2_epoch  = snapstring_to_time_piece_obj($snap2)->epoch;
  
      my $v1 = abs($target_epoch - $snap1_epoch);
      my $v2 = abs($target_epoch - $snap2_epoch);
  
      if ($v1 <= $v2) { return $snap1 }
      else            { return $snap2 }
  }
  
  sub snaps_newer_than { # Has test. Is pure.
  
      # Return all the snapshots from $all_snaps_ref that are newer than
      # $target_snap. We assume that $all_snaps_ref is sorted from
      # newest to oldest.
  
      my $all_snaps_ref = shift // confess missing_arg();
      my $target_snap   = shift // confess missing_arg();
  
      my @newer = ();
  
      for (my $i = 0; $i <= $#{ $all_snaps_ref }; $i++) {
  
  	my $this_snap = $all_snaps_ref->[$i];
  
  	my $cmp = cmp_snaps($this_snap, $target_snap);  
  
  	# if $this_snap is newer than $target_snap
  	if ($cmp == -1) {
  	    push @newer, $this_snap;
  	}
  	else { last }
      }
  
      return wantarray ? @newer : \@newer;
  }
  
  sub snaps_older_than { # Has test. Is pure.
  
      # Return all the snapshots that are older than $target_snap.
  
      my $all_snaps_ref = shift // confess missing_arg();
      my $target_snap   = shift // confess missing_arg();
  
      my @older = ();
      
      my $last_idx = $#{ $all_snaps_ref };
  
      for (my $i = 0; $i <= $last_idx; $i++) {
  
  	my $this_snap = $all_snaps_ref->[$i];
  
  	my $cmp = cmp_snaps($this_snap, $target_snap);  
  
  	# if $this_snap is older than $target_snap
  	if ($cmp == 1) {
  	    @older = @$all_snaps_ref[$i .. $last_idx];
  	    last;
  	}
      }
  
      return wantarray ? @older : \@older;
  }
  
  sub snaps_between { # Has test. Is pure.
  
      # Return all of the snapshots between (inclusive) $target_snap1
      # and $target_snap2. Remember that $all_snaps_ref is sorted
      # newest to oldest.
  
      my $all_snaps_ref = shift // confess missing_arg();
      my $target_snap1  = shift // confess missing_arg();
      my $target_snap2  = shift // confess missing_arg();
  
      # figure out which target snap is newer/older.
  
      my $older;
      my $newer;
  
      if (-1 == cmp_snaps($target_snap1, $target_snap2)) {
  	$newer = $target_snap1;
  	$older = $target_snap2;
      }
      else {
  	$newer = $target_snap2;
  	$older = $target_snap1;
      }
  
      # Find the snaps between (inclusive) $newer and $older. Remember
      # that $all_snaps_ref is sorted newest to oldest.
  
      my @snaps_between = ();
  
      my $last_idx = $#{ $all_snaps_ref };
  
      for (my $i = 0; $i <= $last_idx; $i++) {
  
  	my $this_snap = $all_snaps_ref->[$i];
  
  	my $cmp = cmp_snaps($this_snap, $newer);
  
  	# if $this_snap is older or equal to the $newer
  	if ($cmp == 1 || $cmp == 0) {
  
  	    # between (inclusive)
  	    push @snaps_between, $this_snap if $cmp == 0;
  	    
  	    for (my $j = $i+1; $j <= $last_idx; $j++) {
  
  		my $this_snap = $all_snaps_ref->[$j];
  
  		my $cmp = cmp_snaps($this_snap, $older);
  
  		# if $this_snap is older than or equal to $older
  		if ($cmp == 1 || $cmp == 0) {
  
  		    # between (inclusive)
  		    push @snaps_between, $this_snap if $cmp == 0;
  
  		    # Were done. Break the inner loop. The outer loop
  		    # will be broken as well.
  		    last;
  		}
  
  		else {
  		    push @snaps_between, $this_snap;
  		}
  	    }
  	    
  	    last;
  	}
      }
  
      return wantarray ? @snaps_between : \@snaps_between;
  }
  
  sub newest_snap { # Has test. Is not pure.
  
      # $ref can be either an array ref to an array of sorted snapshots,
      # or a reference to the users config. If $ref is a ref to the
      # config this is because the caller wants to get the newest
      # snapshot of some subvol/backup, and thus will require an extra
      # argument denoting the desired subvol/backup.
  
      my $ref    = shift // confess missing_arg();
      my $subvol = shift; # only needed if $ref is $config_ref
  
      my $ref_type = ref($ref);
  
      if ($ref_type eq 'ARRAY') {
  	return $ref->[0]
      }
  
      if ($ref_type eq 'HASH') {
  	my $all_snaps_ref = all_snaps($ref, $subvol);
  	return $all_snaps_ref->[0];
      }
  
      confess "yabsm: internal error: '$ref' has ref type '$ref_type'";
  }
  
  sub oldest_snap { # Has test. Is not pure.
  
      # $ref can be either an array ref to an array of sorted snapshots,
      # or a reference to the users config. If $ref is a ref to the
      # config this is because the caller wants to get the oldest
      # snapshot of some subvol/backup, and thus will require an extra
      # argument denoting the desired subvol/backup.
      
      my $ref = shift // confess missing_arg();
  
      my $ref_type = ref($ref);
  
      if ($ref_type eq 'ARRAY') {
  	return $ref->[-1];
      }
  
      if ($ref_type eq 'HASH') {
  	my $subject = shift // confess missing_arg();
  	my $all_snaps_ref = all_snaps($ref, $subject);
  	return $all_snaps_ref->[-1];
      }
      
      confess "yabsm: internal error: '$ref' has ref type '$ref_type'";
  }
  
  sub answer_query { # No test. Is not pure.
  
      # Answers $query to find the appropiate snapshot(s) of
      # $subject. We expect that $query has already been
      # validated. $subject can either be a defined subvol or a backup.
  
      my $config_ref = shift // confess missing_arg();
      my $subject    = shift // confess missing_arg();
      my $query      = shift // confess missing_arg();
  
      my $all_snaps_ref = all_snaps($config_ref, $subject);
  
      my @snaps_to_return;
  
      if ($query eq 'all') {
  	
  	# return all the snaps
  
  	@snaps_to_return = @$all_snaps_ref;
      }
  
      elsif ($query eq 'newest') {
  
  	# return just the newest snap
  
  	my $snap = newest_snap($all_snaps_ref);
  
  	@snaps_to_return = ($snap);
      }
  
      elsif ($query eq 'oldest') {
  
  	# return just the oldest snap
  
  	my $snap = oldest_snap($all_snaps_ref);
  
  	@snaps_to_return = ($snap);
      }
  
      elsif (is_immediate($query)) {
  
  	# return the one snap closest to the time denoted by the immediate.
  
  	my $target = immediate_to_snapstring($query); 
  
  	my $snap = snap_closest_to($all_snaps_ref, $target);
  
  	@snaps_to_return = ($snap);
      }
  
      elsif (is_newer_than_query($query)) {
  
  	my (undef, $imm) = split /\s/, $query, 2;
  
  	my $target = immediate_to_snapstring($imm);
  
  	@snaps_to_return = snaps_newer_than($all_snaps_ref, $target);
      }
  
      elsif (is_older_than_query($query)) {
  
  	my (undef, $imm) = split /\s/, $query, 2;
  
  	my $target = immediate_to_snapstring($imm);
  
  	@snaps_to_return = snaps_older_than($all_snaps_ref, $target);
      }
  
      elsif (is_between_query($query)) {
  
  	my (undef, $imm1, $imm2) = split /\s/, $query, 3;
  
  	my $target1 = immediate_to_snapstring($imm1);
  
  	my $target2 = immediate_to_snapstring($imm2);
  
  	@snaps_to_return = snaps_between($all_snaps_ref, $target1, $target2);
      }
  
      else { # input should have already been cleansed
  	confess "yabsm: internal error: '$query' is not a valid query";
      }
  
      return wantarray ? @snaps_to_return : \@snaps_to_return;
  }
  
  sub is_valid_query { # Has test. Is pure.
  
      # True iff $query is a valid query. Used to validate 
      # user input query for 'yabsm find'.
  
      my $query = shift // confess missing_arg();
  
      if ($query eq 'all')             { return 1 }
      if ($query eq 'newest')          { return 1 }
      if ($query eq 'oldest')          { return 1 }
      if (is_immediate($query))        { return 1 }
      if (is_newer_than_query($query)) { return 1 }
      if (is_older_than_query($query)) { return 1 }
      if (is_between_query($query))    { return 1 }
  
      return 0;
  }
  
  sub is_newer_than_query { # Has test. Is pure.
  
      # Return 1 iff $query is a syntactically valid newer_than query.
      # A newer_than query returns all snapshots newer than some
      # immediate.  A newer_than query can be denoted by one of the
      # keywords 'newer', 'after', or 'aft'. A newer_than query takes
      # exactly one immediate as an argument.
  
      my $query = shift // confess missing_arg();
  
      my ($keyword, $imm) = split /\s/, $query, 2;
  
      return 0 if any { not defined } ($keyword, $imm);
  
      my $keyword_correct = $keyword =~ /^(newer|after|aft)$/;
  
      my $imm_correct = is_immediate($imm);
  
      return $keyword_correct && $imm_correct;
  }
  
  sub is_older_than_query { # Has test. Is pure.
  
      # Return 1 iff $query is a syntactically valid older_than query.
      # An older_than query returns all snapshots older than some
      # immediate. A older_than query can be denoted by one of the
      # keywords 'older', 'before', or 'bef'. An older_than query takes
      # exactly one immediate as an argument.
  
      my $query = shift // confess missing_arg();
  
      my ($keyword, $imm) = split /\s/, $query, 2;
  
      return 0 if any { not defined } ($keyword, $imm);
  
      my $keyword_correct = $keyword =~ /^(older|before|bef)$/;
  
      my $imm_correct = is_immediate($imm);
  
      return $keyword_correct && $imm_correct;
  }
  
  sub is_between_query { # Has test. Is pure.
  
      # Return 1 iff $query is a syntactically valid 'between' query.
      # A between query takes two immediate arguments and returns all
      # snapshots between the two immediate times. 
  
      my $query = shift // confess missing_arg();
  
      my ($keyword, $imm1, $imm2) = split /\s/, $query, 3;
  
      return 0 if any { not defined } ($keyword, $imm1, $imm2);
  
      my $keyword_correct = $keyword =~ /^bet(ween)?$/;
  
      my $imm1_correct = is_immediate($imm1);
  
      my $imm2_correct = is_immediate($imm2);
  
      return $keyword_correct && $imm1_correct && $imm2_correct;
  }
  
  sub all_timeframes { # Has test. Is pure.
  
      # Return an array of all yabsm timeframes.
  
      return qw(5minute hourly daily weekly monthly);
  }
  
  sub is_timeframe { # Has test. Is pure.
  
      # true if $tf is a yabsm timeframe.
  
      my $tf = shift // confess missing_arg();
  
      return any { $tf eq $_ } all_timeframes();
  }
  
  sub timeframe_want { # Has test. Is pure.
  
      # true iff $subvol wants to take $timeframe snapshots.
  
      my $config_ref = shift // confess missing_arg();
      my $subvol     = shift // confess missing_arg();
      my $timeframe  = shift // confess missing_arg();
  
      return 'yes' eq $config_ref->{subvols}{$subvol}{"${timeframe}_want"};
  }
  
  sub subvols_timeframes { # Has test. Is pure.
  
      # Return an array of all the timeframes that $subvol wants snapshots for.
  
      my $config_ref = shift // confess missing_arg();
      my $subvol     = shift // confess missing_arg();
      
      my @tfs = ();
  
      foreach my $tf (all_timeframes()) {
          if (timeframe_want($config_ref, $subvol, $tf)) {
              push @tfs, $tf;
          }
      }
  
      return wantarray ? @tfs : \@tfs;
  }
  
  sub all_subvols { # Has test. Is pure.
  
      # Return an array of the names of every user defined subvol.
  
      my $config_ref = shift // confess missing_arg();
  
      my @subvols = sort keys %{$config_ref->{subvols}};
  
      return wantarray ? @subvols : \@subvols;
  }
  
  sub all_backups { # Has test. Is pure.
  
      # Return an array of the names of every user defined backup.
  
      my $config_ref = shift // confess missing_arg();
  
      my @backups = sort keys %{$config_ref->{backups}};
  
      return wantarray ? @backups : \@backups;
  }
  
  sub all_backups_of_subvol { # Has test. Is pure.
  
      # Return an array of all the backups that are backing up $subvol.
  
      my $config_ref = shift // confess missing_arg();
      my $subvol     = shift // confess missing_arg();
  
      my @backups = ();
  
      foreach my $backup (all_backups($config_ref)) {
  	
  	my $this_subvol = $config_ref->{backups}{$backup}{subvol};
  
  	if ($this_subvol eq $subvol) {
  	    push @backups, $backup 
  	}
      }
  
      return wantarray ? @backups : \@backups;
  }
  
  sub is_subject { # Has test. Is pure.
  
      # True iff $subject is an existing user defined subject. A subject
      # is either a subvol or backup.
  
      my $config_ref = shift // confess missing_arg();
      my $subject    = shift // confess missing_arg();
  
      my $is_subvol = is_subvol($config_ref, $subject);
      my $is_backup = is_backup($config_ref, $subject);
  
      return $is_subvol || $is_backup;
  }
  
  sub is_subvol { # Has test. Is pure.
  
      # True iff $subvol is the name of a user defined subvol.
      
      my $config_ref = shift // confess missing_arg();
      my $subvol     = shift // confess missing_arg();
      
      return any { $subvol eq $_ } all_subvols($config_ref);
  }
  
  sub is_backup { # Has test. Is pure.
  
      # True iff $backup is the name of a user defined backup.
  
      my $config_ref = shift // confess missing_arg();
      my $backup     = shift // confess missing_arg();
  
      return any { $backup eq $_ } all_backups($config_ref);
  }
  
  sub is_remote_backup { # Has test. Is pure.
  
      # Return 1 iff $backup is the name of a defined local backup. A
      # local backup is one in which the backups 'remote' field is set
      # to 'yes'.
  
      my $config_ref = shift // confess missing_arg();
      my $backup     = shift // confess missing_arg();
  
      if (is_backup($config_ref, $backup)) {
  	return $config_ref->{backups}{$backup}{remote} eq 'yes';
      }
  
      else { return 0 }
  }
  
  sub schedule_snapshots { # No test. Is not pure.
  
      #TODO
      my $config_ref     = shift // confess missing_arg();
      my $cron_scheduler = shift // confess missing_arg();
  
      foreach my $subvol (Yabsm::Base::all_subvols($config_ref)) {
          
          my $_5minute_want = $config_ref->{subvols}{$subvol}{'5minute_want'};
          my $hourly_want   = $config_ref->{subvols}{$subvol}{hourly_want};
          my $daily_want    = $config_ref->{subvols}{$subvol}{daily_want};
          my $weekly_want   = $config_ref->{subvols}{$subvol}{weekly_want};
          my $monthly_want  = $config_ref->{subvols}{$subvol}{monthly_want};
  
          if ($_5minute_want eq 'yes') {
              $cron_scheduler->add_entry(
                  "*/5 * * * *",
                  sub { do_snapshot($config_ref, $subvol, '5minute') }
              );
          }
  
          if ($hourly_want eq 'yes') {
              $cron_scheduler->add_entry(
                  "0 */1 * * *",
                  sub { do_snapshot($config_ref, $subvol, 'hourly') }
              );
          }
  
          if ($daily_want eq 'yes') {
              my $time = $config_ref->{subvols}{$subvol}{daily_time};
              my $hr   = time_hour($time);
              my $min  = time_minute($time);
              $cron_scheduler->add_entry(
                  "$min $hr * * *",
                  sub { do_snapshot($config_ref, $subvol, 'daily') }
              );
          }
  
          if ($weekly_want eq 'yes') {
              my $time = $config_ref->{subvols}{$subvol}{weekly_time};
              my $hr   = time_hour($time);
              my $min  = time_minute($time);
              my $dow  = day_of_week_num($config_ref->{subvols}{$subvol}{weekly_day});
              $cron_scheduler->add_entry(
                  "$min $hr * * $dow",
                  sub { do_snapshot($config_ref, $subvol, 'weekly') }
              );
          }
  
          if ($monthly_want eq 'yes') {
              my $time = $config_ref->{subvols}{$subvol}{monthly_time};
              my $hr   = time_hour($time);
              my $min  = time_minute($time);
              $cron_scheduler->add_entry(
                  "$min $hr 1 * *",
                  sub { do_snapshot($config_ref, $subvol, 'monthly') }
              );
          }
      }
  }
  
  sub schedule_backups { # No test. Is not pure.
  
      #TODO
      my $config_ref     = shift // confess missing_arg();
      my $cron_scheduler = shift // confess missing_arg();
  
      foreach my $backup (Yabsm::Base::all_backups($config_ref)) {
  
          my $timeframe = $config_ref->{backups}{$backup}{timeframe};
  
          if ($timeframe eq '5minute') {
              $cron_scheduler->add_entry(
                  "*/5 * * * *",
                  sub { Yabsm::Base::do_incremental_backup($config_ref, $backup) }
              );
          }
  
          elsif ($timeframe eq 'hourly') {
              $cron_scheduler->add_entry(
                  "0 */1 * * *",
                  sub { Yabsm::Base::do_incremental_backup($config_ref, $backup) }
              );
          }
  
          elsif ($timeframe eq 'daily') {
              my $time = $config_ref->{backups}{$backup}{time};
              my $hr   = Yabsm::Base::time_hour($time);
              my $min  = Yabsm::Base::time_minute($time);
              $cron_scheduler->add_entry(
                  "$min $hr * * *",
                  sub { Yabsm::Base::do_incremental_backup($config_ref, $backup) }
              );
          }
  
          elsif ($timeframe eq 'weekly') {
              my $time = $config_ref->{backups}{$backup}{time};
              my $hr   = Yabsm::Base::time_hour($time);
              my $min  = Yabsm::Base::time_minute($time);
              my $dow  = Yabsm::Base::day_of_week_num($config_ref->{backups}{$backup}{day});
              $cron_scheduler->add_entry(
                  "$min $hr * * $dow",
                  sub { Yabsm::Base::do_incremental_backup($config_ref, $backup) }
              );
          }
  
          elsif ($timeframe eq 'monthly') {
              my $time = $config_ref->{backups}{$backup}{time};
              my $hr   = Yabsm::Base::time_hour($time);
              my $min  = Yabsm::Base::time_minute($time);
              $cron_scheduler->add_entry(
                  "$min $hr 1 * *",
                  sub { Yabsm::Base::do_incremental_backup($config_ref, $backup) }
              );
          }
      }
  }
  
  sub is_local_backup { # Has test. Is pure.
  
      # Return 1 iff $backup is the name of a defined local backup. A
      # local backup is one in which the backups 'remote' field is set
      # to 'no'.
  
      my $config_ref = shift // confess missing_arg();
      my $backup     = shift // confess missing_arg();
  
      if (is_backup($config_ref, $backup)) {
  	return $config_ref->{backups}{$backup}{remote} eq 'no';
      }
  
      else { return 0 }
  }
  
  sub new_ssh_connection { # No test. Is not pure.
  
      # Create and return a Net::OpenSSH connection object. Kill the
      # program if we cannot establish a connection to $remote host.
  
      my $remote_host = shift // confess missing_arg();
  
      my $ssh = Net::OpenSSH->new( $remote_host,
  			       , batch_mode => 1 # Don't try asking for password
  			       , timeout => 30   # timeout after 30 seconds
  			       , kill_ssh_on_timeout => 1
  			       );
  
      $ssh->error and
        die 'yabsm: ssh error: could not establish passwordless SSH connection: ' . $ssh->error . "\n";
      
      return $ssh;
  }
  
  sub is_day_of_week { # Has test. Is pure.
  
      # Return 1 iff $dow is a valid day of week string. A day of week
      # can either be the full name of the day or just the first 3
      # letters and must be all lowercase letters.
  
      my $dow = shift // confess missing_arg();
  
      my $mon = 'monday';
      my $tue = 'tuesday';
      my $wed = 'wednesday';
      my $thu = 'thursday';
      my $fri = 'friday';
      my $sat = 'saturday';
      my $sun = 'sunday';
  
      return $dow =~ /^($mon|$tue|$wed|$thu|$fri|$sat|$sun)$/;
  }
  
  sub day_of_week_num { # Has test. Is pure.
  
      # Take day of week string ($dow) and return the cooresponding
      # number in the week. We consider monday the first day because
      # cronjobs do, and this function is used to generate cron
      # strings. We expect $dow to have already been cleansed.
  
      my $dow = shift // confess missing_arg();
  
      if    ($dow eq 'monday')    { return 1 }
      elsif ($dow eq 'tuesday')   { return 2 }
      elsif ($dow eq 'wednesday') { return 3 }
      elsif ($dow eq 'thursday')  { return 4 }
      elsif ($dow eq 'friday')    { return 5 }
      elsif ($dow eq 'saturday')  { return 6 }
      elsif ($dow eq 'sunday')    { return 7 }
      else {
          confess "yabsm: internal error: no such day of week '$dow'";
      }
  }
  
  sub all_days_of_week { # No test. Is pure.
  
      # Return all the valid days of the week.
  
      return qw(monday tuesday wednesday thursday friday saturday sunday);
  }
  
  sub missing_arg { 
      return 'yabsm: internal error: subroutine missing a required arg';
  }
  
  1;
YABSM_BASE

$fatpacked{"Yabsm/Commands/CheckConfig.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YABSM_COMMANDS_CHECKCONFIG';
  #  Author:  Nicholas Hubbard
  #  WWW:     https://github.com/NicholasBHubbard/yabsm
  #  License: MIT
  
  #  Check if a config file is a valid yabsmrc file. If no config file
  #  argument is passed then check /etc/yabsmrc. If the config is
  #  erroneous print all errors to stderr and exit with nonzero status.
  #  Else print 'all good' to stdout.
  
  package Yabsm::Commands::CheckConfig;
  
  use strict;
  use warnings;
  use v5.16.3;
  
  # located using lib::relative in yabsm.pl
  use Yabsm::Config;
  
  sub die_usage {
      die "usage: yabsm check-config <?FILE>\n";
  }
  
  sub main {
  
      my $file = shift // '/etc/yabsmd.conf';
  
      die_usage() if @_;
  
      # read_config() will kill the program with error
      # messages if the config is erroneous.
      Yabsm::Config::read_config( $file );
  
      say 'all good';
  
      return;
  }
  
  1;
YABSM_COMMANDS_CHECKCONFIG

$fatpacked{"Yabsm/Commands/Find.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YABSM_COMMANDS_FIND';
  #  Author:  Nicholas Hubbard
  #  WWW:     https://github.com/NicholasBHubbard/yabsm
  #  License: MIT
  
  #  Find one or more snapshots of a subvol or backup by applying a query.
  #  See the yabsm manual for a detailed explanation on queries.
  
  package Yabsm::Commands::Find;
  
  use strict;
  use warnings;
  use v5.16.3;
  
  # located using lib::relative in yabsm.pl
  use Yabsm::Base;
  use Yabsm::Config;
  
  sub die_usage {
      die "usage: yabsm find <SUBVOL> <QUERY>\n";
  }
  
  sub main {
  
      my $subject = shift // die_usage();
      my $query   = shift // die_usage();
  
      die_usage() if @_;
  
      my $config_ref = Yabsm::Config::read_config();
  
      if (not Yabsm::Base::is_subject($config_ref, $subject)) {
  	die "yabsm: error: '$subject' is not a defined subvol or backup\n";
      }
  
      if (not Yabsm::Base::is_valid_query($query)) {
  	die "yabsm: error: '$query' is not a valid query\n"
      }
  
      my @snapshots = Yabsm::Base::answer_query($config_ref, $subject, $query);
  
      say for @snapshots;
  
      return;
  }
  
  1;
YABSM_COMMANDS_FIND

$fatpacked{"Yabsm/Commands/PrintBackups.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YABSM_COMMANDS_PRINTBACKUPS';
  #  Author:  Nicholas Hubbard
  #  WWW:     https://github.com/NicholasBHubbard/yabsm
  #  License: MIT
  
  #  Print the names of all user defined backups separated by newlines.
  
  package Yabsm::Commands::PrintBackups;
  
  use strict;
  use warnings;
  use v5.16.3;
  
  # located using lib::relative in yabsm.pl
  use Yabsm::Base;
  use Yabsm::Config;
  
  sub die_usage {
      die "usage: yabsm print-backups\n";
  }
  
  sub main {
  
      die_usage() if @_;
  
      my $config_ref = Yabsm::Config::read_config();
  
      my @all_backups = Yabsm::Base::all_backups($config_ref);
  
      say for @all_backups;
  
      return;
  }
  
  1;
YABSM_COMMANDS_PRINTBACKUPS

$fatpacked{"Yabsm/Commands/PrintSubvols.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YABSM_COMMANDS_PRINTSUBVOLS';
  #  Author:  Nicholas Hubbard
  #  WWW:     https://github.com/NicholasBHubbard/yabsm
  #  License: MIT
  
  #  Print the names of all user defined subvols separated by newlines.
  
  package Yabsm::Commands::PrintSubvols;
  
  use strict;
  use warnings;
  use v5.16.3;
  
  # located using lib::relative in yabsm.pl
  use Yabsm::Base;
  use Yabsm::Config;
  
  sub die_usage {
      die "usage: yabsm print-subvols\n";
  }
  
  sub main {
  
      die_usage() if @_;
  
      my $config_ref = Yabsm::Config::read_config();
  
      my @all_subvols = Yabsm::Base::all_subvols($config_ref);
  
      say for @all_subvols;
  
      return;
  }
  
  1;
YABSM_COMMANDS_PRINTSUBVOLS

$fatpacked{"Yabsm/Commands/TestRemoteBackupConfig.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YABSM_COMMANDS_TESTREMOTEBACKUPCONFIG';
  #  Author:  Nicholas Hubbard
  #  WWW:     https://github.com/NicholasBHubbard/yabsm
  #  License: MIT
  #
  #  A valid remote backup config is setup so the root user can connect
  #  to the remote host and run btrfs with sudo without having to enter
  #  any passwords.
  
  package Yabsm::Commands::TestRemoteBackupConfig;
  
  use strict;
  use warnings;
  use v5.16.3;
  
  # located using lib::relative in yabsm.pl
  use Yabsm::Base;
  use Yabsm::Config;
  
  sub die_usage {
      die "usage: yabsm test-remote-backup <BACKUP>\n";
  }
  
  sub main {
  
      die "yabsm: error: permission denied\n" if $<;
  
      my $backup = shift // die_usage();
  
      die_usage() if @_;
  
      my $config_ref = Yabsm::Config::read_config();
  
      if (not Yabsm::Base::is_backup($config_ref, $backup)) {
  	die "yabsm: error: no such defined backup '$backup'\n";
      }
  
      if (Yabsm::Base::is_local_backup($config_ref, $backup)) {
  	die "yabsm: error: backup '$backup' is a local backup\n";
      }
  
      my $host = $config_ref->{backups}{$backup}{host};
  
      # new_ssh_connection() will kill the program if a passwordless
      # connection cannot be established.
      my $ssh = Yabsm::Base::new_ssh_connection( $host );
  
      # make sure user can use btrfs with non-interactive sudo
      if (my $out = $ssh->capture('sudo -n btrfs --help 2>&1 1>/dev/null')) {
          chomp $out;
          die "$out\n";
      }
  
      # make sure user has read/write permissions on the remote backup_dir
      my $backup_dir = $config_ref->{backups}{$backup}{backup_dir};
  
      my $backup_dir_exists =  
        "if ! [ -d $backup_dir ]; then "
      . qq(echo -n "yabsm: error: no such directory '$backup_dir' at host '$host'"; fi);
      
      if (my $out = $ssh->capture( $backup_dir_exists )) {
          die "$out\n";
      }
  
      say 'all good';
  
      return;
  }
  
  1;
YABSM_COMMANDS_TESTREMOTEBACKUPCONFIG

$fatpacked{"Yabsm/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YABSM_CONFIG';
  #  Author:  Nicholas Hubbard
  #  WWW:     https://github.com/NicholasBHubbard/yabsm
  #  License: MIT
  
  #  This module exists to provide the read_config() subroutine that is
  #  used to create the $config_ref variable that is passed around the
  #  rest of yabsm constantly. See t/Config.t for this modules testing.
  
  package Yabsm::Config;
  
  use strict;
  use warnings;
  use v5.16.3;
  
  use Exporter 'import';
  our @EXPORT_OK = qw( read_config );
  
  # located using lib::relative in yabsm.pl
  use lib::relative '..';
  use Yabsm::Base;
  
  use Carp;
  use Array::Utils 'array_minus';
  
  use Parser::MGC;
  use base 'Parser::MGC';
  
                   ####################################
                   #         REGEX LOOKUP TABLE       #
                   ####################################
  
  my %regex = ( path         => qr/\/[^#\s]*/
              , subject_name => qr/[a-zA-Z][-\w]*/
              , ssh_host     => qr/[-@.\/\w]+/
              , comment      => qr/#.*/
              , pos_int      => qr/[1-9]\d*/
              , time         => qr/(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]/
              );
  
                   ####################################
                   #          MAIN SUBROUTINE         #
                   ####################################
  
  sub read_config {
  
      my $file = shift // '/etc/yabsmd.conf';
  
      # see documentation of Parser::MGC to see what is going on here
      my $parser = __PACKAGE__->new( toplevel => 'p'
                                   , patterns => { comment => $regex{comment}
                                                 , ident   => qr/[-\w]+/
                                                 }
                                   );
  
      my $config_ref = $parser->from_file($file);
  
      my @errors = ();
  
      push @errors, $_ for missing_subvol_settings($config_ref);
      push @errors, $_ for missing_backup_settings($config_ref);
      push @errors, $_ for missing_misc_settings($config_ref);
  
      if (@errors) {
          die ((join "\n", @errors) . "\n");
      }
  
      return $config_ref;
  }
  
                   ####################################
                   #              PARSER              #
                   ####################################
  
  sub p {
  
      my $self = shift // Yabsm::Base::missing_arg();
  
      my %config;
  
      $self->sequence_of( sub {
          $self->commit;
          $self->any_of(
              sub {
                  $self->token_kw( 'subvol' );
                  $self->commit;
                  my $name = $self->maybe_expect( $regex{subject_name} );
                  $name // $self->fail('expected alphanumeric sequence starting with letter');
                  my $kvs  = $self->scope_of('{', 'subvol_def_p', '}');
                  $config{subvols}{$name} = $kvs;
              },
              sub {                     
                  $self->token_kw( 'backup' );
                  $self->commit;
                  my $name = $self->maybe_expect( $regex{subject_name} );
                  $name // $self->fail('expected alphanumeric sequence starting with letter');
                  my $kvs  = $self->scope_of('{', 'backup_def_p', '}');
                  $config{backups}{$name} = $kvs;
              },
              sub { 
                  my $k = $self->token_kw( misc_keywords() );
                  $self->commit;
                  $self->maybe_expect( '=' ) // $self->fail("expected '='");
                  my $v;
                  # the only misc setting at this time is 'yabsm_dir'
                  if ($k eq 'yabsm_dir') {
                      $v = $self->maybe_expect( $regex{path} );
                      $v // $self->fail('expected file path');
                  }
                  else {
                      confess "internal error: no such misc setting '$k'";
                  }
                  $config{misc}{$k} = $v;
              },
              sub {
                  $self->commit;
                  $self->fail('could not parse subvol, backup or misc setting');
              }
          );
      });
  
      return \%config;
  }
  
  sub subvol_def_p {
  
      my $self = shift // Yabsm::Base::missing_arg();
  
      my %kvs; # return this
      my $k;
      my $v;
  
      $self->sequence_of( sub {
          $self->commit;
          $k = $self->token_kw( subvol_keywords() );
          $self->maybe_expect( '=' ) // $self->fail("expected '='");
          if ($k eq 'mountpoint') {
              $v = $self->maybe_expect( $regex{path} );
              $v // $self->fail('expected file path');
          }
          elsif ($k =~ /_want$/) {
              $v = $self->maybe( sub { $self->token_kw( 'yes', 'no' ) } );
              $v // $self->fail( q(expected 'yes' or 'no') );
          }
          elsif ($k =~ /_time$/) {
              $v = $self->maybe_expect( $regex{time} );
              $v // $self->fail(q(expected time in format 'hh:mm'));
          }
          elsif ($k =~ /_keep$/) {
              $v = $self->maybe_expect( $regex{pos_int} );
              $v // $self->fail('expected positive integer');
          }
          elsif ($k eq 'weekly_day') {
              $v = $self->token_kw( Yabsm::Base::all_days_of_week() );
          }
          else {
              confess "yabsm: internal error: no such subvol setting '$k'";
          }
  
          $kvs{ $k } = $v;
      });
  
      return \%kvs;
  }
  
  sub backup_def_p {
  
      my $self = shift // Yabsm::Base::missing_arg();
  
      my %kvs; # return this
      my $k;
      my $v;
  
      $self->sequence_of( sub {
          $self->commit;
          $k = $self->token_kw( backup_keywords() );
          $self->maybe_expect( '=' ) // $self->fail("expected '='");
  
          if ($k eq 'remote') {
              $v = $self->maybe( sub { $self->token_kw( 'yes', 'no' ) } );
              $v // $self->fail( q(expected 'yes' or 'no') );
          }
          elsif ($k eq 'timeframe') {
              $v = $self->token_kw( Yabsm::Base::all_timeframes() );
          }
          elsif ($k eq 'time') {
              $v = $self->maybe_expect( $regex{time} );
              $v // $self->fail(q(expected time in format 'hh:mm'));
          }
          elsif ($k eq 'backup_dir') {
              $v = $self->maybe_expect( $regex{path} );
              $v // $self->fail('expected file path');
          }
          elsif ($k eq 'keep') {
              $v = $self->maybe_expect( $regex{pos_int} );
              $v // $self->fail('expected positive integer');
          }
          elsif ($k eq 'host') {
              $v = $self->maybe_expect( $regex{ssh_host} );
              $v // $self->fail('expected alphanumeric sequence starting with a letter');
          }
          elsif ($k eq 'subvol') {
              # We check that $v is a defined subvol later
              $v = $self->maybe_expect( $regex{subject_name} );
              $v // $self->fail('expected alphanumeric sequence starting with a letter');
          }
          elsif ($k eq 'day') {
              $v = $self->token_kw( Yabsm::Base::all_days_of_week() );
          }
          else {
              confess "yabsm: internal error: no such backup setting '$k'";
          }
  
          $kvs{ $k } = $v;
      });
  
      return \%kvs;
  }
  
                   ####################################
                   #       STATIC CONFIG ANALYSIS     #
                   ####################################
  
  sub missing_subvol_settings {
  
      my $config_ref = shift // Yabsm::Base::missing_arg();
  
      my @err_msgs = ();
  
      for my $subvol (Yabsm::Base::all_subvols($config_ref)) {
  
          # base required settings
          my @req = qw(mountpoint 5minute_want hourly_want daily_want weekly_want monthly_want);
  
          my @def = keys %{ $config_ref->{subvols}{$subvol} };
  
          if (my @missing = array_minus(@req, @def)) {
              push @err_msgs, "yabsm: config error: subvol '$subvol' missing required setting '$_'" for @missing;
          }
  
          else { # the base required settings are defined
  
              for my $tframe (Yabsm::Base::subvols_timeframes($config_ref, $subvol)) {
                  if ($tframe eq '5minute') {
                      push @req, '5minute_keep';
                  }
                  elsif ($tframe eq 'hourly') {
                      push @req, 'hourly_keep';
                  }
                  elsif ($tframe eq 'daily') {
                      push @req, 'daily_time', 'daily_keep';
                  }
                  elsif ($tframe eq 'weekly') {
                      push @req, 'weekly_time', 'weekly_day', 'weekly_keep';
                  }
                  elsif ($tframe eq 'monthly') {
                      push @req, 'monthly_time', 'monthly_keep';
                  }
                  else {
                      confess "yabsm: internal error: no such timeframe '$tframe'";
                  }
              }
  
              my @def = keys %{ $config_ref->{subvols}{$subvol} };
  
              if (my @missing = array_minus(@req, @def)) {
                  push @err_msgs, "error: subvol '$subvol' missing required setting '$_'" for @missing;
              }
          }
      }
  
      return @err_msgs;
  }
  
  sub missing_backup_settings {
  
      my $config_ref = shift // Yabsm::Base::missing_arg();
  
      my @err_msgs = ();
  
      for my $backup (Yabsm::Base::all_backups($config_ref)) {
  
          # base required settings
          my @req = qw(remote subvol backup_dir timeframe keep);
  
          my @def = keys %{ $config_ref->{backups}{$backup} };
  
          if (my @missing = array_minus(@req, @def)) {
              push @err_msgs, "yabsm: config error: backup '$backup' missing required setting '$_'" for @missing;
          }
  
          else { # the base required settings are defined
  
              my $subvol = $config_ref->{backups}{$backup}{subvol};
              my $remote = $config_ref->{backups}{$backup}{remote};
              my $tframe = $config_ref->{backups}{$backup}{timeframe};
  
              if (not grep { $subvol eq $_ } Yabsm::Base::all_subvols($config_ref)) {
                  push @err_msgs, "yabsm: config error: backup '$backup' backing up undefined subvol '$subvol'";
              }
  
              if ($remote eq 'yes') {
                  push @req, 'host';
              }
  
              if ($tframe eq 'weekly') {
                  push @req, 'time', 'day';
              }
  
              if ($tframe eq 'daily' || $tframe eq 'monthly') {
                  push @req, 'time';
              }
  
              if (my @missing = array_minus(@req, @def)) {
                  push @err_msgs, "yabsm: config error: backup '$backup' missing required setting '$_'" for @missing;
              }
          }
      }
  
      return @err_msgs;
  }
  
  sub missing_misc_settings {
  
      my $config_ref = shift // Yabsm::Base::missing_arg();
  
      my @err_msgs = ();
  
      # for now all misc settings are required
      my @req = misc_keywords();
  
      my @def = keys %{ $config_ref->{misc} };
  
      my @missing = array_minus(@req, @def);
  
      push @err_msgs, "yabsm: config error: missing misc setting '$_'" for @missing;
  
      return @err_msgs;
  }
  
                   ####################################
                   #              KEYWORDS            #
                   ####################################
  
  sub subvol_keywords {
      return qw(mountpoint 5minute_want 5minute_keep hourly_want hourly_keep daily_want daily_time daily_keep weekly_want weekly_time weekly_day weekly_keep monthly_want monthly_time monthly_keep);
  }
  
  sub backup_keywords {
      return qw(subvol remote host keep backup_dir timeframe time day);
  }
  
  sub misc_keywords {
      return qw(yabsm_dir);
  }
  
  1;
YABSM_CONFIG

$fatpacked{"lib/relative.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIB_RELATIVE';
  package lib::relative;
  
  use strict;
  use warnings;
  use Cwd ();
  use File::Basename ();
  use File::Spec ();
  use lib ();
  
  our $VERSION = '1.000';
  
  sub import {
    my ($class, @paths) = @_;
    my $file = (caller)[1];
    my $dir = -e $file ? File::Basename::dirname(Cwd::abs_path $file) : Cwd::getcwd;
    lib->import(map { File::Spec->file_name_is_absolute($_) ? $_ : File::Spec->catdir($dir, $_) } @paths);
  }
  
  1;
  
  =head1 NAME
  
  lib::relative - Add paths relative to the current file to @INC
  
  =head1 SYNOPSIS
  
    # Path is relative to this file, not current working directory
    use lib::relative 'path/to/lib';
    use lib::relative '../../lib';
    
    # Add two lib paths, as in lib.pm
    use lib::relative 'foo', 'bar';
    
    # Absolute paths are passed through unchanged
    use lib::relative 'foo/baz', '/path/to/lib';
    
    # Equivalent code using core modules
    use Cwd ();
    use File::Basename ();
    use File::Spec ();
    use lib File::Spec->catdir(File::Basename::dirname(Cwd::abs_path __FILE__), 'path/to/lib');
  
  =head1 DESCRIPTION
  
  Adding a path to L<@INC|perlvar/"@INC"> to load modules from a local directory
  may seem simple, but has a few common pitfalls to be aware of. Directly adding
  a relative path to C<@INC> means that any later code that changes the current
  working directory will change where modules are loaded from. This applies to
  the C<.> path that used to be in C<@INC> by default until perl 5.26.0, or a
  relative path added in code like C<use lib 'path/to/lib'>, and may be a
  vulnerability if such a location is not supposed to be writable. Additionally,
  the commonly used L<FindBin> module relies on interpreter state and the path to
  the original script invoked by the perl interpreter, sometimes requiring
  workarounds in uncommon cases like generated or embedded code. This module
  proposes a more straightforward method: take a path relative to the
  L<current file|perldata/"Special Literals">, absolutize it, and add it to
  C<@INC>.
  
  If this module is already available to be loaded, it can be used as with
  L<lib>.pm, passing relative paths, which will be absolutized relative to the
  current file then passed on to L<lib>. Multiple arguments will be separately
  absolutized, and absolute paths will be passed on unchanged.
  
  For cases where this module cannot be loaded beforehand, the last section of
  the L</"SYNOPSIS"> can be copy-pasted into a file to perform the same task.
  
  =head1 CAVEATS
  
  Due to C<__FILE__> possibly being a path relative to the current working
  directory, be sure to use C<lib::relative> or the equivalent code from
  L</"SYNOPSIS"> as early as possible in the file. If a C<chdir> occurs before
  this code, it will add the incorrect directory path.
  
  All file paths are expected to be in a format appropriate to the current
  operating system, e.g. C<..\\foo\\bar> on Windows. L<File::Spec/"catdir"> can
  be used to form directory paths portably.
  
  =head1 BUGS
  
  Report any issues on the public bugtracker.
  
  =head1 AUTHOR
  
  Dan Book <dbook@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2017 by Dan Book.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =head1 SEE ALSO
  
  L<lib>, L<FindBin>, L<Dir::Self>
LIB_RELATIVE

$fatpacked{"x86_64-linux/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL';
  # List::Util.pm
  #
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # This module is normally only loaded if the XS module is not available
  
  package List::Util;
  
  use strict;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall reduce sum sum0 shuffle
    pairmap pairgrep pairfirst pairs pairkeys pairvalues
  );
  our $VERSION    = "1.33";
  our $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  sub sum0
  {
     return 0 unless @_;
     goto &sum;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(first max maxstr min minstr reduce shuffle sum);
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have
  expressed would be nice to have in the perl core, but the usage would
  not really be high enough to warrant the use of a keyword, and the size
  so small such that being individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 reduce BLOCK LIST
  
  Reduces LIST by calling BLOCK, in a scalar context, multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a>
  and C<$b> set to the first two elements of the list, subsequent
  calls will be done by setting C<$a> to the result of the previous
  call and C<$b> to the next element in the list.
  
  Returns the result of the last call to BLOCK. If LIST is empty then
  C<undef> is returned. If LIST only contains one element then that
  element is returned and BLOCK is not executed.
  
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
  If your algorithm requires that C<reduce> produce an identity value, then
  make sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The remaining list-reduction functions are all specialisations of this
  generic idea.
  
  =head2 any BLOCK LIST
  
  Similar to C<grep> in that it evaluates BLOCK setting C<$_> to each element
  of LIST in turn. C<any> returns true if any element makes the BLOCK return a
  true value. If BLOCK never returns true or LIST was empty then it returns
  false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  =head2 all BLOCK LIST
  
  Similar to C<any>, except that it requires all elements of the LIST to make
  the BLOCK return true. If any element returns false, then it returns true. If
  the BLOCK never returns false or the LIST was empty then it returns true.
  
  =head2 none BLOCK LIST
  
  =head2 notall BLOCK LIST
  
  Similar to C<any> and C<all>, but with the return sense inverted. C<none>
  returns true if no value in the LIST causes the BLOCK to return true, and
  C<notall> returns true if not all of the values do.
  
  =head2 first BLOCK LIST
  
  Similar to C<grep> in that it evaluates BLOCK setting C<$_> to each element
  of LIST in turn. C<first> returns the first element where the result from
  BLOCK is a true value. If BLOCK never returns true or LIST was empty then
  C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { defined($a) ? $a : wanted($b) ? $b : undef } undef, @list
  
  for example wanted() could be defined() which would return the first
  defined value in @list
  
  =head2 max LIST
  
  Returns the entry in the list with the highest numerical value. If the
  list is empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { $a > $b ? $a : $b } 1..10
  
  =head2 maxstr LIST
  
  Similar to C<max>, but treats all the entries in the list as strings
  and returns the highest string as defined by the C<gt> operator.
  If the list is empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'
  
  =head2 min LIST
  
  Similar to C<max> but returns the entry in the list with the lowest
  numerical value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { $a < $b ? $a : $b } 1..10
  
  =head2 minstr LIST
  
  Similar to C<min>, but treats all the entries in the list as strings
  and returns the lowest string as defined by the C<lt> operator.
  If the list is empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { $a lt $b ? $a : $b } 'A'..'Z'
  
  =head2 sum LIST
  
  Returns the sum of all the elements in LIST. If LIST is empty then
  C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { $a + $b } 1..10
  
  =head2 sum0 LIST
  
  Similar to C<sum>, except this returns 0 when given an empty list, rather
  than C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume
  an even-sized list of pairs. The pairs may be key/value associations from a
  hash, or just a list of values. The functions will all preserve the original
  ordering of the pairs, and will not be confused by multiple pairs having the
  same "key" value - nor even do they require that the first of each pair be a
  plain string.
  
  =cut
  
  =head2 pairgrep BLOCK KVLIST
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the BLOCK multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  KVLIST.
  
  Returns an even-sized list of those pairs for which the BLOCK returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size
  of the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  Similar to C<grep>, C<pairgrep> aliases C<$a> and C<$b> to elements of the
  given list. Any modifications of it by the code block will be visible to
  the caller.
  
  =head2 pairfirst BLOCK KVLIST
  
  Similar to the C<first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the BLOCK multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  KVLIST.
  
  Returns the first pair of values from the list for which the BLOCK returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  Similar to C<grep>, C<pairfirst> aliases C<$a> and C<$b> to elements of the
  given list. Any modifications of it by the code block will be visible to
  the caller.
  
  =head2 pairmap BLOCK KVLIST
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the BLOCK multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  KVLIST.
  
  Returns the concatenation of all the values returned by the BLOCK in list
  context, or the count of the number of items that would have been returned
  in scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  Similar to C<map>, C<pairmap> aliases C<$a> and C<$b> to elements of the
  given list. Any modifications of it by the code block will be visible to
  the caller.
  
  =head2 pairs KVLIST
  
  A convenient shortcut to operating on even-sized lists of pairs, this
  function returns a list of ARRAY references, each containing two items from
  the given list. It is a more efficient version of
  
      pairmap { [ $a, $b ] } KVLIST
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach ( pairs @KVLIST ) {
         my ( $key, $value ) = @$_;
         ...
      }
  
  =head2 pairkeys KVLIST
  
  A convenient shortcut to operating on even-sized lists of pairs, this
  function returns a list of the the first values of each of the pairs in
  the given list. It is a more efficient version of
  
      pairmap { $a } KVLIST
  
  =head2 pairvalues KVLIST
  
  A convenient shortcut to operating on even-sized lists of pairs, this
  function returns a list of the the second values of each of the pairs in
  the given list. It is a more efficient version of
  
      pairmap { $b } KVLIST
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 shuffle LIST
  
  Returns the elements of LIST in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =cut
  
  =head1 KNOWN BUGS
  
  With perl versions prior to 5.005 there are some cases where reduce
  will return an incorrect result. This will show up as test 7 of
  reduce.t failing.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
X86_64-LINUX_LIST_UTIL

$fatpacked{"x86_64-linux/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use List::Util;
  
  our $VERSION = "1.33";       # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_LIST_UTIL_XS

$fatpacked{"x86_64-linux/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SCALAR_UTIL';
  # Scalar::Util.pm
  #
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Scalar::Util;
  
  use strict;
  require Exporter;
  require List::Util; # List::Util loads the XS
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed
    dualvar
    isdual
    isvstring
    isweak
    looks_like_number
    openhandle
    readonly
    refaddr
    reftype
    set_prototype
    tainted
    weaken
  );
  our $VERSION    = "1.33";
  $VERSION   = eval $VERSION;
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have
  expressed would be nice to have in the perl core, but the usage would
  not really be high enough to warrant the use of a keyword, and the size
  so small such that being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines. The
  subroutines defined are
  
  =head2 blessed EXPR
  
  If EXPR evaluates to a blessed reference the name of the package
  that it is blessed into is returned. Otherwise C<undef> is returned.
  
     $scalar = "foo";
     $class  = blessed $scalar;           # undef
  
     $ref    = [];
     $class  = blessed $ref;              # undef
  
     $obj    = bless [], "Foo";
     $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet
  false.
  
  =head2 dualvar NUM, STRING
  
  Returns a scalar that has the value NUM in a numeric context and the
  value STRING in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 isdual EXPR
  
  If EXPR is a scalar that is a dualvar, the result is true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content
  through numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be dual-valued variable, it is
  actually implemented using a tied scalar:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 isvstring EXPR
  
  If EXPR is a scalar which was coded as a vstring the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 looks_like_number EXPR
  
  Returns true if perl thinks EXPR is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 openhandle FH
  
  Returns FH if FH may be used as a filehandle and is open, or FH is a tied
  handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 readonly SCALAR
  
  Returns true if SCALAR is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 refaddr EXPR
  
  If EXPR evaluates to a reference the internal memory address of
  the referenced value is returned. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 reftype EXPR
  
  If EXPR evaluates to a reference the type of the variable referenced
  is returned. Otherwise C<undef> is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 set_prototype CODEREF, PROTOTYPE
  
  Sets the prototype of the given function, or deletes it if PROTOTYPE is
  undef. Returns the CODEREF.
  
      set_prototype \&foo, '$$';
  
  =head2 tainted EXPR
  
  Return true if the result of EXPR is tainted
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head2 weaken REF
  
  REF will be turned into a weak reference. This means that it will not
  hold a reference count on the object it references. Also when the reference
  count on that object reaches zero, REF will be set to undef.
  
  This is useful for keeping copies of references , but you don't want to
  prevent the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference,
  the copy will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never
  be destroyed because there is now always a strong reference to them in the
  @object array.
  
  =head2 isweak EXPR
  
  If EXPR is a scalar which is a weak reference the result is true.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to use
  C<isweak> or C<weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  C<isvstring> you will need to use a newer release of perl.
  
  =item C<NAME> is only available with the XS version of Scalar::Util
  
  C<Scalar::Util> contains both perl and C implementations of many of its functions
  so that those without access to a C compiler may still use it. However some of the functions
  are only available when a C compiler was available to compile the XS version of the extension.
  
  At present that list is: weaken, isweak, dualvar, isvstring, set_prototype
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Except weaken and isweak which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  =cut
X86_64-LINUX_SCALAR_UTIL

$fatpacked{"x86_64-linux/Syntax/Keyword/Try.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SYNTAX_KEYWORD_TRY';
  #  You may distribute under the terms of either the GNU General Public License
  #  or the Artistic License (the same terms as Perl itself)
  #
  #  (C) Paul Evans, 2016-2022 -- leonerd@leonerd.org.uk
  
  package Syntax::Keyword::Try 0.27;
  
  use v5.14;
  use warnings;
  
  use Carp;
  
  require XSLoader;
  XSLoader::load( __PACKAGE__, our $VERSION );
  
  =head1 NAME
  
  C<Syntax::Keyword::Try> - a C<try/catch/finally> syntax for perl
  
  =head1 SYNOPSIS
  
     use Syntax::Keyword::Try;
  
     sub foo {
        try {
           attempt_a_thing();
           return "success";
        }
        catch ($e) {
           warn "It failed - $e";
           return "failure";
        }
     }
  
  =head1 DESCRIPTION
  
  This module provides a syntax plugin that implements exception-handling
  semantics in a form familiar to users of other languages, being built on a
  block labeled with the C<try> keyword, followed by at least one of a C<catch>
  or C<finally> block.
  
  As well as providing a handy syntax for this useful behaviour, this module
  also serves to contain a number of code examples for how to implement parser
  plugins and manipulate optrees to provide new syntax and behaviours for perl
  code.
  
  Syntax similar to this module has now been added to core perl, starting at
  version 5.34.0. If you are writing new code, it is suggested that you instead
  use the L<Feature::Compat::Try> module instead, as that will enable the core
  feature on those supported perl versions, falling back to
  C<Syntax::Keyword::Try> on older perls.
  
  =head1 Experimental Features
  
  Some of the features of this module are currently marked as experimental. They
  will provoke warnings in the C<experimental> category, unless silenced.
  
  You can silence this with C<no warnings 'experimental'> but then that will
  silence every experimental warning, which may hide others unintentionally. For
  a more fine-grained approach you can instead use the import line for this
  module to only silence this module's warnings selectively:
  
     use Syntax::Keyword::Try qw( try :experimental(typed) );
  
     use Syntax::Keyword::Try qw( try :experimental );  # all of the above
  
  Don't forget to import the main C<try> symbol itself, to activate the syntax.
  
  =cut
  
  =head1 KEYWORDS
  
  =head2 try
  
     try {
        STATEMENTS...
     }
     ...
  
  A C<try> statement provides the main body of code that will be invoked, and
  must be followed by either a C<catch> statement, a C<finally> statement, or
  both.
  
  Execution of the C<try> statement itself begins from the block given to the
  statement and continues until either it throws an exception, or completes
  successfully by reaching the end of the block. What will happen next depends
  on the presence of a C<catch> or C<finally> statement immediately following
  it.
  
  The body of a C<try {}> block may contain a C<return> expression. If executed,
  such an expression will cause the entire containing function to return with
  the value provided. This is different from a plain C<eval {}> block, in which
  circumstance only the C<eval> itself would return, not the entire function.
  
  The body of a C<try {}> block may contain loop control expressions (C<redo>,
  C<next>, C<last>) which will have their usual effect on any loops that the
  C<try {}> block is contained by.
  
  The parsing rules for the set of statements (the C<try> block and its
  associated C<catch> and C<finally>) are such that they are parsed as a self-
  contained statement. Because of this, there is no need to end with a
  terminating semicolon.
  
  Even though it parses as a statement and not an expression, a C<try> block can
  still yield a value if it appears as the final statement in its containing
  C<sub> or C<do> block. For example:
  
     my $result = do {
        try { attempt_func() }
        catch ($e) { "Fallback Value" }
     };
  
  Note (especially to users of L<Try::Tiny> and similar) that the C<try {}>
  block itself does not necessarily stop exceptions thrown inside it from
  propagating outside. It is the presence of a later C<catch {}> block which
  causes this to happen. A C<try> with only a C<finally> and no C<catch> will
  still propagate exceptions up to callers as normal.
  
  =head2 catch
  
     ...
     catch ($var) {
        STATEMENTS...
     }
  
  or
  
     ...
     catch {
        STATEMENTS...
     }
  
  A C<catch> statement provides a block of code to the preceding C<try>
  statement that will be invoked in the case that the main block of code throws
  an exception. Optionally a new lexical variable can be provided to store the
  exception in. If not provided, the C<catch> block can inspect the raised
  exception by looking in C<$@> instead.
  
  Presence of this C<catch> statement causes any exception thrown by the
  preceding C<try> block to be non-fatal to the surrounding code. If the
  C<catch> block wishes to optionally handle some exceptions but not others, it
  can re-raise it (or another exception) by calling C<die> in the usual manner.
  
  As with C<try>, the body of a C<catch {}> block may also contain a C<return>
  expression, which as before, has its usual meaning, causing the entire
  containing function to return with the given value. The body may also contain
  loop control expressions (C<redo>, C<next> or C<last>) which also have their
  usual effect.
  
  If a C<catch> statement is not given, then any exceptions raised by the C<try>
  block are raised to the caller in the usual way.
  
  =head2 catch (Typed)
  
     ...
     catch ($var isa Class) { ... }
  
     ...
     catch ($var =~ m/^Regexp match/) { ... }
  
  I<Experimental; since version 0.15.>
  
  Optionally, multiple catch statements can be provided, where each block is
  given a guarding condition, to control whether or not it will catch particular
  exception values. Use of this syntax will provoke an C<experimental> category
  warning on supporting perl versions, unless silenced by importing the
  C<:experimental(typed)> tag (see above).
  
  Two kinds of condition are supported:
  
  =over 4
  
  =item *
  
     catch ($var isa Class)
  
  The block is invoked only if the caught exception is a blessed object, and
  derives from the given package name.
  
  On Perl version 5.32 onwards, this condition test is implemented using the
  same op type that the core C<$var isa Class> syntax is provided by and works
  in exactly the same way.
  
  On older perl versions it is emulated by a compatibility function. Currently
  this function does not respect a C<< ->isa >> method overload on the exception
  instance. Usually this should not be a problem, as exception class types
  rarely provide such a method.
  
  =item *
  
     catch ($var =~ m/regexp/)
  
  The block is invoked only if the caught exception is a string that matches
  the given regexp.
  
  =back
  
  When an exception is caught, each condition is tested in the order they are
  written in, until a matching case is found. If such a case is found the
  corresponding block is invoked, and no further condition is tested. If no
  contional block matched and there is a default (unconditional) block at the
  end then that is invoked instead. If no such block exists, then the exception
  is propagated up to the calling scope.
  
  =head2 finally
  
     ...
     finally {
        STATEMENTS...
     }
  
  A C<finally> statement provides a block of code to the preceding C<try>
  statement (or C<try/catch> pair) which is executed afterwards, both in the
  case of a normal execution or a thrown exception. This code block may be used
  to provide whatever clean-up operations might be required by preceding code.
  
  Because it is executed during a stack cleanup operation, a C<finally {}> block
  may not cause the containing function to return, or to alter the return value
  of it. It also cannot see the containing function's C<@_> arguments array
  (though as it is block scoped within the function, it will continue to share
  any normal lexical variables declared up until that point). It is protected
  from disturbing the value of C<$@>. If the C<finally {}> block code throws an
  exception, this will be printed as a warning and discarded, leaving C<$@>
  containing the original exception, if one existed.
  
  =head1 OTHER MODULES
  
  There are already quite a number of modules on CPAN that provide a
  C<try/catch>-like syntax for Perl.
  
  =over 2
  
  =item *
  
  L<Try>
  
  =item *
  
  L<TryCatch>
  
  =item *
  
  L<Try::Tiny>
  
  =item *
  
  L<Syntax::Feature::Try>
  
  =back
  
  In addition, core perl itself gained a C<try/catch> syntax based on this
  module at version 5.34.0. It is available as C<use feature 'try'>.
  
  They are compared here, by feature:
  
  =head2 True syntax plugin
  
  Like L<Try> and L<Syntax::Feature::Try>, this module is implemented as a true
  syntax plugin, allowing it to provide new parsing rules not available to
  simple functions. Most notably here it means that the resulting combination
  does not need to end in a semicolon.
  
  The core C<feature 'try'> is also implemented as true native syntax in the
  perl parser.
  
  In comparison, L<Try::Tiny> is plain perl and provides its functionality using
  regular perl functions; as such its syntax requires the trailing semicolon.
  
  L<TryCatch> is a hybrid that uses L<Devel::Declare> to parse the syntax tree.
  
  =head2 C<@_> in a try or catch block
  
  Because the C<try> and C<catch> block code is contained in a true block rather
  than an entire anonymous subroutine, invoking it does not interfere with the
  C<@_> arguments array. Code inside these blocks can interact with the
  containing function's array as before.
  
  This feature is unique among these modules; none of the others listed have
  this ability.
  
  The core C<feature 'try'> also behaves in this manner.
  
  =head2 C<return> in a try or catch block
  
  Like L<TryCatch> and L<Syntax::Feature::Try>, the C<return> statement has its
  usual effect within a subroutine containing syntax provided by this module.
  Namely, it causes the containing C<sub> itself to return.
  
  It also behaves this way using the core C<feature 'try'>.
  
  In comparison, using L<Try> or L<Try::Tiny> mean that a C<return> statement
  will only exit from the C<try> block.
  
  =head2 C<next>/C<last>/C<redo> in a try or catch block
  
  The loop control keywords of C<next>, C<last> and C<redo> have their usual
  effect on dynamically contained loops.
  
  These also work fine when using the core C<feature 'try'>.
  
  L<Syntax::Feature::Try> documents that these do not work there. The other
  modules make no statement either way.
  
  =head2 Value Semantics
  
  Like L<Try> and L<Syntax::Feature::Try>, the syntax provided by this module
  only works as a syntax-level statement and not an expression. You cannot
  assign from the result of a C<try> block. A common workaround is to wrap
  the C<try/catch> statement inside a C<do> block, where its final expression
  can be captured and used as a value.
  
  The same C<do> block wrapping also works for the core C<feature 'try'>.
  
  In comparison, the behaviour implemented by L<Try::Tiny> can be used as a
  valued expression, such as assigned to a variable or returned to the caller of
  its containing function.
  
  =head2 C<try> without C<catch>
  
  Like L<Syntax::Feature::Try>, the syntax provided by this module allows a
  C<try> block to be followed by only a C<finally> block, with no C<catch>. In
  this case, exceptions thrown by code contained by the C<try> are not
  suppressed, instead they propagate as normal to callers. This matches the
  behaviour familiar to Java or C++ programmers.
  
  In comparison, the code provided by L<Try> and L<Try::Tiny> always suppress
  exception propagation even without an actual C<catch> block.
  
  The L<TryCatch> module does not allow a C<try> block not followed by C<catch>.
  
  The core C<feature 'try'> does not implement C<finally> at all, and also
  requires that every C<try> block be followed by a C<catch>.
  
  =head2 Typed C<catch>
  
  L<Try> and L<Try::Tiny> make no attempt to perform any kind of typed dispatch
  to distinguish kinds of exception caught by C<catch> blocks.
  
  Likewise the core C<feature 'try'> currently does not provide this ability,
  though it remains an area of ongoing design work.
  
  L<TryCatch> and L<Syntax::Feature::Try> both attempt to provide a kind of
  typed dispatch where different classes of exception are caught by different
  blocks of code, or propagated up entirely to callers.
  
  This module provides such an ability, via the currently-experimental
  C<catch (VAR cond...)> syntax.
  
  The design thoughts continue on the RT ticket
  L<https://rt.cpan.org/Ticket/Display.html?id=123918>.
  
  =cut
  
  sub import
  {
     my $class = shift;
     my $caller = caller;
  
     $class->import_into( $caller, @_ );
  }
  
  my @EXPERIMENTAL = qw( typed );
  
  sub import_into
  {
     my $class = shift;
     my ( $caller, @syms ) = @_;
  
     @syms or @syms = qw( try );
  
     my %syms = map { $_ => 1 } @syms;
     $^H{"Syntax::Keyword::Try/try"}++ if delete $syms{try};
  
     # Largely for Feature::Compat::Try's benefit
     $^H{"Syntax::Keyword::Try/no_finally"}++    if delete $syms{"-no_finally"};
     $^H{"Syntax::Keyword::Try/require_catch"}++ if delete $syms{"-require_catch"};
     $^H{"Syntax::Keyword::Try/require_var"}++   if delete $syms{"-require_var"};
  
     # stablised experiments
     delete $syms{":experimental($_)"} for qw( var );
  
     foreach ( @EXPERIMENTAL ) {
        $^H{"Syntax::Keyword::Try/experimental($_)"}++ if delete $syms{":experimental($_)"};
     }
  
     if( delete $syms{":experimental"} ) {
        $^H{"Syntax::Keyword::Try/experimental($_)"}++ for @EXPERIMENTAL;
     }
  
     # Ignore requests for these, as they come automatically with `try`
     delete @syms{qw( catch finally )};
  
     if( $syms{try_value} or $syms{":experimental(try_value)"} ) {
        croak "The 'try_value' experimental feature is now removed\n" .
              "Instead, you should use  do { try ... }  to yield a value from a try/catch statement";
     }
  
     croak "Unrecognised import symbols @{[ keys %syms ]}" if keys %syms;
  }
  
  =head1 WITH OTHER MODULES
  
  =head2 Future::AsyncAwait
  
  As of C<Future::AsyncAwait> version 0.10 and L<Syntax::Keyword::Try> version
  0.07, cross-module integration tests assert that basic C<try/catch> blocks
  inside an C<async sub> work correctly, including those that attempt to
  C<return> from inside C<try>.
  
     use Future::AsyncAwait;
     use Syntax::Keyword::Try;
  
     async sub attempt
     {
        try {
           await func();
           return "success";
        }
        catch {
           return "failed";
        }
     }
  
  =head1 ISSUES
  
  =head2 Thread-safety at load time cannot be assured before perl 5.16
  
  On F<perl> versions 5.16 and above this module is thread-safe.
  
  On F<perl> version 5.14 this module is thread-safe provided that it is
  C<use>d before any additional threads are created.
  
  However, when using 5.14 there is a race condition if this module is loaded
  late in the program startup, after additional threads have been created. This
  leads to the potential for it to be started up multiple times concurrently,
  which creates data races when modifying internal structures and likely leads
  to a segmentation fault, either during load or soon after when more code is
  compiled.
  
  As a workaround, for any such program that creates multiple threads, loads
  additional code (such as dynamically-discovered plugins), and has to run on
  5.14, it should make sure to
  
     use Syntax::Keyword::Try;
  
  early on in startup, before it spins out any additional threads.
  
  (See also L<https://rt.cpan.org/Public/Bug/Display.html?id=123547>)
  
  =head2 $@ is not local'ised by C<try do> before perl 5.24
  
  On F<perl> versions 5.24 and above, or when using only control-flow statement
  syntax, C<$@> is always correctly C<local>ised.
  
  However, when using the experimental value-yielding expression version
  C<try do {...}> on perl versions 5.22 or older, the C<local>isation of C<$@>
  does not correctly apply around the expression. After such an expression, the
  value of C<$@> will leak out if a failure happened and the C<catch> block was
  invoked, overwriting any previous value that was visible there.
  
  (See also L<https://rt.cpan.org/Public/Bug/Display.html?id=124366>)
  
  =head1 ACKNOWLEDGEMENTS
  
  With thanks to C<Zefram>, C<ilmari> and others from C<irc.perl.org/#p5p> for
  assisting with trickier bits of XS logic.
  
  =head1 AUTHOR
  
  Paul Evans <leonerd@leonerd.org.uk>
  
  =cut
  
  0x55AA;
X86_64-LINUX_SYNTAX_KEYWORD_TRY

$fatpacked{"x86_64-linux/Syntax/Keyword/Try/Deparse.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SYNTAX_KEYWORD_TRY_DEPARSE';
  #  You may distribute under the terms of either the GNU General Public License
  #  or the Artistic License (the same terms as Perl itself)
  #
  #  (C) Paul Evans, 2021 -- leonerd@leonerd.org.uk
  
  package Syntax::Keyword::Try::Deparse 0.27;
  
  use v5.14;
  use warnings;
  
  use B qw( opnumber );
  
  require B::Deparse;
  
  use constant {
     OP_CUSTOM  => opnumber('custom'),
     OP_ENTER   => opnumber('enter'),
     OP_LINESEQ => opnumber('lineseq'),
  };
  
  =head1 NAME
  
  C<Syntax::Keyword::Try::Deparse> - L<B::Deparse> support for L<Syntax::Keyword::Try>
  
  =head1 DESCRIPTION
  
  Loading this module will apply some hacks onto L<B::Deparse> that attempts to
  provide deparse support for code which uses the syntax provided by
  L<Syntax::Keyword::Try>.
  
  =cut
  
  my $orig_pp_leave;
  {
     no warnings 'redefine';
     no strict 'refs';
     $orig_pp_leave = *{"B::Deparse::pp_leave"}{CODE};
     *{"B::Deparse::pp_leave"} = \&pp_leave;
  }
  
  sub pp_leave
  {
     my $self = shift;
     my ( $op ) = @_;
  
     my $enter = $op->first;
     $enter->type == OP_ENTER or
        return $self->$orig_pp_leave( @_ );
  
     my $body = $enter->sibling;
     my $first = $body->first;
  
     my $finally = "";
  
     if( $body->type == OP_LINESEQ and $first->name eq "pushfinally" ) {
        my $finally_cv = $first->sv;
        $finally = "\nfinally " . $self->deparse_sub( $finally_cv ) . "\cK";
  
        $first = $first->sibling;
        $first = $first->sibling while $first and $first->name eq "lineseq";
  
        # Jump over a scope op
        if( $first->type == 0 ) {
           $body  = $first;
           $first = $first->first;
        }
     }
  
     if( $first->type == OP_CUSTOM and $first->name eq "catch" ) {
        # This is a try/catch block
        shift;
        return $self->deparse( $body, @_ ) . $finally;
     }
     elsif( length $finally ) {
        # Body is the remaining siblings. We'll have to do them all together
        my $try = B::Deparse::scopeop( 1, $self, $body, 0 );
  
        return "try {\n\t$try\n\b}" . $finally;
     }
  
     return $orig_pp_leave->($self, @_);
  }
  
  sub B::Deparse::pp_catch
  {
     my $self = shift;
     my ( $op ) = @_;
  
     my $tryop   = $op->first;
     my $catchop = $op->first->sibling;
  
     my $try = $self->pp_leave($tryop, 0);
  
     # skip the OP_SCOPE and dive into the OP_LINESEQ inside
     #
     # TODO: Try to detect the `catch my $e` variable, though that will be hard
     # to dishtinguish from actual code that really does that
     my $catch = $self->deparse($catchop->first, 0);
  
     return "try {\n\t$try\n\b}\ncatch {\n\t$catch\n\b}\cK";
  }
  
  =head1 TODO
  
  Correctly handle typed dispatch cases
  (C<catch($var isa CLASS)>, C<catch($var =~ m/pattern/)>)
  
  =cut
  
  =head1 AUTHOR
  
  Paul Evans <leonerd@leonerd.org.uk>
  
  =cut
  
  0x55AA;
X86_64-LINUX_SYNTAX_KEYWORD_TRY_DEPARSE

$fatpacked{"x86_64-linux/XS/Parse/Infix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_XS_PARSE_INFIX';
  #  You may distribute under the terms of either the GNU General Public License
  #  or the Artistic License (the same terms as Perl itself)
  #
  #  (C) Paul Evans, 2021 -- leonerd@leonerd.org.uk
  
  package XS::Parse::Infix 0.22;
  
  use v5.14;
  use warnings;
  
  # No actual .xs file; the code is implemented in XS::Parse::Keyword
  require XS::Parse::Keyword;
  
  =head1 NAME
  
  C<XS::Parse::Infix> - XS functions to assist in parsing infix operators
  
  =head1 DESCRIPTION
  
  This module provides some XS functions to assist in writing syntax modules
  that provide new infix operators as perl syntax, primarily for authors of
  syntax plugins. It is unlikely to be of much use to anyone else; and highly
  unlikely to be of any use when writing perl code using these. Unless you are
  writing a syntax plugin using XS, this module is not for you.
  
  This module is also currently experimental, and the design is still evolving
  and subject to change. Later versions may break ABI compatibility, requiring
  changes or at least a rebuild of any module that depends on it.
  
  In addition, the places this functionality can be used are relatively small.
  No current release of perl actually supports custom infix operators, though I
  have a branch where I am currently experimenting with such support:
  
  L<https://github.com/leonerd/perl5/tree/infix-plugin>
  
  In addition, the various C<XPK_INFIX_*> token types of L<XS::Parse::Keyword>
  support querying on this module, so some syntax provided by other modules may
  be able to make use of these new infix operators.
  
  =cut
  
  =head1 CONSTANTS
  
  =head2 HAVE_PL_INFIX_PLUGIN
  
     if( XS::Parse::Infix::HAVE_PL_INFIX_PLUGIN ) { ... }
  
  This constant is true if built on a perl that supports the C<PL_infix_plugin>
  extension mechanism, meaning that custom infix operators registered with this
  module will actually be recognised by the perl parser.
  
  No actual production or development releases of perl yet support this feature,
  but see above for details of a branch which does.
  
  =cut
  
  =head1 XS FUNCTIONS
  
  =head2 boot_xs_parse_infix
  
    void boot_xs_parse_infix(double ver);
  
  Call this function from your C<BOOT> section in order to initialise the module
  and parsing hooks.
  
  I<ver> should either be 0 or a decimal number for the module version
  requirement; e.g.
  
     boot_xs_parse_infix(0.14);
  
  =head2 xs_parse_infix_new_op
  
     OP *xs_parse_infix_new_op(const struct XSParseInfixInfo *info, U32 flags,
        OP *lhs, OP *rhs);
  
  This function constructs a new optree fragment to represent invoking the infix
  operator with the given operands. It should be used much the same as core
  perl's C<newBINOP> function.
  
  The C<info> structure pointer would be obtained from the C<infix> field of the
  result of invoking the various C<XPK_INFIX_*> token types from
  C<XS::Parse::Keyword>.
  
  =head2 register_xs_parse_infix
  
     void register_xs_parse_infix(const char *opname,
        const struct XSParseInfixHooks *hooks, void *hookdata);
  
  This function installs a set of parsing hooks to be associated with the given
  operator name. This new operator will then be available via
  L<XS::Parse::Keyword> by the various C<XPK_INFIX_*> token types, or to core
  perl's C<PL_infix_plugin> if availble.
  
  These tokens will all yield an info structure, with the following fields:
  
     struct XSParseInfixInfo {
        const char *opname;
        OPCODE opcode;  /* for built-in operators, or OP_CUSTOM for 
                           custom-registered ones */
  
        struct XSParseInfixHooks *hooks;
        void                     *hookdata;
     };
  
  If the operator name contains any non-ASCII characters they are presumed to be
  in UTF-8 encoding. This will matter for deparse purposes.
  
  =cut
  
  =head1 PARSE HOOKS
  
  The C<XSParseInfixHooks> structure provides the following fields which are
  used at various stages of parsing.
  
     struct XSParseInfixHooks {
        U16 flags; /* currently ignored */
        U8 lhs_flags;
        U8 rhs_flags;
        enum XSParseInfixClassification cls;
  
        const char *wrapper_func_name;
  
        const char *permit_hintkey;
        bool (*permit)(pTHX_ void *hookdata);
  
        OP *(*new_op)(pTHX_ U32 flags, OP *lhs, OP *rhs, void *hookdata);
        OP *(*ppaddr)(pTHX);
     };
  
  =head2 Flags
  
  The C<flags> field is currently ignored. It is defined simply to reserve the
  space in case used in a later version. It should be set to zero.
  
  The C<rhs_flags> field gives details on how to parse and handle the right-hand
  side of the operator syntax. It should be set to one of the following constants:
  
  =over 4
  
  =item XPI_OPERAND_TERM (0)
  
  Default. The operand is a term expression.
  
  =item XPI_OPERAND_TERM_LIST
  
  The operand is a term expression. It will be foced into list context,
  preserving the C<OP_PUSHMARK> at the beginning. This means that the ppfunc for
  this infix operator will have to C<POPMARK> to find that.
  
  =item XPI_OPERAND_LIST
  
  The operand is a list expression. It will be forced into list context, the
  same as above.
  
  =back
  
  In addition the following extra bitflags are defined:
  
  =over 4
  
  =item XPI_OPERAND_ONLY_LOOK
  
  If set, the operator function promises that it will not mutate any of its
  passed values, nor allow leaking of direct alias pointers to them via return
  value or other locations.
  
  This flag is optional; omitting it when applicable will not change any
  observed behaviour. Setting it may enable certain optimisations to be
  performed.
  
  Currently, this flag simply enables an optimisation in the call-checker for
  infix operator wrapper functions that take list-shaped operands. This
  optimisation discards an C<OP_ANONLIST> operation which would create a
  temporary anonymous array reference for its operand values, allowing a slight
  saving of memory use and CPU time. This optimisation is only safe to perform
  if the operator does not mutate or retain aliases of any of the arguments, as
  otherwise the caller might see unexpected modifications or value references to
  the values passed.
  
  =back
  
  The C<lhs_flags> field gives details on how to handle the left-hand side of
  the operator syntax. It takes similar values to C<rhs_flags>, except that it
  does not accept the C<XPI_OPERAND_LIST> value. Parsing always happens on just
  a term expression, though it may be placed into list context (which therefore
  still permits things like parenthesized lists, or array variables).
  
  =head2 The Selection Stage
  
  The C<cls> field gives a "classification" of the operator, suggesting what
  sort of operation it provides. This is used as a filter by the various
  C<XS::Parse::Keyword> selection macros.
  
  The classification should be one of the C<XPI_CLS_*> constants found and
  described further in the main F<XSParseInfix.h> file.
  
  =head2 The C<permit> Stage
  
  As a shortcut for the common case, the C<permit_hintkey> may point to a string
  to look up from the hints hash. If the given key name is not found in the
  hints hash then the keyword is not permitted. If the key is present then the
  C<permit> function is invoked as normal.
  
  If not rejected by a hint key that was not found in the hints hash, the
  function part of the stage is called next and should inspect whether the
  keyword is permitted at this time perhaps by inspecting other lexical clues,
  and return true only if the keyword is permitted.
  
  Both the string and the function are optional. Either or both may be present.
  If neither is present then the keyword is always permitted - which is likely
  not what you wanted to do.
  
  =head2 The Op Generation Stage
  
  If the infix operator is going to be used, then one of the C<new_op> or the
  C<ppaddr> fields explain how to create a new optree fragment.
  
  If C<new_op> is defined then it will be used, and is expected to return an
  optree fragment that consumes the LHS and RHS arguments to implement the
  semantics of the operator. If this is not present, then the C<ppaddr> will be
  used instead to construct a new BINOP of the C<OP_CUSTOM> type.
  
  =head2 The Wrapper Function
  
  Additionally, if the C<wrapper_func_name> field is set to a string, this gives
  the (fully-qualified) name for a function to be generated as part of
  registering the operator. This newly-generated function will act as a wrapper
  for the operator.
  
  For operators whose RHS is a scalar, the wrapper function is assumed to take
  two simple scalar arguments. The result of invoking the function on those
  arguments will be determined by using the operator code.
  
     $result = $lhs OP $rhs;
  
     $result = WRAPPERFUNC( $lhs, $rhs );
  
  For operators whose RHS is a list, the wrapper function takes at least one
  argument, possibly more. The first argument is the scalar on the LHS, and the
  remaining arguments, however many there are, form the RHS:
  
     $result = $lhs OP @rhs;
  
     $result = WRAPPERFUNC( $lhs, @rhs );
  
  For operators whose LHS and RHS is a list, the wrapper function takes two
  arguments which must be array references containing the lists.
  
     $result = @lhs OP @rhs;
  
     $result = WRAPPERFUNC( \@lhs, \@rhs );
  
  This creates a convenience for accessing the operator from perls that do not
  support C<PL_infix_plugin>.
  
  In the case of scalar infix operators, the wrapper function also includes a
  call-checker which attempts to inline the operator directly into the callsite.
  Thus, in simple cases where the function is called directly on exactly two
  scalar arguments (such as in the following), no C<ENTERSUB> overhead will be
  incurred and the generated optree will be identical to that which would have
  been generated by using infix operator syntax directly:
  
     WRAPPERFUNC( $lhs, $rhs );
     WRAPPERFUNC( $lhs, CONSTANT );
     WRAPPERFUNC( $args[0], $args[1] );
     WRAPPERFUNC( $lhs, scalar otherfunc() );
  
  The checker is very pessimistic and will only rewrite callsites where it
  determines this can be done safely. It will not rewrite any of the following
  forms:
  
     WRAPPERFUNC( $onearg );            # not enough args
     WRAPPERFUNC( $x, $y, $z );         # too many args
     WRAPPERFUNC( @args[0,1] );         # not a scalar
     WRAPPERFUNC( $lhs, otherfunc() );  # not a scalar
  
  The wrapper function for infix operators which take lists on both sides also
  has a call-checker which will attempt to inline the operator in similar
  circumstances. In addition to the optimisations described above for scalar
  operators, this checker will also inline an array-reference operator and omit
  the resulting dereference behaviour. Thus, the two following lines emit the
  same optree, without an C<OP_SREFGEN> or C<OP_RV2AV>:
  
     @lhs OP @rhs;
     WRAPPERFUNC( \@lhs, \@rhs );
  
  B<Note> that technically, this optimisation isn't strictly transparent in the
  odd cornercase that one of the referenced arrays is also the backing store for
  a blessed object reference, and that object class has a C<@{}> overload.
  
     my @arr;
     package SomeClass {
        use overload '@{}' => sub { return ["values", "go", "here"]; };
     }
     bless \@arr, "SomeClass";
  
     # this will not actually invoke the overload operator
     WRAPPERFUNC( \@arr, [4, 5, 6] );
  
  As this cornercase relates to taking duplicate references to the same blessed
  object's backing store variable, it should not matter to any real code;
  regular objects that are passed by reference into the wrapper function will
  run their overload methods as normal.
  
  The callchecker for list operands can optionally also discard an op of the
  C<OP_ANONLIST> type, which is used by anonymous array-ref construction:
  
     ($u, $v, $w) OP ($x, $y, $z);
     WRAPPERFUNC( [$u, $v, $w], [$x, $y, $z] );
  
  This optimisation is only performed if the operator declared it safe to do so,
  via the C<XPI_OPERAND_ONLY_LOOK> flag.
  
  =cut
  
  =head1 DEPARSE
  
  This module operates with L<B::Deparse> in order to automatically provide
  deparse support for infix operators. Every infix operator that is implemented
  as a custom op (and thus has the C<ppaddr> hook field set) will have deparse
  logic added. This will allow it to deparse to either the named wrapper
  function, or to the infix operator syntax if on a C<PL_infix_plugin>-enabled
  perl and the appropriate lexical hint is enabled at the callsite.
  
  In order for this to work, it is important that your custom operator is I<not>
  registered as a custom op using the C<Perl_register_custom_op()> function.
  This registration will be performed by C<XS::Parse::Infix> itself at the time
  the infix operator is registered.
  
  =cut
  
  sub B::Deparse::_deparse_infix_wrapperfunc_scalarscalar
  {
     my ( $self, $wrapper_func_name, $op, $ctx ) = @_;
  
     my $lhs = $op->first;
     my $rhs = $op->last;
  
     $_ = $self->deparse( $_, 6 ) for $lhs, $rhs;
  
     return "$wrapper_func_name($lhs, $rhs)";
  }
  
  sub B::Deparse::_deparse_infix_wrapperfunc_listlist
  {
     my ( $self, $wrapper_func_name, $op, $ctx ) = @_;
  
     my $lhs = $op->first;
     my $rhs = $op->last;
  
     foreach my $var ( \$lhs, \$rhs ) {
        my $argop = $$var;
        my $kid;
  
        if( $argop->name eq "null" and
            $argop->first->name eq "pushmark" and
            ($kid = $argop->first->sibling) and
            B::Deparse::null($kid->sibling) ) {
           my $add_refgen;
  
           # A list of a single item
           if( $kid->name eq "rv2av" and $kid->first->name ne "gv" ) {
              $argop = $kid->first;
           }
           elsif( $kid->name eq "padav" or $kid->name eq "rv2av" ) {
              $add_refgen++;
           }
           else {
              print STDERR "Maybe UNWRAP list ${\ $kid->name }\n";
           }
  
           $$var = $self->deparse( $argop, 6 );
  
           $$var = "\\$$var" if $add_refgen;
        }
        else {
           # Pretend the entire list was anonlist
           my @args;
           $argop = $argop->first->sibling; # skip pushmark
           while( not B::Deparse::null($argop) ) {
              push @args, $self->deparse( $argop, 6 );
              $argop = $argop->sibling;
           }
  
           $$var = "[" . join( ", ", @args ) . "]";
        }
     }
  
     return "$wrapper_func_name($lhs, $rhs)";
  }
  
  sub B::Deparse::_deparse_infix_named
  {
     my ( $self, $opname, $op, $ctx ) = @_;
  
     my $lhs = $op->first;
     my $rhs = $op->last;
  
     return join " ",
        $self->deparse_binop_left( $op, $lhs, 14 ),
        $opname,
        $self->deparse_binop_right( $op, $rhs, 14 );
  }
  
  =head1 TODO
  
  =over 4
  
  =item *
  
  Have the entersub checker for list/list operators unwrap arrayref or
  anon-array argument forms (C<WRAPPERFUNC( \@lhs, \@rhs )> or
  C<WRAPPERFUNC( [LHS], [RHS] )>).
  
  =back
  
  =cut
  
  =head1 AUTHOR
  
  Paul Evans <leonerd@leonerd.org.uk>
  
  =cut
  
  0x55AA;
X86_64-LINUX_XS_PARSE_INFIX

$fatpacked{"x86_64-linux/XS/Parse/Infix/Builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_XS_PARSE_INFIX_BUILDER';
  #  You may distribute under the terms of either the GNU General Public License
  #  or the Artistic License (the same terms as Perl itself)
  #
  #  (C) Paul Evans, 2021 -- leonerd@leonerd.org.uk
  
  package XS::Parse::Infix::Builder 0.22;
  
  use v5.14;
  use warnings;
  
  =head1 NAME
  
  C<XS::Parse::Infix::Builder> - build-time support for C<XS::Parse::Infix>
  
  =head1 SYNOPSIS
  
  In F<Build.PL>:
  
     use XS::Parse::Infix::Builder;
  
     my $build = Module::Build->new(
        ...,
        configure_requires => {
           ...
           'XS::Parse::Infix::Builder' => 0,
        }
     );
  
     XS::Parse::Infix::Builder->extend_module_build( $build );
  
     ...
  
  =head1 DESCRIPTION
  
  This module provides a build-time helper to assist authors writing XS modules
  that use L<XS::Parse::Infix>. It prepares a L<Module::Build>-using
  distribution to be able to make use of C<XS::Parse::Infix>.
  
  =cut
  
  require XS::Parse::Infix::Builder_data;
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 write_XSParseInfix_h
  
     XS::Parse::Infix::Builder->write_XSParseInfix_h
  
  Writes the F<XSParseInfix.h> file to the current working directory. To cause
  the compiler to actually find this file, see L</extra_compiler_flags>.
  
  =cut
  
  sub write_XSParseInfix_h
  {
     shift;
  
     open my $out, ">", "XSParseInfix.h" or
        die "Cannot open XSParseInfix.h for writing - $!\n";
  
     $out->print( XS::Parse::Infix::Builder_data->XSPARSEINFIX_H );
  }
  
  =head2 extra_compiler_flags
  
     @flags = XS::Parse::Infix::Builder->extra_compiler_flags
  
  Returns a list of extra flags that the build scripts should add to the
  compiler invocation. This enables the C compiler to find the
  F<XSParseInfix.h> file.
  
  =cut
  
  sub extra_compiler_flags
  {
     shift;
     return "-I.", XS::Parse::Infix::Builder_data->BUILDER_CFLAGS;
  }
  
  =head2 extend_module_build
  
     XS::Parse::Infix::Builder->extend_module_build( $build )
  
  A convenient shortcut for performing all the tasks necessary to make a
  L<Module::Build>-based distribution use the helper.
  
  =cut
  
  sub extend_module_build
  {
     my $self = shift;
     my ( $build ) = @_;
  
     eval { $self->write_XSParseInfix_h } or do {
        warn $@;
        return;
     };
  
     # preserve existing flags
     my @flags = @{ $build->extra_compiler_flags };
     push @flags, $self->extra_compiler_flags;
  
     $build->extra_compiler_flags( @flags );
  }
  
  =head1 AUTHOR
  
  Paul Evans <leonerd@leonerd.org.uk>
  
  =cut
  
  0x55AA;
X86_64-LINUX_XS_PARSE_INFIX_BUILDER

$fatpacked{"x86_64-linux/XS/Parse/Infix/Builder_data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_XS_PARSE_INFIX_BUILDER_DATA';
  package XS::Parse::Infix::Builder_data 0.22;
  
  use v5.14;
  use warnings;
  
  # Additional CFLAGS arguments to pass during compilation
  use constant BUILDER_CFLAGS => ;
  
  # The contents of the "XSParseInfix.h" file
  my $XSParseInfix_h = do {
     local $/;
     readline DATA;
  };
  sub XSPARSEINFIX_H() { $XSParseInfix_h }
  
  0x55AA;
  
  __DATA__
  #ifndef __XS_PARSE_INFIX_H__
  #define __XS_PARSE_INFIX_H__
  
  #define XSPARSEINFIX_ABI_VERSION 1
  
  /* Infix operator classifications */
  /* No built-in operators use the _MISC categories, but they are provided for
   * custom infix operators to use so they are still found by selections */
  enum XSParseInfixClassification {
    XPI_CLS_NONE = 0,
    XPI_CLS_PREDICATE,   /* any boolean-returning operator */
    XPI_CLS_RELATION,    /*  ... any predicate that is typewise symmetric */
    XPI_CLS_EQUALITY,    /*      ... any relation that is true for (x == x) and false otherwise */
    XPI_CLS_SMARTMATCH,  /*  ... the predicate smartmatch (~~) */
    XPI_CLS_MATCHRE,     /*  ... the predicate regexp match (=~) */
    XPI_CLS_ISA,         /*  ... the predicate instance of (isa) */
    XPI_CLS_MATCH_MISC,  /*  ... any other match-like predicate */
    XPI_CLS_ORDERING,    /* cmp or <=> */
  };
  
  enum XSParseInfixSelection {
    XPI_SELECT_ANY,
    XPI_SELECT_PREDICATE, /* any predicate */
    XPI_SELECT_RELATION,  /* any relation */
    XPI_SELECT_EQUALITY,  /* any equality */
    XPI_SELECT_ORDERING,  /* any ordering */
  
    XPI_SELECT_MATCH_NOSMART, /* any equality or other match operator, including smartmatch */
    XPI_SELECT_MATCH_SMART,   /* any equality or other match operator, not including smartmatch */
  };
  
  /* lhs_flags, rhs_flags */
  enum {
    XPI_OPERAND_TERM = 0, /* the "default" termexpr with no context */
    /* other space reserved for other scalar types */
    XPI_OPERAND_TERM_LIST = 6, /* term in list context */
    XPI_OPERAND_LIST      = 7, /* list in list context */
  
    /* Other bitflags */
    XPI_OPERAND_ONLY_LOOK = (1<<3),
  };
  
  struct XSParseInfixHooks {
    U16 flags;
    U8 lhs_flags, rhs_flags;
    enum XSParseInfixClassification cls;
  
    const char *wrapper_func_name;
  
    /* These two hooks are ANDed together; both must pass, if present */
    const char *permit_hintkey;
    bool (*permit) (pTHX_ void *hookdata);
  
    /* These hooks are alternatives; the first one defined is used */
    OP *(*new_op)(pTHX_ U32 flags, OP *lhs, OP *rhs, void *hookdata);
    OP *(*ppaddr)(pTHX); /* A pp func used directly in newBINOP_custom() */
  };
  
  struct XSParseInfixInfo {
    const char *opname;
    OPCODE opcode;
  
    const struct XSParseInfixHooks *hooks;
    void *hookdata;
  };
  
  static OP *(*xs_parse_infix_new_op_func)(pTHX_ const struct XSParseInfixInfo *info, U32 flags, OP *lhs, OP *rhs);
  #define xs_parse_infix_new_op(info, flags, lhs, rhs)  S_xs_parse_infix_new_op(aTHX_ info, flags, lhs, rhs)
  static OP *S_xs_parse_infix_new_op(pTHX_ const struct XSParseInfixInfo *info, U32 flags, OP *lhs, OP *rhs)
  {
    if(!xs_parse_infix_new_op_func)
      croak("Must call boot_xs_parse_infix() first");
  
    return (*xs_parse_infix_new_op_func)(aTHX_ info, flags, lhs, rhs);
  }
  
  static void (*register_xs_parse_infix_func)(pTHX_ const char *kw, const struct XSParseInfixHooks *hooks, void *hookdata);
  #define register_xs_parse_infix(opname, hooks, hookdata)  S_register_xs_parse_infix(aTHX_ opname, hooks, hookdata)
  static void S_register_xs_parse_infix(pTHX_ const char *opname, const struct XSParseInfixHooks *hooks, void *hookdata)
  {
    if(!register_xs_parse_infix_func)
      croak("Must call boot_xs_parse_infix() first");
  
    return (*register_xs_parse_infix_func)(aTHX_ opname, hooks, hookdata);
  }
  
  #define boot_xs_parse_infix(ver) S_boot_xs_parse_infix(aTHX_ ver)
  static void S_boot_xs_parse_infix(pTHX_ double ver) {
    SV **svp;
    SV *versv = ver ? newSVnv(ver) : NULL;
  
    /* XS::Parse::Infix is implemented in XS::Parse::Keyword's .so file */
    load_module(PERL_LOADMOD_NOIMPORT, newSVpvs("XS::Parse::Keyword"), versv, NULL);
  
    svp = hv_fetchs(PL_modglobal, "XS::Parse::Infix/ABIVERSION_MIN", 0);
    if(!svp)
      croak("XS::Parse::Infix ABI minimum version missing");
    int abi_ver = SvIV(*svp);
    if(abi_ver > XSPARSEINFIX_ABI_VERSION)
      croak("XS::Parse::Infix ABI version mismatch - library supports >= %d, compiled for %d",
          abi_ver, XSPARSEINFIX_ABI_VERSION);
  
    svp = hv_fetchs(PL_modglobal, "XS::Parse::Infix/ABIVERSION_MAX", 0);
    abi_ver = SvIV(*svp);
    if(abi_ver < XSPARSEINFIX_ABI_VERSION)
      croak("XS::Parse::Infix ABI version mismatch - library supports <= %d, compiled for %d",
          abi_ver, XSPARSEINFIX_ABI_VERSION);
  
    xs_parse_infix_new_op_func = INT2PTR(OP *(*)(pTHX_ const struct XSParseInfixInfo *, U32, OP *, OP *),
        SvUV(*hv_fetchs(PL_modglobal, "XS::Parse::Infix/new_op()@0", 0)));
    register_xs_parse_infix_func = INT2PTR(void (*)(pTHX_ const char *, const struct XSParseInfixHooks *, void *),
        SvUV(*hv_fetchs(PL_modglobal, "XS::Parse::Infix/register()@1", 0)));
  }
  
  #endif
X86_64-LINUX_XS_PARSE_INFIX_BUILDER_DATA

$fatpacked{"x86_64-linux/XS/Parse/Keyword.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_XS_PARSE_KEYWORD';
  #  You may distribute under the terms of either the GNU General Public License
  #  or the Artistic License (the same terms as Perl itself)
  #
  #  (C) Paul Evans, 2021-2022 -- leonerd@leonerd.org.uk
  
  package XS::Parse::Keyword 0.22;
  
  use v5.14;
  use warnings;
  
  require XSLoader;
  XSLoader::load( __PACKAGE__, our $VERSION );
  
  =head1 NAME
  
  C<XS::Parse::Keyword> - XS functions to assist in parsing keyword syntax
  
  =head1 DESCRIPTION
  
  This module provides some XS functions to assist in writing syntax modules
  that provide new perl-visible syntax, primarily for authors of keyword plugins
  using the C<PL_keyword_plugin> hook mechanism. It is unlikely to be of much
  use to anyone else; and highly unlikely to be any use when writing perl code
  using these. Unless you are writing a keyword plugin using XS, this module is
  not for you.
  
  This module is also currently experimental, and the design is still evolving
  and subject to change. Later versions may break ABI compatibility, requiring
  changes or at least a rebuild of any module that depends on it.
  
  =cut
  
  =head1 XS FUNCTIONS
  
  =head2 boot_xs_parse_keyword
  
     void boot_xs_parse_keyword(double ver);
  
  Call this function from your C<BOOT> section in order to initialise the module
  and parsing hooks.
  
  I<ver> should either be 0 or a decimal number for the module version
  requirement; e.g.
  
     boot_xs_parse_keyword(0.14);
  
  =head2 register_xs_parse_keyword
  
     void register_xs_parse_keyword(const char *keyword,
       const struct XSParseKeywordHooks *hooks, void *hookdata);
  
  This function installs a set of parsing hooks to be associated with the given
  keyword. Such a keyword will then be handled automatically by a keyword parser
  installed by C<XS::Parse::Keyword> itself.
  
  =cut
  
  =head1 PARSE HOOKS
  
  The C<XSParseKeywordHooks> structure provides the following hook stages, which
  are invoked in the given order.
  
  =head2 flags
  
  The following flags are defined:
  
  =over 4
  
  =item C<XPK_FLAG_EXPR>
  
  The parse or build function is expected to return C<KEYWORD_PLUGIN_EXPR>.
  
  =item C<XPK_FLAG_STMT>
  
  The parse or build function is expected to return C<KEYWORD_PLUGIN_STMT>.
  
  These two flags are largely for the benefit of giving static information at
  registration time to assist static parsing or other related tasks to know what
  kind of grammatical element this keyword will produce.
  
  =item C<XPK_FLAG_AUTOSEMI>
  
  The syntax forms a complete statement, which should be followed by a statement
  separator semicolon (C<;>). This semicolon is optional at the end of a block.
  
  The semicolon, if present, will be consumed automatically.
  
  =back
  
  =head2 The C<permit> Stage
  
     const char *permit_hintkey;
     bool (*permit) (pTHX_ void *hookdata);
  
  Called by the installed keyword parser hook which is used to handle keywords
  registered by L</register_xs_parse_keyword>.
  
  As a shortcut for the common case, the C<permit_hintkey> may point to a string
  to look up from the hints hash. If the given key name is not found in the
  hints hash then the keyword is not permitted. If the key is present then the
  C<permit> function is invoked as normal.
  
  If not rejected by a hint key that was not found in the hints hash, the
  function part of the stage is called next and should inspect whether the
  keyword is permitted at this time perhaps by inspecting other lexical clues,
  and return true only if the keyword is permitted.
  
  Both the string and the function are optional. Either or both may be present.
  If neither is present then the keyword is always permitted - which is likely
  not what you wanted to do.
  
  =head2 The C<check> Stage
  
     void (*check)(pTHX_ void *hookdata);
  
  Invoked once the keyword has been permitted. If present, this hook function
  can check the surrounding lexical context, state, or other information and
  throw an exception if it is unhappy that the keyword should apply in this
  position.
  
  =head2 The C<parse> Stage
  
  This stage is invoked once the keyword has been checked, and actually
  parses the incoming text into an optree. It is implemented by calling the
  B<first> of the following function pointers which is not NULL. The invoked
  function may optionally build an optree to represent the parsed syntax, and
  place it into the variable addressed by C<out>. If it does not, then a simple
  C<OP_NULL> will be constructed in its place.
  
  C<lex_read_space()> is called both before and after this stage is invoked, so
  in many simple cases the hook function itself does not need to bother with it.
  
     int (*parse)(pTHX_ OP **out, void *hookdata);
  
  If present, this should consume text from the parser buffer by invoking
  C<lex_*> or C<parse_*> functions and eventually return a C<KEYWORD_PLUGIN_*>
  result value.
  
  This is the most generic and powerful of the options, but requires the most
  amount of implementation work.
  
     int (*build)(pTHX_ OP **out, XSParseKeywordPiece *args[], size_t nargs, void *hookdata);
  
  If C<parse> is not present, this is called instead after parsing a sequence of
  arguments, of types given by the I<pieces> field; which should be a zero-
  terminated array of piece types.
  
  This alternative is somewhat less generic and powerful than providing C<parse>
  yourself, but involves much less parsing work and is shorter and easier to
  implement.
  
     int (*build1)(pTHX_ OP **out, XSParseKeywordPiece *arg0, void *hookdata);
  
  If neither C<parse> nor C<build> are present, this is called as a simpler
  variant of C<build> when only a single argument is required. It takes its type
  from the C<piece1> field instead.
  
  =cut
  
  =head1 PIECES AND PIECE TYPES
  
  When using the C<build> or C<build1> alternatives for the C<parse> phase, the
  actual syntax is parsed automatically by this module, according to the
  specification given by the I<pieces> or I<piece1> field. The result of that
  parsing step is placed into the I<args> or I<arg0> parameter to the invoked
  function, using a C<struct> type consisting of the following fields:
  
     typedef struct
        union {
           OP *op;
           CV *cv;
           SV *sv;
           int i;
           struct {
              SV *name;
              SV *value;
           } attr;
           PADOFFSET padix;
           struct XSParseInfixInfo *infix;
        };
        int line;
     } XSParseKeywordPiece;
  
  Which field of the anonymous union is set depends on the type of the piece.
  The I<line> field contains the line number of the source file where parsing of
  that piece began.
  
  Some piece types are "atomic", whose definition is self-contained. Others are
  structural, defined in terms of inner pieces. Together these form an entire
  tree-shaped definition of the syntax that the keyword expects to find.
  
  Atomic types generally provide exactly one argument into the list of I<args>
  (with the exception of literal matches, which do not provide anything).
  Structural types may provide an initial argument themselves, followed by a
  list of the values of each sub-piece they contained inside them. Thus, while
  the data structure defining the syntax shape is a tree, the argument values it
  parses into is passed as a flat array to the C<build> function.
  
  Some structural types need to be able to determine whether or not syntax
  relating some optional part of them is present in the incoming source text. In
  this case, the pieces relating to those optional parts must support "probing".
  This ability is also noted below.
  
  The type of each piece should be one of the following macro values.
  
  =head2 XPK_BLOCK
  
  I<atomic, can probe, emits op.>
  
     XPK_BLOCK
  
  A brace-delimited block of code is expected, passed as an optree in the I<op>
  field. This will be parsed as a block within the current function scope.
  
  This can be probed by checking for the presence of an open-brace (C<{>)
  character.
  
  Be careful defining grammars with this because an open-brace is also a valid
  character to start a term expression, for example. Given a choice between
  C<XPK_BLOCK> and C<XPK_TERMEXPR>, either of them could try to consume such
  code as
  
     { 123, 456 }
  
  =head2 XPK_BLOCK_VOIDCTX, XPK_BLOCK_SCALARCTX, XPK_BLOCK_LISTCTX
  
  Variants of C<XPK_BLOCK> which wrap a void, scalar or list-context scope
  around the block.
  
  =head2 XPK_PREFIXED_BLOCK
  
  I<structural, emits op.>
  
     XPK_PREFIXED_BLOCK(pieces ...)
  
  Some pieces are expected, followed by a brace-delimited block of code, which
  is passed as an optree in the I<op> field. The prefix pieces are parsed first,
  and their results are passed before the block itself.
  
  The entire sequence, including the prefix items, is contained within a pair of
  C<block_start()> / C<block_end()> calls. This permits the prefix pieces to
  introduce new items into the lexical scope of the block - for example by the
  use of C<XPK_LEXVAR_MY>.
  
  A call to C<intro_my()> is automatically made at the end of the prefix pieces,
  before the block itself is parsed, ensuring any new lexical variables are now
  visible.
  
  In addition, the following extra piece types are recognised here:
  
  =over 4
  
  =item XPK_SETUP
  
     void setup(pTHX_ void *hookdata);
  
     XPK_SETUP(&setup)
  
  I<atomic, emits nothing.>
  
  This piece type runs a function given by pointer. Typically this function may
  be used to introduce new lexical state into the parser, or in some other way
  have some side-effect on the parsing context of the block to be parsed.
  
  =back
  
  =head2 XPK_PREFIXED_BLOCK_ENTERLEAVE
  
  A variant of C<XPK_PREFIXED_BLOCK> which additionally wraps the entire parsing
  operation, including the C<block_start()>, C<block_end()> and any calls to
  C<XPK_SETUP> functions, within a C<ENTER>/C<LEAVE> pair.
  
  This should not make a difference to the standard parser pieces provided here,
  but may be useful behaviour for the code in the setup function, especially if
  it wishes to modify parser state and use the savestack to ensure it is
  restored again when parsing has finished.
  
  =head2 XPK_ANONSUB
  
  I<atomic, emits op.>
  
  A brace-delimited block of code is expected, and assembled into the body of a
  new anonymous subroutine. This will be passed as a protosub CV in the I<cv>
  field.
  
  =head2 XPK_TERMEXPR
  
  I<atomic, emits op.>
  
     XPK_TERMEXPR
  
  A term expression is expected, parsed using C<parse_termexpr()>, and passed as
  an optree in the I<op> field.
  
  =head2 XPK_TERMEXPR_VOIDCTX, XPK_TERMEXPR_SCALARCTX
  
  Variants of C<XPK_TERMEXPR> which puts the expression in void or scalar context.
  
  =head2 XPK_LISTEXPR
  
  I<atomic, emits op.>
  
     XPK_LISTEXPR
  
  A list expression is expected, parsed using C<parse_listexpr()>, and passed as
  an optree in the I<op> field.
  
  =head2 XPK_LISTEXPR_LISTCTX
  
  Variant of C<XPK_LISTEXPR> which puts the expression in list context.
  
  =head2 XPK_IDENT, XPK_IDENT_OPT
  
  I<atomic, can probe, emits sv.>
  
  A bareword identifier name is expected, and passed as an SV containing a PV
  in the I<sv> field. An identifier is not permitted to contain a double colon
  (C<::>).
  
  The C<_OPT>-suffixed version is optional; if no identifier is found then I<sv>
  is set to C<NULL>.
  
  =head2 XPK_PACKAGENAME, XPK_PACKAGENAME_OPT
  
  I<atomic, can probe, emits sv.>
  
  A bareword package name is expected, and passed as an SV containing a PV in
  the I<sv> field. A package name is similar to an identifier, except it permits
  double colons in the middle.
  
  The C<_OPT>-suffixed version is optional; if no package name is found then
  I<sv> is set to C<NULL>.
  
  =head2 XPK_LEXVARNAME
  
  I<atomic, emits sv.>
  
     XPK_LEXVARNAME(kind)
  
  A lexical variable name is expected, and passed as an SV containing a PV in
  the I<sv> field. The C<kind> argument specifies what kinds of variable are
  permitted, and should be a bitmask of one or more bits from
  C<XPK_LEXVAR_SCALAR>, C<XPK_LEXVAR_ARRAY> and C<XPK_LEXVAR_HASH>. A convenient
  shortcut C<XPK_LEXVAR_ANY> permits all three.
  
  =head2 XPK_ATTRIBUTES
  
  I<atomic, emits i followed by more args.>
  
  A list of C<:>-prefixed attributes is expected, in the same format as sub or
  variable attributes. An optional leading C<:> indicates the presence of
  attributes, then one or more of them are parsed. Attributes may be optionally
  separated by additional C<:>s, but this is not required.
  
  Each attribute is expected to be an identifier name, followed by an optional
  value wrapped in parentheses. Whitespace is B<NOT> permitted between the name
  and value, as per standard Perl parsing rules.
  
     :attrname
     :attrname(value)
  
  The I<i> field indicates how many attributes were found. That number of
  additional arguments are then passed, each containing two SVs in the
  I<attr.name> and I<attr.value> fields. This number may be zero.
  
  It is not an error for there to be no attributes present, or for the optional
  colon to be missing. In this case I<i> will be set to zero.
  
  =head2 XPK_VSTRING, XPK_VSTRING_OPT
  
  I<atomic, can probe, emits sv.>
  
  A version string is expected, of the form C<v1.234> including the leading C<v>
  character. It is passed as a L<version> SV object in the I<sv> field.
  
  The C<_OPT>-suffixed version is optional; if no version string is found then
  I<sv> is set to C<NULL>.
  
  =head2 XPK_LEXVAR_MY
  
  I<atomic, emits padix.>
  
     XPK_LEXVAR_MY(kind)
  
  A lexical variable name is expected, added to the current pad as if specified
  in a C<my> expression, and passed as the pad index in the I<padix> field.
  
  The C<kind> argument specifies what kinds of variable are permitted, as per
  C<XPK_LEXVARNAME>.
  
  =head2 XPK_COMMA, XPK_COLON, XPK_EQUALS
  
  I<atomic, can probe, emits nothing.>
  
  A literal character (C<,>, C<:> or C<=>) is expected. No argument value is passed.
  
  =head2 XPK_AUTOSEMI
  
  I<atomic, emits nothing.>
  
  A literal semicolon (C<;>) as a statement terminator is optionally expected.
  If the next token is a closing brace to indicate the end of a block, then a
  semicolon is not required. If anything else is encountered an error will be
  raised.
  
  This piece type is the same as specifying the C<XPK_FLAG_AUTOSEMI>. It is
  useful to put at the end of a sequence that forms part of a choice of syntax,
  where some forms indicate a statement ending in a semicolon, whereas others
  may end in a full block that does not need one.
  
  =head2 XPK_INFIX_*
  
  I<atomic, can probe, emits infix.>
  
  An infix operator as recognised by L<XS::Parse::Infix>. The returned pointer
  points to a structure allocated by C<XS::Parse::Infix> describing the
  operator.
  
  Various versions of the macro are provided, each using a different selection
  filter to choose certain available infix operators:
  
     XPK_INFIX_RELATION         # any relational operator
     XPK_INFIX_EQUALITY         # an equality operator like `==` or `eq`
     XPK_INFIX_MATCH_NOSMART    # any sort of "match"-like operator, except smartmatch
     XPK_INFIX_MATCH_SMART      # XPK_INFIX_MATCH_NOSMART plus smartmatch
  
  =head2 XPK_LITERAL
  
  I<atomic, can probe, emits nothing.>
  
     XPK_LITERAL("literal")
  
  A literal string match is expected. No argument value is passed.
  
  This form should generally be avoided if at all possible, because it is very
  easy to abuse to make syntaxes which confuse humans and code tools alike.
  Generally it is best reserved just for the first component of a
  C<XPK_OPTIONAL> or C<XPK_REPEATED> sequence, to provide a "secondary keyword"
  that such a repeated item can look out for.
  
  This was previously called C<XPK_STRING>, and is provided as a synonym for
  back-compatibility but new code should use this new name instead.
  
  =head2 XPK_SEQUENCE
  
  I<structural, might support probe, emits nothing.>
  
     XPK_SEQUENCE(pieces ...)
  
  A structural type which contains a number of pieces. This is normally
  equivalent to simply placing the pieces in sequence inside their own
  container, but it is useful inside C<XPK_CHOICE> or C<XPK_TAGGEDCHOICE>.
  
  An C<XPK_SEQUENCE> supports probe if its first contained piece does; i.e.
  is transparent to probing.
  
  =head2 XPK_OPTIONAL
  
  I<structural, emits i.>
  
     XPK_OPTIONAL(pieces ...)
  
  A structural type which may expects to find its contained pieces, or is happy
  not to. This will pass an argument whose I<i> field contains either 1 or 0,
  depending whether the contents were found. The first piece type within must
  support probe.
  
  =head2 XPK_REPEATED
  
  I<structural, emits i.>
  
     XPK_REPEATED(pieces ...)
  
  A structural type which expects to find zero or more repeats of its contained
  pieces. This will pass an argument whose I<i> field contains the count of the
  number of repeats it found. The first piece type within must support probe.
  
  =head2 XPK_CHOICE
  
  I<structural, can probe, emits i.>
  
     XPK_CHOICE(options ...)
  
  A structural type which expects to find one of a number of alternative
  options. An ordered list of types is provided, all of which must support
  probe. This will pass an argument whose I<i> field gives the index of the
  first choice that was accepted. The first option takes the value 0.
  
  As each of the options is interpreted as an alternative, not a sequence, you
  should use C<XPK_SEQUENCE> if a sequence of multiple items should be
  considered as a single alternative.
  
  It is not an error if no choice matches. At that point, the I<i> field will be
  set to -1.
  
  If you require a failure message in this case, set the final choice to be of
  type C<XPK_FAILURE>. This will cause an error message to be printed instead.
  
     XPK_FAILURE("message string")
  
  =head2 XPK_TAGGEDCHOICE
  
  I<structural, can probe, emits i.>
  
     XPK_TAGGEDCHOICE(choice, tag, ...)
  
  A structural type similar to C<XPK_CHOICE>, except that each choice type is
  followed by an element of type C<XPK_TAG> which gives an integer. It is that
  integer value, rather than the positional index of the choice within the list,
  which is passed in the I<i> field.
  
     XPK_TAG(value)
  
  As each of the options is interpreted as an alternative, not a sequence, you
  should use C<XPK_SEQUENCE> if a sequence of multiple items should be
  considered as a single alternative.
  
  =head2 XPK_COMMALIST
  
  I<structural, might support probe, emits i.>
  
     XPK_COMMALIST(pieces ...)
  
  A structural type which expects to find one or more repeats of its contained
  pieces, separated by literal comma (C<,>) characters. This is somewhat similar
  to C<XPK_REPEATED>, except that it needs at least one copy, needs commas
  between its items, but does not require that the first contained piece support
  probe (the comma itself is sufficient to indicate a repeat).
  
  An C<XPK_COMMALIST> supports probe if its first contained piece does; i.e.
  is transparent to probing.
  
  =head2 XPK_PARENSCOPE
  
  I<structural, can probe, emits nothing.>
  
     XPK_PARENSCOPE(pieces ...)
  
  A structural type which expects to find a sequence of pieces, all contained in
  parentheses as C<( ... )>. This will pass no extra arguments.
  
  =head2 XPK_BRACKETSCOPE
  
  I<structural, can probe, emits nothing.>
  
     XPK_BRACKETSCOPE(pieces ...)
  
  A structural type which expects to find a sequence of pieces, all contained in
  square brackets as C<[ ... ]>. This will pass no extra arguments.
  
  =head2 XPK_BRACESCOPE
  
  I<structural, can probe, emits nothing.>
  
     XPK_BRACESCOPE(pieces ...)
  
  A structural type which expects to find a sequence of pieces, all contained in
  braces as C<{ ... }>. This will pass no extra arguments.
  
  Note that this is not necessary to use with C<XPK_BLOCK> or C<XPK_ANONSUB>;
  those will already consume a set of braces. This is intended for special
  constrained syntax that should not just accept an arbitrary block.
  
  =head2 XPK_CHEVRONSCOPE
  
  I<structural, can probe, emits nothing.>
  
     XPK_CHEVRONSCOPE(pieces ...)
  
  A structural type which expects to find a sequence of pieces, all contained in
  angle brackets as C<< < ... > >>. This will pass no extra arguments.
  
  Remember that expressions like C<< a > b >> are valid term expressions, so the
  contents of this scope shouldn't allow arbitrary expressions or the closing
  bracket will be ambiguous.
  
  =head2 XPK_PARENSCOPE_OPT, XPK_BRACKETSCOPE_OPT, XPK_BRACESCOPE_OPT, XPK_CHEVRONSCOPE_OPT
  
  I<structural, can probe, emits i.>
  
     XPK_PARENSCOPE_OPT(pieces ...)
     XPK_BRACKETSCOPE_OPT(pieces ...)
     XPK_BRACESCOPE_OPT(pieces ...)
     XPK_CHEVERONSCOPE_OPT(pieces ...)
  
  Each of the four C<XPK_...SCOPE> macros above has an optional variant, whose
  name is suffixed by C<_OPT>. These pass an argument whose I<i> field is either
  true or false, indicating whether the scope was found, followed by the values
  from the scope itself.
  
  This is a convenient shortcut to nesting the scope within a C<XPK_OPTIONAL>
  macro.
  
  =cut
  
  =head1 AUTHOR
  
  Paul Evans <leonerd@leonerd.org.uk>
  
  =cut
  
  0x55AA;
X86_64-LINUX_XS_PARSE_KEYWORD

$fatpacked{"x86_64-linux/XS/Parse/Keyword/Builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_XS_PARSE_KEYWORD_BUILDER';
  #  You may distribute under the terms of either the GNU General Public License
  #  or the Artistic License (the same terms as Perl itself)
  #
  #  (C) Paul Evans, 2021 -- leonerd@leonerd.org.uk
  
  package XS::Parse::Keyword::Builder 0.22;
  
  use v5.14;
  use warnings;
  
  =head1 NAME
  
  C<XS::Parse::Keyword::Builder> - build-time support for C<XS::Parse::Keyword>
  
  =head1 SYNOPSIS
  
  In F<Build.PL>:
  
     use XS::Parse::Keyword::Builder;
  
     my $build = Module::Build->new(
        ...,
        configure_requires => {
           ...
           'XS::Parse::Keyword::Builder' => 0,
        }
     );
  
     XS::Parse::Keyword::Builder->extend_module_build( $build );
  
     ...
  
  =head1 DESCRIPTION
  
  This module provides a build-time helper to assist authors writing XS modules
  that use L<XS::Parse::Keyword>. It prepares a L<Module::Build>-using
  distribution to be able to make use of C<XS::Parse::Keyword>.
  
  =cut
  
  require XS::Parse::Keyword::Builder_data;
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 write_XSParseKeyword_h
  
     XS::Parse::Keyword::Builder->write_XSParseKeyword_h
  
  Writes the F<XSParseKeyword.h> file to the current working directory. To cause
  the compiler to actually find this file, see L</extra_compiler_flags>.
  
  =cut
  
  sub write_XSParseKeyword_h
  {
     shift;
  
     open my $out, ">", "XSParseKeyword.h" or
        die "Cannot open XSParseKeyword.h for writing - $!\n";
  
     $out->print( XS::Parse::Keyword::Builder_data->XSPARSEKEYWORD_H );
  }
  
  =head2 extra_compiler_flags
  
     @flags = XS::Parse::Keyword::Builder->extra_compiler_flags
  
  Returns a list of extra flags that the build scripts should add to the
  compiler invocation. This enables the C compiler to find the
  F<XSParseKeyword.h> file.
  
  =cut
  
  sub extra_compiler_flags
  {
     shift;
     return "-I.", XS::Parse::Keyword::Builder_data->BUILDER_CFLAGS;
  }
  
  =head2 extend_module_build
  
     XS::Parse::Keyword::Builder->extend_module_build( $build )
  
  A convenient shortcut for performing all the tasks necessary to make a
  L<Module::Build>-based distribution use the helper.
  
  =cut
  
  sub extend_module_build
  {
     my $self = shift;
     my ( $build ) = @_;
  
     eval { $self->write_XSParseKeyword_h } or do {
        warn $@;
        return;
     };
  
     # preserve existing flags
     my @flags = @{ $build->extra_compiler_flags };
     push @flags, $self->extra_compiler_flags;
  
     $build->extra_compiler_flags( @flags );
  }
  
  =head1 AUTHOR
  
  Paul Evans <leonerd@leonerd.org.uk>
  
  =cut
  
  0x55AA;
X86_64-LINUX_XS_PARSE_KEYWORD_BUILDER

$fatpacked{"x86_64-linux/XS/Parse/Keyword/Builder_data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_XS_PARSE_KEYWORD_BUILDER_DATA';
  package XS::Parse::Keyword::Builder_data 0.22;
  
  use v5.14;
  use warnings;
  
  # Additional CFLAGS arguments to pass during compilation
  use constant BUILDER_CFLAGS => ;
  
  # The contents of the "XSParseKeyword.h" file
  my $XSParseKeyword_h = do {
     local $/;
     readline DATA;
  };
  sub XSPARSEKEYWORD_H() { $XSParseKeyword_h }
  
  0x55AA;
  
  __DATA__
  #ifndef __XS_PARSE_KEYWORD_H__
  #define __XS_PARSE_KEYWORD_H__
  
  #define XSPARSEKEYWORD_ABI_VERSION 2
  
  struct XSParseKeywordPieceType;
  struct XSParseKeywordPieceType {
    int type;
    union {
      char                                  c;      /* LITERALCHAR */
      const char                           *str;    /* LITERALSTR */
      const struct XSParseKeywordPieceType *pieces; /* SCOPEs */
      void                                (*callback)(pTHX_ void *hookdata); /* SETUP */
    } u;
  };
  
  enum {
    XPK_FLAG_EXPR     = (1<<0),
    XPK_FLAG_STMT     = (1<<1),
    XPK_FLAG_AUTOSEMI = (1<<2),
  };
  
  enum {
    /* skip zero */
  
    /*                                    emits */
    XS_PARSE_KEYWORD_LITERALCHAR = 1,   /* nothing */
    XS_PARSE_KEYWORD_LITERALSTR,        /* nothing */
    XS_PARSE_KEYWORD_AUTOSEMI,          /* nothing */
    XS_PARSE_KEYWORD_FAILURE = 0x0f,    /* nothing */
  
    XS_PARSE_KEYWORD_BLOCK = 0x10,      /* op */
    XS_PARSE_KEYWORD_ANONSUB,           /* cv */
    /* TODO: XS_PARSE_KEYWORD_ARITHEXPR = 0x12 */
    XS_PARSE_KEYWORD_TERMEXPR = 0x13,   /* op */
    XS_PARSE_KEYWORD_LISTEXPR,          /* op */
    /* TODO: XS_PARSE_KEYWORD_FULLEXPR = 0x15 */
    XS_PARSE_KEYWORD_IDENT = 0x16,      /* sv */
    XS_PARSE_KEYWORD_PACKAGENAME,       /* sv */
    XS_PARSE_KEYWORD_LEXVARNAME,        /* sv */
    XS_PARSE_KEYWORD_LEXVAR,            /* padix */
    XS_PARSE_KEYWORD_ATTRS,             /* i / {attr.name + attr.val} */
    XS_PARSE_KEYWORD_VSTRING,           /* sv */
  
    XS_PARSE_KEYWORD_INFIX = 0x40,      /* infix */
  
    XS_PARSE_KEYWORD_SETUP = 0x70,      /* invokes callback, emits nothing */
  
    XS_PARSE_KEYWORD_SEQUENCE = 0x80,   /* contained */
    XS_PARSE_KEYWORD_REPEATED,          /* i, contained */
    XS_PARSE_KEYWORD_CHOICE,            /* i, contained */
    XS_PARSE_KEYWORD_TAGGEDCHOICE,      /* i, contained */
    XS_PARSE_KEYWORD_SEPARATEDLIST,     /* i, contained */
    XS_PARSE_KEYWORD_PARENSCOPE = 0xb0, /* contained */
    XS_PARSE_KEYWORD_BRACKETSCOPE,      /* contained */
    XS_PARSE_KEYWORD_BRACESCOPE,        /* contained */
    XS_PARSE_KEYWORD_CHEVRONSCOPE,      /* contained */
  };
  
  enum {
    XPK_LEXVAR_SCALAR = (1<<0),
    XPK_LEXVAR_ARRAY  = (1<<1),
    XPK_LEXVAR_HASH   = (1<<2),
    XPK_LEXVAR_ANY    = XPK_LEXVAR_SCALAR|XPK_LEXVAR_ARRAY|XPK_LEXVAR_HASH,
  };
  
  enum {
    XPK_TYPEFLAG_OPT      = (1<<16),
    XPK_TYPEFLAG_SPECIAL  = (1<<17), /* on XPK_BLOCK: scoped
                                        on XPK_LEXVAR: my */
  
    /* These three are shifted versions of perl's G_VOID, G_SCALAR, G_LIST */
    XPK_TYPEFLAG_G_VOID   = (1<<18),
    XPK_TYPEFLAG_G_SCALAR = (2<<18),
    XPK_TYPEFLAG_G_LIST   = (3<<18),
  
    XPK_TYPEFLAG_ENTERLEAVE = (1<<20), /* wrap ENTER/LEAVE pair around the item */
  };
  
  #define XPK_BLOCK_flags(flags) {.type = XS_PARSE_KEYWORD_BLOCK|(flags), .u.pieces = NULL}
  #define XPK_BLOCK              XPK_BLOCK_flags(0)
  #define XPK_BLOCK_VOIDCTX      XPK_BLOCK_flags(XPK_TYPEFLAG_SPECIAL|XPK_TYPEFLAG_G_VOID)
  #define XPK_BLOCK_SCALARCTX    XPK_BLOCK_flags(XPK_TYPEFLAG_SPECIAL|XPK_TYPEFLAG_G_SCALAR)
  #define XPK_BLOCK_LISTCTX      XPK_BLOCK_flags(XPK_TYPEFLAG_SPECIAL|XPK_TYPEFLAG_G_LIST)
  
  #define XPK_PREFIXED_BLOCK_flags(flags,...) \
    {.type = XS_PARSE_KEYWORD_BLOCK|flags, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  #define XPK_PREFIXED_BLOCK(...)            XPK_PREFIXED_BLOCK_flags(0, __VA_ARGS__)
  #define XPK_PREFIXED_BLOCK_ENTERLEAVE(...) XPK_PREFIXED_BLOCK_flags(XPK_TYPEFLAG_ENTERLEAVE, __VA_ARGS__)
  
  #define XPK_SETUP(setup)       {.type = XS_PARSE_KEYWORD_SETUP, .u.callback = setup}
  
  #define XPK_ANONSUB {.type = XS_PARSE_KEYWORD_ANONSUB}
  
  #define XPK_TERMEXPR_flags(flags) {.type = XS_PARSE_KEYWORD_TERMEXPR|(flags)}
  #define XPK_TERMEXPR              XPK_TERMEXPR_flags(0)
  #define XPK_TERMEXPR_VOIDCTX      XPK_TERMEXPR_flags(XPK_TYPEFLAG_G_VOID)
  #define XPK_TERMEXPR_SCALARCTX    XPK_TERMEXPR_flags(XPK_TYPEFLAG_G_SCALAR)
  #define XPK_LISTEXPR_flags(flags) {.type = XS_PARSE_KEYWORD_LISTEXPR|(flags)}
  #define XPK_LISTEXPR              XPK_LISTEXPR_flags(0)
  #define XPK_LISTEXPR_LISTCTX      XPK_LISTEXPR_flags(XPK_TYPEFLAG_G_LIST)
  
  #define XPK_IDENT           {.type = XS_PARSE_KEYWORD_IDENT                       }
  #define XPK_IDENT_OPT       {.type = XS_PARSE_KEYWORD_IDENT      |XPK_TYPEFLAG_OPT}
  #define XPK_PACKAGENAME     {.type = XS_PARSE_KEYWORD_PACKAGENAME                 }
  #define XPK_PACKAGENAME_OPT {.type = XS_PARSE_KEYWORD_PACKAGENAME|XPK_TYPEFLAG_OPT}
  
  #define XPK_LEXVARNAME(kind) {.type = XS_PARSE_KEYWORD_LEXVARNAME, .u.c = kind}
  
  #define XPK_LEXVAR_MY(kind) {.type = XS_PARSE_KEYWORD_LEXVAR|XPK_TYPEFLAG_SPECIAL, .u.c = kind}
  
  #define XPK_ATTRIBUTES {.type = XS_PARSE_KEYWORD_ATTRS}
  
  #define XPK_VSTRING     {.type = XS_PARSE_KEYWORD_VSTRING}
  #define XPK_VSTRING_OPT {.type = XS_PARSE_KEYWORD_VSTRING|XPK_TYPEFLAG_OPT}
  
  #define XPK_COMMA  {.type = XS_PARSE_KEYWORD_LITERALCHAR, .u.c = ','}
  #define XPK_COLON  {.type = XS_PARSE_KEYWORD_LITERALCHAR, .u.c = ':'}
  #define XPK_EQUALS {.type = XS_PARSE_KEYWORD_LITERALCHAR, .u.c = '='}
  
  #define XPK_LITERAL(s) {.type = XS_PARSE_KEYWORD_LITERALSTR, .u.str = (const char *)s}
  #define XPK_STRING(s)  XPK_LITERAL(s)
  #define XPK_AUTOSEMI   {.type = XS_PARSE_KEYWORD_AUTOSEMI}
  
  #define XPK_INFIX(select) {.type = XS_PARSE_KEYWORD_INFIX, .u.c = select}
  #define XPK_INFIX_RELATION       XPK_INFIX(XPI_SELECT_RELATION)
  #define XPK_INFIX_EQUALITY       XPK_INFIX(XPI_SELECT_EQUALITY)
  #define XPK_INFIX_MATCH_NOSMART  XPK_INFIX(XPI_SELECT_MATCH_NOSMART)
  #define XPK_INFIX_MATCH_SMART    XPK_INFIX(XPI_SELECT_MATCH_SMART)
  
  #define XPK_SEQUENCE(...) \
    {.type = XS_PARSE_KEYWORD_SEQUENCE, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  /* First piece of these must be something probe-able */
  #define XPK_OPTIONAL(...) \
    {.type = XS_PARSE_KEYWORD_SEQUENCE|XPK_TYPEFLAG_OPT, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  #define XPK_REPEATED(...) \
    {.type = XS_PARSE_KEYWORD_REPEATED, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  /* Every piece must be probeable */
  #define XPK_CHOICE(...) \
    {.type = XS_PARSE_KEYWORD_CHOICE, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  /* Every piece must be probeable, and followed by XPK_TAG */
  #define XPK_TAGGEDCHOICE(...) \
    {.type = XS_PARSE_KEYWORD_TAGGEDCHOICE, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0}, {0} }}
  #define XPK_TAG(val) \
    {.type = val}
  #define XPK_COMMALIST(...) \
    {.type = XS_PARSE_KEYWORD_SEPARATEDLIST, .u.pieces = (const struct XSParseKeywordPieceType []){ \
        {.type = XS_PARSE_KEYWORD_LITERALCHAR, .u.c = ','}, __VA_ARGS__, {0}}}
  
  #define XPK_FAILURE(s) {.type = XS_PARSE_KEYWORD_FAILURE, .u.str = (const char *)s}
  
  #define XPK_PARENSCOPE(...) \
    {.type = XS_PARSE_KEYWORD_PARENSCOPE, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  #define XPK_PARENSCOPE_OPT(...) \
    {.type = XS_PARSE_KEYWORD_PARENSCOPE|XPK_TYPEFLAG_OPT, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  
  #define XPK_BRACKETSCOPE(...) \
    {.type = XS_PARSE_KEYWORD_BRACKETSCOPE, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  #define XPK_BRACKETSCOPE_OPT(...) \
    {.type = XS_PARSE_KEYWORD_BRACKETSCOPE|XPK_TYPEFLAG_OPT, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  
  #define XPK_BRACESCOPE(...) \
    {.type = XS_PARSE_KEYWORD_BRACESCOPE, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  #define XPK_BRACESCOPE_OPT(...) \
    {.type = XS_PARSE_KEYWORD_BRACESCOPE|XPK_TYPEFLAG_OPT, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  
  #define XPK_CHEVRONSCOPE(...) \
    {.type = XS_PARSE_KEYWORD_CHEVRONSCOPE, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  #define XPK_CHEVRONSCOPE_OPT(...) \
    {.type = XS_PARSE_KEYWORD_CHEVRONSCOPE|XPK_TYPEFLAG_OPT, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  
  /* This type defined in XSParseInfix.h */
  typedef struct XSParseInfixInfo XSParseInfixInfo;
  
  typedef struct {
    union {
      OP *op;
      CV *cv;
      SV *sv;
      int i;
      struct { SV *name; SV *value; } attr;
      PADOFFSET padix;
      XSParseInfixInfo *infix;
    };
    int line;
  } XSParseKeywordPiece;
  
  struct XSParseKeywordHooks {
    U32 flags;
  
    /* used by build1 */
    struct XSParseKeywordPieceType piece1;
    /* alternatively, used by build */
    const struct XSParseKeywordPieceType *pieces;
  
    /* These two hooks are ANDed together; both must pass, if present */
    const char *permit_hintkey;
    bool (*permit) (pTHX_ void *hookdata);
  
    void (*check)(pTHX_ void *hookdata);
  
    /* These are alternatives; the first one defined is used */
    int (*parse)(pTHX_ OP **opp, void *hookdata);
    int (*build)(pTHX_ OP **out, XSParseKeywordPiece *args[], size_t nargs, void *hookdata);
    int (*build1)(pTHX_ OP **out, XSParseKeywordPiece *arg0, void *hookdata);
  };
  
  static void (*register_xs_parse_keyword_func)(pTHX_ const char *kwname, const struct XSParseKeywordHooks *hooks, void *hookdata);
  #define register_xs_parse_keyword(kwname, hooks, hookdata)  S_register_xs_parse_keyword(aTHX_ kwname, hooks, hookdata)
  static void S_register_xs_parse_keyword(pTHX_ const char *kwname, const struct XSParseKeywordHooks *hooks, void *hookdata)
  {
    if(!register_xs_parse_keyword_func)
      croak("Must call boot_xs_parse_keyword() first");
  
    (*register_xs_parse_keyword_func)(aTHX_ kwname, hooks, hookdata);
  }
  
  #define boot_xs_parse_keyword(ver) S_boot_xs_parse_keyword(aTHX_ ver)
  static void S_boot_xs_parse_keyword(pTHX_ double ver) {
    SV **svp;
    SV *versv = ver ? newSVnv(ver) : NULL;
  
    load_module(PERL_LOADMOD_NOIMPORT, newSVpvs("XS::Parse::Keyword"), versv, NULL);
  
    svp = hv_fetchs(PL_modglobal, "XS::Parse::Keyword/ABIVERSION_MIN", 0);
    if(!svp)
      croak("XS::Parse::Keyword ABI minimum version missing");
    int abi_ver = SvIV(*svp);
    if(abi_ver > XSPARSEKEYWORD_ABI_VERSION)
      croak("XS::Parse::Keyword ABI version mismatch - library supports >= %d, compiled for %d",
          abi_ver, XSPARSEKEYWORD_ABI_VERSION);
  
    svp = hv_fetchs(PL_modglobal, "XS::Parse::Keyword/ABIVERSION_MAX", 0);
    abi_ver = SvIV(*svp);
    if(abi_ver < XSPARSEKEYWORD_ABI_VERSION)
      croak("XS::Parse::Keyword ABI version mismatch - library supports <= %d, compiled for %d",
          abi_ver, XSPARSEKEYWORD_ABI_VERSION);
  
    register_xs_parse_keyword_func = INT2PTR(void (*)(pTHX_ const char *, const struct XSParseKeywordHooks *, void *),
        SvUV(*hv_fetchs(PL_modglobal, "XS::Parse::Keyword/register()@2", 0)));
  }
  
  #endif
X86_64-LINUX_XS_PARSE_KEYWORD_BUILDER_DATA

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use strict;
use warnings;
use v5.16.3;

use Carp;
use File::Path;
use Try::Tiny;
use Schedule::Cron;

use lib::relative 'lib';

use Yabsm::Base;
use Yabsm::Config;

die "yabsm: error: permission denied\n" if $<;

my $usage = "usage: yabsmd <start|stop|restart>\n";

my $resource_dir = '/run/yabsmd';
my $pid_file     = "$resource_dir/yabsmd.pid";
my $socket_path  = "$resource_dir/yabsmd.socket";

my $log_dir      = '/var/log/yabsmd';
my $std_log      = "$log_dir/yabsmd-std.log";
my $err_log      = "$log_dir/yabsmd-err.log";

#open STDOUT, '>>', $std_log;
#open STDERR, '>>', $err_log;

$SIG{INT}  = \&yabsmd_stop;
$SIG{TERM} = \&yabsmd_stop;
$SIG{HUP}  = \&yabsmd_restart;

# Main

die $usage unless $#ARGV == 0 && $ARGV[0] =~ /^(start|stop|restart)$/;

$ARGV[0] eq 'start'   && yabsmd_start();
$ARGV[0] eq 'stop'    && yabsmd_stop();
$ARGV[0] eq 'restart' && yabsmd_restart();

# Implementation

sub cron_dispatcher {
  say "ID:   ", shift;
  say "Args: ", "@_";
}

sub yabsmd_start {

    # Program will die with relevant error messages if config is invalid.
    my $config_ref = Yabsm::Config::read_config();

    rmtree $resource_dir if -d $resource_dir;
    mkdir $resource_dir;

    open my $fh, '>', $pid_file or die "yabsmd: error: failed to open file '$pid_file'\n";
    say $fh $$;
    close $fh;
    chmod 0644, $pid_file;

    my $cron_scheduler = new Schedule::Cron(\&cron_dispatcher);

    Yabsm::Base::schedule_snapshots($config_ref, $cron_scheduler);
    Yabsm::Base::schedule_backups($config_ref, $cron_scheduler);

    $cron_scheduler->run();
}

sub yabsmd_stop {

    rmtree $resource_dir if -d $resource_dir;

    exit 0;
}

sub yabsmd_restart { yabsmd_stop() ; yabsmd_start() }
