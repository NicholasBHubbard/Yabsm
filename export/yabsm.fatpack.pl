#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Array/Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARRAY_UTILS';
  package Array::Utils;
  
  =head1 NAME
  
  Array::Utils - small utils for array manipulation
  
  =head1 SYNOPSIS
  
  	use Array::Utils qw(:all);
  	
  	my @a = qw( a b c d );
  	my @b = qw( c d e f );
  
  	# symmetric difference
  	my @diff = array_diff(@a, @b);
  
  	# intersection
  	my @isect = intersect(@a, @b);
  	
  	# unique union
  	my @unique = unique(@a, @b);
  	
  	# check if arrays contain same members
  	if ( !array_diff(@a, @b) ) {
  		# do something
  	}
  	
  	# get items from array @a that are not in array @b
  	my @minus = array_minus( @a, @b );
  	
  =head1 DESCRIPTION
  
  A small pure-perl module containing list manipulation routines. The module
  emerged because I was tired to include same utility routines in numerous projects.
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item C<unique>
  
  Returns an array of unique items in the arguments list.
  
  =item C<intersect>
  
  Returns an intersection of two arrays passed as arguments, keeping the order of the
  second parameter. A nice side effect of this function can be exploited in situations as:
  
  	@atreides = qw( Leto Paul Alia 'Leto II' );
  	@mylist = qw( Alia Leto );
  	@mylist = intersect( @mylist, @atreides );  # and @mylist is ordered as Leto,Alia
  
  =item C<array_diff>
  
  Return symmetric difference of two arrays passed as arguments.
  
  =item C<array_minus>
  
  Returns the difference of the passed arrays A and B (only those 
  array elements that exist in A and do not exist in B). 
  If an empty array is returned, A is subset of B.
  
  Function was proposed by Laszlo Forro <salmonix@gmail.com>.
  
  =back
  
  =head1 BUGS
  
  None known yet
  
  =head1 AUTHOR
  
  Sergei A. Fedorov <zmij@cpan.org>
  
  I will be happy to have your feedback about the module.
  
  =head1 COPYRIGHT
  
  This module is Copyright (c) 2007 Sergei A. Fedorov.
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public
  License or the Artistic License, as specified in the Perl README file.
  
  =head1 WARRANTY
  
  This is free software. IT COMES WITHOUT WARRANTY OF ANY KIND.
  
  =cut
  
  use strict;
  
  require Exporter;
  our @ISA = qw(Exporter);
  
  our %EXPORT_TAGS = (
  	all	=> [ qw(
  		&unique
  		&intersect
  		&array_diff
  		&array_minus
  	) ],
  );
  our @EXPORT_OK = ( @{ $EXPORT_TAGS{'all'} } );
  
  our $VERSION = '0.5';
  
  sub unique(@) {
  	return keys %{ {map { $_ => undef } @_}}; 
  }
  
  sub intersect(\@\@) {
  	my %e = map { $_ => undef } @{$_[0]};
  	return grep { exists( $e{$_} ) } @{$_[1]};
  }
  
  sub array_diff(\@\@) {
  	my %e = map { $_ => undef } @{$_[1]};
  	return @{[ ( grep { (exists $e{$_}) ? ( delete $e{$_} ) : ( 1 ) } @{ $_[0] } ), keys %e ] };
  }
  
  sub array_minus(\@\@) {
  	my %e = map{ $_ => undef } @{$_[1]};
  	return grep( ! exists( $e{$_} ), @{$_[0]} ); 
  }
  
  1;
ARRAY_UTILS

$fatpacked{"Feature/Compat/Try.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FEATURE_COMPAT_TRY';
  #  You may distribute under the terms of either the GNU General Public License
  #  or the Artistic License (the same terms as Perl itself)
  #
  #  (C) Paul Evans, 2021 -- leonerd@leonerd.org.uk
  
  package Feature::Compat::Try 0.04;
  
  use v5.14;
  use warnings;
  use feature ();
  
  use constant HAVE_FEATURE_TRY => defined $feature::feature{try};
  
  =head1 NAME
  
  C<Feature::Compat::Try> - make C<try/catch> syntax available
  
  =head1 SYNOPSIS
  
     use Feature::Compat::Try;
  
     sub foo
     {
        try {
           attempt_a_thing();
           return "success";
        }
        catch ($e) {
           warn "It failed - $e";
           return "failure";
        }
     }
  
  =head1 DESCRIPTION
  
  This module is written in preparation for when perl will gain true native
  syntax support for C<try/catch> control flow.
  
  Perl added such syntax in the development version 5.33.7, which is enabled
  by
  
     use feature 'try';
  
  On that version of perl or later, this module simply enables the core feature
  equivalent to using it directly. On such perls, this module will install with
  no non-core dependencies, and requires no C compiler.
  
  On older versions of perl before such syntax is available, it is currently
  provided instead using the L<Syntax::Keyword::Try> module, imported with a
  special set of options to configure it to recognise exactly and only the same
  syntax as the core perl feature, thus ensuring that any code using it will
  still continue to function on that newer perl.
  
  =cut
  
  =head1 KEYWORDS
  
  =head2 try
  
     try {
        STATEMENTS...
     }
     ...
  
  A C<try> statement provides the main body of code that will be invoked, and
  must be followed by a C<catch> statement.
  
  Execution of the C<try> statement itself begins from the block given to the
  statement and continues until either it throws an exception, or completes
  successfully by reaching the end of the block.
  
  The body of a C<try {}> block may contain a C<return> expression. If executed,
  such an expression will cause the entire containing function to return with
  the value provided. This is different from a plain C<eval {}> block, in which
  circumstance only the C<eval> itself would return, not the entire function.
  
  The body of a C<try {}> block may contain loop control expressions (C<redo>,
  C<next>, C<last>) which will have their usual effect on any loops that the
  C<try {}> block is contained by.
  
  The parsing rules for the set of statements (the C<try> block and its
  associated C<catch>) are such that they are parsed as a self-contained
  statement. Because of this, there is no need to end with a terminating
  semicolon.
  
  Even though it parses as a statement and not an expression, a C<try> block can
  still yield a value if it appears as the final statement in its containing
  C<sub> or C<do> block. For example:
  
     my $result = do {
        try { attempt_func() }
        catch ($e) { "Fallback Value" }
     };
  
  =head2 catch
  
     ...
     catch ($var) {
        STATEMENTS...
     }
  
  A C<catch> statement provides a block of code to the preceding C<try>
  statement that will be invoked in the case that the main block of code throws
  an exception. A new lexical variable is created to store the exception in.
  
  Presence of this C<catch> statement causes any exception thrown by the
  preceding C<try> block to be non-fatal to the surrounding code. If the
  C<catch> block wishes to optionally handle some exceptions but not others, it
  can re-raise it (or another exception) by calling C<die> in the usual manner.
  
  As with C<try>, the body of a C<catch {}> block may also contain a C<return>
  expression, which as before, has its usual meaning, causing the entire
  containing function to return with the given value. The body may also contain
  loop control expressions (C<redo>, C<next> or C<last>) which also have their
  usual effect.
  
  =cut
  
  sub import
  {
     if( HAVE_FEATURE_TRY ) {
        feature->import(qw( try ));
        require warnings;
        warnings->unimport(qw( experimental::try ));
     }
     else {
        require Syntax::Keyword::Try;
        Syntax::Keyword::Try->VERSION( '0.22' );
        Syntax::Keyword::Try->import(qw( try -no_finally -require_var ));
     }
  }
  
  =head1 COMPATIBILITY NOTES
  
  This module may use either L<Syntax::Keyword::Try> or the perl core C<try>
  feature to implement its syntax. While the two behave very similarly, and both
  conform to the description given above, the following differences should be
  noted.
  
  =over 4
  
  =item * Visibility to C<caller()>
  
  The C<Syntax::Keyword::Try> module implements C<try> blocks by using C<eval>
  frames. As a result, they are visible to the C<caller()> function and hence to
  things like C<Carp::longmess> when viewed as stack traces.
  
  By comparison, core's C<feature 'try'> creates a new kind of context stack
  entry that is ignored by C<caller()> and hence these blocks do not show up in
  stack traces.
  
  This should not matter to most use-cases - e.g. even C<Carp::croak> will be
  fine here. But if you are using C<caller()> with calculated indexes to inspect
  the state of callers to your code and there may be C<try> frames in the way,
  you will need to somehow account for the difference in stack height.
  
  =back
  
  =cut
  
  =head1 AUTHOR
  
  Paul Evans <leonerd@leonerd.org.uk>
  
  =cut
  
  0x55AA;
FEATURE_COMPAT_TRY

$fatpacked{"File/Slurp/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SLURP_TINY';
  package File::Slurp::Tiny;
  $File::Slurp::Tiny::VERSION = '0.004';
  use strict;
  use warnings;
  
  use Carp 'croak';
  use Exporter 5.57 'import';
  use File::Spec::Functions 'catfile';
  use FileHandle;
  our @EXPORT_OK = qw/read_file read_lines write_file read_dir/;
  
  my $default_layer = $^O eq 'MSWin32' ? ':crlf' : ':unix';
  
  sub read_file {
  	my ($filename, %options) = @_;
  	my $layer = $options{binmode} || $default_layer;
  	my $buf_ref = defined $options{buf_ref} ? $options{buf_ref} : \my $buf;
  
  	open my $fh, "<$layer", $filename or croak "Couldn't open $filename: $!";
  	if (my $size = -s $fh) {
  		my ($pos, $read) = 0;
  		do {
  			defined($read = read $fh, ${$buf_ref}, $size - $pos, $pos) or croak "Couldn't read $filename: $!";
  			$pos += $read;
  		} while ($read && $pos < $size);
  	}
  	else {
  		${$buf_ref} = do { local $/; <$fh> };
  	}
  	close $fh;
  	return if not defined wantarray or $options{buf_ref};
  	return $options{scalar_ref} ? $buf_ref : $buf;
  }
  
  sub read_lines {
  	my ($filename, %options) = @_;
  	my $layer = delete $options{binmode} || ':';
  	
  	open my $fh, "<$layer", $filename or croak "Couldn't open $filename: $!";
  	return <$fh> if not %options;
  	my @buf = <$fh>;
  	close $fh;
  	chomp @buf if $options{chomp};
  	return $options{array_ref} ? \@buf : @buf;
  }
  
  sub write_file {
  	my ($filename, undef, %options) = @_;
  	my $layer = $options{binmode} || $default_layer;
  	my $mode = $options{append} ? '>>' : '>';
  	my $buf_ref = defined $options{buf_ref} ? $options{buf_ref} : \$_[1];
  
  	open my $fh, $mode.$layer, $filename or croak "Couldn't open $filename: $!";
  	$fh->autoflush(1);
  	print $fh ${$buf_ref} or croak "Couldn't write to $filename: $!";
  	close $fh or croak "Couldn't close $filename: $!";
  	return;
  }
  
  sub read_dir {
  	my ($dirname, %options) = @_;
  	opendir my ($dir), $dirname or croak "Could not open $dirname: $!";
  	my @ret = grep { not m/ \A \.\.? \z /x } readdir $dir;
  	@ret = map { catfile($dirname, $_) } @ret if $options{prefix};
  	closedir $dir;
  	return @ret;
  }
  
  1;
  
  # ABSTRACT: A simple, sane and efficient file slurper [DISCOURAGED]
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  File::Slurp::Tiny - A simple, sane and efficient file slurper [DISCOURAGED]
  
  =head1 VERSION
  
  version 0.004
  
  =head1 SYNOPSIS
  
   use File::Slurp::Tiny 'read_file';
   my $content = read_file($filename);
  
  =head1 DISCOURAGED
  
  B<This module is discouraged in favor of L<File::Slurper|File::Slurper>>. While a useful experiment, it turned out to be both too similar to File::Slurp (still containing most problematic features of File::Slurp's interface) and yet not similar enough to be a true drop-in replacement.
  
  Bugs will still be fixed, but new features will probably not be added.
  
  =head1 DESCRIPTION
  
  This module provides functions for fast and correct slurping and spewing. All functions are optionally exported.
  
  =head1 FUNCTIONS
  
  =head2 read_file($filename, %options)
  
  Reads file C<$filename> into a scalar. By default it returns this scalar. Can optionally take these named arguments:
  
  =over 4
  
  =item * binmode
  
  Set the layers to read the file with. The default will be something sensible on your platform.
  
  =item * buf_ref
  
  Pass a reference to a scalar to read the file into, instead of returning it by value. This has performance benefits.
  
  =item * scalar_ref
  
  If set to true, C<read_file> will return a reference to a scalar containing the file content.
  
  =back
  
  =head2 read_lines($filename, %options)
  
  Reads file C<$filename> into a list/array. By default it returns this list. Can optionally take these named arguments:
  
  =over 4
  
  =item * binmode
  
  Set the layers to read the file with. The default will be something sensible on your platform.
  
  =item * array_ref
  
  Pass a reference to an array to read the lines into, instead of returning them by value. This has performance benefits.
  
  =item * chomp
  
  C<chomp> the lines.
  
  =back
  
  =head2 write_file($filename, $content, %options)
  
  Open C<$filename>, and write C<$content> to it. Can optionally take this named argument:
  
  =over 4
  
  =item * binmode
  
  Set the layers to write the file with. The default will be something sensible on your platform.
  
  =back
  
  =head2 read_dir($dirname, %options)
  
  Open C<dirname> and return all entries except C<.> and C<..>. Can optionally take this named argument:
  
  =over 4
  
  =item * prefix
  
  This will prepend C<$dir> to the entries
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Path::Tiny>
  
  A minimalistic abstraction not only around 
  
  =item * L<File::Slurp>
  
  Another file slurping tool.
  
  =back
  
  =head1 AUTHOR
  
  Leon Timmermans <leont@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Leon Timmermans.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
FILE_SLURP_TINY

$fatpacked{"Log/Log4perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL';
  ##################################################
  package Log::Log4perl;
  ##################################################
  
  END { local($?); Log::Log4perl::Logger::cleanup(); }
  
  use 5.006;
  use strict;
  use warnings;
  
  use Carp;
  
  use Log::Log4perl::Util;
  use Log::Log4perl::Logger;
  use Log::Log4perl::Level;
  use Log::Log4perl::Config;
  use Log::Log4perl::Appender;
  
  our $VERSION = '1.55';
  
     # set this to '1' if you're using a wrapper
     # around Log::Log4perl
  our $caller_depth = 0;
  
      #this is a mapping of convenience names to opcode masks used in
      #$ALLOWED_CODE_OPS_IN_CONFIG_FILE below
  our %ALLOWED_CODE_OPS = (
      'safe'        => [ ':browse' ],
      'restrictive' => [ ':default' ],
  );
  
  our %WRAPPERS_REGISTERED = map { $_ => 1 } qw(Log::Log4perl);
  
      #set this to the opcodes which are allowed when
      #$ALLOW_CODE_IN_CONFIG_FILE is set to a true value
      #if undefined, there are no restrictions on code that can be
      #excuted
  our @ALLOWED_CODE_OPS_IN_CONFIG_FILE;
  
      #this hash lists things that should be exported into the Safe
      #compartment.  The keys are the package the symbol should be
      #exported from and the values are array references to the names
      #of the symbols (including the leading type specifier)
  our %VARS_SHARED_WITH_SAFE_COMPARTMENT = (
      main => [ '%ENV' ],
  );
  
      #setting this to a true value will allow Perl code to be executed
      #within the config file.  It works in conjunction with
      #$ALLOWED_CODE_OPS_IN_CONFIG_FILE, which if defined restricts the
      #opcodes which can be executed using the 'Safe' module.
      #setting this to a false value disables code execution in the
      #config file
  our $ALLOW_CODE_IN_CONFIG_FILE = 1;
  
      #arrays in a log message will be joined using this character,
      #see Log::Log4perl::Appender::DBI
  our $JOIN_MSG_ARRAY_CHAR = '';
  
      #version required for XML::DOM, to enable XML Config parsing
      #and XML Config unit tests
  our $DOM_VERSION_REQUIRED = '1.29'; 
  
  our $CHATTY_DESTROY_METHODS = 0;
  
  our $LOGDIE_MESSAGE_ON_STDERR = 1;
  our $LOGEXIT_CODE             = 1;
  our %IMPORT_CALLED;
  
  our $EASY_CLOSURES = {};
  
    # to throw refs as exceptions via logcarp/confess, turn this off
  our $STRINGIFY_DIE_MESSAGE = 1;
  
  use constant _INTERNAL_DEBUG => 0;
  
  ##################################################
  sub import {
  ##################################################
      my($class) = shift;
  
      my $caller_pkg = caller();
  
      return 1 if $IMPORT_CALLED{$caller_pkg}++;
  
      my(%tags) = map { $_ => 1 } @_;
  
          # Lazy man's logger
      if(exists $tags{':easy'}) {
          $tags{':levels'} = 1;
          $tags{':nowarn'} = 1;
          $tags{'get_logger'} = 1;
      }
  
      if(exists $tags{':no_extra_logdie_message'}) {
          $Log::Log4perl::LOGDIE_MESSAGE_ON_STDERR = 0;
          delete $tags{':no_extra_logdie_message'};
      }
  
      if(exists $tags{get_logger}) {
          # Export get_logger into the calling module's 
          no strict qw(refs);
          *{"$caller_pkg\::get_logger"} = *get_logger;
  
          delete $tags{get_logger};
      }
  
      if(exists $tags{':levels'}) {
          # Export log levels ($DEBUG, $INFO etc.) from Log4perl::Level
          for my $key (keys %Log::Log4perl::Level::PRIORITY) {
              my $name  = "$caller_pkg\::$key";
                 # Need to split this up in two lines, or CVS will
                 # mess it up.
              my $value = $Log::Log4perl::Level::PRIORITY{
                $key};
              no strict qw(refs);
              *{"$name"} = \$value;
          } 
  
          delete $tags{':levels'};
      }
  
          # Lazy man's logger
      if(exists $tags{':easy'}) {
          delete $tags{':easy'};
  
              # Define default logger object in caller's package
          my $logger = get_logger("$caller_pkg");
          
              # Define DEBUG, INFO, etc. routines in caller's package
          for(qw(TRACE DEBUG INFO WARN ERROR FATAL ALWAYS)) {
              my $level   = $_;
              $level = "OFF" if $level eq "ALWAYS";
              my $lclevel = lc($_);
              easy_closure_create($caller_pkg, $_, sub {
                  Log::Log4perl::Logger::init_warn() unless 
                      $Log::Log4perl::Logger::INITIALIZED or
                      $Log::Log4perl::Logger::NON_INIT_WARNED;
                  $logger->{$level}->($logger, @_, $level);
              }, $logger);
          }
  
              # Define LOGCROAK, LOGCLUCK, etc. routines in caller's package
          for(qw(LOGCROAK LOGCLUCK LOGCARP LOGCONFESS)) {
              my $method = "Log::Log4perl::Logger::" . lc($_);
  
              easy_closure_create($caller_pkg, $_, sub {
                  unshift @_, $logger;
                  goto &$method;
              }, $logger);
          }
  
              # Define LOGDIE, LOGWARN
           easy_closure_create($caller_pkg, "LOGDIE", sub {
               Log::Log4perl::Logger::init_warn() unless 
                       $Log::Log4perl::Logger::INITIALIZED or
                       $Log::Log4perl::Logger::NON_INIT_WARNED;
               $logger->{FATAL}->($logger, @_, "FATAL");
               $Log::Log4perl::LOGDIE_MESSAGE_ON_STDERR ?
                   CORE::die(Log::Log4perl::Logger::callerline(join '', @_)) :
                   exit $Log::Log4perl::LOGEXIT_CODE;
           }, $logger);
  
           easy_closure_create($caller_pkg, "LOGEXIT", sub {
              Log::Log4perl::Logger::init_warn() unless 
                      $Log::Log4perl::Logger::INITIALIZED or
                      $Log::Log4perl::Logger::NON_INIT_WARNED;
              $logger->{FATAL}->($logger, @_, "FATAL");
              exit $Log::Log4perl::LOGEXIT_CODE;
           }, $logger);
  
          easy_closure_create($caller_pkg, "LOGWARN", sub {
              Log::Log4perl::Logger::init_warn() unless 
                      $Log::Log4perl::Logger::INITIALIZED or
                      $Log::Log4perl::Logger::NON_INIT_WARNED;
              $logger->{WARN}->($logger, @_, "WARN");
              CORE::warn(Log::Log4perl::Logger::callerline(join '', @_))
                  if $Log::Log4perl::LOGDIE_MESSAGE_ON_STDERR;
          }, $logger);
      }
  
      if(exists $tags{':nowarn'}) {
          $Log::Log4perl::Logger::NON_INIT_WARNED = 1;
          delete $tags{':nowarn'};
      }
  
      if(exists $tags{':nostrict'}) {
          $Log::Log4perl::Logger::NO_STRICT = 1;
          delete $tags{':nostrict'};
      }
  
      if(exists $tags{':resurrect'}) {
          my $FILTER_MODULE = "Filter::Util::Call";
          if(! Log::Log4perl::Util::module_available($FILTER_MODULE)) {
              die "$FILTER_MODULE required with :resurrect" .
                  "(install from CPAN)";
          }
          eval "require $FILTER_MODULE" or die "Cannot pull in $FILTER_MODULE";
          Filter::Util::Call::filter_add(
              sub {
                  my($status);
                  s/^\s*###l4p// if
                      ($status = Filter::Util::Call::filter_read()) > 0;
                  $status;
                  });
          delete $tags{':resurrect'};
      }
  
      if(keys %tags) {
          # We received an Option we couldn't understand.
          die "Unknown Option(s): @{[keys %tags]}";
      }
  }
  
  ##################################################
  sub initialized {
  ##################################################
      return $Log::Log4perl::Logger::INITIALIZED;
  }
  
  ##################################################
  sub new {
  ##################################################
      die "THIS CLASS ISN'T FOR DIRECT USE. " .
          "PLEASE CHECK 'perldoc " . __PACKAGE__ . "'.";
  }
  
  ##################################################
  sub reset { # Mainly for debugging/testing
  ##################################################
      # Delegate this to the logger ...
      return Log::Log4perl::Logger->reset();
  }
  
  ##################################################
  sub init_once { # Call init only if it hasn't been
                  # called yet.
  ##################################################
      init(@_) unless $Log::Log4perl::Logger::INITIALIZED;
  }
  
  ##################################################
  sub init { # Read the config file
  ##################################################
      my($class, @args) = @_;
  
      #woops, they called ::init instead of ->init, let's be forgiving
      if ($class ne __PACKAGE__) {
          unshift(@args, $class);
      }
  
      # Delegate this to the config module
      return Log::Log4perl::Config->init(@args);
  }
  
  ##################################################
  sub init_and_watch { 
  ##################################################
      my($class, @args) = @_;
  
      #woops, they called ::init instead of ->init, let's be forgiving
      if ($class ne __PACKAGE__) {
          unshift(@args, $class);
      }
  
      # Delegate this to the config module
      return Log::Log4perl::Config->init_and_watch(@args);
  }
  
  
  ##################################################
  sub easy_init { # Initialize the root logger with a screen appender
  ##################################################
      my($class, @args) = @_;
  
      # Did somebody call us with Log::Log4perl::easy_init()?
      if(ref($class) or $class =~ /^\d+$/) {
          unshift @args, $class;
      }
  
      # Reset everything first
      Log::Log4perl->reset();
  
      my @loggers = ();
  
      my %default = ( level    => $DEBUG,
                      file     => "STDERR",
                      utf8     => undef,
                      category => "",
                      layout   => "%d %m%n",
                    );
  
      if(!@args) {
          push @loggers, \%default;
      } else {
          for my $arg (@args) {
              if($arg =~ /^\d+$/) {
                  my %logger = (%default, level => $arg);
                  push @loggers, \%logger;
              } elsif(ref($arg) eq "HASH") {
                  my %logger = (%default, %$arg);
                  push @loggers, \%logger;
              } else {
                  # I suggest this becomes a croak() after a
                  # reasonable deprecation cycle.
                  carp "All arguments to easy_init should be either "
                     . "an integer log level or a hash reference.";
              }
          }
      }
  
      for my $logger (@loggers) {
  
          my $app;
  
          if($logger->{file} =~ /^stderr$/i) {
              $app = Log::Log4perl::Appender->new(
                  "Log::Log4perl::Appender::Screen",
                  utf8 => $logger->{utf8});
          } elsif($logger->{file} =~ /^stdout$/i) {
              $app = Log::Log4perl::Appender->new(
                  "Log::Log4perl::Appender::Screen",
                  stderr => 0,
                  utf8   => $logger->{utf8});
          } else {
              my $binmode;
              if($logger->{file} =~ s/^(:.*?)>/>/) {
                  $binmode = $1;
              }
              $logger->{file} =~ /^(>)?(>)?/;
              my $mode = ($2 ? "append" : "write");
              $logger->{file} =~ s/.*>+\s*//g;
              $app = Log::Log4perl::Appender->new(
                  "Log::Log4perl::Appender::File",
                  filename => $logger->{file},
                  mode     => $mode,
                  utf8     => $logger->{utf8},
                  binmode  => $binmode,
              );
          }
  
          my $layout = Log::Log4perl::Layout::PatternLayout->new(
                                                          $logger->{layout});
          $app->layout($layout);
  
          my $log = Log::Log4perl->get_logger($logger->{category});
          $log->level($logger->{level});
          $log->add_appender($app);
      }
  
      $Log::Log4perl::Logger::INITIALIZED = 1;
  }
  
  ##################################################
  sub wrapper_register {  
  ##################################################
      my $wrapper = $_[-1];
  
      $WRAPPERS_REGISTERED{ $wrapper } = 1;
  }
  
  ##################################################
  sub get_logger {  # Get an instance (shortcut)
  ##################################################
      # get_logger() can be called in the following ways:
      #
      #   (1) Log::Log4perl::get_logger()     => ()
      #   (2) Log::Log4perl->get_logger()     => ("Log::Log4perl")
      #   (3) Log::Log4perl::get_logger($cat) => ($cat)
      #   
      #   (5) Log::Log4perl->get_logger($cat) => ("Log::Log4perl", $cat)
      #   (6)   L4pSubclass->get_logger($cat) => ("L4pSubclass", $cat)
  
      # Note that (4) L4pSubclass->get_logger() => ("L4pSubclass")
      # is indistinguishable from (3) and therefore can't be allowed.
      # Wrapper classes always have to specify the category explicitly.
  
      my $category;
  
      if(@_ == 0) {
            # 1
          my $level = 0;
          do { $category = scalar caller($level++);
          } while exists $WRAPPERS_REGISTERED{ $category };
  
      } elsif(@_ == 1) {
            # 2, 3
          $category = $_[0];
  
          my $level = 0;
          while(exists $WRAPPERS_REGISTERED{ $category }) { 
              $category = scalar caller($level++);
          }
  
      } else {
            # 5, 6
          $category = $_[1];
      }
  
      # Delegate this to the logger module
      return Log::Log4perl::Logger->get_logger($category);
  }
  
  ###########################################
  sub caller_depth_offset {
  ###########################################
      my( $level ) = @_;
  
      my $category;
  
      { 
          my $category = scalar caller($level + 1);
  
          if(defined $category and
             exists $WRAPPERS_REGISTERED{ $category }) {
              $level++;
              redo;
          }
      }
  
      return $level;
  }
  
  ##################################################
  sub appenders {  # Get a hashref of all defined appender wrappers
  ##################################################
      return \%Log::Log4perl::Logger::APPENDER_BY_NAME;
  }
  
  ##################################################
  sub add_appender { # Add an appender to the system, but don't assign
  	           # it to a logger yet
  ##################################################
      my($class, $appender) = @_;
  
      my $name = $appender->name();
      die "Mandatory parameter 'name' missing in appender" unless defined $name;
  
        # Make it known by name in the Log4perl universe
        # (so that composite appenders can find it)
      Log::Log4perl->appenders()->{ $name } = $appender;
  }
  
  ##################################################
  # Return number of appenders changed
  sub appender_thresholds_adjust {  # Readjust appender thresholds
  ##################################################
          # If someone calls L4p-> and not L4p::
      shift if $_[0] eq __PACKAGE__;
      my($delta, $appenders) = @_;
  	my $retval = 0;
  
      if($delta == 0) {
            # Nothing to do, no delta given.
          return;
      }
  
      if(defined $appenders) {
              # Map names to objects
          $appenders = [map { 
                         die "Unkown appender: '$_'" unless exists
                            $Log::Log4perl::Logger::APPENDER_BY_NAME{
                              $_};
                         $Log::Log4perl::Logger::APPENDER_BY_NAME{
                           $_} 
                        } @$appenders];
      } else {
              # Just hand over all known appenders
          $appenders = [values %{Log::Log4perl::appenders()}] unless 
              defined $appenders;
      }
  
          # Change all appender thresholds;
      foreach my $app (@$appenders) {
          my $old_thres = $app->threshold();
          my $new_thres;
          if($delta > 0) {
              $new_thres = Log::Log4perl::Level::get_higher_level(
                               $old_thres, $delta);
          } else {
              $new_thres = Log::Log4perl::Level::get_lower_level(
                               $old_thres, -$delta);
          }
  
          ++$retval if ($app->threshold($new_thres) == $new_thres);
      }
  	return $retval;
  }
  
  ##################################################
  sub appender_by_name {  # Get a (real) appender by name
  ##################################################
          # If someone calls L4p->appender_by_name and not L4p::appender_by_name
      shift if $_[0] eq __PACKAGE__;
  
      my($name) = @_;
  
      if(defined $name and
         exists $Log::Log4perl::Logger::APPENDER_BY_NAME{
                   $name}) {
          return $Log::Log4perl::Logger::APPENDER_BY_NAME{
                   $name}->{appender};
      } else {
          return undef;
      }
  }
  
  ##################################################
  sub eradicate_appender {  # Remove an appender from the system
  ##################################################
          # If someone calls L4p->... and not L4p::...
      shift if $_[0] eq __PACKAGE__;
      Log::Log4perl::Logger->eradicate_appender(@_);
  }
  
  ##################################################
  sub infiltrate_lwp {  # 
  ##################################################
      no warnings qw(redefine);
  
      my $l4p_wrapper = sub {
          my($prio, @message) = @_;
          local $Log::Log4perl::caller_depth =
                $Log::Log4perl::caller_depth + 2;
          get_logger(scalar caller(1))->log($prio, @message);
      };
  
      *LWP::Debug::trace = sub { 
          $l4p_wrapper->($INFO, @_); 
      };
      *LWP::Debug::conns =
      *LWP::Debug::debug = sub { 
          $l4p_wrapper->($DEBUG, @_); 
      };
  }
  
  ##################################################
  sub easy_closure_create {
  ##################################################
      my($caller_pkg, $entry, $code, $logger) = @_;
  
      no strict 'refs';
  
      print("easy_closure: Setting shortcut $caller_pkg\::$entry ", 
           "(logger=$logger\n") if _INTERNAL_DEBUG;
  
      $EASY_CLOSURES->{ $caller_pkg }->{ $entry } = $logger;
      *{"$caller_pkg\::$entry"} = $code;
  }
  
  ###########################################
  sub easy_closure_cleanup {
  ###########################################
      my($caller_pkg, $entry) = @_;
  
      no warnings 'redefine';
      no strict 'refs';
  
      my $logger = $EASY_CLOSURES->{ $caller_pkg }->{ $entry };
  
      print("easy_closure: Nuking easy shortcut $caller_pkg\::$entry ", 
           "(logger=$logger\n") if _INTERNAL_DEBUG;
  
      *{"$caller_pkg\::$entry"} = sub { };
      delete $EASY_CLOSURES->{ $caller_pkg }->{ $entry };
  }
  
  ##################################################
  sub easy_closure_category_cleanup {
  ##################################################
      my($caller_pkg) = @_;
  
      if(! exists $EASY_CLOSURES->{ $caller_pkg } ) {
          return 1;
      }
  
      for my $entry ( keys %{ $EASY_CLOSURES->{ $caller_pkg } } ) {
          easy_closure_cleanup( $caller_pkg, $entry );
      }
  
      delete $EASY_CLOSURES->{ $caller_pkg };
  }
  
  ###########################################
  sub easy_closure_global_cleanup {
  ###########################################
  
      for my $caller_pkg ( keys %$EASY_CLOSURES ) {
          easy_closure_category_cleanup( $caller_pkg );
      }
  }
  
  ###########################################
  sub easy_closure_logger_remove {
  ###########################################
      my($class, $logger) = @_;
  
      PKG: for my $caller_pkg ( keys %$EASY_CLOSURES ) {
          for my $entry ( keys %{ $EASY_CLOSURES->{ $caller_pkg } } ) {
              if( $logger == $EASY_CLOSURES->{ $caller_pkg }->{ $entry } ) {
                  easy_closure_category_cleanup( $caller_pkg );
                  next PKG;
              }
          }
      }
  }
  
  ##################################################
  sub remove_logger {
  ##################################################
      my ($class, $logger) = @_;
  
      # Any stealth logger convenience function still using it will
      # now become a no-op.
      Log::Log4perl->easy_closure_logger_remove( $logger );
  
      # Remove the logger from the system
        # Need to split this up in two lines, or CVS will
        # mess it up.
      delete $Log::Log4perl::Logger::LOGGERS_BY_NAME->{ 
        $logger->{category} };
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl - Log4j implementation for Perl
  
  =head1 SYNOPSIS
          
  		# Easy mode if you like it simple ...
  
      use Log::Log4perl qw(:easy);
      Log::Log4perl->easy_init($ERROR);
  
      DEBUG "This doesn't go anywhere";
      ERROR "This gets logged";
  
          # ... or standard mode for more features:
  
      Log::Log4perl::init('/etc/log4perl.conf');
      
      --or--
      
          # Check config every 10 secs
      Log::Log4perl::init_and_watch('/etc/log4perl.conf',10);
  
      --then--
      
      $logger = Log::Log4perl->get_logger('house.bedrm.desk.topdrwr');
      
      $logger->debug('this is a debug message');
      $logger->info('this is an info message');
      $logger->warn('etc');
      $logger->error('..');
      $logger->fatal('..');
      
      #####/etc/log4perl.conf###############################
      log4perl.logger.house              = WARN,  FileAppndr1
      log4perl.logger.house.bedroom.desk = DEBUG, FileAppndr1
      
      log4perl.appender.FileAppndr1      = Log::Log4perl::Appender::File
      log4perl.appender.FileAppndr1.filename = desk.log 
      log4perl.appender.FileAppndr1.layout   = \
                              Log::Log4perl::Layout::SimpleLayout
      ######################################################
  
  =head1 ABSTRACT
  
  Log::Log4perl provides a powerful logging API for your application
  
  =head1 DESCRIPTION
  
  Log::Log4perl lets you remote-control and fine-tune the logging behaviour
  of your system from the outside. It implements the widely popular 
  (Java-based) Log4j logging package in pure Perl. 
  
  B<For a detailed tutorial on Log::Log4perl usage, please read> 
  
  L<http://www.perl.com/pub/a/2002/09/11/log4perl.html>
  
  Logging beats a debugger if you want to know what's going on 
  in your code during runtime. However, traditional logging packages
  are too static and generate a flood of log messages in your log files
  that won't help you.
  
  C<Log::Log4perl> is different. It allows you to control the number of 
  logging messages generated at three different levels:
  
  =over 4
  
  =item *
  
  At a central location in your system (either in a configuration file or
  in the startup code) you specify I<which components> (classes, functions) 
  of your system should generate logs.
  
  =item *
  
  You specify how detailed the logging of these components should be by
  specifying logging I<levels>.
  
  =item *
  
  You also specify which so-called I<appenders> you want to feed your
  log messages to ("Print it to the screen and also append it to /tmp/my.log")
  and which format ("Write the date first, then the file name and line 
  number, and then the log message") they should be in.
  
  =back
  
  This is a very powerful and flexible mechanism. You can turn on and off
  your logs at any time, specify the level of detail and make that
  dependent on the subsystem that's currently executed. 
  
  Let me give you an example: You might 
  find out that your system has a problem in the 
  C<MySystem::Helpers::ScanDir>
  component. Turning on detailed debugging logs all over the system would
  generate a flood of useless log messages and bog your system down beyond
  recognition. With C<Log::Log4perl>, however, you can tell the system:
  "Continue to log only severe errors to the log file. Open a second
  log file, turn on full debug logs in the C<MySystem::Helpers::ScanDir>
  component and dump all messages originating from there into the new
  log file". And all this is possible by just changing the parameters
  in a configuration file, which your system can re-read even 
  while it's running!
  
  =head1 How to use it
  
  The C<Log::Log4perl> package can be initialized in two ways: Either
  via Perl commands or via a C<log4j>-style configuration file.
  
  =head2 Initialize via a configuration file
  
  This is the easiest way to prepare your system for using
  C<Log::Log4perl>. Use a configuration file like this:
  
      ############################################################
      # A simple root logger with a Log::Log4perl::Appender::File 
      # file appender in Perl.
      ############################################################
      log4perl.rootLogger=ERROR, LOGFILE
      
      log4perl.appender.LOGFILE=Log::Log4perl::Appender::File
      log4perl.appender.LOGFILE.filename=/var/log/myerrs.log
      log4perl.appender.LOGFILE.mode=append
      
      log4perl.appender.LOGFILE.layout=PatternLayout
      log4perl.appender.LOGFILE.layout.ConversionPattern=[%r] %F %L %c - %m%n
  
  These lines define your standard logger that's appending severe
  errors to C</var/log/myerrs.log>, using the format
  
      [millisecs] source-filename line-number class - message newline
  
  Assuming that this configuration file is saved as C<log.conf>, you need to 
  read it in the startup section of your code, using the following
  commands:
  
    use Log::Log4perl;
    Log::Log4perl->init("log.conf");
  
  After that's done I<somewhere> in the code, you can retrieve
  logger objects I<anywhere> in the code. Note that
  there's no need to carry any logger references around with your 
  functions and methods. You can get a logger anytime via a singleton
  mechanism:
  
      package My::MegaPackage;
      use  Log::Log4perl;
  
      sub some_method {
          my($param) = @_;
  
          my $log = Log::Log4perl->get_logger("My::MegaPackage");
  
          $log->debug("Debug message");
          $log->info("Info message");
          $log->error("Error message");
  
          ...
      }
  
  With the configuration file above, C<Log::Log4perl> will write
  "Error message" to the specified log file, but won't do anything for 
  the C<debug()> and C<info()> calls, because the log level has been set
  to C<ERROR> for all components in the first line of 
  configuration file shown above.
  
  Why C<Log::Log4perl-E<gt>get_logger> and
  not C<Log::Log4perl-E<gt>new>? We don't want to create a new
  object every time. Usually in OO-Programming, you create an object
  once and use the reference to it to call its methods. However,
  this requires that you pass around the object to all functions
  and the last thing we want is pollute each and every function/method
  we're using with a handle to the C<Logger>:
  
      sub function {  # Brrrr!!
          my($logger, $some, $other, $parameters) = @_;
      }
  
  Instead, if a function/method wants a reference to the logger, it
  just calls the Logger's static C<get_logger($category)> method to obtain
  a reference to the I<one and only> possible logger object of
  a certain category.
  That's called a I<singleton> if you're a Gamma fan.
  
  How does the logger know
  which messages it is supposed to log and which ones to suppress?
  C<Log::Log4perl> works with inheritance: The config file above didn't 
  specify anything about C<My::MegaPackage>. 
  And yet, we've defined a logger of the category 
  C<My::MegaPackage>.
  In this case, C<Log::Log4perl> will walk up the namespace hierarchy
  (C<My> and then we're at the root) to figure out if a log level is
  defined somewhere. In the case above, the log level at the root
  (root I<always> defines a log level, but not necessarily an appender)
  defines that 
  the log level is supposed to be C<ERROR> -- meaning that I<DEBUG>
  and I<INFO> messages are suppressed. Note that this 'inheritance' is
  unrelated to Perl's class inheritance, it is merely related to the
  logger namespace.
  By the way, if you're ever in doubt about what a logger's category is, 
  use C<$logger-E<gt>category()> to retrieve it.
  
  =head2 Log Levels
  
  There are six predefined log levels: C<FATAL>, C<ERROR>, C<WARN>, C<INFO>,
  C<DEBUG>, and C<TRACE> (in descending priority). Your configured logging level
  has to at least match the priority of the logging message.
  
  If your configured logging level is C<WARN>, then messages logged 
  with C<info()>, C<debug()>, and C<trace()> will be suppressed. 
  C<fatal()>, C<error()> and C<warn()> will make their way through,
  because their priority is higher or equal than the configured setting.
  
  Instead of calling the methods
  
      $logger->trace("...");  # Log a trace message
      $logger->debug("...");  # Log a debug message
      $logger->info("...");   # Log a info message
      $logger->warn("...");   # Log a warn message
      $logger->error("...");  # Log a error message
      $logger->fatal("...");  # Log a fatal message
  
  you could also call the C<log()> method with the appropriate level
  using the constants defined in C<Log::Log4perl::Level>:
  
      use Log::Log4perl::Level;
  
      $logger->log($TRACE, "...");
      $logger->log($DEBUG, "...");
      $logger->log($INFO, "...");
      $logger->log($WARN, "...");
      $logger->log($ERROR, "...");
      $logger->log($FATAL, "...");
  
  This form is rarely used, but it comes in handy if you want to log 
  at different levels depending on an exit code of a function:
  
      $logger->log( $exit_level{ $rc }, "...");
  
  As for needing more logging levels than these predefined ones: It's
  usually best to steer your logging behaviour via the category 
  mechanism instead.
  
  If you need to find out if the currently configured logging
  level would allow a logger's logging statement to go through, use the
  logger's C<is_I<level>()> methods:
  
      $logger->is_trace()    # True if trace messages would go through
      $logger->is_debug()    # True if debug messages would go through
      $logger->is_info()     # True if info messages would go through
      $logger->is_warn()     # True if warn messages would go through
      $logger->is_error()    # True if error messages would go through
      $logger->is_fatal()    # True if fatal messages would go through
  
  Example: C<$logger-E<gt>is_warn()> returns true if the logger's current
  level, as derived from either the logger's category (or, in absence of
  that, one of the logger's parent's level setting) is 
  C<$WARN>, C<$ERROR> or C<$FATAL>.
  
  Also available are a series of more Java-esque functions which return
  the same values. These are of the format C<isI<Level>Enabled()>,
  so C<$logger-E<gt>isDebugEnabled()> is synonymous to 
  C<$logger-E<gt>is_debug()>.
  
  
  These level checking functions
  will come in handy later, when we want to block unnecessary
  expensive parameter construction in case the logging level is too
  low to log the statement anyway, like in:
  
      if($logger->is_error()) {
          $logger->error("Erroneous array: @super_long_array");
      }
  
  If we had just written
  
      $logger->error("Erroneous array: @super_long_array");
  
  then Perl would have interpolated
  C<@super_long_array> into the string via an expensive operation
  only to figure out shortly after that the string can be ignored
  entirely because the configured logging level is lower than C<$ERROR>.
  
  The to-be-logged
  message passed to all of the functions described above can
  consist of an arbitrary number of arguments, which the logging functions
  just chain together to a single string. Therefore
  
      $logger->debug("Hello ", "World", "!");  # and
      $logger->debug("Hello World!");
  
  are identical.
  
  Note that even if one of the methods above returns true, it doesn't 
  necessarily mean that the message will actually get logged. 
  What is_debug() checks is that
  the logger used is configured to let a message of the given priority 
  (DEBUG) through. But after this check, Log4perl will eventually apply custom 
  filters and forward the message to one or more appenders. None of this
  gets checked by is_xxx(), for the simple reason that it's 
  impossible to know what a custom filter does with a message without
  having the actual message or what an appender does to a message without
  actually having it log it.
  
  =head2 Log and die or warn
  
  Often, when you croak / carp / warn / die, you want to log those messages.
  Rather than doing the following:
  
      $logger->fatal($err) && die($err);
  
  you can use the following:
  
      $logger->logdie($err);
  
  And if instead of using
  
      warn($message);
      $logger->warn($message);
  
  to both issue a warning via Perl's warn() mechanism and make sure you have
  the same message in the log file as well, use:
  
      $logger->logwarn($message);
  
  Since there is
  an ERROR level between WARN and FATAL, there are two additional helper
  functions in case you'd like to use ERROR for either warn() or die():
  
      $logger->error_warn();
      $logger->error_die();
  
  Finally, there's the Carp functions that, in addition to logging,
  also pass the stringified message to their companions in the Carp package:
  
      $logger->logcarp();        # warn w/ 1-level stack trace
      $logger->logcluck();       # warn w/ full stack trace
      $logger->logcroak();       # die w/ 1-level stack trace
      $logger->logconfess();     # die w/ full stack trace
  
  =head2 Appenders
  
  If you don't define any appenders, nothing will happen. Appenders will
  be triggered whenever the configured logging level requires a message
  to be logged and not suppressed.
  
  C<Log::Log4perl> doesn't define any appenders by default, not even the root
  logger has one.
  
  C<Log::Log4perl> already comes with a standard set of appenders:
  
      Log::Log4perl::Appender::Screen
      Log::Log4perl::Appender::ScreenColoredLevels
      Log::Log4perl::Appender::File
      Log::Log4perl::Appender::Socket
      Log::Log4perl::Appender::DBI
      Log::Log4perl::Appender::Synchronized
      Log::Log4perl::Appender::RRDs
  
  to log to the screen, to files and to databases. 
  
  On CPAN, you can find additional appenders like
  
      Log::Log4perl::Layout::XMLLayout
  
  by Guido Carls E<lt>gcarls@cpan.orgE<gt>.
  It allows for hooking up Log::Log4perl with the graphical Log Analyzer
  Chainsaw (see 
  L<Log::Log4perl::FAQ/"Can I use Log::Log4perl with log4j's Chainsaw?">).
  
  =head2 Additional Appenders via Log::Dispatch
  
  C<Log::Log4perl> also supports I<Dave Rolskys> excellent C<Log::Dispatch>
  framework which implements a wide variety of different appenders. 
  
  Here's the list of appender modules currently available via C<Log::Dispatch>:
  
         Log::Dispatch::ApacheLog
         Log::Dispatch::DBI (by Tatsuhiko Miyagawa)
         Log::Dispatch::Email,
         Log::Dispatch::Email::MailSend,
         Log::Dispatch::Email::MailSendmail,
         Log::Dispatch::Email::MIMELite
         Log::Dispatch::File
         Log::Dispatch::FileRotate (by Mark Pfeiffer)
         Log::Dispatch::Handle
         Log::Dispatch::Screen
         Log::Dispatch::Syslog
         Log::Dispatch::Tk (by Dominique Dumont)
  
  Please note that in order to use any of these additional appenders, you
  have to fetch Log::Dispatch from CPAN and install it. Also the particular
  appender you're using might require installing the particular module.
  
  For additional information on appenders, please check the
  L<Log::Log4perl::Appender> manual page.
  
  =head2 Appender Example
  
  Now let's assume that we want to log C<info()> or
  higher prioritized messages in the C<Foo::Bar> category
  to both STDOUT and to a log file, say C<test.log>.
  In the initialization section of your system,
  just define two appenders using the readily available
  C<Log::Log4perl::Appender::File> and C<Log::Log4perl::Appender::Screen> 
  modules:
  
    use Log::Log4perl;
  
       # Configuration in a string ...
    my $conf = q(
      log4perl.category.Foo.Bar          = INFO, Logfile, Screen
  
      log4perl.appender.Logfile          = Log::Log4perl::Appender::File
      log4perl.appender.Logfile.filename = test.log
      log4perl.appender.Logfile.layout   = Log::Log4perl::Layout::PatternLayout
      log4perl.appender.Logfile.layout.ConversionPattern = [%r] %F %L %m%n
  
      log4perl.appender.Screen         = Log::Log4perl::Appender::Screen
      log4perl.appender.Screen.stderr  = 0
      log4perl.appender.Screen.layout = Log::Log4perl::Layout::SimpleLayout
    );
  
       # ... passed as a reference to init()
    Log::Log4perl::init( \$conf );
  
  Once the initialization shown above has happened once, typically in
  the startup code of your system, just use the defined logger anywhere in 
  your system:
  
    ##########################
    # ... in some function ...
    ##########################
    my $log = Log::Log4perl::get_logger("Foo::Bar");
  
      # Logs both to STDOUT and to the file test.log
    $log->info("Important Info!");
  
  The C<layout> settings specified in the configuration section define the 
  format in which the
  message is going to be logged by the specified appender. The format shown
  for the file appender is logging not only the message but also the number of
  milliseconds since the program has started (%r), the name of the file
  the call to the logger has happened and the line number there (%F and
  %L), the message itself (%m) and a OS-specific newline character (%n):
  
      [187] ./myscript.pl 27 Important Info!
  
  The
  screen appender above, on the other hand, 
  uses a C<SimpleLayout>, which logs the 
  debug level, a hyphen (-) and the log message:
  
      INFO - Important Info!
  
  For more detailed info on layout formats, see L<Log Layouts>. 
  
  In the configuration sample above, we chose to define a I<category> 
  logger (C<Foo::Bar>).
  This will cause only messages originating from
  this specific category logger to be logged in the defined format
  and locations.
  
  =head2 Logging newlines
  
  There's some controversy between different logging systems as to when and 
  where newlines are supposed to be added to logged messages.
  
  The Log4perl way is that a logging statement I<should not> 
  contain a newline:
  
      $logger->info("Some message");
      $logger->info("Another message");
  
  If this is supposed to end up in a log file like
  
      Some message
      Another message
  
  then an appropriate appender layout like "%m%n" will take care of adding
  a newline at the end of each message to make sure every message is 
  printed on its own line.
  
  Other logging systems, Log::Dispatch in particular, recommend adding the
  newline to the log statement. This doesn't work well, however, if you, say,
  replace your file appender by a database appender, and all of a sudden
  those newlines scattered around the code don't make sense anymore.
  
  Assigning matching layouts to different appenders and leaving newlines
  out of the code solves this problem. If you inherited code that has logging
  statements with newlines and want to make it work with Log4perl, read
  the L<Log::Log4perl::Layout::PatternLayout> documentation on how to 
  accomplish that.
  
  =head2 Configuration files
  
  As shown above, you can define C<Log::Log4perl> loggers both from within
  your Perl code or from configuration files. The latter have the unbeatable
  advantage that you can modify your system's logging behaviour without 
  interfering with the code at all. So even if your code is being run by 
  somebody who's totally oblivious to Perl, they still can adapt the
  module's logging behaviour to their needs.
  
  C<Log::Log4perl> has been designed to understand C<Log4j> configuration
  files -- as used by the original Java implementation. Instead of 
  reiterating the format description in [2], let me just list three
  examples (also derived from [2]), which should also illustrate
  how it works:
  
      log4j.rootLogger=DEBUG, A1
      log4j.appender.A1=org.apache.log4j.ConsoleAppender
      log4j.appender.A1.layout=org.apache.log4j.PatternLayout
      log4j.appender.A1.layout.ConversionPattern=%-4r %-5p %c %x - %m%n
  
  This enables messages of priority C<DEBUG> or higher in the root
  hierarchy and has the system write them to the console. 
  C<ConsoleAppender> is a Java appender, but C<Log::Log4perl> jumps
  through a significant number of hoops internally to map these to their
  corresponding Perl classes, C<Log::Log4perl::Appender::Screen> in this case.
  
  Second example:
  
      log4perl.rootLogger=DEBUG, A1
      log4perl.appender.A1=Log::Log4perl::Appender::Screen
      log4perl.appender.A1.layout=PatternLayout
      log4perl.appender.A1.layout.ConversionPattern=%d %-5p %c - %m%n
      log4perl.logger.com.foo=WARN
  
  This defines two loggers: The root logger and the C<com.foo> logger.
  The root logger is easily triggered by debug-messages, 
  but the C<com.foo> logger makes sure that messages issued within
  the C<Com::Foo> component and below are only forwarded to the appender
  if they're of priority I<warning> or higher. 
  
  Note that the C<com.foo> logger doesn't define an appender. Therefore,
  it will just propagate the message up the hierarchy until the root logger
  picks it up and forwards it to the one and only appender of the root
  category, using the format defined for it.
  
  Third example:
  
      log4j.rootLogger=DEBUG, stdout, R
      log4j.appender.stdout=org.apache.log4j.ConsoleAppender
      log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
      log4j.appender.stdout.layout.ConversionPattern=%5p (%F:%L) - %m%n
      log4j.appender.R=org.apache.log4j.RollingFileAppender
      log4j.appender.R.File=example.log
      log4j.appender.R.layout=org.apache.log4j.PatternLayout
      log4j.appender.R.layout.ConversionPattern=%p %c - %m%n
  
  The root logger defines two appenders here: C<stdout>, which uses 
  C<org.apache.log4j.ConsoleAppender> (ultimately mapped by C<Log::Log4perl>
  to L<Log::Log4perl::Appender::Screen>) to write to the screen. And
  C<R>, a C<org.apache.log4j.RollingFileAppender> 
  (mapped by C<Log::Log4perl> to 
  L<Log::Dispatch::FileRotate> with the C<File> attribute specifying the
  log file.
  
  See L<Log::Log4perl::Config> for more examples and syntax explanations.
  
  =head2 Log Layouts
  
  If the logging engine passes a message to an appender, because it thinks
  it should be logged, the appender doesn't just
  write it out haphazardly. There's ways to tell the appender how to format
  the message and add all sorts of interesting data to it: The date and
  time when the event happened, the file, the line number, the
  debug level of the logger and others.
  
  There's currently two layouts defined in C<Log::Log4perl>: 
  C<Log::Log4perl::Layout::SimpleLayout> and
  C<Log::Log4perl::Layout::PatternLayout>:
  
  =over 4 
  
  =item C<Log::Log4perl::SimpleLayout> 
  
  formats a message in a simple
  way and just prepends it by the debug level and a hyphen:
  C<"$level - $message>, for example C<"FATAL - Can't open password file">.
  
  =item C<Log::Log4perl::Layout::PatternLayout> 
  
  on the other hand is very powerful and 
  allows for a very flexible format in C<printf>-style. The format
  string can contain a number of placeholders which will be
  replaced by the logging engine when it's time to log the message:
  
      %c Category of the logging event.
      %C Fully qualified package (or class) name of the caller
      %d Current date in yyyy/MM/dd hh:mm:ss format
      %F File where the logging event occurred
      %H Hostname (if Sys::Hostname is available)
      %l Fully qualified name of the calling method followed by the
         callers source the file name and line number between 
         parentheses.
      %L Line number within the file where the log statement was issued
      %m The message to be logged
      %m{chomp} The message to be logged, stripped off a trailing newline
      %M Method or function where the logging request was issued
      %n Newline (OS-independent)
      %p Priority of the logging event
      %P pid of the current process
      %r Number of milliseconds elapsed from program start to logging 
         event
      %R Number of milliseconds elapsed from last logging event to
         current logging event 
      %T A stack trace of functions called
      %x The topmost NDC (see below)
      %X{key} The entry 'key' of the MDC (see below)
      %% A literal percent (%) sign
  
  NDC and MDC are explained in L<"Nested Diagnostic Context (NDC)">
  and L<"Mapped Diagnostic Context (MDC)">.
  
  Also, C<%d> can be fine-tuned to display only certain characteristics
  of a date, according to the SimpleDateFormat in the Java World
  (L<http://java.sun.com/j2se/1.3/docs/api/java/text/SimpleDateFormat.html>)
  
  In this way, C<%d{HH:mm}> displays only hours and minutes of the current date,
  while C<%d{yy, EEEE}> displays a two-digit year, followed by a spelled-out day
  (like C<Wednesday>). 
  
  Similar options are available for shrinking the displayed category or
  limit file/path components, C<%F{1}> only displays the source file I<name>
  without any path components while C<%F> logs the full path. %c{2} only
  logs the last two components of the current category, C<Foo::Bar::Baz> 
  becomes C<Bar::Baz> and saves space.
  
  If those placeholders aren't enough, then you can define your own right in
  the config file like this:
  
      log4perl.PatternLayout.cspec.U = sub { return "UID $<" }
  
  See L<Log::Log4perl::Layout::PatternLayout> for further details on
  customized specifiers.
  
  Please note that the subroutines you're defining in this way are going
  to be run in the C<main> namespace, so be sure to fully qualify functions
  and variables if they're located in different packages.
  
  SECURITY NOTE: this feature means arbitrary perl code can be embedded in the 
  config file.  In the rare case where the people who have access to your config 
  file are different from the people who write your code and shouldn't have 
  execute rights, you might want to call
  
      Log::Log4perl::Config->allow_code(0);
  
  before you call init(). Alternatively you can supply a restricted set of
  Perl opcodes that can be embedded in the config file as described in
  L<"Restricting what Opcodes can be in a Perl Hook">.
  
  =back
  
  All placeholders are quantifiable, just like in I<printf>. Following this 
  tradition, C<%-20c> will reserve 20 chars for the category and left-justify it.
  
  For more details on logging and how to use the flexible and the simple
  format, check out the original C<log4j> website under
  
  L<SimpleLayout|http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/SimpleLayout.html>
  and
  L<PatternLayout|http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/PatternLayout.html>
  
  =head2 Penalties
  
  Logging comes with a price tag. C<Log::Log4perl> has been optimized
  to allow for maximum performance, both with logging enabled and disabled.
  
  But you need to be aware that there's a small hit every time your code
  encounters a log statement -- no matter if logging is enabled or not. 
  C<Log::Log4perl> has been designed to keep this so low that it will
  be unnoticeable to most applications.
  
  Here's a couple of tricks which help C<Log::Log4perl> to avoid
  unnecessary delays:
  
  You can save serious time if you're logging something like
  
          # Expensive in non-debug mode!
      for (@super_long_array) {
          $logger->debug("Element: $_");
      }
  
  and C<@super_long_array> is fairly big, so looping through it is pretty
  expensive. Only you, the programmer, knows that going through that C<for>
  loop can be skipped entirely if the current logging level for the 
  actual component is higher than C<debug>.
  In this case, use this instead:
  
          # Cheap in non-debug mode!
      if($logger->is_debug()) {
          for (@super_long_array) {
              $logger->debug("Element: $_");
          }
      }
  
  If you're afraid that generating the parameters to the
  logging function is fairly expensive, use closures:
  
          # Passed as subroutine ref
      use Data::Dumper;
      $logger->debug(sub { Dumper($data) } );
  
  This won't unravel C<$data> via Dumper() unless it's actually needed
  because it's logged. 
  
  Also, Log::Log4perl lets you specify arguments
  to logger functions in I<message output filter syntax>:
  
      $logger->debug("Structure: ",
                     { filter => \&Dumper,
                       value  => $someref });
  
  In this way, shortly before Log::Log4perl sending the
  message out to any appenders, it will be searching all arguments for
  hash references and treat them in a special way:
  
  It will invoke the function given as a reference with the C<filter> key
  (C<Data::Dumper::Dumper()>) and pass it the value that came with
  the key named C<value> as an argument.
  The anonymous hash in the call above will be replaced by the return 
  value of the filter function.
  
  =head1 Categories
  
  B<Categories are also called "Loggers" in Log4perl, both refer
  to the same thing and these terms are used interchangeably.>
  C<Log::Log4perl> uses I<categories> to determine if a log statement in
  a component should be executed or suppressed at the current logging level.
  Most of the time, these categories are just the classes the log statements
  are located in:
  
      package Candy::Twix;
  
      sub new { 
          my $logger = Log::Log4perl->get_logger("Candy::Twix");
          $logger->debug("Creating a new Twix bar");
          bless {}, shift;
      }
   
      # ...
  
      package Candy::Snickers;
  
      sub new { 
          my $logger = Log::Log4perl->get_logger("Candy.Snickers");
          $logger->debug("Creating a new Snickers bar");
          bless {}, shift;
      }
  
      # ...
  
      package main;
      Log::Log4perl->init("mylogdefs.conf");
  
          # => "LOG> Creating a new Snickers bar"
      my $first = Candy::Snickers->new();
          # => "LOG> Creating a new Twix bar"
      my $second = Candy::Twix->new();
  
  Note that you can separate your category hierarchy levels
  using either dots like
  in Java (.) or double-colons (::) like in Perl. Both notations
  are equivalent and are handled the same way internally.
  
  However, categories are just there to make
  use of inheritance: if you invoke a logger in a sub-category, 
  it will bubble up the hierarchy and call the appropriate appenders.
  Internally, categories are not related to the class hierarchy of the program
  at all -- they're purely virtual. You can use arbitrary categories --
  for example in the following program, which isn't oo-style, but
  procedural:
  
      sub print_portfolio {
  
          my $log = Log::Log4perl->get_logger("user.portfolio");
          $log->debug("Quotes requested: @_");
  
          for(@_) {
              print "$_: ", get_quote($_), "\n";
          }
      }
  
      sub get_quote {
  
          my $log = Log::Log4perl->get_logger("internet.quotesystem");
          $log->debug("Fetching quote: $_[0]");
  
          return yahoo_quote($_[0]);
      }
  
  The logger in first function, C<print_portfolio>, is assigned the
  (virtual) C<user.portfolio> category. Depending on the C<Log4perl>
  configuration, this will either call a C<user.portfolio> appender,
  a C<user> appender, or an appender assigned to root -- without
  C<user.portfolio> having any relevance to the class system used in 
  the program.
  The logger in the second function adheres to the 
  C<internet.quotesystem> category -- again, maybe because it's bundled 
  with other Internet functions, but not because there would be
  a class of this name somewhere.
  
  However, be careful, don't go overboard: if you're developing a system
  in object-oriented style, using the class hierarchy is usually your best
  choice. Think about the people taking over your code one day: The
  class hierarchy is probably what they know right up front, so it's easy
  for them to tune the logging to their needs.
  
  =head2 Turn off a component
  
  C<Log4perl> doesn't only allow you to selectively switch I<on> a category
  of log messages, you can also use the mechanism to selectively I<disable>
  logging in certain components whereas logging is kept turned on in higher-level
  categories. This mechanism comes in handy if you find that while bumping 
  up the logging level of a high-level (i. e. close to root) category, 
  that one component logs more than it should, 
  
  Here's how it works: 
  
      ############################################################
      # Turn off logging in a lower-level category while keeping
      # it active in higher-level categories.
      ############################################################
      log4perl.rootLogger=DEBUG, LOGFILE
      log4perl.logger.deep.down.the.hierarchy = ERROR, LOGFILE
  
      # ... Define appenders ...
  
  This way, log messages issued from within 
  C<Deep::Down::The::Hierarchy> and below will be
  logged only if they're C<ERROR> or worse, while in all other system components
  even C<DEBUG> messages will be logged.
  
  =head2 Return Values
  
  All logging methods return values indicating if their message
  actually reached one or more appenders. If the message has been
  suppressed because of level constraints, C<undef> is returned.
  
  For example,
  
      my $ret = $logger->info("Message");
  
  will return C<undef> if the system debug level for the current category
  is not C<INFO> or more permissive. 
  If Log::Log4perl
  forwarded the message to one or more appenders, the number of appenders
  is returned.
  
  If appenders decide to veto on the message with an appender threshold,
  the log method's return value will have them excluded. This means that if
  you've got one appender holding an appender threshold and you're 
  logging a message
  which passes the system's log level hurdle but not the appender threshold,
  C<0> will be returned by the log function.
  
  The bottom line is: Logging functions will return a I<true> value if the message
  made it through to one or more appenders and a I<false> value if it didn't.
  This allows for constructs like
  
      $logger->fatal("@_") or print STDERR "@_\n";
  
  which will ensure that the fatal message isn't lost
  if the current level is lower than FATAL or printed twice if 
  the level is acceptable but an appender already points to STDERR.
  
  =head2 Pitfalls with Categories
  
  Be careful with just blindly reusing the system's packages as
  categories. If you do, you'll get into trouble with inherited methods.
  Imagine the following class setup:
  
      use Log::Log4perl;
  
      ###########################################
      package Bar;
      ###########################################
      sub new {
          my($class) = @_;
          my $logger = Log::Log4perl::get_logger(__PACKAGE__);
          $logger->debug("Creating instance");
          bless {}, $class;
      }
      ###########################################
      package Bar::Twix;
      ###########################################
      our @ISA = qw(Bar);
  
      ###########################################
      package main;
      ###########################################
      Log::Log4perl->init(\ qq{
      log4perl.category.Bar.Twix = DEBUG, Screen
      log4perl.appender.Screen = Log::Log4perl::Appender::Screen
      log4perl.appender.Screen.layout = SimpleLayout
      });
  
      my $bar = Bar::Twix->new();
  
  C<Bar::Twix> just inherits everything from C<Bar>, including the constructor
  C<new()>.
  Contrary to what you might be thinking at first, this won't log anything. 
  Reason for this is the C<get_logger()> call in package C<Bar>, which
  will always get a logger of the C<Bar> category, even if we call C<new()> via
  the C<Bar::Twix> package, which will make perl go up the inheritance 
  tree to actually execute C<Bar::new()>. Since we've only defined logging
  behaviour for C<Bar::Twix> in the configuration file, nothing will happen.
  
  This can be fixed by changing the C<get_logger()> method in C<Bar::new()>
  to obtain a logger of the category matching the
  I<actual> class of the object, like in
  
          # ... in Bar::new() ...
      my $logger = Log::Log4perl::get_logger( $class );
  
  In a method other than the constructor, the class name of the actual
  object can be obtained by calling C<ref()> on the object reference, so
  
      package BaseClass;
      use Log::Log4perl qw( get_logger );
  
      sub new { 
          bless {}, shift; 
      }
  
      sub method {
          my( $self ) = @_;
  
          get_logger( ref $self )->debug( "message" );
      }
  
      package SubClass;
      our @ISA = qw(BaseClass);
  
  is the recommended pattern to make sure that 
  
      my $sub = SubClass->new();
      $sub->meth();
  
  starts logging if the C<"SubClass"> category 
  (and not the C<"BaseClass"> category has logging enabled at the DEBUG level.
  
  =head2 Initialize once and only once
  
  It's important to realize that Log::Log4perl gets initialized once and only
  once, typically at the start of a program or system. Calling C<init()>
  more than once will cause it to clobber the existing configuration and
  I<replace> it by the new one.
  
  If you're in a traditional CGI environment, where every request is
  handled by a new process, calling C<init()> every time is fine. In
  persistent environments like C<mod_perl>, however, Log::Log4perl
  should be initialized either at system startup time (Apache offers
  startup handlers for that) or via
  
          # Init or skip if already done
      Log::Log4perl->init_once($conf_file);
  
  C<init_once()> is identical to C<init()>, just with the exception
  that it will leave a potentially existing configuration alone and 
  will only call C<init()> if Log::Log4perl hasn't been initialized yet.
  
  If you're just curious if Log::Log4perl has been initialized yet, the
  check
  
      if(Log::Log4perl->initialized()) {
          # Yes, Log::Log4perl has already been initialized
      } else {
          # No, not initialized yet ...
      }
  
  can be used.
  
  If you're afraid that the components of your system are stepping on 
  each other's toes or if you are thinking that different components should
  initialize Log::Log4perl separately, try to consolidate your system
  to use a centralized Log4perl configuration file and use 
  Log4perl's I<categories> to separate your components.
  
  =head2 Custom Filters
  
  Log4perl allows the use of customized filters in its appenders
  to control the output of messages. These filters might grep for
  certain text chunks in a message, verify that its priority
  matches or exceeds a certain level or that this is the 10th
  time the same message has been submitted -- and come to a log/no log 
  decision based upon these circumstantial facts.
  
  Check out L<Log::Log4perl::Filter> for detailed instructions 
  on how to use them.
  
  =head2 Performance
  
  The performance of Log::Log4perl calls obviously depends on a lot of things.
  But to give you a general idea, here's some rough numbers:
  
  On a Pentium 4 Linux box at 2.4 GHz, you'll get through
  
  =over 4
  
  =item *
  
  500,000 suppressed log statements per second
  
  =item *
  
  30,000 logged messages per second (using an in-memory appender)
  
  =item *
  
  init_and_watch delay mode: 300,000 suppressed, 30,000 logged.
  init_and_watch signal mode: 450,000 suppressed, 30,000 logged.
  
  =back
  
  Numbers depend on the complexity of the Log::Log4perl configuration.
  For a more detailed benchmark test, check the C<docs/benchmark.results.txt> 
  document in the Log::Log4perl distribution.
  
  =head1 Cool Tricks
  
  Here's a collection of useful tricks for the advanced C<Log::Log4perl> user.
  For more, check the FAQ, either in the distribution 
  (L<Log::Log4perl::FAQ>) or on L<http://log4perl.sourceforge.net>.
  
  =head2 Shortcuts
  
  When getting an instance of a logger, instead of saying
  
      use Log::Log4perl;
      my $logger = Log::Log4perl->get_logger();
  
  it's often more convenient to import the C<get_logger> method from 
  C<Log::Log4perl> into the current namespace:
  
      use Log::Log4perl qw(get_logger);
      my $logger = get_logger();
  
  Please note this difference: To obtain the root logger, please use
  C<get_logger("")>, call it without parameters (C<get_logger()>), you'll
  get the logger of a category named after the current package. 
  C<get_logger()> is equivalent to C<get_logger(__PACKAGE__)>.
  
  =head2 Alternative initialization
  
  Instead of having C<init()> read in a configuration file by specifying
  a file name or passing it a reference to an open filehandle
  (C<Log::Log4perl-E<gt>init( \*FILE )>),
  you can 
  also pass in a reference to a string, containing the content of
  the file:
  
      Log::Log4perl->init( \$config_text );
  
  Also, if you've got the C<name=value> pairs of the configuration in
  a hash, you can just as well initialize C<Log::Log4perl> with
  a reference to it:
  
      my %key_value_pairs = (
          "log4perl.rootLogger"       => "ERROR, LOGFILE",
          "log4perl.appender.LOGFILE" => "Log::Log4perl::Appender::File",
          ...
      );
  
      Log::Log4perl->init( \%key_value_pairs );
  
  Or also you can use a URL, see below:
  
  =head2 Using LWP to parse URLs
  
  (This section borrowed from XML::DOM::Parser by T.J. Mather).
  
  The init() function now also supports URLs, e.g. I<http://www.erols.com/enno/xsa.xml>.
  It uses LWP to download the file and then calls parse() on the resulting string.
  By default it will use a L<LWP::UserAgent> that is created as follows:
  
   use LWP::UserAgent;
   $LWP_USER_AGENT = LWP::UserAgent->new;
   $LWP_USER_AGENT->env_proxy;
  
  Note that env_proxy reads proxy settings from environment variables, which is what Log4perl needs to
  do to get through our firewall. If you want to use a different LWP::UserAgent, you can 
  set it with
  
      Log::Log4perl::Config::set_LWP_UserAgent($my_agent);
  
  Currently, LWP is used when the filename (passed to parsefile) starts with one of
  the following URL schemes: http, https, ftp, wais, gopher, or file (followed by a colon.)
  
  Don't use this feature with init_and_watch().
  
  =head2 Automatic reloading of changed configuration files
  
  Instead of just statically initializing Log::Log4perl via
  
      Log::Log4perl->init($conf_file);
  
  there's a way to have Log::Log4perl periodically check for changes
  in the configuration and reload it if necessary:
  
      Log::Log4perl->init_and_watch($conf_file, $delay);
  
  In this mode, Log::Log4perl will examine the configuration file 
  C<$conf_file> every C<$delay> seconds for changes via the file's
  last modification timestamp. If the file has been updated, it will
  be reloaded and replace the current Log::Log4perl configuration.
  
  The way this works is that with every logger function called 
  (debug(), is_debug(), etc.), Log::Log4perl will check if the delay 
  interval has expired. If so, it will run a -M file check on the 
  configuration file. If its timestamp has been modified, the current
  configuration will be dumped and new content of the file will be
  loaded.
  
  This convenience comes at a price, though: Calling time() with every
  logging function call, especially the ones that are "suppressed" (!), 
  will slow down these Log4perl calls by about 40%.
  
  To alleviate this performance hit a bit, C<init_and_watch()> 
  can be configured to listen for a Unix signal to reload the 
  configuration instead:
  
      Log::Log4perl->init_and_watch($conf_file, 'HUP');
  
  This will set up a signal handler for SIGHUP and reload the configuration
  if the application receives this signal, e.g. via the C<kill> command:
  
      kill -HUP pid
  
  where C<pid> is the process ID of the application. This will bring you back
  to about 85% of Log::Log4perl's normal execution speed for suppressed
  statements. For details, check out L<"Performance">. For more info
  on the signal handler, look for L<Log::Log4perl::Config::Watch/"SIGNAL MODE">.
  
  If you have a somewhat long delay set between physical config file checks
  or don't want to use the signal associated with the config file watcher,
  you can trigger a configuration reload at the next possible time by
  calling C<Log::Log4perl::Config-E<gt>watcher-E<gt>force_next_check()>.
  
  One thing to watch out for: If the configuration file contains a syntax
  or other fatal error, a running application will stop with C<die> if
  this damaged configuration will be loaded during runtime, triggered
  either by a signal or if the delay period expired and the change is 
  detected. This behaviour might change in the future.
  
  To allow the application to intercept and control a configuration reload
  in init_and_watch mode, a callback can be specified:
  
      Log::Log4perl->init_and_watch($conf_file, 10, { 
              preinit_callback => \&callback });
  
  If Log4perl determines that the configuration needs to be reloaded, it will
  call the C<preinit_callback> function without parameters. If the callback
  returns a true value, Log4perl will proceed and reload the configuration.  If
  the callback returns a false value, Log4perl will keep the old configuration
  and skip reloading it until the next time around.  Inside the callback, an
  application can run all kinds of checks, including accessing the configuration
  file, which is available via
  C<Log::Log4perl::Config-E<gt>watcher()-E<gt>file()>.
  
  =head2 Variable Substitution
  
  To avoid having to retype the same expressions over and over again,
  Log::Log4perl's configuration files support simple variable substitution.
  New variables are defined simply by adding
  
      varname = value
  
  lines to the configuration file before using
  
      ${varname}
  
  afterwards to recall the assigned values. Here's an example:
  
      layout_class   = Log::Log4perl::Layout::PatternLayout
      layout_pattern = %d %F{1} %L> %m %n
      
      log4perl.category.Bar.Twix = WARN, Logfile, Screen
  
      log4perl.appender.Logfile  = Log::Log4perl::Appender::File
      log4perl.appender.Logfile.filename = test.log
      log4perl.appender.Logfile.layout = ${layout_class}
      log4perl.appender.Logfile.layout.ConversionPattern = ${layout_pattern}
  
      log4perl.appender.Screen  = Log::Log4perl::Appender::Screen
      log4perl.appender.Screen.layout = ${layout_class}
      log4perl.appender.Screen.layout.ConversionPattern = ${layout_pattern}
  
  This is a convenient way to define two appenders with the same layout 
  without having to retype the pattern definitions.
  
  Variable substitution via C<${varname}> 
  will first try to find an explicitly defined 
  variable. If that fails, it will check your shell's environment
  for a variable of that name. If that also fails, the program will C<die()>.
  
  =head2 Perl Hooks in the Configuration File
  
  If some of the values used in the Log4perl configuration file 
  need to be dynamically modified by the program, use Perl hooks:
  
      log4perl.appender.File.filename = \
          sub { return getLogfileName(); }
  
  Each value starting with the string C<sub {...> is interpreted as Perl code to
  be executed at the time the application parses the configuration
  via C<Log::Log4perl::init()>. The return value of the subroutine
  is used by Log::Log4perl as the configuration value.
  
  The Perl code is executed in the C<main> package, functions in
  other packages have to be called in fully-qualified notation.
  
  Here's another example, utilizing an environment variable as a
  username for a DBI appender:
  
      log4perl.appender.DB.username = \
          sub { $ENV{DB_USER_NAME } }
  
  However, please note the difference between these code snippets and those
  used for user-defined conversion specifiers as discussed in
  L<Log::Log4perl::Layout::PatternLayout>: 
  While the snippets above are run I<once>
  when C<Log::Log4perl::init()> is called, the conversion specifier
  snippets are executed I<each time> a message is rendered according to
  the PatternLayout.
  
  SECURITY NOTE: this feature means arbitrary perl code can be embedded in the 
  config file.  In the rare case where the people who have access to your config 
  file are different from the people who write your code and shouldn't have 
  execute rights, you might want to set
  
      Log::Log4perl::Config->allow_code(0);
  
  before you call init().  Alternatively you can supply a restricted set of
  Perl opcodes that can be embedded in the config file as described in
  L<"Restricting what Opcodes can be in a Perl Hook">.
  
  =head2 Restricting what Opcodes can be in a Perl Hook
  
  The value you pass to Log::Log4perl::Config->allow_code() determines whether
  the code that is embedded in the config file is eval'd unrestricted, or
  eval'd in a Safe compartment.  By default, a value of '1' is assumed,
  which does a normal 'eval' without any restrictions. A value of '0' 
  however prevents any embedded code from being evaluated.
  
  If you would like fine-grained control over what can and cannot be included
  in embedded code, then please utilize the following methods:
  
   Log::Log4perl::Config->allow_code( $allow );
   Log::Log4perl::Config->allowed_code_ops($op1, $op2, ... );
   Log::Log4perl::Config->vars_shared_with_safe_compartment( [ \%vars | $package, \@vars ] );
   Log::Log4perl::Config->allowed_code_ops_convenience_map( [ \%map | $name, \@mask ] );
  
  Log::Log4perl::Config-E<gt>allowed_code_ops() takes a list of opcode masks
  that are allowed to run in the compartment.  The opcode masks must be
  specified as described in L<Opcode>:
  
   Log::Log4perl::Config->allowed_code_ops(':subprocess');
  
  This example would allow Perl operations like backticks, system, fork, and
  waitpid to be executed in the compartment.  Of course, you probably don't
  want to use this mask -- it would allow exactly what the Safe compartment is
  designed to prevent.
  
  Log::Log4perl::Config-E<gt>vars_shared_with_safe_compartment() 
  takes the symbols which
  should be exported into the Safe compartment before the code is evaluated. 
  The keys of this hash are the package names that the symbols are in, and the
  values are array references to the literal symbol names.  For convenience,
  the default settings export the '%ENV' hash from the 'main' package into the
  compartment:
  
   Log::Log4perl::Config->vars_shared_with_safe_compartment(
     main => [ '%ENV' ],
   );
  
  Log::Log4perl::Config-E<gt>allowed_code_ops_convenience_map() is an accessor
  method to a map of convenience names to opcode masks. At present, the
  following convenience names are defined:
  
   safe        = [ ':browse' ]
   restrictive = [ ':default' ]
  
  For convenience, if Log::Log4perl::Config-E<gt>allow_code() is called with a
  value which is a key of the map previously defined with
  Log::Log4perl::Config-E<gt>allowed_code_ops_convenience_map(), then the
  allowed opcodes are set according to the value defined in the map. If this
  is confusing, consider the following:
  
   use Log::Log4perl;
   
   my $config = <<'END';
    log4perl.logger = INFO, Main
    log4perl.appender.Main = Log::Log4perl::Appender::File
    log4perl.appender.Main.filename = \
        sub { "example" . getpwuid($<) . ".log" }
    log4perl.appender.Main.layout = Log::Log4perl::Layout::SimpleLayout
   END
   
   $Log::Log4perl::Config->allow_code('restrictive');
   Log::Log4perl->init( \$config );       # will fail
   $Log::Log4perl::Config->allow_code('safe');
   Log::Log4perl->init( \$config );       # will succeed
  
  The reason that the first call to -E<gt>init() fails is because the
  'restrictive' name maps to an opcode mask of ':default'.  getpwuid() is not
  part of ':default', so -E<gt>init() fails.  The 'safe' name maps to an opcode
  mask of ':browse', which allows getpwuid() to run, so -E<gt>init() succeeds.
  
  allowed_code_ops_convenience_map() can be invoked in several ways:
  
  =over 4
  
  =item allowed_code_ops_convenience_map()
  
  Returns the entire convenience name map as a hash reference in scalar
  context or a hash in list context.
  
  =item allowed_code_ops_convenience_map( \%map )
  
  Replaces the entire convenience name map with the supplied hash reference.
  
  =item allowed_code_ops_convenience_map( $name )
  
  Returns the opcode mask for the given convenience name, or undef if no such
  name is defined in the map.
  
  =item allowed_code_ops_convenience_map( $name, \@mask )
  
  Adds the given name/mask pair to the convenience name map.  If the name
  already exists in the map, it's value is replaced with the new mask.
  
  =back
  
  as can vars_shared_with_safe_compartment():
  
  =over 4
  
  =item vars_shared_with_safe_compartment()
  
  Return the entire map of packages to variables as a hash reference in scalar
  context or a hash in list context.
  
  =item vars_shared_with_safe_compartment( \%packages )
  
  Replaces the entire map of packages to variables with the supplied hash
  reference.
  
  =item vars_shared_with_safe_compartment( $package )
  
  Returns the arrayref of variables to be shared for a specific package.
  
  =item vars_shared_with_safe_compartment( $package, \@vars )
  
  Adds the given package / varlist pair to the map.  If the package already
  exists in the map, it's value is replaced with the new arrayref of variable
  names.
  
  =back
  
  For more information on opcodes and Safe Compartments, see L<Opcode> and
  L<Safe>.
  
  =head2 Changing the Log Level on a Logger
  
  Log4perl provides some internal functions for quickly adjusting the
  log level from within a running Perl program. 
  
  Now, some people might
  argue that you should adjust your levels from within an external 
  Log4perl configuration file, but Log4perl is everybody's darling.
  
  Typically run-time adjusting of levels is done
  at the beginning, or in response to some external input (like a
  "more logging" runtime command for diagnostics).
  
  You get the log level from a logger object with:
  
      $current_level = $logger->level();
  
  and you may set it with the same method, provided you first
  imported the log level constants, with:
  
      use Log::Log4perl::Level;
  
  Then you can set the level on a logger to one of the constants,
  
      $logger->level($ERROR); # one of DEBUG, INFO, WARN, ERROR, FATAL
  
  To B<increase> the level of logging currently being done, use:
  
      $logger->more_logging($delta);
  
  and to B<decrease> it, use:
  
      $logger->less_logging($delta);
  
  $delta must be a positive integer (for now, we may fix this later ;).
  
  There are also two equivalent functions:
  
      $logger->inc_level($delta);
      $logger->dec_level($delta);
  
  They're included to allow you a choice in readability. Some folks
  will prefer more/less_logging, as they're fairly clear in what they
  do, and allow the programmer not to worry too much about what a Level
  is and whether a higher level means more or less logging. However,
  other folks who do understand and have lots of code that deals with
  levels will probably prefer the inc_level() and dec_level() methods as
  they want to work with Levels and not worry about whether that means
  more or less logging. :)
  
  That diatribe aside, typically you'll use more_logging() or inc_level()
  as such:
  
      my $v = 0; # default level of verbosity.
      
      GetOptions("v+" => \$v, ...);
  
      if( $v ) {
        $logger->more_logging($v); # inc logging level once for each -v in ARGV
      }
  
  =head2 Custom Log Levels
  
  First off, let me tell you that creating custom levels is heavily
  deprecated by the log4j folks. Indeed, instead of creating additional
  levels on top of the predefined DEBUG, INFO, WARN, ERROR and FATAL, 
  you should use categories to control the amount of logging smartly,
  based on the location of the log-active code in the system.
  
  Nevertheless, 
  Log4perl provides a nice way to create custom levels via the 
  create_custom_level() routine function. However, this must be done
  before the first call to init() or get_logger(). Say you want to create
  a NOTIFY logging level that comes after WARN (and thus before INFO).
  You'd do such as follows:
  
      use Log::Log4perl;
      use Log::Log4perl::Level;
  
      Log::Log4perl::Logger::create_custom_level("NOTIFY", "WARN");
  
  And that's it! C<create_custom_level()> creates the following functions /
  variables for level FOO:
  
      $FOO_INT        # integer to use in L4p::Level::to_level()
      $logger->foo()  # log function to log if level = FOO
      $logger->is_foo()   # true if current level is >= FOO
  
  These levels can also be used in your
  config file, but note that your config file probably won't be
  portable to another log4perl or log4j environment unless you've
  made the appropriate mods there too.
  
  Since Log4perl translates log levels to syslog and Log::Dispatch if 
  their appenders are used, you may add mappings for custom levels as well:
  
    Log::Log4perl::Level::add_priority("NOTIFY", "WARN",
                                       $syslog_equiv, $log_dispatch_level);
  
  For example, if your new custom "NOTIFY" level is supposed to map 
  to syslog level 2 ("LOG_NOTICE") and Log::Dispatch level 2 ("notice"), use:
  
    Log::Log4perl::Logger::create_custom_level("NOTIFY", "WARN", 2, 2);
  
  =head2 System-wide log levels
  
  As a fairly drastic measure to decrease (or increase) the logging level
  all over the system with one single configuration option, use the C<threshold>
  keyword in the Log4perl configuration file:
  
      log4perl.threshold = ERROR
  
  sets the system-wide (or hierarchy-wide according to the log4j documentation)
  to ERROR and therefore deprives every logger in the system of the right 
  to log lower-prio messages.
  
  =head2 Easy Mode
  
  For teaching purposes (especially for [1]), I've put C<:easy> mode into 
  C<Log::Log4perl>, which just initializes a single root logger with a 
  defined priority and a screen appender including some nice standard layout:
  
      ### Initialization Section
      use Log::Log4perl qw(:easy);
      Log::Log4perl->easy_init($ERROR);  # Set priority of root logger to ERROR
  
      ### Application Section
      my $logger = get_logger();
      $logger->fatal("This will get logged.");
      $logger->debug("This won't.");
  
  This will dump something like
  
      2002/08/04 11:43:09 ERROR> script.pl:16 main::function - This will get logged.
  
  to the screen. While this has been proven to work well familiarizing people
  with C<Log::Logperl> slowly, effectively avoiding to clobber them over the 
  head with a 
  plethora of different knobs to fiddle with (categories, appenders, levels, 
  layout), the overall mission of C<Log::Log4perl> is to let people use
  categories right from the start to get used to the concept. So, let's keep
  this one fairly hidden in the man page (congrats on reading this far :).
  
  =head2 Stealth loggers
  
  Sometimes, people are lazy. If you're whipping up a 50-line script and want 
  the comfort of Log::Log4perl without having the burden of carrying a
  separate log4perl.conf file or a 5-liner defining that you want to append
  your log statements to a file, you can use the following features:
  
      use Log::Log4perl qw(:easy);
  
      Log::Log4perl->easy_init( { level   => $DEBUG,
                                  file    => ">>test.log" } );
  
          # Logs to test.log via stealth logger
      DEBUG("Debug this!");
      INFO("Info this!");
      WARN("Warn this!");
      ERROR("Error this!");
  
      some_function();
  
      sub some_function {
              # Same here
          FATAL("Fatal this!");
      }
  
  In C<:easy> mode, C<Log::Log4perl> will instantiate a I<stealth logger>
  and introduce the
  convenience functions C<TRACE>, C<DEBUG()>, C<INFO()>, C<WARN()>, 
  C<ERROR()>, C<FATAL()>, and C<ALWAYS> into the package namespace.
  These functions simply take messages as
  arguments and forward them to the stealth loggers methods (C<debug()>,
  C<info()>, and so on).
  
  If a message should never be blocked, regardless of the log level,
  use the C<ALWAYS> function which corresponds to a log level of C<OFF>:
  
      ALWAYS "This will be printed regardless of the log level";
  
  The C<easy_init> method can be called with a single level value to
  create a STDERR appender and a root logger as in
  
      Log::Log4perl->easy_init($DEBUG);
  
  or, as shown below (and in the example above) 
  with a reference to a hash, specifying values
  for C<level> (the logger's priority), C<file> (the appender's data sink),
  C<category> (the logger's category and C<layout> for the appender's 
  pattern layout specification.
  All key-value pairs are optional, they 
  default to C<$DEBUG> for C<level>, C<STDERR> for C<file>,
  C<""> (root category) for C<category> and 
  C<%d %m%n> for C<layout>:
  
      Log::Log4perl->easy_init( { level    => $DEBUG,
                                  file     => ">test.log",
                                  utf8     => 1,
                                  category => "Bar::Twix",
                                  layout   => '%F{1}-%L-%M: %m%n' } );
  
  The C<file> parameter takes file names preceded by C<"E<gt>">
  (overwrite) and C<"E<gt>E<gt>"> (append) as arguments. This will
  cause C<Log::Log4perl::Appender::File> appenders to be created behind
  the scenes. Also the keywords C<STDOUT> and C<STDERR> (no C<E<gt>> or
  C<E<gt>E<gt>>) are recognized, which will utilize and configure
  C<Log::Log4perl::Appender::Screen> appropriately. The C<utf8> flag,
  if set to a true value, runs a C<binmode> command on the file handle
  to establish a utf8 line discipline on the file, otherwise you'll get a
  'wide character in print' warning message and probably not what you'd
  expect as output.
  
  The stealth loggers can be used in different packages, you just need to make
  sure you're calling the "use" function in every package you're using
  C<Log::Log4perl>'s easy services:
  
      package Bar::Twix;
      use Log::Log4perl qw(:easy);
      sub eat { DEBUG("Twix mjam"); }
  
      package Bar::Mars;
      use Log::Log4perl qw(:easy);
      sub eat { INFO("Mars mjam"); }
  
      package main;
  
      use Log::Log4perl qw(:easy);
  
      Log::Log4perl->easy_init( { level    => $DEBUG,
                                  file     => ">>test.log",
                                  category => "Bar::Twix",
                                  layout   => '%F{1}-%L-%M: %m%n' },
                                { level    => $DEBUG,
                                  file     => "STDOUT",
                                  category => "Bar::Mars",
                                  layout   => '%m%n' },
                              );
      Bar::Twix::eat();
      Bar::Mars::eat();
  
  As shown above, C<easy_init()> will take any number of different logger 
  definitions as hash references.
  
  Also, stealth loggers feature the functions C<LOGWARN()>, C<LOGDIE()>,
  and C<LOGEXIT()>,
  combining a logging request with a subsequent Perl warn() or die() or exit()
  statement. So, for example
  
      if($all_is_lost) {
          LOGDIE("Terrible Problem");
      }
  
  will log the message if the package's logger is at least C<FATAL> but
  C<die()> (including the traditional output to STDERR) in any case afterwards.
  
  See L<"Log and die or warn"> for the similar C<logdie()> and C<logwarn()>
  functions of regular (i.e non-stealth) loggers.
  
  Similarily, C<LOGCARP()>, C<LOGCLUCK()>, C<LOGCROAK()>, and C<LOGCONFESS()>
  are provided in C<:easy> mode, facilitating the use of C<logcarp()>,
  C<logcluck()>, C<logcroak()>, and C<logconfess()> with stealth loggers.
  
  B<When using Log::Log4perl in easy mode, 
  please make sure you understand the implications of 
  L</"Pitfalls with Categories">>.
  
  By the way, these convenience functions perform exactly as fast as the 
  standard Log::Log4perl logger methods, there's I<no> performance penalty
  whatsoever.
  
  =head2 Nested Diagnostic Context (NDC)
  
  If you find that your application could use a global (thread-specific)
  data stack which your loggers throughout the system have easy access to,
  use Nested Diagnostic Contexts (NDCs). Also check out
  L<"Mapped Diagnostic Context (MDC)">, this might turn out to be even more
  useful.
  
  For example, when handling a request of a web client, it's probably 
  useful to have the user's IP address available in all log statements
  within code dealing with this particular request. Instead of passing
  this piece of data around between your application functions, you can just
  use the global (but thread-specific) NDC mechanism. It allows you
  to push data pieces (scalars usually) onto its stack via
  
      Log::Log4perl::NDC->push("San");
      Log::Log4perl::NDC->push("Francisco");
  
  and have your loggers retrieve them again via the "%x" placeholder in
  the PatternLayout. With the stack values above and a PatternLayout format
  like "%x %m%n", the call
  
      $logger->debug("rocks");
  
  will end up as 
  
      San Francisco rocks
  
  in the log appender.
  
  The stack mechanism allows for nested structures.
  Just make sure that at the end of the request, you either decrease the stack
  one by one by calling
  
      Log::Log4perl::NDC->pop();
      Log::Log4perl::NDC->pop();
  
  or clear out the entire NDC stack by calling
  
      Log::Log4perl::NDC->remove();
  
  Even if you should forget to do that, C<Log::Log4perl> won't grow the stack
  indefinitely, but limit it to a maximum, defined in C<Log::Log4perl::NDC>
  (currently 5). A call to C<push()> on a full stack will just replace
  the topmost element by the new value.
  
  Again, the stack is always available via the "%x" placeholder
  in the Log::Log4perl::Layout::PatternLayout class whenever a logger
  fires. It will replace "%x" by the blank-separated list of the
  values on the stack. It does that by just calling
  
      Log::Log4perl::NDC->get();
  
  internally. See details on how this standard log4j feature is implemented
  in L<Log::Log4perl::NDC>.
  
  =head2 Mapped Diagnostic Context (MDC)
  
  Just like the previously discussed NDC stores thread-specific
  information in a stack structure, the MDC implements a hash table
  to store key/value pairs in.
  
  The static method
  
      Log::Log4perl::MDC->put($key, $value);
  
  stores C<$value> under a key C<$key>, with which it can be retrieved later
  (possibly in a totally different part of the system) by calling
  the C<get> method:
  
      my $value = Log::Log4perl::MDC->get($key);
  
  If no value has been stored previously under C<$key>, the C<get> method
  will return C<undef>.
  
  Typically, MDC values are retrieved later on via the C<"%X{...}"> placeholder
  in C<Log::Log4perl::Layout::PatternLayout>. If the C<get()> method
  returns C<undef>, the placeholder will expand to the string C<[undef]>.
  
  An application taking a web request might store the remote host
  like
  
      Log::Log4perl::MDC->put("remote_host", $r->headers("HOST"));
  
  at its beginning and if the appender's layout looks something like
  
      log4perl.appender.Logfile.layout.ConversionPattern = %X{remote_host}: %m%n
  
  then a log statement like
  
     DEBUG("Content delivered");
  
  will log something like
  
     adsl-63.dsl.snf.pacbell.net: Content delivered 
  
  later on in the program.
  
  For details, please check L<Log::Log4perl::MDC>.
  
  =head2 Resurrecting hidden Log4perl Statements
  
  Sometimes scripts need to be deployed in environments without having
  Log::Log4perl installed yet. On the other hand, you don't want to
  live without your Log4perl statements -- they're gonna come in
  handy later.
  
  So, just deploy your script with Log4perl statements commented out with the
  pattern C<###l4p>, like in
  
      ###l4p DEBUG "It works!";
      # ...
      ###l4p INFO "Really!";
  
  If Log::Log4perl is available,
  use the C<:resurrect> tag to have Log4perl resurrect those buried 
  statements before the script starts running:
  
      use Log::Log4perl qw(:resurrect :easy);
  
      ###l4p Log::Log4perl->easy_init($DEBUG);
      ###l4p DEBUG "It works!";
      # ...
      ###l4p INFO "Really!";
  
  This will have a source filter kick in and indeed print
  
      2004/11/18 22:08:46 It works!
      2004/11/18 22:08:46 Really!
  
  In environments lacking Log::Log4perl, just comment out the first line
  and the script will run nevertheless (but of course without logging):
  
      # use Log::Log4perl qw(:resurrect :easy);
  
      ###l4p Log::Log4perl->easy_init($DEBUG);
      ###l4p DEBUG "It works!";
      # ...
      ###l4p INFO "Really!";
  
  because everything's a regular comment now. Alternatively, put the
  magic Log::Log4perl comment resurrection line into your shell's 
  PERL5OPT environment variable, e.g. for bash:
  
      set PERL5OPT=-MLog::Log4perl=:resurrect,:easy
      export PERL5OPT
  
  This will awaken the giant within an otherwise silent script like
  the following:
  
      #!/usr/bin/perl
  
      ###l4p Log::Log4perl->easy_init($DEBUG);
      ###l4p DEBUG "It works!";
  
  As of C<Log::Log4perl> 1.12, you can even force I<all> modules
  loaded by a script to have their hidden Log4perl statements
  resurrected. For this to happen, load C<Log::Log4perl::Resurrector>
  I<before> loading any modules:
  
      use Log::Log4perl qw(:easy);
      use Log::Log4perl::Resurrector;
  
      use Foobar; # All hidden Log4perl statements in here will
                  # be uncommented before Foobar gets loaded.
  
      Log::Log4perl->easy_init($DEBUG);
      ...
  
  Check the C<Log::Log4perl::Resurrector> manpage for more details.
  
  =head2 Access defined appenders
  
  All appenders defined in the configuration file or via Perl code
  can be retrieved by the C<appender_by_name()> class method. This comes
  in handy if you want to manipulate or query appender properties after
  the Log4perl configuration has been loaded via C<init()>.
  
  Note that internally, Log::Log4perl uses the C<Log::Log4perl::Appender> 
  wrapper class to control the real appenders (like 
  C<Log::Log4perl::Appender::File> or C<Log::Dispatch::FileRotate>). 
  The C<Log::Log4perl::Appender> class has an C<appender> attribute,
  pointing to the real appender.
  
  The reason for this is that external appenders like 
  C<Log::Dispatch::FileRotate> don't support all of Log::Log4perl's 
  appender control mechanisms (like appender thresholds).
  
  The previously mentioned method C<appender_by_name()> returns a
  reference to the I<real> appender object. If you want access to the
  wrapper class (e.g. if you want to modify the appender's threshold),
  use the hash C<$Log::Log4perl::Logger::APPENDER_BY_NAME{...}> instead,
  which holds references to all appender wrapper objects.
  
  =head2 Modify appender thresholds
  
  To set an appender's threshold, use its C<threshold()> method:
  
      $app->threshold( $FATAL );
  
  To conveniently adjust I<all> appender thresholds (e.g. because a script
  uses more_logging()), use
  
         # decrease thresholds of all appenders
      Log::Log4perl->appender_thresholds_adjust(-1);
  
  This will decrease the thresholds of all appenders in the system by
  one level, i.e. WARN becomes INFO, INFO becomes DEBUG, etc. To only modify 
  selected ones, use
  
         # decrease thresholds of selected appenders
      Log::Log4perl->appender_thresholds_adjust(-1, ['AppName1', ...]);
  
  and pass the names of affected appenders in a ref to an array.
  
  =head1 Advanced configuration within Perl
  
  Initializing Log::Log4perl can certainly also be done from within Perl.
  At last, this is what C<Log::Log4perl::Config> does behind the scenes.
  Log::Log4perl's configuration file parsers are using a publically 
  available API to set up Log::Log4perl's categories, appenders and layouts.
  
  Here's an example on how to configure two appenders with the same layout
  in Perl, without using a configuration file at all:
  
    ########################
    # Initialization section
    ########################
    use Log::Log4perl;
    use Log::Log4perl::Layout;
    use Log::Log4perl::Level;
  
       # Define a category logger
    my $log = Log::Log4perl->get_logger("Foo::Bar");
  
       # Define a layout
    my $layout = Log::Log4perl::Layout::PatternLayout->new("[%r] %F %L %m%n");
  
       # Define a file appender
    my $file_appender = Log::Log4perl::Appender->new(
                            "Log::Log4perl::Appender::File",
                            name      => "filelog",
                            filename  => "/tmp/my.log");
  
       # Define a stdout appender
    my $stdout_appender =  Log::Log4perl::Appender->new(
                            "Log::Log4perl::Appender::Screen",
                            name      => "screenlog",
                            stderr    => 0);
  
       # Define a mixed stderr/stdout appender
    my $mixed_stdout_stderr_appender = Log::Log4perl::Appender->new(
                            "Log::Log4perl::Appender::Screen",
                            name      => "screenlog",
                            stderr    => { ERROR => 1, FATAL => 1 });
  
       # Have both appenders use the same layout (could be different)
    $stdout_appender->layout($layout);
    $file_appender->layout($layout);
  
    $log->add_appender($stdout_appender);
    $log->add_appender($file_appender);
    $log->level($INFO);
  
  Please note the class of the appender object is passed as a I<string> to
  C<Log::Log4perl::Appender> in the I<first> argument. Behind the scenes,
  C<Log::Log4perl::Appender> will create the necessary
  C<Log::Log4perl::Appender::*> (or C<Log::Dispatch::*>) object and pass
  along the name value pairs we provided to
  C<Log::Log4perl::Appender-E<gt>new()> after the first argument.
  
  The C<name> value is optional and if you don't provide one,
  C<Log::Log4perl::Appender-E<gt>new()> will create a unique one for you.
  The names and values of additional parameters are dependent on the requirements
  of the particular appender class and can be looked up in their
  manual pages.
  
  A side note: In case you're wondering if
  C<Log::Log4perl::Appender-E<gt>new()> will also take care of the
  C<min_level> argument to the C<Log::Dispatch::*> constructors called
  behind the scenes -- yes, it does. This is because we want the
  C<Log::Dispatch> objects to blindly log everything we send them
  (C<debug> is their lowest setting) because I<we> in C<Log::Log4perl>
  want to call the shots and decide on when and what to log.
  
  The call to the appender's I<layout()> method specifies the format (as a
  previously created C<Log::Log4perl::Layout::PatternLayout> object) in which the
  message is being logged in the specified appender. 
  If you don't specify a layout, the logger will fall back to
  C<Log::Log4perl::SimpleLayout>, which logs the debug level, a hyphen (-)
  and the log message.
  
  Layouts are objects, here's how you create them:
  
          # Create a simple layout
      my $simple = Log::Log4perl::SimpleLayout();
  
          # create a flexible layout:
          # ("yyyy/MM/dd hh:mm:ss (file:lineno)> message\n")
      my $pattern = Log::Log4perl::Layout::PatternLayout("%d (%F:%L)> %m%n");
  
  Every appender has exactly one layout assigned to it. You assign
  the layout to the appender using the appender's C<layout()> object:
  
      my $app =  Log::Log4perl::Appender->new(
                    "Log::Log4perl::Appender::Screen",
                    name      => "screenlog",
                    stderr    => 0);
  
          # Assign the previously defined flexible layout
      $app->layout($pattern);
  
          # Add the appender to a previously defined logger
      $logger->add_appender($app);
  
          # ... and you're good to go!
      $logger->debug("Blah");
          # => "2002/07/10 23:55:35 (test.pl:207)> Blah\n"
  
  It's also possible to remove appenders from a logger:
  
      $logger->remove_appender($appender_name);
  
  will remove an appender, specified by name, from a given logger. 
  Please note that this does
  I<not> remove an appender from the system.
  
  To eradicate an appender from the system, 
  you need to call C<Log::Log4perl-E<gt>eradicate_appender($appender_name)>
  which will first remove the appender from every logger in the system
  and then will delete all references Log4perl holds to it.
  
  To remove a logger from the system, use 
  C<Log::Log4perl-E<gt>remove_logger($logger)>. After the remaining 
  reference C<$logger> goes away, the logger will self-destruct. If the
  logger in question is a stealth logger, all of its convenience shortcuts
  (DEBUG, INFO, etc) will turn into no-ops.
  
  =head1 How about Log::Dispatch::Config?
  
  Tatsuhiko Miyagawa's C<Log::Dispatch::Config> is a very clever 
  simplified logger implementation, covering some of the I<log4j>
  functionality. Among the things that 
  C<Log::Log4perl> can but C<Log::Dispatch::Config> can't are:
  
  =over 4
  
  =item *
  
  You can't assign categories to loggers. For small systems that's fine,
  but if you can't turn off and on detailed logging in only a tiny
  subsystem of your environment, you're missing out on a majorly
  useful log4j feature.
  
  =item *
  
  Defining appender thresholds. Important if you want to solve problems like
  "log all messages of level FATAL to STDERR, plus log all DEBUG
  messages in C<Foo::Bar> to a log file". If you don't have appenders
  thresholds, there's no way to prevent cluttering STDERR with DEBUG messages.
  
  =item *
  
  PatternLayout specifications in accordance with the standard
  (e.g. "%d{HH:mm}").
  
  =back
  
  Bottom line: Log::Dispatch::Config is fine for small systems with
  simple logging requirements. However, if you're
  designing a system with lots of subsystems which you need to control
  independently, you'll love the features of C<Log::Log4perl>,
  which is equally easy to use.
  
  =head1 Using Log::Log4perl with wrapper functions and classes
  
  If you don't use C<Log::Log4perl> as described above, 
  but from a wrapper function, the pattern layout will generate wrong data 
  for %F, %C, %L, and the like. Reason for this is that C<Log::Log4perl>'s 
  loggers assume a static caller depth to the application that's using them. 
  
  If you're using
  one (or more) wrapper functions, C<Log::Log4perl> will indicate where
  your logger function called the loggers, not where your application
  called your wrapper:
  
      use Log::Log4perl qw(:easy);
      Log::Log4perl->easy_init({ level => $DEBUG, 
                                 layout => "%M %m%n" });
  
      sub mylog {
          my($message) = @_;
  
          DEBUG $message;
      }
  
      sub func {
          mylog "Hello";
      }
  
      func();
  
  prints
  
      main::mylog Hello
  
  but that's probably not what your application expects. Rather, you'd
  want
  
      main::func Hello
  
  because the C<func> function called your logging function.
  
  But don't despair, there's a solution: Just register your wrapper
  package with Log4perl beforehand. If Log4perl then finds that it's being 
  called from a registered wrapper, it will automatically step up to the
  next call frame.
  
      Log::Log4perl->wrapper_register(__PACKAGE__);
  
      sub mylog {
          my($message) = @_;
  
          DEBUG $message;
      }
  
  Alternatively, you can increase the value of the global variable
  C<$Log::Log4perl::caller_depth> (defaults to 0) by one for every
  wrapper that's in between your application and C<Log::Log4perl>,
  then C<Log::Log4perl> will compensate for the difference:
  
      sub mylog {
          my($message) = @_;
  
          local $Log::Log4perl::caller_depth =
                $Log::Log4perl::caller_depth + 1;
          DEBUG $message;
      }
  
  Also, note that if you're writing a subclass of Log4perl, like
  
      package MyL4pWrapper;
      use Log::Log4perl;
      our @ISA = qw(Log::Log4perl);
  
  and you want to call get_logger() in your code, like
  
      use MyL4pWrapper;
  
      sub get_logger {
          my $logger = Log::Log4perl->get_logger();
      }
  
  then the get_logger() call will get a logger for the C<MyL4pWrapper>
  category, not for the package calling the wrapper class as in
  
      package UserPackage;
      my $logger = MyL4pWrapper->get_logger();
  
  To have the above call to get_logger return a logger for the 
  "UserPackage" category, you need to tell Log4perl that "MyL4pWrapper"
  is a Log4perl wrapper class:
  
      use MyL4pWrapper;
      Log::Log4perl->wrapper_register(__PACKAGE__);
  
      sub get_logger {
            # Now gets a logger for the category of the calling package
          my $logger = Log::Log4perl->get_logger();
      }
  
  This feature works both for Log4perl-relaying classes like the wrapper
  described above, and for wrappers that inherit from Log4perl use Log4perl's
  get_logger function via inheritance, alike.
  
  =head1 Access to Internals
  
  The following methods are only of use if you want to peek/poke in
  the internals of Log::Log4perl. Be careful not to disrupt its
  inner workings.
  
  =over 4
  
  =item C<< Log::Log4perl->appenders() >>
  
  To find out which appenders are currently defined (not only
  for a particular logger, but overall), a C<appenders()>
  method is available to return a reference to a hash mapping appender
  names to their Log::Log4perl::Appender object references.
  
  =back
  
  =head1 Dirty Tricks
  
  =over 4
  
  =item infiltrate_lwp()
  
  The famous LWP::UserAgent module isn't Log::Log4perl-enabled. Often, though,
  especially when tracing Web-related problems, it would be helpful to get
  some insight on what's happening inside LWP::UserAgent. Ideally, LWP::UserAgent
  would even play along in the Log::Log4perl framework.
  
  A call to C<Log::Log4perl-E<gt>infiltrate_lwp()> does exactly this. 
  In a very rude way, it pulls the rug from under LWP::UserAgent and transforms
  its C<debug/conn> messages into C<debug()> calls of loggers of the category
  C<"LWP::UserAgent">. Similarily, C<LWP::UserAgent>'s C<trace> messages 
  are turned into C<Log::Log4perl>'s C<info()> method calls. Note that this
  only works for LWP::UserAgent versions E<lt> 5.822, because this (and
  probably later) versions miss debugging functions entirely.
  
  =item Suppressing 'duplicate' LOGDIE messages
  
  If a script with a simple Log4perl configuration uses logdie() to catch
  errors and stop processing, as in 
  
      use Log::Log4perl qw(:easy) ;
      Log::Log4perl->easy_init($DEBUG);
      
      shaky_function() or LOGDIE "It failed!";
  
  there's a cosmetic problem: The message gets printed twice:
  
      2005/07/10 18:37:14 It failed!
      It failed! at ./t line 12
  
  The obvious solution is to use LOGEXIT() instead of LOGDIE(), but there's
  also a special tag for Log4perl that suppresses the second message:
  
      use Log::Log4perl qw(:no_extra_logdie_message);
  
  This causes logdie() and logcroak() to call exit() instead of die(). To
  modify the script exit code in these occasions, set the variable
  C<$Log::Log4perl::LOGEXIT_CODE> to the desired value, the default is 1.
  
  =item Redefine values without causing errors
  
  Log4perl's configuration file parser has a few basic safety mechanisms to 
  make sure configurations are more or less sane. 
  
  One of these safety measures is catching redefined values. For example, if
  you first write
  
      log4perl.category = WARN, Logfile
  
  and then a couple of lines later
  
      log4perl.category = TRACE, Logfile
  
  then you might have unintentionally overwritten the first value and Log4perl
  will die on this with an error (suspicious configurations always throw an
  error). Now, there's a chance that this is intentional, for example when
  you're lumping together several configuration files and actually I<want>
  the first value to overwrite the second. In this case use
  
      use Log::Log4perl qw(:nostrict);
  
  to put Log4perl in a more permissive mode.
  
  =item Prevent croak/confess from stringifying
  
  The logcroak/logconfess functions stringify their arguments before
  they pass them to Carp's croak/confess functions. This can get in the
  way if you want to throw an object or a hashref as an exception, in
  this case use:
  
      $Log::Log4perl::STRINGIFY_DIE_MESSAGE = 0;
  
      eval {
            # throws { foo => "bar" }
            # without stringification
          $logger->logcroak( { foo => "bar" } );
      };
  
  =back
  
  =head1 EXAMPLE
  
  A simple example to cut-and-paste and get started:
  
      use Log::Log4perl qw(get_logger);
      
      my $conf = q(
      log4perl.category.Bar.Twix         = WARN, Logfile
      log4perl.appender.Logfile          = Log::Log4perl::Appender::File
      log4perl.appender.Logfile.filename = test.log
      log4perl.appender.Logfile.layout = \
          Log::Log4perl::Layout::PatternLayout
      log4perl.appender.Logfile.layout.ConversionPattern = %d %F{1} %L> %m %n
      );
      
      Log::Log4perl::init(\$conf);
      
      my $logger = get_logger("Bar::Twix");
      $logger->error("Blah");
  
  This will log something like
  
      2002/09/19 23:48:15 t1 25> Blah 
  
  to the log file C<test.log>, which Log4perl will append to or 
  create it if it doesn't exist already.
  
  =head1 INSTALLATION
  
  If you want to use external appenders provided with C<Log::Dispatch>,
  you need to install C<Log::Dispatch> (2.00 or better) from CPAN,
  which itself depends on C<Attribute-Handlers> and
  C<Params-Validate>. And a lot of other modules, that's the reason
  why we're now shipping Log::Log4perl with its own standard appenders
  and only if you wish to use additional ones, you'll have to go through
  the C<Log::Dispatch> installation process.
  
  Log::Log4perl needs C<Test::More>, C<Test::Harness> and C<File::Spec>, 
  but they already come with fairly recent versions of perl.
  If not, everything's automatically fetched from CPAN if you're using the CPAN 
  shell (CPAN.pm), because they're listed as dependencies.
  
  C<Time::HiRes> (1.20 or better) is required only if you need the
  fine-grained time stamps of the C<%r> parameter in
  C<Log::Log4perl::Layout::PatternLayout>.
  
  Manual installation works as usual with
  
      perl Makefile.PL
      make
      make test
      make install
  
  =head1 DEVELOPMENT
  
  Log::Log4perl is still being actively developed. We will
  always make sure the test suite (approx. 500 cases) will pass, but there 
  might still be bugs. please check L<http://github.com/mschilli/log4perl>
  for the latest release. The api has reached a mature state, we will 
  not change it unless for a good reason.
  
  Bug reports and feedback are always welcome, just email them to our 
  mailing list shown in the AUTHORS section. We're usually addressing
  them immediately.
  
  =head1 REFERENCES
  
  =over 4
  
  =item [1]
  
  Michael Schilli, "Retire your debugger, log smartly with Log::Log4perl!",
  Tutorial on perl.com, 09/2002, 
  L<http://www.perl.com/pub/a/2002/09/11/log4perl.html>
  
  =item [2]
  
  Ceki Glc, "Short introduction to log4j",
  L<http://logging.apache.org/log4j/1.2/manual.html>
  
  =item [3]
  
  Vipan Singla, "Don't Use System.out.println! Use Log4j.",
  L<http://www.vipan.com/htdocs/log4jhelp.html>
  
  =item [4]
  
  The Log::Log4perl project home page: L<http://log4perl.com>
  
  =back
  
  =head1 SEE ALSO
  
  L<Log::Log4perl::Config|Log::Log4perl::Config>,
  L<Log::Log4perl::Appender|Log::Log4perl::Appender>,
  L<Log::Log4perl::Layout::PatternLayout|Log::Log4perl::Layout::PatternLayout>,
  L<Log::Log4perl::Layout::SimpleLayout|Log::Log4perl::Layout::SimpleLayout>,
  L<Log::Log4perl::Level|Log::Log4perl::Level>,
  L<Log::Log4perl::JavaMap|Log::Log4perl::JavaMap>
  L<Log::Log4perl::NDC|Log::Log4perl::NDC>,
  
  =head1 AUTHORS
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier, David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
LOG_LOG4PERL

$fatpacked{"Log/Log4perl/Appender.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER';
  ##################################################
  package Log::Log4perl::Appender;
  ##################################################
  
  use 5.006;
  use strict;
  use warnings;
  
  use Log::Log4perl::Level;
  use Carp;
  
  use constant _INTERNAL_DEBUG => 0;
  
  our $unique_counter = 0;
  
  ##################################################
  sub reset {
  ##################################################
      $unique_counter = 0;
  }
  
  ##################################################
  sub unique_name {
  ##################################################
          # THREADS: Need to lock here to make it thread safe
      $unique_counter++;
      my $unique_name = sprintf("app%03d", $unique_counter);
          # THREADS: Need to unlock here to make it thread safe
      return $unique_name;
  }
  
  ##################################################
  sub new {
  ##################################################
      my($class, $appenderclass, %params) = @_;
  
          # Pull in the specified Log::Log4perl::Appender object
      eval {
  
             # Eval erroneously succeeds on unknown appender classes if
             # the eval string just consists of valid perl code (e.g. an
             # appended ';' in $appenderclass variable). Fail if we see
             # anything in there that can't be class name.
          die "'$appenderclass' not a valid class name " if 
              $appenderclass =~ /[^:\w]/;
  
          # Check if the class/package is already available because
          # something like Class::Prototyped injected it previously.
  
          # Use UNIVERSAL::can to check the appender's new() method
          # [RT 28987]
          if( ! $appenderclass->can('new') ) {
              # Not available yet, try to pull it in.
              # see 'perldoc -f require' for why two evals
              eval "require $appenderclass";
                   #unless ${$appenderclass.'::IS_LOADED'};  #for unit tests, 
                                                            #see 004Config
              die $@ if $@;
          }
      };
  
      $@ and die "ERROR: can't load appenderclass '$appenderclass'\n$@";
      print "Appender class $appenderclass loaded OK ($@)\n" if _INTERNAL_DEBUG;
  
      $params{name} = unique_name() unless exists $params{name};
  
      # If it's a Log::Dispatch::File appender, default to append 
      # mode (Log::Dispatch::File defaults to 'clobber') -- consensus 9/2002
      # (Log::Log4perl::Appender::File already defaults to 'append')
      if ($appenderclass eq 'Log::Dispatch::File' &&
          ! exists $params{mode}) {
          $params{mode} = 'append';
      }
  
      print "Calling $appenderclass new\n" if _INTERNAL_DEBUG;
  
      my $appender = $appenderclass->new(
              # Set min_level to the lowest setting. *we* are 
              # controlling this now, the appender should just
              # log it with no questions asked.
          min_level => 'debug',
              # Set 'name' and other parameters
          map { $_ => $params{$_} } keys %params,
      );
  
      print "Calling $appenderclass new returned OK\n" if _INTERNAL_DEBUG;
  
      my $self = {
                   appender  => $appender,
                   name      => $params{name},
                   layout    => undef,
                   level     => $ALL,
                   composite => 0,
                 };
  
          #whether to collapse arrays, etc.
      $self->{warp_message} = $params{warp_message};
  
      if (!$INC{'Log/Log4perl/Config.pm'}) {
          require Log::Log4perl::Config;
      }
  
      if($self->{warp_message} and
         my $cref = 
         Log::Log4perl::Config::compile_if_perl($self->{warp_message})) {
          $self->{warp_message} = $cref;
      }
      
      bless $self, $class;
  
      return $self;
  }
  
  ##################################################
  sub composite { # Set/Get the composite flag
  ##################################################
      my ($self, $flag) = @_;
  
      $self->{composite} = $flag if defined $flag;
      return $self->{composite};
  }
  
  ##################################################
  sub threshold { # Set/Get the appender threshold
  ##################################################
      my ($self, $level) = @_;
  
      print "Setting threshold to $level\n" if _INTERNAL_DEBUG;
  
      if(defined $level) {
          # Checking for \d makes for a faster regex(p)
          $self->{level} = ($level =~ /^(\d+)$/) ? $level :
              # Take advantage of &to_priority's error reporting
              Log::Log4perl::Level::to_priority($level);
      }
  
      return $self->{level};
  }
  
  ##################################################
  sub log { 
  ##################################################
  # Relay this call to Log::Log4perl::Appender:* or
  # Log::Dispatch::*
  ##################################################
      my ($self, $p, $category, $level, $cache) = @_;
  
      # Check if the appender has a last-minute veto in form
      # of an "appender threshold"
      if($self->{level} > $
                          Log::Log4perl::Level::PRIORITY{$level}) {
          print "$self->{level} > $level, aborting\n" if _INTERNAL_DEBUG;
          return undef;
      }
  
      # Run against the (yes only one) customized filter (which in turn
      # might call other filters via the Boolean filter) and check if its
      # ok() method approves the message or blocks it.
      if($self->{filter}) {
          if($self->{filter}->ok(%$p,
                                 log4p_category => $category,
                                 log4p_level    => $level )) {
              print "Filter $self->{filter}->{name} passes\n" if _INTERNAL_DEBUG;
          } else {
              print "Filter $self->{filter}->{name} blocks\n" if _INTERNAL_DEBUG;
              return undef;
          }
      }
  
      unless($self->composite()) {
  
              #not defined, the normal case
          if (! defined $self->{warp_message} ){
                  #join any message elements
              if (ref $p->{message} eq "ARRAY") {
                  for my $i (0..$#{$p->{message}}) {
                      if( !defined $p->{message}->[ $i ] ) {
                          local $Carp::CarpLevel =
                          $Carp::CarpLevel + $Log::Log4perl::caller_depth + 1;
                          carp "Warning: Log message argument #" . 
                               ($i+1) . " undefined";
                      }
                  }
                  $p->{message} = 
                      join($Log::Log4perl::JOIN_MSG_ARRAY_CHAR, 
                           @{$p->{message}} 
                           );
              }
              
              #defined but false, e.g. Appender::DBI
          } elsif (! $self->{warp_message}) {
              ;  #leave the message alone
      
          } elsif (ref($self->{warp_message}) eq "CODE") {
              #defined and a subref
              $p->{message} = 
                  [$self->{warp_message}->(@{$p->{message}})];
          } else {
              #defined and a function name?
              no strict qw(refs);
              $p->{message} = 
                  [$self->{warp_message}->(@{$p->{message}})];
          }
  
          $p->{message} = $self->{layout}->render($p->{message}, 
              $category,
              $level,
              3 + $Log::Log4perl::caller_depth,
          ) if $self->layout();
      }
  
      my $args = [%$p, log4p_category => $category, log4p_level => $level];
  
      if(defined $cache) {
          $$cache = $args;
      } else {
          $self->{appender}->log(@$args);
      }
  
      return 1;
  }
  
  ###########################################
  sub log_cached {
  ###########################################
      my ($self, $cache) = @_;
  
      $self->{appender}->log(@$cache);
  }
  
  ##################################################
  sub name { # Set/Get the name
  ##################################################
      my($self, $name) = @_;
  
          # Somebody wants to *set* the name?
      if($name) {
          $self->{name} = $name;
      }
  
      return $self->{name};
  }
  
  ###########################################
  sub layout { # Set/Get the layout object
               # associated with this appender
  ###########################################
      my($self, $layout) = @_;
  
          # Somebody wants to *set* the layout?
      if($layout) {
          $self->{layout} = $layout;
  
          # somebody wants a layout, but not set yet, so give 'em default
      }elsif (! $self->{layout}) {
          $self->{layout} = Log::Log4perl::Layout::SimpleLayout
                                                  ->new($self->{name});
  
      }
  
      return $self->{layout};
  }
  
  ##################################################
  sub filter { # Set filter
  ##################################################
      my ($self, $filter) = @_;
  
      if($filter) {
          print "Setting filter to $filter->{name}\n" if _INTERNAL_DEBUG;
          $self->{filter} = $filter;
      }
  
      return $self->{filter};
  }
  
  ##################################################
  sub AUTOLOAD { 
  ##################################################
  # Relay everything else to the underlying 
  # Log::Log4perl::Appender::* or Log::Dispatch::*
  #  object
  ##################################################
      my $self = shift;
  
      no strict qw(vars);
  
      $AUTOLOAD =~ s/.*:://;
  
      if(! defined $self->{appender}) {
          die "Can't locate object method $AUTOLOAD() in ", __PACKAGE__;
      }
  
      return $self->{appender}->$AUTOLOAD(@_);
  }
  
  ##################################################
  sub DESTROY {
  ##################################################
      foreach my $key (keys %{$_[0]}) {
          # print "deleting $key\n";
          delete $_[0]->{$key};
      }
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Appender - Log appender class
  
  =head1 SYNOPSIS
  
    use Log::Log4perl;
  
        # Define a logger
    my $logger = Log::Log4perl->get_logger("abc.def.ghi");
  
        # Define a layout
    my $layout = Log::Log4perl::Layout::PatternLayout->new(
                     "%d (%F:%L)> %m");
  
        # Define an appender
    my $appender = Log::Log4perl::Appender->new(
                     "Log::Log4perl::Appender::Screen",
                     name => 'dumpy');
  
        # Set the appender's layout
    $appender->layout($layout);
    $logger->add_appender($appender);
  
  =head1 DESCRIPTION
  
  This class is a wrapper around the C<Log::Log4perl::Appender>
  appender set. 
  
  It also supports the <Log::Dispatch::*> collections of appenders. The
  module hides the idiosyncrasies of C<Log::Dispatch> (e.g. every
  dispatcher gotta have a name, but there's no accessor to retrieve it)
  from C<Log::Log4perl> and yet re-uses the extremely useful variety of
  dispatchers already created and tested in C<Log::Dispatch>.
  
  =head1 FUNCTIONS
  
  =head2 Log::Log4perl::Appender->new($dispatcher_class_name, ...);
  
  The constructor C<new()> takes the name of the appender
  class to be created as a I<string> (!) argument, optionally followed by 
  a number of appender-specific parameters,
  for example:
  
        # Define an appender
    my $appender = Log::Log4perl::Appender->new(
        "Log::Log4perl::Appender::File"
        filename => 'out.log');
  
  In case of C<Log::Dispatch> appenders,
  if no C<name> parameter is specified, the appender object will create
  a unique one (format C<appNNN>), which can be retrieved later via
  the C<name()> method:
  
    print "The appender's name is ", $appender->name(), "\n";
  
  Other parameters are specific to the appender class being used.
  In the case above, the C<filename> parameter specifies the name of 
  the C<Log::Log4perl::Appender::File> dispatcher used. 
  
  However, if, for instance, 
  you're using a C<Log::Dispatch::Email> dispatcher to send you 
  email, you'll have to specify C<from> and C<to> email addresses.
  Every dispatcher is different.
  Please check the C<Log::Dispatch::*> documentation for the appender used
  for details on specific requirements.
  
  The C<new()> method will just pass these parameters on to a newly created
  C<Log::Dispatch::*> object of the specified type.
  
  When it comes to logging, the C<Log::Log4perl::Appender> will transparently
  relay all messages to the C<Log::Dispatch::*> object it carries 
  in its womb.
  
  =head2 $appender->layout($layout);
  
  The C<layout()> method sets the log layout
  used by the appender to the format specified by the 
  C<Log::Log4perl::Layout::*> object which is passed to it as a reference.
  Currently there's two layouts available:
  
      Log::Log4perl::Layout::SimpleLayout
      Log::Log4perl::Layout::PatternLayout
  
  Please check the L<Log::Log4perl::Layout::SimpleLayout> and 
  L<Log::Log4perl::Layout::PatternLayout> manual pages for details.
  
  =head1 Supported Appenders 
  
  Here's the list of appender modules currently available via C<Log::Dispatch>,
  if not noted otherwise, written by Dave Rolsky:
  
         Log::Dispatch::ApacheLog
         Log::Dispatch::DBI (by Tatsuhiko Miyagawa)
         Log::Dispatch::Email,
         Log::Dispatch::Email::MailSend,
         Log::Dispatch::Email::MailSendmail,
         Log::Dispatch::Email::MIMELite
         Log::Dispatch::File
         Log::Dispatch::FileRotate (by Mark Pfeiffer)
         Log::Dispatch::Handle
         Log::Dispatch::Screen
         Log::Dispatch::Syslog
         Log::Dispatch::Tk (by Dominique Dumont)
  
  C<Log4perl> doesn't care which ones you use, they're all handled in 
  the same way via the C<Log::Log4perl::Appender> interface.
  Please check the well-written manual pages of the 
  C<Log::Dispatch> hierarchy on how to use each one of them.
  
  =head1 Parameters passed on to the appender's log() method
  
  When calling the appender's log()-Funktion, Log::Log4perl will 
  submit a list of key/value pairs. Entries to the following keys are
  guaranteed to be present:
  
  =over 4
  
  =item message
  
  Text of the rendered message
  
  =item log4p_category
  
  Name of the category of the logger that triggered the event.
  
  =item log4p_level
  
  Log::Log4perl level of the event
  
  =back
  
  =head1 Pitfalls
  
  Since the C<Log::Dispatch::File> appender truncates log files by default,
  and most of the time this is I<not> what you want, we've instructed 
  C<Log::Log4perl> to change this behavior by slipping it the 
  C<mode =E<gt> append> parameter behind the scenes. So, effectively
  with C<Log::Log4perl> 0.23, a configuration like
  
      log4perl.category = INFO, FileAppndr
      log4perl.appender.FileAppndr          = Log::Dispatch::File
      log4perl.appender.FileAppndr.filename = test.log
      log4perl.appender.FileAppndr.layout   = Log::Log4perl::Layout::SimpleLayout
  
  will always I<append> to an existing logfile C<test.log> while if you 
  specifically request clobbering like in
  
      log4perl.category = INFO, FileAppndr
      log4perl.appender.FileAppndr          = Log::Dispatch::File
      log4perl.appender.FileAppndr.filename = test.log
      log4perl.appender.FileAppndr.mode     = write
      log4perl.appender.FileAppndr.layout   = Log::Log4perl::Layout::SimpleLayout
  
  it will overwrite an existing log file C<test.log> and start from scratch.
  
  =head1 Appenders Expecting Message Chunks
  
  Instead of simple strings, certain appenders are expecting multiple fields
  as log messages. If a statement like 
  
      $logger->debug($ip, $user, "signed in");
  
  causes an off-the-shelf C<Log::Log4perl::Appender::Screen> 
  appender to fire, the appender will 
  just concatenate the three message chunks passed to it
  in order to form a single string.
  The chunks will be separated by a string defined in 
  C<$Log::Log4perl::JOIN_MSG_ARRAY_CHAR> (defaults to the empty string
  ""). 
  
  However, different appenders might choose to 
  interpret the message above differently: An
  appender like C<Log::Log4perl::Appender::DBI> might take the
  three arguments passed to the logger and put them in three separate
  rows into the DB.
  
  The  C<warp_message> appender option is used to specify the desired 
  behavior.
  If no setting for the appender property
  
      # *** Not defined ***
      # log4perl.appender.SomeApp.warp_message
  
  is defined in the Log4perl configuration file, the
  appender referenced by C<SomeApp> will fall back to the standard behavior
  and join all message chunks together, separating them by
  C<$Log::Log4perl::JOIN_MSG_ARRAY_CHAR>.
  
  If, on the other hand, it is set to a false value, like in
  
      log4perl.appender.SomeApp.layout=NoopLayout
      log4perl.appender.SomeApp.warp_message = 0
  
  then the message chunks are passed unmodified to the appender as an
  array reference. Please note that you need to set the appender's
  layout to C<Log::Log4perl::Layout::NoopLayout> which just leaves 
  the messages chunks alone instead of formatting them or replacing
  conversion specifiers.
  
  B<Please note that the standard appenders in the Log::Dispatch hierarchy
  will choke on a bunch of messages passed to them as an array reference. 
  You can't use C<warp_message = 0> (or the function name syntax
  defined below) on them.
  Only special appenders like Log::Log4perl::Appender::DBI can deal with
  this.>
  
  If (and now we're getting fancy)
  an appender expects message chunks, but we would 
  like to pre-inspect and probably modify them before they're 
  actually passed to the appender's C<log>
  method, an inspection subroutine can be defined with the
  appender's C<warp_message> property:
  
      log4perl.appender.SomeApp.layout=NoopLayout
      log4perl.appender.SomeApp.warp_message = sub { \
                                             $#_ = 2 if @_ > 3; \
                                             return @_; }
  
  The inspection subroutine defined by the C<warp_message> 
  property will receive the list of message chunks, like they were
  passed to the logger and is expected to return a corrected list.
  The example above simply limits the argument list to a maximum of
  three by cutting off excess elements and returning the shortened list.
  
  Also, the warp function can be specified by name like in
  
      log4perl.appender.SomeApp.layout=NoopLayout
      log4perl.appender.SomeApp.warp_message = main::filter_my_message
  
  In this example,
  C<filter_my_message> is a function in the C<main> package, 
  defined like this:
  
      my $COUNTER = 0;
  
      sub filter_my_message {
          my @chunks = @_;
          unshift @chunks, ++$COUNTER;
          return @chunks;
      }
  
  The subroutine above will add an ever increasing counter
  as an additional first field to 
  every message passed to the C<SomeApp> appender -- but not to
  any other appender in the system.
  
  =head2 Composite Appenders
  
  Composite appenders relay their messages to sub-appenders after providing
  some filtering or synchronizing functionality on incoming messages. 
  Examples are 
  Log::Log4perl::Appender::Synchronized,
  Log::Log4perl::Appender::Limit, and
  Log::Log4perl::Appender::Buffer. Check their manual pages for details.
  
  Composite appender objects are regular Log::Log4perl::Appender objects, 
  but they have the composite flag set:
  
      $app->composite(1);
  
  and they define a post_init() method, which sets the appender it relays
  its messages to:
  
      ###########################################
      sub post_init {
      ############################################
          my($self) = @_;
      
          if(! exists $self->{appender}) {
              die "No appender defined for " . __PACKAGE__;
          }
      
          my $appenders = Log::Log4perl->appenders();
          my $appender = Log::Log4perl->appenders()->{$self->{appender}};
      
          if(! defined $appender) {
              die "Appender $self->{appender} not defined (yet) when " .
                  __PACKAGE__ . " needed it";
          }
      
          $self->{app} = $appender;
      }
  
  The reason for this post-processing step is that the relay appender
  might not be defined yet when the composite appender gets defined.
  This can happen if Log4perl is initialized with a configuration file
  (which is the most common way to initialize Log4perl), because
  appenders spring into existence in unpredictable order.
  
  For example, if you define a Synchronized appender like
  
      log4perl.appender.Syncer            = Log::Log4perl::Appender::Synchronized
      log4perl.appender.Syncer.appender   = Logfile
  
  then Log4perl will set the appender's C<appender> attribute to the
  I<name> of the appender to finally relay messages to. After the
  Log4perl configuration file has been processed, Log4perl will remember to 
  call the composite appender's post_init() method, which will grab
  the relay appender instance referred to by the name (Logfile) 
  and set it in its C<app> attribute. This is exactly what the
  code snippet above does.
  
  But if you initialize Log4perl by its API, you need to remember to
  perform these steps. Here's the lineup:
  
      use Log::Log4perl qw(get_logger :levels);
      
      my $fileApp = Log::Log4perl::Appender->new(
      		'Log::Log4perl::Appender::File',
      		name     => 'MyFileApp',
      		filename => 'mylog',
      		mode     => 'append',
      		);
      $fileApp->layout(
      		Log::Log4perl::Layout::PatternLayout::Multiline->new(
      			'%d{yyyy-MM-dd HH:mm:ss} %p [%c] #%P> %m%n')
      		);
        # Make the appender known to the system (without assigning it to
        # any logger
      Log::Log4perl->add_appender( $fileApp );
      
      my $syncApp = Log::Log4perl::Appender->new(
      		'Log::Log4perl::Appender::Synchronized',
      		name       => 'MySyncApp',
      		appender   => 'MyFileApp',
      		key        => 'nem',
      		);
      $syncApp->post_init();
      $syncApp->composite(1);
  
        # The Synchronized appender is now ready, assign it to a logger
        # and start logging.
      get_logger("")->add_appender($syncApp);
  
      get_logger("")->level($DEBUG);
      get_logger("wonk")->debug("waah!");
  
  The composite appender's log() function will typically cache incoming 
  messages until a certain trigger condition is met and then forward a bulk
  of messages to the relay appender.
  
  Caching messages is surprisingly tricky, because you want them to look
  like they came from the code location they were originally issued from
  and not from the location that triggers the flush. Luckily, Log4perl
  offers a cache mechanism for messages, all you need to do is call the
  base class' log() function with an additional reference to a scalar,
  and then save its content to your composite appender's message buffer
  afterwards:
  
      ###########################################
      sub log {
      ###########################################
          my($self, %params) = @_;
  
          # ... some logic to decide whether to cache or flush
  
              # Adjust the caller stack
          local $Log::Log4perl::caller_depth =
                $Log::Log4perl::caller_depth + 2;
  
              # We need to cache.
              # Ask the appender to save a cached message in $cache
          $self->{relay_app}->SUPER::log(\%params,
                               $params{log4p_category},
                               $params{log4p_level}, \my $cache);
  
              # Save it in the appender's message buffer
          push @{ $self->{buffer} }, $cache;
      }
  
  Note that before calling the log() method of the relay appender's base class
  (and thus introducing two additional levels on the call stack), we need to
  adjust the call stack to allow Log4perl to render cspecs like the %M or %L
  correctly.  The cache will then contain a correctly rendered message, according
  to the layout of the target appender.
  
  Later, when the time comes to flush the cached messages, a call to the relay
  appender's base class' log_cached() method with the cached message as 
  an argument will forward the correctly rendered message:
  
      ###########################################
      sub log {
      ###########################################
          my($self, %params) = @_;
  
          # ... some logic to decide whether to cache or flush
  
              # Flush pending messages if we have any
          for my $cache (@{$self->{buffer}}) {
              $self->{relay_app}->SUPER::log_cached($cache);
          }
      }
  
  
  =head1 SEE ALSO
  
  Log::Dispatch
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_APPENDER

$fatpacked{"Log/Log4perl/Appender/Buffer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_BUFFER';
  ######################################################################
  # Buffer.pm -- 2004, Mike Schilli <m@perlmeister.com>
  ######################################################################
  # Composite appender buffering messages until a trigger condition is met.
  ######################################################################
  
  ###########################################
  package Log::Log4perl::Appender::Buffer;
  ###########################################
  
  use strict;
  use warnings;
  
  our @ISA = qw(Log::Log4perl::Appender);
  
  our $VERSION    = '1.53';
  
  ###########################################
  sub new {
  ###########################################
      my($class, %options) = @_;
  
      my $self = {
          appender=> undef,
          buffer  => [],
          options => { 
              max_messages  => undef, 
              trigger       => undef,
              trigger_level => undef,
          },
          level   => 0,
          %options,
      };
  
      if($self->{trigger_level}) {
          $self->{trigger} = level_trigger($self->{trigger_level});
      }
  
          # Pass back the appender to be synchronized as a dependency
          # to the configuration file parser
      push @{$options{l4p_depends_on}}, $self->{appender};
  
          # Run our post_init method in the configurator after
          # all appenders have been defined to make sure the
          # appender we're playing 'dam' for really exists
      push @{$options{l4p_post_config_subs}}, sub { $self->post_init() };
  
      bless $self, $class;
  }
  
  ###########################################
  sub log {
  ###########################################
      my($self, %params) = @_;
  
      local $Log::Log4perl::caller_depth =
          $Log::Log4perl::caller_depth + 2;
  
          # Do we need to discard a message because there's already
          # max_size messages in the buffer?
      if(defined $self->{max_messages} and
         @{$self->{buffer}} == $self->{max_messages}) {
          shift @{$self->{buffer}};
      }
          # Ask the appender to save a cached message in $cache
      $self->{app}->SUPER::log(\%params,
                           $params{log4p_category},
                           $params{log4p_level}, \my $cache);
  
          # Save it in the appender's message buffer, but only if
          # it hasn't been suppressed by an appender threshold
      if( defined $cache ) {
          push @{ $self->{buffer} }, $cache;
      }
  
      $self->flush() if $self->{trigger}->($self, \%params);
  }
  
  ###########################################
  sub flush {
  ###########################################
      my($self) = @_;
  
          # Flush pending messages if we have any
      for my $cache (@{$self->{buffer}}) {
          $self->{app}->SUPER::log_cached($cache);
      }
  
          # Empty buffer
      $self->{buffer} = [];
  }
  
  ###########################################
  sub post_init {
  ###########################################
      my($self) = @_;
  
      if(! exists $self->{appender}) {
         die "No appender defined for " . __PACKAGE__;
      }
  
      my $appenders = Log::Log4perl->appenders();
      my $appender = Log::Log4perl->appenders()->{$self->{appender}};
  
      if(! defined $appender) {
         die "Appender $self->{appender} not defined (yet) when " .
             __PACKAGE__ . " needed it";
      }
  
      $self->{app} = $appender;
  }
  
  ###########################################
  sub level_trigger {
  ###########################################
      my($level) = @_;
  
          # closure holding $level
      return sub {
          my($self, $params) = @_;
  
          return Log::Log4perl::Level::to_priority(
                   $params->{log4p_level}) >= 
                 Log::Log4perl::Level::to_priority($level);
      };
  }
      
  ###########################################
  sub DESTROY {
  ###########################################
      my($self) = @_;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Appender::Buffer - Buffering Appender
  
  =head1 SYNOPSIS
  
      use Log::Log4perl qw(:easy);
  
      my $conf = qq(
      log4perl.category                  = DEBUG, Buffer
  
          # Regular Screen Appender
      log4perl.appender.Screen           = Log::Log4perl::Appender::Screen
      log4perl.appender.Screen.stdout    = 1
      log4perl.appender.Screen.layout    = PatternLayout
      log4perl.appender.Screen.layout.ConversionPattern = %d %p %c %m %n
  
          # Buffering appender, using the appender above as outlet
      log4perl.appender.Buffer               = Log::Log4perl::Appender::Buffer
      log4perl.appender.Buffer.appender      = Screen
      log4perl.appender.Buffer.trigger_level = ERROR
      );
  
      Log::Log4perl->init(\$conf);
  
      DEBUG("This message gets buffered.");
      INFO("This message gets buffered also.");
  
      # Time passes. Nothing happens. But then ...
  
      print "It's GO time!!!\n";
  
      ERROR("This message triggers a buffer flush.");
  
  =head1 DESCRIPTION
  
  C<Log::Log4perl::Appender::Buffer> takes these arguments:
  
  =over 4
  
  =item C<appender>
  
  Specifies the name of the appender it buffers messages for. The
  appender specified must be defined somewhere in the configuration file,
  not necessarily before the definition of 
  C<Log::Log4perl::Appender::Buffer>.
  
  =item C<max_messages>
  
  Specifies the maximum number of messages the appender will hold in
  its ring buffer. C<max_messages> is optional. By default,
  C<Log::Log4perl::Appender::Buffer> will I<not> limit the number of
  messages buffered. This might be undesirable in long-running processes
  accumulating lots of messages before a flush happens. If
  C<max_messages> is set to a numeric value,
  C<Log::Log4perl::Appender::Buffer> will displace old messages in its
  buffer to make room if the buffer is full.
  
  =item C<trigger_level>
  
  If trigger_level is set to one of Log4perl's levels (see
  Log::Log4perl::Level), a C<trigger> function will be defined internally
  to flush the buffer if a message with a priority of $level or higher
  comes along. This is just a convenience function. Defining
  
      log4perl.appender.Buffer.trigger_level = ERROR
  
  is equivalent to creating a trigger function like
  
      log4perl.appender.Buffer.trigger = sub {   \
          my($self, $params) = @_;               \
          return $params->{log4p_level} >=       \
                 $Log::Log4perl::Level::ERROR; }
  
  See the next section for defining generic trigger functions.
  
  =item C<trigger>
  
  C<trigger> holds a reference to a subroutine, which
  C<Log::Log4perl::Appender::Buffer> will call on every incoming message
  with the same parameters as the appender's C<log()> method:
  
          my($self, $params) = @_;
  
  C<$params> references a hash containing
  the message priority (key C<l4p_level>), the
  message category (key C<l4p_category>) and the content of the message
  (key C<message>).
  
  If the subroutine returns 1, it will trigger a flush of buffered messages.
  
  Shortcut 
  
  =back
  
  =head1 DEVELOPMENT NOTES
  
  C<Log::Log4perl::Appender::Buffer> is a I<composite> appender.
  Unlike other appenders, it doesn't log any messages, it just
  passes them on to its attached sub-appender.
  For this reason, it doesn't need a layout (contrary to regular appenders).
  If it defines none, messages are passed on unaltered.
  
  Custom filters are also applied to the composite appender only.
  They are I<not> applied to the sub-appender. Same applies to appender
  thresholds. This behaviour might change in the future.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_APPENDER_BUFFER

$fatpacked{"Log/Log4perl/Appender/DBI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_DBI';
  package Log::Log4perl::Appender::DBI;
  
  our @ISA = qw(Log::Log4perl::Appender);
  
  use Carp;
  
  use strict;
  use DBI;
  
  sub new {
      my($proto, %p) = @_;
      my $class = ref $proto || $proto;
  
      my $self = bless {}, $class;
  
      $self->_init(%p);
  
      my %defaults = (
          reconnect_attempts => 1,
          reconnect_sleep    => 0,
      );
  
      for (keys %defaults) {
          if(exists $p{$_}) {
              $self->{$_} = $p{$_};
          } else {
              $self->{$_} = $defaults{$_};
          }
      }
  
      #e.g.
      #log4j.appender.DBAppndr.params.1 = %p    
      #log4j.appender.DBAppndr.params.2 = %5.5m
      foreach my $pnum (keys %{$p{params}}){
          $self->{bind_value_layouts}{$pnum} = 
                  Log::Log4perl::Layout::PatternLayout->new({
                     ConversionPattern  => {value  => $p{params}->{$pnum}},
                     undef_column_value => undef,
                  });
      }
      #'bind_value_layouts' now contains a PatternLayout
      #for each parameter heading for the Sql engine
  
      $self->{SQL} = $p{sql}; #save for error msg later on
  
      $self->{MAX_COL_SIZE} = $p{max_col_size};
  
      $self->{BUFFERSIZE} = $p{bufferSize} || 1; 
  
      if ($p{usePreparedStmt}) {
          $self->{sth} = $self->create_statement($p{sql});
          $self->{usePreparedStmt} = 1;
      }else{
          $self->{layout} = Log::Log4perl::Layout::PatternLayout->new({
              ConversionPattern  => {value  => $p{sql}},
              undef_column_value => undef,
          });
      }
  
      if ($self->{usePreparedStmt} &&  $self->{bufferSize}){
          warn "Log4perl: you've defined both usePreparedStmt and bufferSize \n".
          "in your appender '$p{name}'--\n".
          "I'm going to ignore bufferSize and just use a prepared stmt\n";
      }
  
      return $self;
  }
  
  
  sub _init {
      my $self = shift;
      my %params = @_;
  
      if ($params{dbh}) {
          $self->{dbh} = $params{dbh};
      } else {
          $self->{connect} = sub {
              DBI->connect(@params{qw(datasource username password)},
                           {PrintError => 0, $params{attrs} ? %{$params{attrs}} : ()})
                              or croak "Log4perl: $DBI::errstr";
          };
          $self->{dbh} = $self->{connect}->();
          $self->{_mine} = 1;
      }
  }
  
  sub create_statement {
      my ($self, $stmt) = @_;
  
      $stmt || croak "Log4perl: sql not set in Log4perl::Appender::DBI";
  
      return $self->{dbh}->prepare($stmt) || croak "Log4perl: DBI->prepare failed $DBI::errstr\n$stmt";
  
  }
  
  
  sub log {
      my $self = shift;
      my %p = @_;
  
      #%p is
      #    { name    => $appender_name,
      #      level   => loglevel
      #      message => $message,
      #      log4p_category => $category,
      #      log4p_level  => $level,);
      #    },
  
          #getting log4j behavior with no specified ConversionPattern
      chomp $p{message} unless ref $p{message}; 
  
          
      my $qmarks = $self->calculate_bind_values(\%p);
  
  
      if ($self->{usePreparedStmt}) {
  
          $self->query_execute($self->{sth}, @$qmarks);
  
      }else{
  
          #first expand any %x's in the statement
          my $stmt = $self->{layout}->render(
                          $p{message},
                          $p{log4p_category},
                          $p{log4p_level},
                          5 + $Log::Log4perl::caller_depth,  
                          );
  
          push @{$self->{BUFFER}}, $stmt, $qmarks;
  
          $self->check_buffer();
      }
  }
  
  sub query_execute {
      my($self, $sth, @qmarks) = @_;
  
      my $errstr = "[no error]";
  
      for my $attempt (0..$self->{reconnect_attempts}) {
          #warn "Exe: @qmarks"; # TODO
          if(! $sth->execute(@qmarks)) {
  
                    # save errstr because ping() would override it [RT 56145]
                  $errstr = $self->{dbh}->errstr();
  
                  # Exe failed -- was it because we lost the DB
                  # connection?
                  if($self->{dbh}->ping()) {
                      # No, the connection is ok, we failed because there's
                      # something wrong with the execute(): Bad SQL or 
                      # missing parameters or some such). Abort.
                      croak "Log4perl: DBI appender error: '$errstr'";
                  }
  
                  if($attempt == $self->{reconnect_attempts}) {
                      croak "Log4perl: DBI appender failed to " .
                            ($self->{reconnect_attempts} == 1 ? "" : "re") .
                            "connect " .
                            "to database after " .
                            "$self->{reconnect_attempts} attempt" .
                            ($self->{reconnect_attempts} == 1 ? "" : "s") .
                            " (last error error was [$errstr]";
                  }
              if(! $self->{dbh}->ping()) {
                  # Ping failed, try to reconnect
                  if($attempt) {
                      #warn "Sleeping"; # TODO
                      sleep($self->{reconnect_sleep}) if $self->{reconnect_sleep};
                  }
  
                  eval {
                      #warn "Reconnecting to DB"; # TODO
                      $self->{dbh} = $self->{connect}->();
                  };
              }
  
              if ($self->{usePreparedStmt}) {
                  $sth = $self->create_statement($self->{SQL});
                  $self->{sth} = $sth if $self->{sth};
              } else {
                  #warn "Pending stmt: $self->{pending_stmt}"; #TODO
                  $sth = $self->create_statement($self->{pending_stmt});
              }
  
              next;
          }
          return 1;
      }
      croak "Log4perl: DBI->execute failed $errstr, \n".
            "on $self->{SQL}\n @qmarks";
  }
  
  sub calculate_bind_values {
      my ($self, $p) = @_;
  
      my @qmarks;
      my $user_ph_idx = 0;
  
      my $i=0;
      
      if ($self->{bind_value_layouts}) {
  
          my $prev_pnum = 0;
          my $max_pnum = 0;
      
          my @pnums = sort {$a <=> $b} keys %{$self->{bind_value_layouts}};
          $max_pnum = $pnums[-1];
          
          #Walk through the integers for each possible bind value.
          #If it doesn't have a layout assigned from the config file
          #then shift it off the array from the $log call
          #This needs to be reworked now that we always get an arrayref? --kg 1/2003
          foreach my $pnum (1..$max_pnum){
              my $msg;
      
                  #we've got a bind_value_layout to fill the spot
              if ($self->{bind_value_layouts}{$pnum}){
                 $msg = $self->{bind_value_layouts}{$pnum}->render(
                          $p->{message},
                          $p->{log4p_category},
                          $p->{log4p_level},
                          5 + $Log::Log4perl::caller_depth,  
                      );
  
                 #we don't have a bind_value_layout, so get
                 #a message bit
              }elsif (ref $p->{message} eq 'ARRAY' && @{$p->{message}}){
                  #$msg = shift @{$p->{message}};
                  $msg = $p->{message}->[$i++];
  
                 #here handle cases where we ran out of message bits
                 #before we ran out of bind_value_layouts, just keep going
              }elsif (ref $p->{message} eq 'ARRAY'){
                  $msg = undef;
                  $p->{message} = undef;
  
                 #here handle cases where we didn't get an arrayref
                 #log the message in the first placeholder and nothing in the rest
              }elsif (! ref $p->{message} ){
                  $msg = $p->{message};
                  $p->{message} = undef;
  
              }
  
              if ($self->{MAX_COL_SIZE} &&
                  length($msg) > $self->{MAX_COL_SIZE}){
                  substr($msg, $self->{MAX_COL_SIZE}) = '';
              }
              push @qmarks, $msg;
          }
      }
  
      #handle leftovers
      if (ref $p->{message} eq 'ARRAY' && @{$p->{message}} ) {
          #push @qmarks, @{$p->{message}};
          push @qmarks, @{$p->{message}}[$i..@{$p->{message}}-1];
  
      }
  
      return \@qmarks;
  }
  
  
  sub check_buffer {
      my $self = shift;
  
      return unless ($self->{BUFFER} && ref $self->{BUFFER} eq 'ARRAY');
  
      if (scalar @{$self->{BUFFER}} >= $self->{BUFFERSIZE} * 2) {
  
          my ($sth, $stmt, $prev_stmt);
  
          $prev_stmt = ""; # Init to avoid warning (ms 5/10/03)
  
          while (@{$self->{BUFFER}}) {
              my ($stmt, $qmarks) = splice (@{$self->{BUFFER}},0,2);
  
              $self->{pending_stmt} = $stmt;
  
                  #reuse the sth if the stmt doesn't change
              if ($stmt ne $prev_stmt) {
                  $sth->finish if $sth;
                  $sth = $self->create_statement($stmt);
              }
  
              $self->query_execute($sth, @$qmarks);
  
              $prev_stmt = $stmt;
  
          }
  
          $sth->finish;
  
          my $dbh = $self->{dbh};
  
          if ($dbh && ! $dbh->{AutoCommit}) {
              $dbh->commit;
          }
      }
  }
  
  sub DESTROY {
      my $self = shift;
  
      $self->{BUFFERSIZE} = 1;
  
      $self->check_buffer();
  
      if ($self->{_mine} && $self->{dbh}) {
          $self->{dbh}->disconnect;
      }
  }
  
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Appender::DBI - implements appending to a DB
  
  =head1 SYNOPSIS
  
      my $config = q{
       log4j.category = WARN, DBAppndr
       log4j.appender.DBAppndr             = Log::Log4perl::Appender::DBI
       log4j.appender.DBAppndr.datasource  = DBI:CSV:f_dir=t/tmp
       log4j.appender.DBAppndr.username    = bobjones
       log4j.appender.DBAppndr.password    = 12345
       log4j.appender.DBAppndr.sql         = \
          insert into log4perltest           \
          (loglevel, custid, category, message, ipaddr) \
          values (?,?,?,?,?)
       log4j.appender.DBAppndr.params.1 = %p    
                                     #2 is custid from the log() call
       log4j.appender.DBAppndr.params.3 = %c
                                     #4 is the message from log()
                                     #5 is ipaddr from log()
  
       log4j.appender.DBAppndr.usePreparedStmt = 1
        #--or--
       log4j.appender.DBAppndr.bufferSize = 2
  
       #just pass through the array of message items in the log statement
       log4j.appender.DBAppndr.layout    = Log::Log4perl::Layout::NoopLayout
       log4j.appender.DBAppndr.warp_message = 0
  
       #driver attributes support
       log4j.appender.DBAppndr.attrs.f_encoding = utf8
      };
  
     Log::Log4perl::init ( \$config ) ;                                      
  
     my $logger = Log::Log4perl->get_logger () ;                             
      $logger->warn( $custid, 'big problem!!', $ip_addr );
  
  =head1 CAVEAT
  
  This is a very young module and there are a lot of variations
  in setups with different databases and connection methods,
  so make sure you test thoroughly!  Any feedback is welcome!
  
  =head1 DESCRIPTION
  
  This is a specialized Log::Dispatch object customized to work with
  log4perl and its abilities, originally based on Log::Dispatch::DBI 
  by Tatsuhiko Miyagawa but with heavy modifications.
  
  It is an attempted compromise between what Log::Dispatch::DBI was 
  doing and what log4j's JDBCAppender does.  Note the log4j docs say
  the JDBCAppender "is very likely to be completely replaced in the future."
  
  The simplest usage is this:
  
      log4j.category = WARN, DBAppndr
      log4j.appender.DBAppndr            = Log::Log4perl::Appender::DBI
      log4j.appender.DBAppndr.datasource = DBI:CSV:f_dir=t/tmp
      log4j.appender.DBAppndr.username   = bobjones
      log4j.appender.DBAppndr.password   = 12345
      log4j.appender.DBAppndr.sql        = \
         INSERT INTO logtbl                \
            (loglevel, message)            \
            VALUES ('%c','%m')
  
      log4j.appender.DBAppndr.layout    = Log::Log4perl::Layout::PatternLayout
  
  
      $logger->fatal('fatal message');
      $logger->warn('warning message');
  
      ===============================
      |FATAL|fatal message          |
      |WARN |warning message        |
      ===============================
  
  
  But the downsides to that usage are:
  
  =over 4
  
  =item * 
  
  You'd better be darn sure there are not quotes in your log message, or your
  insert could have unforeseen consequences!  This is a very insecure way to
  handle database inserts, using place holders and bind values is much better, 
  keep reading. (Note that the log4j docs warn "Be careful of quotes in your 
  messages!") B<*>.
  
  =item *
  
  It's not terribly high-performance, a statement is created and executed
  for each log call.
  
  =item *
  
  The only run-time parameter you get is the %m message, in reality
  you probably want to log specific data in specific table columns.
  
  =back
  
  So let's try using placeholders, and tell the logger to create a
  prepared statement handle at the beginning and just reuse it 
  (just like Log::Dispatch::DBI does)
  
  
      log4j.appender.DBAppndr.sql = \
         INSERT INTO logtbl \
            (custid, loglevel, message) \
            VALUES (?,?,?)
  
      #---------------------------------------------------
      #now the bind values:
                                    #1 is the custid
      log4j.appender.DBAppndr.params.2 = %p    
                                    #3 is the message
      #---------------------------------------------------
  
      log4j.appender.DBAppndr.layout    = Log::Log4perl::Layout::NoopLayout
      log4j.appender.DBAppndr.warp_message = 0
      
      log4j.appender.DBAppndr.usePreparedStmt = 1
      
      
      $logger->warn( 1234, 'warning message' ); 
  
  
  Now see how we're using the '?' placeholders in our statement?  This
  means we don't have to worry about messages that look like 
  
      invalid input: 1234';drop table custid;
  
  fubaring our database!
  
  Normally a list of things in the logging statement gets concatenated into 
  a single string, but setting C<warp_message> to 0 and using the 
  NoopLayout means that in
  
      $logger->warn( 1234, 'warning message', 'bgates' );
  
  the individual list values will still be available for the DBI appender later 
  on.  (If C<warp_message> is not set to 0, the default behavior is to
  join the list elements into a single string.   If PatternLayout or SimpleLayout
  are used, their attempt to C<render()> your layout will result in something 
  like "ARRAY(0x841d8dc)" in your logs.  More information on C<warp_message>
  is in Log::Log4perl::Appender.)
  
  In your insert SQL you can mix up '?' placeholders with conversion specifiers 
  (%c, %p, etc) as you see fit--the logger will match the question marks to 
  params you've defined in the config file and populate the rest with values 
  from your list.  If there are more '?' placeholders than there are values in 
  your message, it will use undef for the rest.  For instance, 
  
  	log4j.appender.DBAppndr.sql =                 \
  	   insert into log4perltest                   \
  	   (loglevel, message, datestr, subpoena_id)\
  	   values (?,?,?,?)
  	log4j.appender.DBAppndr.params.1 = %p
  	log4j.appender.DBAppndr.params.3 = %d
  
  	log4j.appender.DBAppndr.warp_message=0
  
  
  	$logger->info('arrest him!', $subpoena_id);
  
  results in the first '?' placeholder being bound to %p, the second to
  "arrest him!", the third to the date from "%d", and the fourth to your
  $subpoenaid.  If you forget the $subpoena_id and just log
  
  	$logger->info('arrest him!');
  
  then you just get undef in the fourth column.
  
  
  If the logger statement is also being handled by other non-DBI appenders,
  they will just join the list into a string, joined with 
  C<$Log::Log4perl::JOIN_MSG_ARRAY_CHAR> (default is an empty string).
  
  And see the C<usePreparedStmt>?  That creates a statement handle when
  the logger object is created and just reuses it.  That, however, may
  be problematic for long-running processes like webservers, in which case
  you can use this parameter instead
  
      log4j.appender.DBAppndr.bufferSize=2
  
  This copies log4j's JDBCAppender's behavior, it saves up that many
  log statements and writes them all out at once.  If your INSERT
  statement uses only ? placeholders and no %x conversion specifiers
  it should be quite efficient because the logger can re-use the
  same statement handle for the inserts.
  
  If the program ends while the buffer is only partly full, the DESTROY
  block should flush the remaining statements, if the DESTROY block
  runs of course.
  
  * I<As I was writing this, Danko Mannhaupt was coming out with his
  improved log4j JDBCAppender (http://www.mannhaupt.com/danko/projects/)
  which overcomes many of the drawbacks of the original JDBCAppender.>
  
  =head1 DESCRIPTION 2
  
  Or another way to say the same thing:
  
  The idea is that if you're logging to a database table, you probably
  want specific parts of your log information in certain columns.  To this
  end, you pass an list to the log statement, like 
  
      $logger->warn('big problem!!',$userid,$subpoena_nr,$ip_addr);
  
  and the array members drop into the positions defined by the placeholders
  in your SQL statement. You can also define information in the config
  file like
  
      log4j.appender.DBAppndr.params.2 = %p    
  
  in which case those numbered placeholders will be filled in with
  the specified values, and the rest of the placeholders will be
  filled in with the values from your log statement's array.
  
  =head1 MISC PARAMETERS
  
  
  =over 4
  
  =item usePreparedStmt
  
  See above.
  
  =item warp_message
  
  see Log::Log4perl::Appender
  
  =item max_col_size
  
  If you're used to just throwing debugging messages like huge stacktraces
  into your logger, some databases (Sybase's DBD!!) may surprise you 
  by choking on data size limitations.  Normally, the data would
  just be truncated to fit in the column, but Sybases's DBD it turns out
  maxes out at 255 characters.  Use this parameter in such a situation
  to truncate long messages before they get to the INSERT statement.
  
  =back
  
  =head1 CHANGING DBH CONNECTIONS (POOLING)
  
  If you want to get your dbh from some place in particular, like
  maybe a pool, subclass and override _init() and/or create_statement(), 
  for instance 
  
      sub _init {
          ; #no-op, no pooling at this level
      }
      sub create_statement {
          my ($self, $stmt) = @_;
      
          $stmt || croak "Log4perl: sql not set in ".__PACKAGE__;
      
          return My::Connections->getConnection->prepare($stmt) 
              || croak "Log4perl: DBI->prepare failed $DBI::errstr\n$stmt";
      }
  
  
  =head1 LIFE OF CONNECTIONS
  
  If you're using C<log4j.appender.DBAppndr.usePreparedStmt>
  this module creates an sth when it starts and keeps it for the life
  of the program.  For long-running processes (e.g. mod_perl), connections
  might go stale, but if C<Log::Log4perl::Appender::DBI> tries to write
  a message and figures out that the DB connection is no longer working
  (using DBI's ping method), it will reconnect.
  
  The reconnection process can be controlled by two parameters,
  C<reconnect_attempts> and C<reconnect_sleep>. C<reconnect_attempts>
  specifies the number of reconnections attempts the DBI appender 
  performs until it gives up and dies. C<reconnect_sleep> is the
  time between reconnection attempts, measured in seconds.
  C<reconnect_attempts> defaults to 1,  C<reconnect_sleep> to 0.
  
  Alternatively, use C<Apache::DBI> or C<Apache::DBI::Cache> and read
  CHANGING DB CONNECTIONS above.
  
  Note that C<Log::Log4perl::Appender::DBI> holds one connection open
  for every appender, which might be too many.
  
  =head1 SEE ALSO
  
  L<Log::Dispatch::DBI>
  
  L<Log::Log4perl::JavaMap::JDBCAppender>
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_APPENDER_DBI

$fatpacked{"Log/Log4perl/Appender/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_FILE';
  ##################################################
  package Log::Log4perl::Appender::File;
  ##################################################
  
  our @ISA = qw(Log::Log4perl::Appender);
  
  use warnings;
  use strict;
  use Log::Log4perl::Config::Watch;
  use Fcntl;
  use File::Path;
  use File::Spec::Functions qw(splitpath catpath);
  use constant _INTERNAL_DEBUG => 0;
  use constant SYSWRITE_UTF8_OK => ( $] < 5.024 );
  
  ##################################################
  sub new {
  ##################################################
      my($class, @options) = @_;
  
      my $self = {
          name      => "unknown name",
          umask     => undef,
          owner     => undef,
          group     => undef,
          autoflush => 1,
          syswrite  => 0,
          mode      => "append",
          binmode   => undef,
          utf8      => 0,
          recreate  => 0,
          recreate_check_interval => 30,
          recreate_check_signal   => undef,
          recreate_pid_write      => undef,
          create_at_logtime       => 0,
          header_text             => undef,
          mkpath                  => 0,
          mkpath_umask            => 0,
          @options,
      };
  
      if($self->{create_at_logtime}) {
          $self->{recreate}  = 1;
      }
      for my $param ('umask', 'mkpath_umask') {
          if(defined $self->{$param} and $self->{$param} =~ /^0/) {
                  # umask value is a string, meant to be an oct value
              $self->{$param} = oct($self->{$param});
          }
      }
  
      die "Mandatory parameter 'filename' missing" unless
          exists $self->{filename};
  
      bless $self, $class;
  
      if($self->{recreate_pid_write}) {
          print "Creating pid file",
                " $self->{recreate_pid_write}\n" if _INTERNAL_DEBUG;
          open FILE, ">$self->{recreate_pid_write}" or
              die "Cannot open $self->{recreate_pid_write}";
          print FILE "$$\n";
          close FILE;
      }
  
      print "Calling syswrite_encoder\n" if _INTERNAL_DEBUG;
  
      $self->{syswrite_encoder} = $self->syswrite_encoder();
  
      print "syswrite_encoder returned\n" if _INTERNAL_DEBUG;
  
          # This will die() if it fails
      $self->file_open() unless $self->{create_at_logtime};
  
      return $self;
  }
  
  ##################################################
  sub syswrite_encoder {
  ##################################################
      my($self) = @_;
  
      if( !SYSWRITE_UTF8_OK and $self->{syswrite} and $self->{utf8} ) {
          print "Requiring Encode\n" if _INTERNAL_DEBUG;
          eval { require Encode };
          print "Requiring Encode returned: $@\n" if _INTERNAL_DEBUG;
  
          if( $@ ) {
              die "syswrite and utf8 requires Encode.pm";
          } else {
              return sub { Encode::encode_utf8($_[0]) };
          }
      }
  
      return undef;
  }
  
  ##################################################
  sub filename {
  ##################################################
      my($self) = @_;
  
      return $self->{filename};
  }
  
  ##################################################
  sub file_open {
  ##################################################
      my($self) = @_;
  
      my $arrows  = ">";
      my $sysmode = (O_CREAT|O_WRONLY);
  
  
      if($self->{mode} eq "append") {
          $arrows   = ">>";
          $sysmode |= O_APPEND;
      } elsif ($self->{mode} eq "pipe") {
          $arrows = "|";
      } else {
          $sysmode |= O_TRUNC;
      }
  
      my $fh = do { local *FH; *FH; };
  
  
      my $didnt_exist = ! -e $self->{filename};
      if($didnt_exist && $self->{mkpath}) {
          my ($volume, $path, $file) = splitpath($self->{filename});
          if($path ne '' && !-e $path) {
              my $old_umask = umask($self->{mkpath_umask}) if defined $self->{mkpath_umask};
              my $options = {};
              foreach my $param (qw(owner group) ) {
                  $options->{$param} = $self->{$param} if defined $self->{$param};
              }
              eval {
                  mkpath(catpath($volume, $path, ''),$options);
              };
              umask($old_umask) if defined $old_umask;
              die "Can't create path ${path} ($!)" if $@;
          }
      }
  
      my $old_umask = umask($self->{umask}) if defined $self->{umask};
  
      eval {
          if($self->{syswrite}) {
              sysopen $fh, "$self->{filename}", $sysmode or
                  die "Can't sysopen $self->{filename} ($!)";
          } else {
              open $fh, "$arrows$self->{filename}" or
                  die "Can't open $self->{filename} ($!)";
          }
      };
      umask($old_umask) if defined $old_umask;
      die $@ if $@;
  
      if($didnt_exist and
           ( defined $self->{owner} or defined $self->{group} )
        ) {
  
          eval { $self->perms_fix() };
  
          if($@) {
                # Cleanup and re-throw
              unlink $self->{filename};
              die $@;
          }
      }
  
      if($self->{recreate}) {
          $self->{watcher} = Log::Log4perl::Config::Watch->new(
              file           => $self->{filename},
              (defined $self->{recreate_check_interval} ?
                (check_interval => $self->{recreate_check_interval}) : ()),
              (defined $self->{recreate_check_signal} ?
                (signal => $self->{recreate_check_signal}) : ()),
          );
      }
  
      $self->{fh} = $fh;
  
      if ($self->{autoflush} and ! $self->{syswrite}) {
          my $oldfh = select $self->{fh};
          $| = 1;
          select $oldfh;
      }
  
      if (defined $self->{binmode}) {
          binmode $self->{fh}, $self->{binmode};
      }
  
      if ($self->{utf8}) {
            # older perls can handle syswrite+utf8 just fine
          if(SYSWRITE_UTF8_OK or !$self->{syswrite}) {
              binmode $self->{fh}, ":utf8";
          }
      }
  
      if(defined $self->{header_text}) {
          if( $self->{header_text} !~ /\n\Z/ ) {
              $self->{header_text} .= "\n";
          }
  
            # quick and dirty print/syswrite without the usual
            # log() recreate magic.
          local $self->{recreate} = 0;
          $self->log( message => $self->{header_text} );
      }
  }
  
  ##################################################
  sub file_close {
  ##################################################
      my($self) = @_;
  
      if(defined $self->{fh}) {
          $self->close_with_care( $self->{ fh } );
      }
  
      undef $self->{fh};
  }
  
  ##################################################
  sub perms_fix {
  ##################################################
      my($self) = @_;
  
      my ($uid_org, $gid_org) = (stat $self->{filename})[4,5];
  
      my ($uid, $gid) = ($uid_org, $gid_org);
  
      if(!defined $uid) {
          die "stat of $self->{filename} failed ($!)";
      }
  
      my $needs_fixing = 0;
  
      if(defined $self->{owner}) {
          $uid = $self->{owner};
          if($self->{owner} !~ /^\d+$/) {
              $uid = (getpwnam($self->{owner}))[2];
              die "Unknown user: $self->{owner}" unless defined $uid;
          }
      }
  
      if(defined $self->{group}) {
          $gid = $self->{group};
          if($self->{group} !~ /^\d+$/) {
              $gid = getgrnam($self->{group});
  
              die "Unknown group: $self->{group}" unless defined $gid;
          }
      }
      if($uid != $uid_org or $gid != $gid_org) {
          chown($uid, $gid, $self->{filename}) or
              die "chown('$uid', '$gid') on '$self->{filename}' failed: $!";
      }
  }
  
  ##################################################
  sub file_switch {
  ##################################################
      my($self, $new_filename) = @_;
  
      print "Switching file from $self->{filename} to $new_filename\n" if
          _INTERNAL_DEBUG;
  
      $self->file_close();
      $self->{filename} = $new_filename;
      $self->file_open();
  }
  
  ##################################################
  sub log {
  ##################################################
      my($self, %params) = @_;
  
      # Warning: this function gets called by file_open() which assumes 
      # it can use it as a simple print/syswrite wrapper by temporary 
      # disabling the 'recreate' entry. Add anything fancy here and 
      # fix up file_open() accordingly.
  
      if($self->{recreate}) {
          if($self->{recreate_check_signal}) {
              if(!$self->{watcher} or
                 $self->{watcher}->{signal_caught}) {
                  $self->file_switch($self->{filename});
                  $self->{watcher}->{signal_caught} = 0;
              }
          } else {
              if(!$self->{watcher} or
                  $self->{watcher}->file_has_moved()) {
                  $self->file_switch($self->{filename});
              }
          }
      }
  
      my $fh = $self->{fh};
  
      if($self->{syswrite}) {
           my $rc = 
             syswrite( $fh, 
                 $self->{ syswrite_encoder } ?
                   $self->{ syswrite_encoder }->($params{message}) :
                   $params{message} );
  
           if(!defined $rc) {
               die "Cannot syswrite to '$self->{filename}': $!";
           }
      } else {
          print $fh $params{message} or
              die "Cannot write to '$self->{filename}': $!";
      }
  }
  
  ##################################################
  sub DESTROY {
  ##################################################
      my($self) = @_;
  
      if ($self->{fh}) {
          my $fh = $self->{fh};
          $self->close_with_care( $fh );
      }
  }
  
  ###########################################
  sub close_with_care {
  ###########################################
      my( $self, $fh ) = @_;
  
      my $prev_rc = $?;
  
      my $rc = close $fh;
  
        # [rt #84723] If a sig handler is reaping the child generated
        # by close() internally before close() gets to it, it'll
        # result in a weird (but benign) error that we don't want to
        # expose to the user.
      if( !$rc ) {
          if( $self->{ mode } eq "pipe" and
              $!{ ECHILD } ) {
              if( $Log::Log4perl::CHATTY_DESTROY_METHODS ) {
                  warn "$$: pipe closed with ECHILD error -- guess that's ok";
              }
              $? = $prev_rc;
          } else {
              warn "Can't close $self->{filename} ($!)";
          }
      }
  
      return $rc;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Appender::File - Log to file
  
  =head1 SYNOPSIS
  
      use Log::Log4perl::Appender::File;
  
      my $app = Log::Log4perl::Appender::File->new(
        filename  => 'file.log',
        mode      => 'append',
        autoflush => 1,
        umask     => 0222,
      );
  
      $file->log(message => "Log me\n");
  
  =head1 DESCRIPTION
  
  This is a simple appender for writing to a file.
  
  The C<log()> method takes a single scalar. If a newline character
  should terminate the message, it has to be added explicitly.
  
  Upon destruction of the object, the filehandle to access the
  file is flushed and closed.
  
  If you want to switch over to a different logfile, use the
  C<file_switch($newfile)> method which will first close the old
  file handle and then open a one to the new file specified.
  
  =head2 OPTIONS
  
  =over 4
  
  =item filename
  
  Name of the log file.
  
  =item mode
  
  Messages will be append to the file if C<$mode> is set to the
  string C<"append">. Will clobber the file
  if set to C<"clobber">. If it is C<"pipe">, the file will be understood
  as executable to pipe output to. Default mode is C<"append">.
  
  =item autoflush
  
  C<autoflush>, if set to a true value, triggers flushing the data
  out to the file on every call to C<log()>. C<autoflush> is on by default.
  
  =item syswrite
  
  C<syswrite>, if set to a true value, makes sure that the appender uses
  syswrite() instead of print() to log the message. C<syswrite()> usually
  maps to the operating system's C<write()> function and makes sure that
  no other process writes to the same log file while C<write()> is busy.
  Might safe you from having to use other synchronisation measures like
  semaphores (see: Synchronized appender).
  
  =item umask
  
  Specifies the C<umask> to use when creating the file, determining
  the file's permission settings.
  If set to C<0022> (default), new
  files will be created with C<rw-r--r--> permissions.
  If set to C<0000>, new files will be created with C<rw-rw-rw-> permissions.
  
  =item owner
  
  If set, specifies that the owner of the newly created log file should
  be different from the effective user id of the running process.
  Only makes sense if the process is running as root.
  Both numerical user ids and user names are acceptable.
  Log4perl does not attempt to change the ownership of I<existing> files.
  
  =item group
  
  If set, specifies that the group of the newly created log file should
  be different from the effective group id of the running process.
  Only makes sense if the process is running as root.
  Both numerical group ids and group names are acceptable.
  Log4perl does not attempt to change the group membership of I<existing> files.
  
  =item utf8
  
  If you're printing out Unicode strings, the output filehandle needs
  to be set into C<:utf8> mode:
  
      my $app = Log::Log4perl::Appender::File->new(
        filename  => 'file.log',
        mode      => 'append',
        utf8      => 1,
      );
  
  =item binmode
  
  To manipulate the output filehandle via C<binmode()>, use the
  binmode parameter:
  
      my $app = Log::Log4perl::Appender::File->new(
        filename  => 'file.log',
        mode      => 'append',
        binmode   => ":utf8",
      );
  
  A setting of ":utf8" for C<binmode> is equivalent to specifying
  the C<utf8> option (see above).
  
  =item recreate
  
  Normally, if a file appender logs to a file and the file gets moved to
  a different location (e.g. via C<mv>), the appender's open file handle
  will automatically follow the file to the new location.
  
  This may be undesirable. When using an external logfile rotator,
  for example, the appender should create a new file under the old name
  and start logging into it. If the C<recreate> option is set to a true value,
  C<Log::Log4perl::Appender::File> will do exactly that. It defaults to
  false. Check the C<recreate_check_interval> option for performance
  optimizations with this feature.
  
  =item recreate_check_interval
  
  In C<recreate> mode, the appender has to continuously check if the
  file it is logging to is still in the same location. This check is
  fairly expensive, since it has to call C<stat> on the file name and
  figure out if its inode has changed. Doing this with every call
  to C<log> can be prohibitively expensive. Setting it to a positive
  integer value N will only check the file every N seconds. It defaults to 30.
  
  This obviously means that the appender will continue writing to
  a moved file until the next check occurs, in the worst case
  this will happen C<recreate_check_interval> seconds after the file
  has been moved or deleted. If this is undesirable,
  setting C<recreate_check_interval> to 0 will have the
  appender check the file with I<every> call to C<log()>.
  
  =item recreate_check_signal
  
  In C<recreate> mode, if this option is set to a signal name
  (e.g. "USR1"), the appender will recreate a missing logfile
  when it receives the signal. It uses less resources than constant
  polling. The usual limitation with perl's signal handling apply.
  Check the FAQ for using this option with the log rotating
  utility C<newsyslog>.
  
  =item recreate_pid_write
  
  The popular log rotating utility C<newsyslog> expects a pid file
  in order to send the application a signal when its logs have
  been rotated. This option expects a path to a file where the pid
  of the currently running application gets written to.
  Check the FAQ for using this option with the log rotating
  utility C<newsyslog>.
  
  =item create_at_logtime
  
  The file appender typically creates its logfile in its constructor, i.e.
  at Log4perl C<init()> time. This is desirable for most use cases, because
  it makes sure that file permission problems get detected right away, and
  not after days/weeks/months of operation when the appender suddenly needs
  to log something and fails because of a problem that was obvious at
  startup.
  
  However, there are rare use cases where the file shouldn't be created
  at Log4perl C<init()> time, e.g. if the appender can't be used by the current
  user although it is defined in the configuration file. If you set
  C<create_at_logtime> to a true value, the file appender will try to create
  the file at log time. Note that this setting lets permission problems
  sit undetected until log time, which might be undesirable.
  
  =item header_text
  
  If you want Log4perl to print a header into every newly opened
  (or re-opened) logfile, set C<header_text> to either a string
  or a subroutine returning a string. If the message doesn't have a newline,
  a newline at the end of the header will be provided.
  
  =item mkpath
  
  If this this option is set to true,
  the directory path will be created if it does not exist yet.
  
  =item mkpath_umask
  
  Specifies the C<umask> to use when creating the directory, determining
  the directory's permission settings.
  If set to C<0022> (default), new
  directory will be created with C<rwxr-xr-x> permissions.
  If set to C<0000>, new directory will be created with C<rwxrwxrwx> permissions.
  
  =back
  
  Design and implementation of this module has been greatly inspired by
  Dave Rolsky's C<Log::Dispatch> appender framework.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt>
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches):
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull,
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter,
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope,
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_APPENDER_FILE

$fatpacked{"Log/Log4perl/Appender/Limit.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_LIMIT';
  ######################################################################
  # Limit.pm -- 2003, Mike Schilli <m@perlmeister.com>
  ######################################################################
  # Special composite appender limiting the number of messages relayed
  # to its appender(s).
  ######################################################################
  
  ###########################################
  package Log::Log4perl::Appender::Limit;
  ###########################################
  
  use strict;
  use warnings;
  use Storable;
  
  our @ISA = qw(Log::Log4perl::Appender);
  
  our $VERSION    = '1.53';
  
  ###########################################
  sub new {
  ###########################################
      my($class, %options) = @_;
  
      my $self = {
          max_until_flushed   => undef,
          max_until_discarded => undef,
          appender_method_on_flush 
                              => undef,
          appender            => undef,
          accumulate          => 1,
          persistent          => undef,
          block_period        => 3600,
          buffer              => [],
          %options,
      };
  
          # Pass back the appender to be limited as a dependency
          # to the configuration file parser
      push @{$options{l4p_depends_on}}, $self->{appender};
  
          # Run our post_init method in the configurator after
          # all appenders have been defined to make sure the
          # appenders we're connecting to really exist.
      push @{$options{l4p_post_config_subs}}, sub { $self->post_init() };
  
      bless $self, $class;
  
      if(defined $self->{persistent}) {
          $self->restore();
      }
  
      return $self;
  }
  
  ###########################################
  sub log {
  ###########################################
      my($self, %params) = @_;
      
      local $Log::Log4perl::caller_depth =
          $Log::Log4perl::caller_depth + 2;
  
          # Check if message needs to be discarded
      my $discard = 0;
      if(defined $self->{max_until_discarded} and
         scalar @{$self->{buffer}} >= $self->{max_until_discarded} - 1) {
          $discard = 1;
      }
  
          # Check if we need to flush
      my $flush = 0;
      if(defined $self->{max_until_flushed} and
         scalar @{$self->{buffer}} >= $self->{max_until_flushed} - 1) {
          $flush = 1;
      }
  
      if(!$flush and
         (exists $self->{sent_last} and
          $self->{sent_last} + $self->{block_period} > time()
         )
        ) {
              # Message needs to be blocked for now.
          return if $discard;
  
              # Ask the appender to save a cached message in $cache
          $self->{app}->SUPER::log(\%params,
                               $params{log4p_category},
                               $params{log4p_level}, \my $cache);
  
              # Save message and other parameters
          push @{$self->{buffer}}, $cache if $self->{accumulate};
  
          $self->save() if $self->{persistent};
  
          return;
      }
  
      # Relay all messages we got to the SUPER class, which needs to render the
      # messages according to the appender's layout, first.
  
          # Log pending messages if we have any
      $self->flush();
  
          # Log current message as well
      $self->{app}->SUPER::log(\%params,
                               $params{log4p_category},
                               $params{log4p_level});
  
      $self->{sent_last} = time();
  
          # We need to store the timestamp persistently, if requested
      $self->save() if $self->{persistent};
  }
  
  ###########################################
  sub post_init {
  ###########################################
      my($self) = @_;
  
      if(! exists $self->{appender}) {
         die "No appender defined for " . __PACKAGE__;
      }
  
      my $appenders = Log::Log4perl->appenders();
      my $appender = Log::Log4perl->appenders()->{$self->{appender}};
  
      if(! defined $appender) {
         die "Appender $self->{appender} not defined (yet) when " .
             __PACKAGE__ . " needed it";
      }
  
      $self->{app} = $appender;
  }
  
  ###########################################
  sub save {
  ###########################################
      my($self) = @_;
  
      my $pdata = [$self->{buffer}, $self->{sent_last}];
  
          # Save the buffer if we're in persistent mode
      store $pdata, $self->{persistent} or
          die "Cannot save messages in $self->{persistent} ($!)";
  }
  
  ###########################################
  sub restore {
  ###########################################
      my($self) = @_;
  
      if(-f $self->{persistent}) {
          my $pdata = retrieve $self->{persistent} or
              die "Cannot retrieve messages from $self->{persistent} ($!)";
          ($self->{buffer}, $self->{sent_last}) = @$pdata;
      }
  }
  
  ###########################################
  sub flush {
  ###########################################
      my($self) = @_;
  
          # Log pending messages if we have any
      for(@{$self->{buffer}}) {
          $self->{app}->SUPER::log_cached($_);
      }
  
        # call flush() on the attached appender if so desired.
      if( $self->{appender_method_on_flush} ) {
          no strict 'refs';
          my $method = $self->{appender_method_on_flush};
          $self->{app}->$method();
      }
  
          # Empty buffer
      $self->{buffer} = [];
  }
  
  ###########################################
  sub DESTROY {
  ###########################################
      my($self) = @_;
  
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Appender::Limit - Limit message delivery via block period
  
  =head1 SYNOPSIS
  
      use Log::Log4perl qw(:easy);
  
      my $conf = qq(
        log4perl.category = WARN, Limiter
      
            # Email appender
        log4perl.appender.Mailer          = Log::Dispatch::Email::MailSend
        log4perl.appender.Mailer.to       = drone\@pageme.com
        log4perl.appender.Mailer.subject  = Something's broken!
        log4perl.appender.Mailer.buffered = 0
        log4perl.appender.Mailer.layout   = PatternLayout
        log4perl.appender.Mailer.layout.ConversionPattern=%d %m %n
  
            # Limiting appender, using the email appender above
        log4perl.appender.Limiter              = Log::Log4perl::Appender::Limit
        log4perl.appender.Limiter.appender     = Mailer
        log4perl.appender.Limiter.block_period = 3600
      );
  
      Log::Log4perl->init(\$conf);
      WARN("This message will be sent immediately.");
      WARN("This message will be delayed by one hour.");
      sleep(3601);
      WARN("This message plus the last one will be sent now, seperately.");
  
  =head1 DESCRIPTION
  
  =over 4
  
  =item C<appender>
  
  Specifies the name of the appender used by the limiter. The
  appender specified must be defined somewhere in the configuration file,
  not necessarily before the definition of 
  C<Log::Log4perl::Appender::Limit>.
  
  =item C<block_period>
  
  Period in seconds between delivery of messages. If messages arrive in between,
  they will be either saved (if C<accumulate> is set to a true value) or
  discarded (if C<accumulate> isn't set).
  
  =item C<persistent>
  
  File name in which C<Log::Log4perl::Appender::Limit> persistently stores 
  delivery times. If omitted, the appender will have no recollection of what
  happened when the program restarts.
  
  =item C<max_until_flushed>
  
  Maximum number of accumulated messages. If exceeded, the appender flushes 
  all messages, regardless if the interval set in C<block_period> 
  has passed or not. Don't mix with C<max_until_discarded>.
  
  =item C<max_until_discarded>
  
  Maximum number of accumulated messages. If exceeded, the appender will
  simply discard additional messages, waiting for C<block_period> to expire
  to flush all accumulated messages. Don't mix with C<max_until_flushed>.
  
  =item C<appender_method_on_flush>
  
  Optional method name to be called on the appender attached to the
  limiter when messages are flushed. For example, to have the sample code 
  in the SYNOPSIS section bundle buffered emails into one, change the 
  mailer's C<buffered> parameter to C<1> and set the limiters 
  C<appender_method_on_flush> value to the string C<"flush">:
  
        log4perl.category = WARN, Limiter
      
            # Email appender
        log4perl.appender.Mailer          = Log::Dispatch::Email::MailSend
        log4perl.appender.Mailer.to       = drone\@pageme.com
        log4perl.appender.Mailer.subject  = Something's broken!
        log4perl.appender.Mailer.buffered = 1
        log4perl.appender.Mailer.layout   = PatternLayout
        log4perl.appender.Mailer.layout.ConversionPattern=%d %m %n
  
            # Limiting appender, using the email appender above
        log4perl.appender.Limiter              = Log::Log4perl::Appender::Limit
        log4perl.appender.Limiter.appender     = Mailer
        log4perl.appender.Limiter.block_period = 3600
        log4perl.appender.Limiter.appender_method_on_flush = flush
  
  This will cause the mailer to buffer messages and wait for C<flush()>
  to send out the whole batch. The limiter will then call the appender's
  C<flush()> method when it's own buffer gets flushed out.
  
  =back
  
  If the appender attached to C<Limit> uses C<PatternLayout> with a timestamp
  specifier, you will notice that the message timestamps are reflecting the
  original log event, not the time of the message rendering in the
  attached appender. Major trickery has been applied to accomplish 
  this (Cough!).
  
  =head1 DEVELOPMENT NOTES
  
  C<Log::Log4perl::Appender::Limit> is a I<composite> appender.
  Unlike other appenders, it doesn't log any messages, it just
  passes them on to its attached sub-appender.
  For this reason, it doesn't need a layout (contrary to regular appenders).
  If it defines none, messages are passed on unaltered.
  
  Custom filters are also applied to the composite appender only.
  They are I<not> applied to the sub-appender. Same applies to appender
  thresholds. This behaviour might change in the future.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_APPENDER_LIMIT

$fatpacked{"Log/Log4perl/Appender/RRDs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_RRDS';
  ##################################################
  package Log::Log4perl::Appender::RRDs;
  ##################################################
  our @ISA = qw(Log::Log4perl::Appender);
  
  use warnings;
  use strict;
  use RRDs;
  
  ##################################################
  sub new {
  ##################################################
      my($class, @options) = @_;
  
      my $self = {
          name             => "unknown name",
          dbname           => undef,
          rrdupd_params => [],
          @options,
      };
  
      die "Mandatory parameter 'dbname' missing" unless
          defined $self->{dbname};
  
      bless $self, $class;
  
      return $self;
  }
  
  ##################################################
  sub log {
  ##################################################
      my($self, %params) = @_;
  
      #print "UPDATE: '$self->{dbname}' - '$params{message}'\n";
  
      RRDs::update($self->{dbname}, 
                   @{$params{rrdupd_params}},
                   $params{message}) or
          die "Cannot update rrd $self->{dbname} ",
              "with $params{message} ($!)";
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Appender::RRDs - Log to a RRDtool Archive
      
  =head1 SYNOPSIS
      
      use Log::Log4perl qw(get_logger);
      use RRDs;
      
      my $DB = "myrrddb.dat";
      
      RRDs::create(
        $DB, "--step=1",
        "DS:myvalue:GAUGE:2:U:U",
        "RRA:MAX:0.5:1:120");
      
      print time(), "\n";
      
      Log::Log4perl->init(\qq{
        log4perl.category = INFO, RRDapp
        log4perl.appender.RRDapp = Log::Log4perl::Appender::RRDs
        log4perl.appender.RRDapp.dbname = $DB
        log4perl.appender.RRDapp.layout = Log::Log4perl::Layout::PatternLayout
        log4perl.appender.RRDapp.layout.ConversionPattern = N:%m
      });
      
      my $logger = get_logger();
      
      for(10, 15, 20, 25) {
          $logger->info($_);
          sleep 1;
      }
     
  =head1 DESCRIPTION
  
  C<Log::Log4perl::Appender::RRDs> appenders facilitate writing data
  to RRDtool round-robin archives via Log4perl. For documentation
  on RRD and its Perl interface C<RRDs> (which comes with the distribution),
  check out L<http://rrdtool.org>.
  
  Messages sent to Log4perl's RRDs appender are expected to be numerical values
  (ints or floats), which then are used to run a C<rrdtool update> command
  on an existing round-robin database. The name of this database needs to
  be set in the appender's C<dbname> configuration parameter.
  
  If there's more parameters you wish to pass to the C<update> method,
  use the C<rrdupd_params> configuration parameter:
  
      log4perl.appender.RRDapp.rrdupd_params = --template=in:out
  
  To read out the round robin database later on, use C<rrdtool fetch>
  or C<rrdtool graph> for graphic displays.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_APPENDER_RRDS

$fatpacked{"Log/Log4perl/Appender/Screen.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_SCREEN';
  ##################################################
  package Log::Log4perl::Appender::Screen;
  ##################################################
  
  our @ISA = qw(Log::Log4perl::Appender);
  
  use warnings;
  use strict;
  
  use IO::Handle;
  
  ##################################################
  sub new {
  ##################################################
      my($class, @options) = @_;
  
      my $self = {
          autoflush   => 0,
          name        => "unknown name",
          stderr      => 1,
          utf8        => undef,
          @options,
      };
  
      if( $self->{utf8} ) {
          if( $self->{stderr} ) {
              binmode STDERR, ":utf8";
          } else {
              binmode STDOUT, ":utf8";
          }
      }
  
      if( $self->{autoflush} ) {
          if( $self->{stderr} ) {
              STDERR->autoflush(1);
          } else {
              STDOUT->autoflush(1);
          }
      }
  
      bless $self, $class;
  }
  
  ##################################################
  sub log {
  ##################################################
      my($self, %params) = @_;
  
      my $fh = \*STDOUT;
      if (ref $self->{stderr}) {
          $fh = \*STDERR if $self->{stderr}{ $params{'log4p_level'} }
                              || $self->{stderr}{ lc $params{'log4p_level'} };
      } elsif ($self->{stderr}) {
          $fh = \*STDERR;
      }
  
      print $fh $params{message};
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Appender::Screen - Log to STDOUT/STDERR
  
  =head1 SYNOPSIS
  
      use Log::Log4perl::Appender::Screen;
  
      my $app = Log::Log4perl::Appender::Screen->new(
        autoflush => 1,
        stderr    => 0,
        utf8      => 1,
      );
  
      $file->log(message => "Log me\n");
  
  =head1 DESCRIPTION
  
  This is a simple appender for writing to STDOUT or STDERR.
  
  The constructor C<new()> takes an optional parameter C<stderr>:
  
  =over
  
  =item *
  
  If set to a false value, it will log all levels to STDOUT (or, more
  accurately, whichever file handle is selected via C<select()>, STDOUT
  by default).
  
  =item *
  
  If set to a hash, then any C<log4p_level> with a truthy value will
  dynamically use STDERR, or STDOUT otherwise.
  
  =item *
  
  Otherwise, if a true value (the default setting is 1), messages will be
  logged to STDERR.
  
  =back
  
      # All messages/levels to STDERR
      my $app = Log::Log4perl::Appender::Screen->new(
          stderr  => 1,
      );
  
      # Only ERROR and FATAL to STDERR (case-sensitive)
      my $app = Log::Log4perl::Appender::Screen->new(
          stderr  => { ERROR => 1, FATAL => 1},
      );
  
  Design and implementation of this module has been greatly inspired by
  Dave Rolsky's C<Log::Dispatch> appender framework.
  
  To enable printing wide utf8 characters, set the utf8 option to a true
  value:
  
      my $app = Log::Log4perl::Appender::Screen->new(
        stderr    => 1,
        utf8      => 1,
      );
  
  This will issue the necessary binmode command to the selected output
  channel (stderr/stdout).
  
  To enable L<autoflush|perlvar/"HANDLE-E<gt>autoflush( EXPR )">, set the
  C<autoflush> option to a true value:
  
      my $app = Log::Log4perl::Appender::Screen->new(
        autoflush => 1,
      );
  
  This will issue the necessary autoflush command to the selected output
  channel (stderr/stdout).
  
  This is required in containers, especially when the log volume is low, to
  not buffer the log messages and cause a significant delay.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt>
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches):
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull,
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter,
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope,
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_APPENDER_SCREEN

$fatpacked{"Log/Log4perl/Appender/ScreenColoredLevels.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_SCREENCOLOREDLEVELS';
  ##################################################
  package Log::Log4perl::Appender::ScreenColoredLevels;
  ##################################################
  use Log::Log4perl::Appender::Screen;
  our @ISA = qw(Log::Log4perl::Appender::Screen);
  
  use warnings;
  use strict;
  
  use Term::ANSIColor qw();
  use Log::Log4perl::Level;
  
  BEGIN {
      $Term::ANSIColor::EACHLINE="\n";
  }
  
  ##################################################
  sub new {
  ##################################################
      my($class, %options) = @_;
  
      my %specific_options = ( color => {} );
  
      for my $option ( keys %specific_options ) {
          $specific_options{ $option } = delete $options{ $option } if
              exists $options{ $option };
      }
  
      my $self = $class->SUPER::new( %options );
      @$self{ keys %specific_options } = values %specific_options;
      bless $self, __PACKAGE__; # rebless
  
        # also accept lower/mixed case levels in config
      for my $level ( keys %{ $self->{color} } ) {
          my $uclevel = uc($level);
          $self->{color}->{$uclevel} = $self->{color}->{$level};
      }
  
      my %default_colors = (
          TRACE   => 'yellow',
          DEBUG   => '',
          INFO    => 'green',
          WARN    => 'blue',
          ERROR   => 'magenta',
          FATAL   => 'red',
      );
      for my $level ( keys %default_colors ) {
          if ( ! exists $self->{ 'color' }->{ $level } ) {
              $self->{ 'color' }->{ $level } = $default_colors{ $level };
          }
      }
  
      bless $self, $class;
  }
      
  ##################################################
  sub log {
  ##################################################
      my($self, %params) = @_;
  
      my $msg = $params{ 'message' };
  
      if ( my $color = $self->{ 'color' }->{ $params{ 'log4p_level' } } ) {
          $msg = Term::ANSIColor::colored( $msg, $color );
      }
  
      my $fh = \*STDOUT;
      if (ref $self->{stderr}) {
          $fh = \*STDERR if $self->{stderr}{ $params{'log4p_level'} }
                              || $self->{stderr}{ lc $params{'log4p_level'} };
      } elsif ($self->{stderr}) {
          $fh = \*STDERR;
      }
  
      print $fh $msg;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Appender::ScreenColoredLevels - Colorize messages according to level
  
  =head1 SYNOPSIS
  
      use Log::Log4perl qw(:easy);
  
      Log::Log4perl->init(\ <<'EOT');
        log4perl.category = DEBUG, Screen
        log4perl.appender.Screen = \
            Log::Log4perl::Appender::ScreenColoredLevels
        log4perl.appender.Screen.layout = \
            Log::Log4perl::Layout::PatternLayout
        log4perl.appender.Screen.layout.ConversionPattern = \
            %d %F{1} %L> %m %n
      EOT
  
        # Appears black
      DEBUG "Debug Message";
  
        # Appears green
      INFO  "Info Message";
  
        # Appears blue
      WARN  "Warn Message";
  
        # Appears magenta
      ERROR "Error Message";
  
        # Appears red
      FATAL "Fatal Message";
  
  =head1 DESCRIPTION
  
  This appender acts like Log::Log4perl::Appender::Screen, except that
  it colorizes its output, based on the priority of the message sent.
  
  You can configure the colors and attributes used for the different
  levels, by specifying them in your configuration:
  
      log4perl.appender.Screen.color.TRACE=cyan
      log4perl.appender.Screen.color.DEBUG=bold blue
  
  You can also specify nothing, to indicate that level should not have
  coloring applied, which means the text will be whatever the default
  color for your terminal is.  This is the default for debug messages.
  
      log4perl.appender.Screen.color.DEBUG=
  
  You can use any attribute supported by L<Term::ANSIColor> as a configuration
  option.
  
      log4perl.appender.Screen.color.FATAL=\
          bold underline blink red on_white
  
  The commonly used colors and attributes are:
  
  =over 4
  
  =item attributes
  
  BOLD, DARK, UNDERLINE, UNDERSCORE, BLINK
  
  =item colors
  
  BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE
  
  =item background colors
  
  ON_BLACK, ON_RED, ON_GREEN, ON_YELLOW, ON_BLUE, ON_MAGENTA, ON_CYAN, ON_WHITE
  
  =back
  
  See L<Term::ANSIColor> for a complete list, and information on which are
  supported by various common terminal emulators.
  
  The default values for these options are:
  
  =over 4
  
  =item Trace
  
  Yellow
  
  =item Debug
  
  None (whatever the terminal default is)
  
  =item Info
  
  Green
  
  =item Warn
  
  Blue
  
  =item Error
  
  Magenta
  
  =item Fatal
  
  Red
  
  =back
  
  The constructor C<new()> takes an optional parameter C<stderr>,
  if set to a true value, the appender will log all levels to STDERR.
  If C<stderr> is set to a false value, it will log all levels to
  STDOUT. Otherwise, C<stderr> may be set to a hash, with a key for
  each C<log4p_level> and a truthy value to dynamically use stderr.
  The default setting for C<stderr> is 1, so all messages will be logged
  to STDERR by default.
  
      # All messages/levels to STDERR
      my $app = Log::Log4perl::Appender::Screen->new(
          stderr  => 1,
      );
  
      # Only ERROR and FATAL to STDERR (case-sensitive)
      my $app = Log::Log4perl::Appender::Screen->new(
          stderr  => { ERROR => 1, FATAL => 1},
      );
  
  The constructor can also take an optional
  parameter C<color>, whose value is a  hashref of color configuration
  options, any levels that are not included in the hashref will be set
  to their default values.
  
  =head2 Using ScreenColoredLevels on Windows
  
  Note that if you're using this appender on Windows, you need to fetch
  Win32::Console::ANSI from CPAN and add
  
      use Win32::Console::ANSI;
  
  to your script.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_APPENDER_SCREENCOLOREDLEVELS

$fatpacked{"Log/Log4perl/Appender/Socket.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_SOCKET';
  ##################################################
  package Log::Log4perl::Appender::Socket;
  ##################################################
  our @ISA = qw(Log::Log4perl::Appender);
  
  use warnings;
  use strict;
  
  use IO::Socket::INET;
  
  ##################################################
  sub new {
  ##################################################
      my($class, @options) = @_;
  
      my $self = {
          name            => "unknown name",
          silent_recovery => 0,
          no_warning      => 0,
          PeerAddr        => "localhost",
          Proto           => 'tcp',
          Timeout         => 5,
          @options,
      };
  
      bless $self, $class;
  
      unless ($self->{defer_connection}){
          unless($self->connect(@options)) {
              if($self->{silent_recovery}) {
                  if( ! $self->{no_warning}) {
                      warn "Connect to $self->{PeerAddr}:$self->{PeerPort} failed: $!";
                  }
                 return $self;
              }
              die "Connect to $self->{PeerAddr}:$self->{PeerPort} failed: $!";
          }
  
          $self->{socket}->autoflush(1); 
          #autoflush has been the default behavior since 1997
      }
  
      return $self;
  }
      
  ##################################################
  sub connect {
  ##################################################
      my($self, @options) = @_;
  
      $self->{socket} = IO::Socket::INET->new(@options);
  
      return $self->{socket};
  }
  
  ##################################################
  sub log {
  ##################################################
      my($self, %params) = @_;
  
  
      {
              # If we were never able to establish
              # a connection, try to establish one 
              # here. If it fails, return.
          if(($self->{silent_recovery} or $self->{defer_connection}) and 
             !defined $self->{socket}) {
              if(! $self->connect(%$self)) {
                  return undef;
              }
          }
    
              # Try to send the message across
          eval { $self->{socket}->send($params{message}); 
               };
  
          if($@) {
              warn "Send to " . ref($self) . " failed ($@), retrying once...";
              if($self->connect(%$self)) {
                  redo;
              }
              if($self->{silent_recovery}) {
                  return undef;
              }
              warn "Reconnect to $self->{PeerAddr}:$self->{PeerPort} " .
                   "failed: $!";
              return undef;
          }
      };
  
      return 1;
  }
  
  ##################################################
  sub DESTROY {
  ##################################################
      my($self) = @_;
  
      undef $self->{socket};
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Appender::Socket - Log to a socket
  
  =head1 SYNOPSIS
  
      use Log::Log4perl::Appender::Socket;
  
      my $appender = Log::Log4perl::Appender::Socket->new(
        PeerAddr => "server.foo.com",
        PeerPort => 1234,
      );
  
      $appender->log(message => "Log me\n");
  
  =head1 DESCRIPTION
  
  This is a simple appender for writing to a socket. It relies on
  L<IO::Socket::INET> and offers all parameters this module offers.
  
  Upon destruction of the object, pending messages will be flushed
  and the socket will be closed.
  
  If the appender cannot contact the server during the initialization
  phase (while running the constructor C<new>), it will C<die()>.
  
  If the appender fails to log a message because the socket's C<send()>
  method fails (most likely because the server went down), it will
  try to reconnect once. If it succeeds, the message will be sent.
  If the reconnect fails, a warning is sent to STDERR and the C<log()>
  method returns, discarding the message.
  
  If the option C<silent_recovery> is given to the constructor and
  set to a true value, the behaviour is different: If the socket connection
  can't be established at initialization time, a single warning is issued.
  Every log attempt will then try to establish the connection and 
  discard the message silently if it fails.
  If you don't even want the warning, set the C<no_warning> option to
  a true value.
  
  Connecting at initialization time may not be the best option when
  running under Apache1 Apache2/prefork, because the parent process creates
  the socket and the connections are shared among the forked children--all
  the children writing to the same socket could intermingle messages.  So instead
  of that, you can use C<defer_connection> which will put off making the
  connection until the first log message is sent.
  
  =head1 EXAMPLE
  
  Write a server quickly using the IO::Socket::INET module:
  
      use IO::Socket::INET;
  
      my $sock = IO::Socket::INET->new(
          Listen    => 5,
          LocalAddr => 'localhost',
          LocalPort => 12345,
          Proto     => 'tcp');
  
      while(my $client = $sock->accept()) {
          print "Client connected\n";
          while(<$client>) {
              print "$_\n";
          }
      }
  
  Start it and then run the following script as a client:
  
      use Log::Log4perl qw(:easy);
  
      my $conf = q{
          log4perl.category                  = WARN, Socket
          log4perl.appender.Socket           = Log::Log4perl::Appender::Socket
          log4perl.appender.Socket.PeerAddr  = localhost
          log4perl.appender.Socket.PeerPort  = 12345
          log4perl.appender.Socket.layout    = SimpleLayout
      };
  
      Log::Log4perl->init(\$conf);
  
      sleep(2);
  
      for(1..10) {
          ERROR("Quack!");
          sleep(5);
      }
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_APPENDER_SOCKET

$fatpacked{"Log/Log4perl/Appender/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_STRING';
  package Log::Log4perl::Appender::String;
  our @ISA = qw(Log::Log4perl::Appender);
  
  ##################################################
  # Log dispatcher writing to a string buffer
  ##################################################
  
  ##################################################
  sub new {
  ##################################################
      my $proto  = shift;
      my $class  = ref $proto || $proto;
      my %params = @_;
  
      my $self = {
          name      => "unknown name",
          string    => "",
          %params,
      };
  
      bless $self, $class;
  }
  
  ##################################################
  sub log {   
  ##################################################
      my $self = shift;
      my %params = @_;
  
      $self->{string} .= $params{message};
  }
  
  ##################################################
  sub string {   
  ##################################################
      my($self, $new) = @_;
  
      if(defined $new) {
          $self->{string} = $new;
      }
  
      return $self->{string};
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Appender::String - Append to a string
  
  =head1 SYNOPSIS
  
    use Log::Log4perl::Appender::String;
  
    my $appender = Log::Log4perl::Appender::String->new( 
        name      => 'my string appender',
    );
  
        # Append to the string
    $appender->log( 
        message => "I'm searching the city for sci-fi wasabi\n" 
    );
  
        # Retrieve the result
    my $result = $appender->string();
  
        # Reset the buffer to the empty string
    $appender->string("");
  
  =head1 DESCRIPTION
  
  This is a simple appender used internally by C<Log::Log4perl>. It
  appends messages to a scalar instance variable.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_APPENDER_STRING

$fatpacked{"Log/Log4perl/Appender/Synchronized.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_SYNCHRONIZED';
  ######################################################################
  # Synchronized.pm -- 2003, 2007 Mike Schilli <m@perlmeister.com>
  ######################################################################
  # Special appender employing a locking strategy to synchronize
  # access.
  ######################################################################
  
  ###########################################
  package Log::Log4perl::Appender::Synchronized;
  ###########################################
  
  use strict;
  use warnings;
  use Log::Log4perl::Util::Semaphore;
  
  our @ISA = qw(Log::Log4perl::Appender);
  
  our $VERSION    = '1.53';
  
  ###########################################
  sub new {
  ###########################################
      my($class, %options) = @_;
  
      my $self = {
          appender=> undef,
          key     => '_l4p',
          level   => 0,
          %options,
      };
  
      my @values = ();
      for my $param (qw(uid gid mode destroy key)) {
          push @values, $param, $self->{$param} if defined $self->{$param};
      }
  
      $self->{sem} = Log::Log4perl::Util::Semaphore->new(
          @values
      );
  
          # Pass back the appender to be synchronized as a dependency
          # to the configuration file parser
      push @{$options{l4p_depends_on}}, $self->{appender};
  
          # Run our post_init method in the configurator after
          # all appenders have been defined to make sure the
          # appender we're synchronizing really exists
      push @{$options{l4p_post_config_subs}}, sub { $self->post_init() };
  
      bless $self, $class;
  }
  
  ###########################################
  sub log {
  ###########################################
      my($self, %params) = @_;
      
      $self->{sem}->semlock();
  
      # Relay that to the SUPER class which needs to render the
      # message according to the appender's layout, first.
      $Log::Log4perl::caller_depth +=2;
      $self->{app}->SUPER::log(\%params, 
                               $params{log4p_category},
                               $params{log4p_level});
      $Log::Log4perl::caller_depth -=2;
  
      $self->{sem}->semunlock();
  }
  
  ###########################################
  sub post_init {
  ###########################################
      my($self) = @_;
  
      if(! exists $self->{appender}) {
         die "No appender defined for " . __PACKAGE__;
      }
  
      my $appenders = Log::Log4perl->appenders();
      my $appender = Log::Log4perl->appenders()->{$self->{appender}};
  
      if(! defined $appender) {
         die "Appender $self->{appender} not defined (yet) when " .
             __PACKAGE__ . " needed it";
      }
  
      $self->{app} = $appender;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Appender::Synchronized - Synchronizing other appenders
  
  =head1 SYNOPSIS
  
      use Log::Log4perl qw(:easy);
  
      my $conf = qq(
      log4perl.category                   = WARN, Syncer
      
          # File appender (unsynchronized)
      log4perl.appender.Logfile           = Log::Log4perl::Appender::File
      log4perl.appender.Logfile.autoflush = 1
      log4perl.appender.Logfile.filename  = test.log
      log4perl.appender.Logfile.mode      = truncate
      log4perl.appender.Logfile.layout    = SimpleLayout
      
          # Synchronizing appender, using the file appender above
      log4perl.appender.Syncer            = Log::Log4perl::Appender::Synchronized
      log4perl.appender.Syncer.appender   = Logfile
  );
  
      Log::Log4perl->init(\$conf);
      WARN("This message is guaranteed to be complete.");
  
  =head1 DESCRIPTION
  
  If multiple processes are using the same C<Log::Log4perl> appender 
  without synchronization, overwrites might happen. A typical scenario
  for this would be a process spawning children, each of which inherits
  the parent's Log::Log4perl configuration.
  
  In most cases, you won't need an external synchronisation tool like
  Log::Log4perl::Appender::Synchronized at all. Log4perl's file appender, 
  Log::Log4perl::Appender::File, for example, provides the C<syswrite>
  mechanism for making sure that even long log lines won't interleave.
  Short log lines won't interleave anyway, because the operating system
  makes sure the line gets written before a task switch occurs.
  
  In cases where you need additional synchronization, however, you can use
  C<Log::Log4perl::Appender::Synchronized> as a gateway between your
  loggers and your appenders. An appender itself, 
  C<Log::Log4perl::Appender::Synchronized> just takes two additional
  arguments:
  
  =over 4
  
  =item C<appender>
  
  Specifies the name of the appender it synchronizes access to. The
  appender specified must be defined somewhere in the configuration file,
  not necessarily before the definition of 
  C<Log::Log4perl::Appender::Synchronized>.
  
  =item C<key>
  
  This optional argument specifies the key for the semaphore that
  C<Log::Log4perl::Appender::Synchronized> uses internally to ensure
  atomic operations. It defaults to C<_l4p>. If you define more than
  one C<Log::Log4perl::Appender::Synchronized> appender, it is 
  important to specify different keys for them, as otherwise every
  new C<Log::Log4perl::Appender::Synchronized> appender will nuke
  previously defined semaphores. The maximum key length is four
  characters, longer keys will be truncated to 4 characters -- 
  C<mylongkey1> and C<mylongkey2> are interpreted to be the same:
  C<mylo> (thanks to David Viner E<lt>dviner@yahoo-inc.comE<gt> for
  pointing this out).
  
  =back
  
  C<Log::Log4perl::Appender::Synchronized> uses Log::Log4perl::Util::Semaphore
  internally to perform locking with semaphores provided by the
  operating system used.
  
  =head2 Performance tips
  
  The C<Log::Log4perl::Appender::Synchronized> serializes access to a
  protected resource globally, slowing down actions otherwise performed in
  parallel.
  
  Unless specified otherwise, all instances of 
  C<Log::Log4perl::Appender::Synchronized> objects in the system will
  use the same global IPC key C<_l4p>.
  
  To control access to different appender instances, it often makes sense
  to define different keys for different synchronizing appenders. In this
  way, Log::Log4perl serializes access to each appender instance separately:
  
      log4perl.category                   = WARN, Syncer1, Syncer2
      
          # File appender 1 (unsynchronized)
      log4perl.appender.Logfile1           = Log::Log4perl::Appender::File
      log4perl.appender.Logfile1.filename  = test1.log
      log4perl.appender.Logfile1.layout    = SimpleLayout
      
          # File appender 2 (unsynchronized)
      log4perl.appender.Logfile2           = Log::Log4perl::Appender::File
      log4perl.appender.Logfile2.filename  = test2.log
      log4perl.appender.Logfile2.layout    = SimpleLayout
      
          # Synchronizing appender, using the file appender above
      log4perl.appender.Syncer1            = Log::Log4perl::Appender::Synchronized
      log4perl.appender.Syncer1.appender   = Logfile1
      log4perl.appender.Syncer1.key        = l4p1
  
          # Synchronizing appender, using the file appender above
      log4perl.appender.Syncer2            = Log::Log4perl::Appender::Synchronized
      log4perl.appender.Syncer2.appender   = Logfile2
      log4perl.appender.Syncer2.key        = l4p2
  
  Without the C<.key = l4p1> and C<.key = l4p2> lines, both Synchronized 
  appenders would be using the default C<_l4p> key, causing unnecessary
  serialization of output written to different files.
  
  =head2 Advanced configuration
  
  To configure the underlying Log::Log4perl::Util::Semaphore module in 
  a different way than with the default settings provided by 
  Log::Log4perl::Appender::Synchronized, use the following parameters:
  
      log4perl.appender.Syncer1.destroy  = 1
      log4perl.appender.Syncer1.mode     = sub { 0775 }
      log4perl.appender.Syncer1.uid      = hugo
      log4perl.appender.Syncer1.gid      = 100
  
  Valid options are 
  C<destroy> (Remove the semaphore on exit), 
  C<mode> (permissions on the semaphore), 
  C<uid> (uid or user name the semaphore is owned by), 
  and
  C<gid> (group id the semaphore is owned by), 
  
  Note that C<mode> is usually given in octal and therefore needs to be
  specified as a perl sub {}, unless you want to calculate what 0755 means
  in decimal.
  
  Changing ownership or group settings for a semaphore will obviously only
  work if the current user ID owns the semaphore already or if the current
  user is C<root>. The C<destroy> option causes the current process to 
  destroy the semaphore on exit. Spawned children of the process won't
  inherit this behavior.
  
  =head2 Semaphore user and group IDs with mod_perl
  
  Setting user and group IDs is especially important when the Synchronized
  appender is used with mod_perl. If Log4perl gets initialized by a startup
  handler, which runs as root, and not as the user who will later use
  the semaphore, the settings for uid, gid, and mode can help establish 
  matching semaphore ownership and access rights.
  
  =head1 DEVELOPMENT NOTES
  
  C<Log::Log4perl::Appender::Synchronized> is a I<composite> appender.
  Unlike other appenders, it doesn't log any messages, it just
  passes them on to its attached sub-appender.
  For this reason, it doesn't need a layout (contrary to regular appenders).
  If it defines none, messages are passed on unaltered.
  
  Custom filters are also applied to the composite appender only.
  They are I<not> applied to the sub-appender. Same applies to appender
  thresholds. This behaviour might change in the future.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_APPENDER_SYNCHRONIZED

$fatpacked{"Log/Log4perl/Appender/TestArrayBuffer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_TESTARRAYBUFFER';
  ##################################################
  package Log::Log4perl::Appender::TestArrayBuffer;
  ##################################################
  # Like Log::Log4perl::Appender::TestBuffer, just with 
  # array capability.
  # For testing only.
  ##################################################
  
  use base qw( Log::Log4perl::Appender::TestBuffer );
  
  ##################################################
  sub log {   
  ##################################################
      my $self = shift;
      my %params = @_;
  
      $self->{buffer} .= "[$params{level}]: " if $LOG_PRIORITY;
  
      if(ref($params{message}) eq "ARRAY") {
          $self->{buffer} .= "[" . join(',', @{$params{message}}) . "]";
      } else {
          $self->{buffer} .= $params{message};
      }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Appender::TestArrayBuffer - Subclass of Appender::TestBuffer
  
  =head1 SYNOPSIS
  
    use Log::Log4perl::Appender::TestArrayBuffer;
  
    my $appender = Log::Log4perl::Appender::TestArrayBuffer->new( 
        name      => 'buffer',
    );
  
        # Append to the buffer
    $appender->log( 
        level =  > 'alert', 
        message => ['first', 'second', 'third'],
    );
  
        # Retrieve the result
    my $result = $appender->buffer();
  
        # Reset the buffer to the empty string
    $appender->reset();
  
  =head1 DESCRIPTION
  
  This class is a subclass of Log::Log4perl::Appender::TestBuffer and
  just provides message array refs as an additional feature. 
  
  Just like Log::Log4perl::Appender::TestBuffer, 
  Log::Log4perl::Appender::TestArrayBuffer is used for internal
  Log::Log4perl testing only.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_APPENDER_TESTARRAYBUFFER

$fatpacked{"Log/Log4perl/Appender/TestBuffer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_TESTBUFFER';
  package Log::Log4perl::Appender::TestBuffer;
  our @ISA = qw(Log::Log4perl::Appender);
  
  ##################################################
  # Log dispatcher writing to a string buffer
  # For testing.
  # This is like having a Log::Log4perl::Appender::TestBuffer
  ##################################################
  
  our %POPULATION       = ();
  our $LOG_PRIORITY     = 0;
  our $DESTROY_MESSAGES = "";
  
  ##################################################
  sub new {
  ##################################################
      my $proto  = shift;
      my $class  = ref $proto || $proto;
      my %params = @_;
  
      my $self = {
          name      => "unknown name",
          %params,
      };
  
      bless $self, $class;
  
      $self->{stderr} = exists $params{stderr} ? $params{stderr} : 1;
      $self->{buffer} = "";
  
      $POPULATION{$self->{name}} = $self;
  
      return $self;
  }
  
  ##################################################
  sub log {   
  ##################################################
      my $self = shift;
      my %params = @_;
  
      if( !defined $params{level} ) {
          die "No level defined in log() call of " . __PACKAGE__;
      }
      $self->{buffer} .= "[$params{level}]: " if $LOG_PRIORITY;
      $self->{buffer} .= $params{message};
  }
  
  ###########################################
  sub clear {
  ###########################################
      my($self) = @_;
  
      $self->{buffer} = "";
  }
  
  ##################################################
  sub buffer {   
  ##################################################
      my($self, $new) = @_;
  
      if(defined $new) {
          $self->{buffer} = $new;
      }
  
      return $self->{buffer};
  }
  
  ##################################################
  sub reset {   
  ##################################################
      my($self) = @_;
  
      %POPULATION = ();
      $self->{buffer} = "";
  }
  
  ##################################################
  sub DESTROY {   
  ##################################################
      my($self) = @_;
  
      $DESTROY_MESSAGES .= __PACKAGE__ . " destroyed";
  
      #this delete() along with &reset() above was causing
      #Attempt to free unreferenced scalar at 
      #blib/lib/Log/Log4perl/TestBuffer.pm line 69.
      #delete $POPULATION{$self->name};
  }
  
  ##################################################
  sub by_name {   
  ##################################################
      my($self, $name) = @_;
  
      # Return a TestBuffer by appender name. This is useful if
      # test buffers are created behind our back (e.g. via the
      # Log4perl config file) and later on we want to 
      # retrieve an instance to query its content.
  
      die "No name given"  unless defined $name;
  
      return $POPULATION{$name};
  
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Appender::TestBuffer - Appender class for testing
  
  =head1 SYNOPSIS
  
    use Log::Log4perl::Appender::TestBuffer;
  
    my $appender = Log::Log4perl::Appender::TestBuffer->new( 
        name      => 'mybuffer',
    );
  
        # Append to the buffer
    $appender->log( 
        level =  > 'alert', 
        message => "I'm searching the city for sci-fi wasabi\n" 
    );
  
        # Retrieve the result
    my $result = $appender->buffer();
  
        # Clear the buffer to the empty string
    $appender->clear();
  
  =head1 DESCRIPTION
  
  This class is used for internal testing of C<Log::Log4perl>. It
  is a C<Log::Dispatch>-style appender, which writes to a buffer 
  in memory, from where actual results can be easily retrieved later
  to compare with expected results.
  
  Every buffer created is stored in an internal global array, and can
  later be referenced by name:
  
      my $app = Log::Log4perl::Appender::TestBuffer->by_name("mybuffer");
  
  retrieves the appender object of a previously created buffer "mybuffer".
  To reset this global array and have it forget all of the previously 
  created testbuffer appenders (external references to those appenders
  nonwithstanding), use
  
      Log::Log4perl::Appender::TestBuffer->reset();
  
  =head1 SEE ALSO
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_APPENDER_TESTBUFFER

$fatpacked{"Log/Log4perl/Appender/TestFileCreeper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_TESTFILECREEPER';
  ##################################################
  package Log::Log4perl::Appender::TestFileCreeper;
  ##################################################
  # Test appender, intentionally slow. It writes 
  # out one byte at a time to provoke sync errors.
  # Don't use it, unless for testing.
  ##################################################
  
  use warnings;
  use strict;
  
  use Log::Log4perl::Appender::File;
  
  our @ISA = qw(Log::Log4perl::Appender::File);
  
  ##################################################
  sub log {
  ##################################################
      my($self, %params) = @_;
  
      my $fh = $self->{fh};
  
      for (split //, $params{message}) {
          print $fh $_;
          my $oldfh = select $self->{fh}; 
          $| = 1; 
          select $oldfh;
      }
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Appender::TestFileCreeper - Intentionally slow test appender
  
  =head1 SYNOPSIS
  
      use Log::Log4perl::Appender::TestFileCreeper;
  
      my $app = Log::Log4perl::Appender::TestFileCreeper->new(
        filename  => 'file.log',
        mode      => 'append',
      );
  
      $file->log(message => "Log me\n");
  
  =head1 DESCRIPTION
  
  This is a test appender, and it is intentionally slow. It writes 
  out one byte at a time to provoke sync errors. Don't use it, unless 
  for testing.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_APPENDER_TESTFILECREEPER

$fatpacked{"Log/Log4perl/Catalyst.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_CATALYST';
  package Log::Log4perl::Catalyst;
  
  use strict;
  use Log::Log4perl qw(:levels);
  use Log::Log4perl::Logger;
  
  our $VERSION                  = '1.53';
  our $CATALYST_APPENDER_SUFFIX = "catalyst_buffer";
  our $LOG_LEVEL_ADJUSTMENT     = 1;
  
  init();
  
  ##################################################
  sub init {
  ##################################################
  
      my @levels = qw[ trace debug info warn error fatal ];
  
      Log::Log4perl->wrapper_register(__PACKAGE__);
  
      for my $level (@levels) {
          no strict 'refs';
  
          *{$level} = sub {
              my ( $self, @message ) = @_;
  
              local $Log::Log4perl::caller_depth =
                    $Log::Log4perl::caller_depth +
                       $LOG_LEVEL_ADJUSTMENT;
  
              my $logger = Log::Log4perl->get_logger();
              $logger->$level(@message);
              return 1;
          };
  
          *{"is_$level"} = sub {
              my ( $self, @message ) = @_;
  
              local $Log::Log4perl::caller_depth =
                    $Log::Log4perl::caller_depth +
                       $LOG_LEVEL_ADJUSTMENT;
  
              my $logger = Log::Log4perl->get_logger();
              my $func   = "is_" . $level;
              return $logger->$func;
          };
      }
  }
  
  ##################################################
  sub new {
  ##################################################
      my($class, $config, %options) = @_;
  
      my $self = {
          autoflush   => 0,
          abort       => 0,
          watch_delay => 0,
          %options,
      };
  
      if( !Log::Log4perl->initialized() ) {
          if( defined $config ) {
              if( $self->{watch_delay} ) {
                  Log::Log4perl::init_and_watch( $config, $self->{watch_delay} );
              } else {
                  Log::Log4perl::init( $config );
              }
          } else {
               Log::Log4perl->easy_init({
                   level  => $DEBUG,
                   layout => "[%d] [catalyst] [%p] %m%n",
               });
          }
      }
  
        # Unless we have autoflush, Catalyst likes to buffer all messages
        # until it calls flush(). This is somewhat unusual for Log4perl,
        # but we just put an army of buffer appenders in front of all 
        # appenders defined in the system.
  
      if(! $options{autoflush} ) {
          for my $appender (values %Log::Log4perl::Logger::APPENDER_BY_NAME) {
              next if $appender->{name} =~ /_$CATALYST_APPENDER_SUFFIX$/;
  
              # put a buffering appender in front of every appender
              # defined so far
  
              my $buf_app_name = "$appender->{name}_$CATALYST_APPENDER_SUFFIX";
  
              my $buf_app = Log::Log4perl::Appender->new(
                  'Log::Log4perl::Appender::Buffer',
                  name       => $buf_app_name,
                  appender   => $appender->{name},
                  trigger    => sub { 0 },    # only trigger on explicit flush()
              );
  
              Log::Log4perl->add_appender($buf_app);
              $buf_app->post_init();
              $buf_app->composite(1);
  
              # Point all loggers currently connected to the previously defined
              # appenders to the chained buffer appenders instead.
  
              foreach my $logger (
                             values %$Log::Log4perl::Logger::LOGGERS_BY_NAME){
                  if(defined $logger->remove_appender( $appender->{name}, 0, 1)) {
                      $logger->add_appender( $buf_app );
                  }
              }
          }
      }
  
      bless $self, $class;
  
      return $self;
  }
  
  ##################################################
  sub _flush {
  ##################################################
      my ($self) = @_;
  
      for my $appender (values %Log::Log4perl::Logger::APPENDER_BY_NAME) {
          next if $appender->{name} !~ /_$CATALYST_APPENDER_SUFFIX$/;
  
          if ($self->abort) {
              $appender->{appender}{buffer} = [];
          }
          else {
              $appender->flush();
          }
      }
  
      $self->abort(undef);
  }
  
  ##################################################
  sub abort {
  ##################################################
      my $self = shift;
  
      $self->{abort} = $_[0] if @_;
  
      return $self->{abort};
  }
  
  ##################################################
  sub levels {
  ##################################################
        # stub function, until we have something meaningful
      return 0;
  }
  
  ##################################################
  sub enable {
  ##################################################
        # stub function, until we have something meaningful
      return 0;
  }
  
  ##################################################
  sub disable {
  ##################################################
        # stub function, until we have something meaningful
      return 0;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Catalyst - Log::Log4perl Catalyst Module
  
  =head1 SYNOPSIS
  
  In your main Catalyst application module:
  
    use Log::Log4perl::Catalyst;
  
      # Either make Log4perl act like the Catalyst default logger:
    __PACKAGE__->log(Log::Log4perl::Catalyst->new());
  
      # or use a Log4perl configuration file, utilizing the full 
      # functionality of Log4perl
    __PACKAGE__->log(Log::Log4perl::Catalyst->new('l4p.conf'));
    
  ... and then sprinkle logging statements all over any code executed
  by Catalyst:
  
      $c->log->debug("This is using log4perl!");
  
  =head1 DESCRIPTION
  
  This module provides Log4perl functions to Catalyst applications. It was
  inspired by Catalyst::Log::Log4perl on CPAN, but has been completely 
  rewritten and uses a different approach to unite Catalyst and Log4perl.
  
  Log4perl provides loggers, usually associated with the current
  package, which can then be remote-controlled by a central
  configuration. This means that if you have a controller function like
  
      package MyApp::Controller::User;
  
      sub add : Chained('base'): PathPart('add'): Args(0) {
          my ( $self, $c ) = @_;
  
          $c->log->info("Adding a user");
          # ...
      }
  
  Level-based control is available via the following methods:
  
     $c->log->debug("Reading configuration");
     $c->log->info("Adding a user");
     $c->log->warn("Can't read configuration ($!)");
     $c->log->error("Can't add user ", $user);
     $c->log->fatal("Database down, aborting request");
  
  But that's not all, Log4perl is much more powerful.
  
  The logging statement can be suppressed or activated based on a Log4perl
  file that looks like
  
        # All MyApp loggers opened up for DEBUG and above
      log4perl.logger.MyApp = DEBUG, Screen
      # ...
  
  or 
  
        # All loggers block messages below INFO
      log4perl.logger=INFO, Screen
      # ...
  
  respectively. See the Log4perl manpage on how to perform fine-grained 
  log-level and location filtering, and how to forward messages not only
  to the screen or to log files, but also to databases, email appenders,
  and much more.
  
  Also, you can change the message layout. For example if you want
  to know where a particular statement was logged, turn on file names and 
  line numbers:
  
      # Log4perl configuration file
      # ...
      log4perl.appender.Screen.layout.ConversionPattern = \
            %F{1}-%L: %p %m%n
  
  Messages will then look like
  
      MyApp.pm-1869: INFO Saving user profile for user "wonko"
  
  Or want to log a request's IP address with every log statement? No problem 
  with Log4perl, just call
  
      Log::Log4perl::MDC->put( "ip", $c->req->address() );
  
  at the beginning of the request cycle and use
  
      # Log4perl configuration file
      # ...
      log4perl.appender.Screen.layout.ConversionPattern = \
            [%d]-%X{ip} %F{1}-%L: %p %m%n
  
  as a Log4perl layout. Messages will look like
  
      [2010/02/22 23:25:55]-123.122.108.10 MyApp.pm-1953: INFO Reading profile for user "wonko"
  
  Again, check the Log4perl manual page, there's a plethora of configuration
  options.
  
  =head1 METHODS
  
  =over 4
  
  =item new($config, [%options])
  
  If called without parameters, new() initializes Log4perl in a way 
  so that messages are logged similarly to Catalyst's default logging
  mechanism. If you provide a configuration, either the name of a configuration
  file or a reference to a scalar string containing the configuration, it
  will call Log4perl with these parameters.
  
  The second (optional) parameter is a list of key/value pairs:
  
    'autoflush'   =>  1   # Log without buffering ('abort' not supported)
    'watch_delay' => 30   # If set, use L<Log::Log4perl>'s init_and_watch
  
  =item _flush()
  
  Flushes the cache.
  
  =item abort($abort)
  
  Clears the logging system's internal buffers without logging anything.
  
  =back
  
  =head2 Using :easy Macros with Catalyst
  
  If you're tired of typing
  
      $c->log->debug("...");
  
  and would prefer to use Log4perl's convenient :easy mode macros like
  
      DEBUG "...";
  
  then just pull those macros in via Log::Log4perl's :easy mode and start
  cranking:
  
      use Log::Log4perl qw(:easy);
  
        # ... use macros later on
      sub base :Chained('/') :PathPart('apples') :CaptureArgs(0) {
          my ( $self, $c ) = @_;
  
          DEBUG "Handling apples";
      }
  
  Note the difference between Log4perl's initialization in Catalyst, which
  uses the Catalyst-specific Log::Log4perl::Catalyst module (top of this
  page), and making use of Log4perl's loggers with the standard 
  Log::Log4perl loggers and macros. While initialization requires Log4perl
  to perform dark magic to conform to Catalyst's different logging strategy,
  obtaining Log4perl's logger objects or calling its macros are unchanged.
  
  Instead of using Catalyst's way of referencing the "context" object $c to 
  obtain logger references via its log() method, you can just as well use 
  Log4perl's get_logger() or macros to access Log4perl's logger singletons. 
  The result is the same.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_CATALYST

$fatpacked{"Log/Log4perl/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_CONFIG';
  ##################################################
  package Log::Log4perl::Config;
  ##################################################
  use 5.006;
  use strict;
  use warnings;
  
  use Log::Log4perl::Logger;
  use Log::Log4perl::Level;
  use Log::Log4perl::Config::PropertyConfigurator;
  use Log::Log4perl::JavaMap;
  use Log::Log4perl::Filter;
  use Log::Log4perl::Filter::Boolean;
  use Log::Log4perl::Config::Watch;
  
  use constant _INTERNAL_DEBUG => 0;
  
  our $CONFIG_FILE_READS       = 0;
  our $CONFIG_INTEGRITY_CHECK  = 1;
  our $CONFIG_INTEGRITY_ERROR  = undef;
  
  our $WATCHER;
  our $DEFAULT_WATCH_DELAY = 60; # seconds
  our $OPTS = {};
  our $OLD_CONFIG;
  our $LOGGERS_DEFINED;
  our $UTF8 = 0;
  
  ###########################################
  sub init {
  ###########################################
      Log::Log4perl::Logger->reset();
  
      undef $WATCHER; # just in case there's a one left over (e.g. test cases)
  
      return _init(@_);
  }
  
  ###########################################
  sub utf8 {
  ###########################################
      my( $class, $flag ) = @_;
  
      $UTF8 = $flag if defined $flag;
  
      return $UTF8;
  }
  
  ###########################################
  sub watcher {
  ###########################################
      return $WATCHER;
  }
  
  ###########################################
  sub init_and_watch {
  ###########################################
      my ($class, $config, $delay, $opts) = @_;
          # delay can be a signal name - in this case we're gonna
          # set up a signal handler.
  
      if(defined $WATCHER) {
          $config = $WATCHER->file();
          if(defined $Log::Log4perl::Config::Watch::SIGNAL_CAUGHT) {
              $delay  = $WATCHER->signal();
          } else {
              $delay  = $WATCHER->check_interval();
          }
      }
  
      print "init_and_watch ($config-$delay). Resetting.\n" if _INTERNAL_DEBUG;
  
      Log::Log4perl::Logger->reset();
  
      defined ($delay) or $delay = $DEFAULT_WATCH_DELAY;  
  
      if (ref $config) {
          die "Log4perl can only watch a file, not a string of " .
              "configuration information";
      }elsif ($config =~ m!^(https?|ftp|wais|gopher|file):!){
          die "Log4perl can only watch a file, not a url like $config";
      }
  
      if($delay =~ /\D/) {
          $WATCHER = Log::Log4perl::Config::Watch->new(
                            file         => $config,
                            signal       => $delay,
                            l4p_internal => 1,
                     );
      } else {
          $WATCHER = Log::Log4perl::Config::Watch->new(
                            file           => $config,
                            check_interval => $delay,
                            l4p_internal   => 1,
                     );
      }
  
      if(defined $opts) {
          die "Parameter $opts needs to be a hash ref" if ref($opts) ne "HASH";
          $OPTS = $opts;
      }
  
      eval { _init($class, $config); };
  
      if($@) {
          die "$@" unless defined $OLD_CONFIG;
              # Call _init with a pre-parsed config to go back to old setting
          _init($class, undef, $OLD_CONFIG);
          warn "Loading new config failed, reverted to old one\n";
      }
  }
  
  ##################################################
  sub _init {
  ##################################################
      my($class, $config, $data) = @_;
  
      my %additivity = ();
  
      $LOGGERS_DEFINED = 0;
  
      print "Calling _init\n" if _INTERNAL_DEBUG;
  
      #keep track so we don't create the same one twice
      my %appenders_created = ();
  
      #some appenders need to run certain subroutines right at the
      #end of the configuration phase, when all settings are in place.
      my @post_config_subs  = ();
  
      # This logic is probably suited to win an obfuscated programming
      # contest. It desperately needs to be rewritten.
      # Basically, it works like this:
      # config_read() reads the entire config file into a hash of hashes:
      #     log4j.logger.foo.bar.baz: WARN, A1
      # gets transformed into
      #     $data->{log4j}->{logger}->{foo}->{bar}->{baz} = "WARN, A1";
      # The code below creates the necessary loggers, sets the appenders
      # and the layouts etc.
      # In order to transform parts of this tree back into identifiers
      # (like "foo.bar.baz"), we're using the leaf_paths functions below.
      # Pretty scary. But it allows the lines of the config file to be
      # in *arbitrary* order.
  
      $data = config_read($config) unless defined $data;
      
      if(_INTERNAL_DEBUG) {
          require Data::Dumper;
          Data::Dumper->import();
          print Data::Dumper::Dumper($data);
      }
  
      my @loggers      = ();
      my %filter_names = ();
  
      my $system_wide_threshold;
  
        # Autocorrect the rootlogger/rootLogger typo
      if(exists $data->{rootlogger} and 
         ! exists $data->{rootLogger}) {
           $data->{rootLogger} = $data->{rootlogger};
      }
  
          # Find all logger definitions in the conf file. Start
          # with root loggers.
      if(exists $data->{rootLogger}) {
          $LOGGERS_DEFINED++;
          push @loggers, ["", $data->{rootLogger}->{value}];
      }
          
          # Check if we've got a system-wide threshold setting
      if(exists $data->{threshold}) {
              # yes, we do.
          $system_wide_threshold = $data->{threshold}->{value};
      }
  
      if (exists $data->{oneMessagePerAppender}){
                      $Log::Log4perl::one_message_per_appender = 
                          $data->{oneMessagePerAppender}->{value};
      }
  
      if(exists $data->{utcDateTimes}) {
          require Log::Log4perl::DateFormat;
            # Need to split this up in two lines, or CVS will
            # mess it up.
          $Log::Log4perl::DateFormat::GMTIME = 
            !!$data->{utcDateTimes}->{value};
      }
  
          # Boolean filters 
      my %boolean_filters = ();
  
          # Continue with lower level loggers. Both 'logger' and 'category'
          # are valid keywords. Also 'additivity' is one, having a logger
          # attached. We'll differentiate between the two further down.
      for my $key (qw(logger category additivity PatternLayout filter)) {
  
          if(exists $data->{$key}) {
  
              for my $path (@{leaf_paths($data->{$key})}) {
  
                  print "Path before: @$path\n" if _INTERNAL_DEBUG;
  
                  my $value = boolean_to_perlish(pop @$path);
  
                  pop @$path; # Drop the 'value' keyword part
  
                  if($key eq "additivity") {
                      # This isn't a logger but an additivity setting.
                      # Save it in a hash under the logger's name for later.
                      $additivity{join('.', @$path)} = $value;
  
                      #a global user-defined conversion specifier (cspec)
                  }elsif ($key eq "PatternLayout"){
                      &add_global_cspec(@$path[-1], $value);
  
                  }elsif ($key eq "filter"){
                      print "Found entry @$path\n" if _INTERNAL_DEBUG;
                      $filter_names{@$path[0]}++;
                  } else {
  
                      if (ref($value) eq "ARRAY") {
                        die "Multiple definitions of logger ".join('.',@$path)." in log4perl config";
                      }
  
                      # This is a regular logger
                      $LOGGERS_DEFINED++;
                      push @loggers, [join('.', @$path), $value];
                  }
              }
          }
      }
  
          # Now go over all filters found by name
      for my $filter_name (sort keys %filter_names) {
  
          print "Checking filter $filter_name\n" if _INTERNAL_DEBUG;
  
              # The boolean filter needs all other filters already
              # initialized, defer its initialization
          if($data->{filter}->{$filter_name}->{value} eq
             "Log::Log4perl::Filter::Boolean") {
              print "Boolean filter ($filter_name)\n" if _INTERNAL_DEBUG;
              $boolean_filters{$filter_name}++;
              next;
          }
  
          my $type = $data->{filter}->{$filter_name}->{value};
          if(my $code = compile_if_perl($type)) {
              $type = $code;
          }
          
          print "Filter $filter_name is of type $type\n" if _INTERNAL_DEBUG;
  
          my $filter;
  
          if(ref($type) eq "CODE") {
                  # Subroutine - map into generic Log::Log4perl::Filter class
              $filter = Log::Log4perl::Filter->new($filter_name, $type);
          } else {
                  # Filter class
                  die "Filter class '$type' doesn't exist" unless
                       Log::Log4perl::Util::module_available($type);
                  eval "require $type" or die "Require of $type failed ($!)";
  
                  # Invoke with all defined parameter
                  # key/values (except the key 'value' which is the entry 
                  # for the class)
              $filter = $type->new(name => $filter_name,
                  map { $_ => $data->{filter}->{$filter_name}->{$_}->{value} } 
                  grep { $_ ne "value" } 
                  sort keys %{$data->{filter}->{$filter_name}});
          }
              # Register filter with the global filter registry
          $filter->register();
      }
  
          # Initialize boolean filters (they need the other filters to be
          # initialized to be able to compile their logic)
      for my $name (sort keys %boolean_filters) {
          my $logic = $data->{filter}->{$name}->{logic}->{value};
          die "No logic defined for boolean filter $name" unless defined $logic;
          my $filter = Log::Log4perl::Filter::Boolean->new(
                           name  => $name, 
                           logic => $logic);
          $filter->register();
      }
  
      for (@loggers) {
          my($name, $value) = @$_;
  
          my $logger = Log::Log4perl::Logger->get_logger($name);
          my ($level, @appnames) = split /\s*,\s*/, $value;
  
          $logger->level(
              Log::Log4perl::Level::to_priority($level),
              'dont_reset_all');
  
          if(exists $additivity{$name}) {
              $logger->additivity($additivity{$name}, 1);
          }
  
          for my $appname (@appnames) {
  
              my $appender = create_appender_instance(
                  $data, $appname, \%appenders_created, \@post_config_subs,
                  $system_wide_threshold);
  
              $logger->add_appender($appender, 'dont_reset_all');
              set_appender_by_name($appname, $appender, \%appenders_created);
          }
      }
  
      #run post_config subs
      for(@post_config_subs) {
          $_->();
      }
  
      #now we're done, set up all the output methods (e.g. ->debug('...'))
      Log::Log4perl::Logger::reset_all_output_methods();
  
      #Run a sanity test on the config not disabled
      if($Log::Log4perl::Config::CONFIG_INTEGRITY_CHECK and
         !config_is_sane()) {
          warn "Log::Log4perl configuration looks suspicious: ",
               "$CONFIG_INTEGRITY_ERROR";
      }
  
          # Successful init(), save config for later
      $OLD_CONFIG = $data;
  
      $Log::Log4perl::Logger::INITIALIZED = 1;
  }
  
  ##################################################
  sub config_is_sane {
  ##################################################
      if(! $LOGGERS_DEFINED) {
          $CONFIG_INTEGRITY_ERROR = "No loggers defined";
          return 0;
      }    
  
      if(scalar keys %Log::Log4perl::Logger::APPENDER_BY_NAME == 0) {
          $CONFIG_INTEGRITY_ERROR = "No appenders defined";
          return 0;
      }
  
      return 1;
  }
  
  ##################################################
  sub create_appender_instance {
  ##################################################
      my($data, $appname, $appenders_created, $post_config_subs,
         $system_wide_threshold) = @_;
  
      my $appenderclass = get_appender_by_name(
              $data, $appname, $appenders_created);
  
      print "appenderclass=$appenderclass\n" if _INTERNAL_DEBUG;
  
      my $appender;
  
      if (ref $appenderclass) {
          $appender = $appenderclass;
      } else {
          die "ERROR: you didn't tell me how to " .
              "implement your appender '$appname'"
                  unless $appenderclass;
  
          if (Log::Log4perl::JavaMap::translate($appenderclass)){
              # It's Java. Try to map
              print "Trying to map Java $appname\n" if _INTERNAL_DEBUG;
              $appender = Log::Log4perl::JavaMap::get($appname, 
                                          $data->{appender}->{$appname});
  
          }else{
              # It's Perl
              my @params = grep { $_ ne "layout" and
                                  $_ ne "value"
                                } sort keys %{$data->{appender}->{$appname}};
      
              my %param = ();
              foreach my $pname (@params){
                  #this could be simple value like 
                  #{appender}{myAppender}{file}{value} => 'log.txt'
                  #or a structure like
                  #{appender}{myAppender}{login} => 
                  #                         { name => {value => 'bob'},
                  #                           pwd  => {value => 'xxx'},
                  #                         }
                  #in the latter case we send a hashref to the appender
                  if (exists $data->{appender}{$appname}
                                    {$pname}{value}      ) {
                      $param{$pname} = $data->{appender}{$appname}
                                              {$pname}{value};
                  }else{
                      $param{$pname} = {map {$_ => $data->{appender}
                                                          {$appname}
                                                          {$pname}
                                                          {$_}
                                                          {value}} 
                                       sort keys %{$data->{appender}
                                                     {$appname}
                                                     {$pname}}
                                       };
                  }
      
              }
  
              my $depends_on = [];
      
              $appender = Log::Log4perl::Appender->new(
                  $appenderclass, 
                  name                 => $appname,
                  l4p_post_config_subs => $post_config_subs,
                  l4p_depends_on       => $depends_on,
                  %param,
              ); 
      
              for my $dependency (@$depends_on) {
                  # If this appender indicates that it needs other appenders
                  # to exist (e.g. because it's a composite appender that
                  # relays messages on to its appender-refs) then we're 
                  # creating their instances here. Reason for this is that 
                  # these appenders are not attached to any logger and are
                  # therefore missed by the config parser which goes through
                  # the defined loggers and just creates *their* attached
                  # appenders.
                  $appender->composite(1);
                  next if exists $appenders_created->{$appname};
                  my $app = create_appender_instance($data, $dependency, 
                               $appenders_created,
                               $post_config_subs);
                  # If the appender appended a subroutine to $post_config_subs
                  # (a reference to an array of subroutines)
                  # here, the configuration parser will later execute this
                  # method. This is used by a composite appender which needs
                  # to make sure all of its appender-refs are available when
                  # all configuration settings are done.
  
                  # Smuggle this sub-appender into the hash of known appenders 
                  # without attaching it to any logger directly.
                  $
                  Log::Log4perl::Logger::APPENDER_BY_NAME{$dependency} = $app;
              }
          }
      }
  
      add_layout_by_name($data, $appender, $appname) unless
          $appender->composite();
  
         # Check for appender thresholds
      my $threshold = 
         $data->{appender}->{$appname}->{Threshold}->{value};
  
      if(defined $system_wide_threshold and
         !defined $threshold) {
          $threshold = $system_wide_threshold;
      }
  
      if(defined $threshold) {
              # Need to split into two lines because of CVS
          $appender->threshold($
              Log::Log4perl::Level::PRIORITY{$threshold});
      }
  
          # Check for custom filters attached to the appender
      my $filtername = 
         $data->{appender}->{$appname}->{Filter}->{value};
      if(defined $filtername) {
              # Need to split into two lines because of CVS
          my $filter = Log::Log4perl::Filter::by_name($filtername);
          die "Filter $filtername doesn't exist" unless defined $filter;
          $appender->filter($filter);
      }
  
      if(defined $system_wide_threshold and
         defined $threshold and
         $
          Log::Log4perl::Level::PRIORITY{$system_wide_threshold} > 
         $
           Log::Log4perl::Level::PRIORITY{$threshold}
        ) {
          $appender->threshold($
              Log::Log4perl::Level::PRIORITY{$system_wide_threshold});
      }
  
      if(exists $data->{appender}->{$appname}->{threshold}) {
          die "invalid keyword 'threshold' - perhaps you meant 'Threshold'?";
      }
  
      return $appender;
  }
  
  ###########################################
  sub add_layout_by_name {
  ###########################################
      my($data, $appender, $appender_name) = @_;
  
      my $layout_class = $data->{appender}->{$appender_name}->{layout}->{value};
  
      die "Layout not specified for appender $appender_name" unless $layout_class;
  
      $layout_class =~ s/org.apache.log4j./Log::Log4perl::Layout::/;
  
          # Check if we have this layout class
      if(!Log::Log4perl::Util::module_available($layout_class)) {
          if(Log::Log4perl::Util::module_available(
             "Log::Log4perl::Layout::$layout_class")) {
              # Someone used the layout shortcut, use the fully qualified
              # module name instead.
              $layout_class = "Log::Log4perl::Layout::$layout_class";
          } else {
              die "ERROR: trying to set layout for $appender_name to " .
                  "'$layout_class' failed ($@)";
          }
      }
      Log::Log4perl::Util::module_available($layout_class) or
          die "Require to $layout_class failed ($@)";
  
      $appender->layout($layout_class->new(
          $data->{appender}->{$appender_name}->{layout},
          ));
  }
  
  ###########################################
  sub get_appender_by_name {
  ###########################################
      my($data, $name, $appenders_created) = @_;
  
      if (exists $appenders_created->{$name}) {
          return $appenders_created->{$name};
      } else {
          return $data->{appender}->{$name}->{value};
      }
  }
  
  ###########################################
  sub set_appender_by_name {
  ###########################################
  # keep track of appenders we've already created
  ###########################################
      my($appname, $appender, $appenders_created) = @_;
  
      $appenders_created->{$appname} ||= $appender;
  }
  
  ##################################################
  sub add_global_cspec {
  ##################################################
  # the config file said
  # log4j.PatternLayout.cspec.Z=sub {return $$*2}
  ##################################################
      my ($letter, $perlcode) = @_;
  
      die "error: only single letters allowed in log4j.PatternLayout.cspec.$letter"
          unless ($letter =~ /^[a-zA-Z]$/);
  
      Log::Log4perl::Layout::PatternLayout::add_global_cspec($letter, $perlcode);
  }
  
  my $LWP_USER_AGENT;
  sub set_LWP_UserAgent
  {
      $LWP_USER_AGENT = shift;
  }
  
  
  ###########################################
  sub config_read {
  ###########################################
  # Read the lib4j configuration and store the
  # values into a nested hash structure.
  ###########################################
      my($config) = @_;
  
      die "Configuration not defined" unless defined $config;
  
      my @text;
      my $parser;
  
      $CONFIG_FILE_READS++;  # Count for statistical purposes
  
      my $base_configurator = Log::Log4perl::Config::BaseConfigurator->new(
          utf8 => $UTF8,
      );
  
      my $data = {};
  
      if (ref($config) eq 'HASH') {   # convert the hashref into a list 
                                      # of name/value pairs
          print "Reading config from hash\n" if _INTERNAL_DEBUG;
          @text = ();
          for my $key ( sort keys %$config ) {
              if( ref( $config->{$key} ) eq "CODE" ) {
                  $config->{$key} = $config->{$key}->();
              }
              push @text, $key . '=' . $config->{$key} . "\n";
          }
      } elsif (ref $config eq 'SCALAR') {
          print "Reading config from scalar\n" if _INTERNAL_DEBUG;
          @text = split(/\n/,$$config);
  
      } elsif (ref $config eq 'GLOB' or 
               ref $config eq 'IO::File') {
              # If we have a file handle, just call the reader
          print "Reading config from file handle\n" if _INTERNAL_DEBUG;
          @text = @{ $base_configurator->file_h_read( $config ) };
  
      } elsif (ref $config) {
              # Caller provided a config parser object, which already
              # knows which file (or DB or whatever) to parse.
          print "Reading config from parser object\n" if _INTERNAL_DEBUG;
          $data = $config->parse();
          return $data;
  
      } elsif ($config =~ m|^ldap://|){
         if(! Log::Log4perl::Util::module_available("Net::LDAP")) {
             die "Log4perl: missing Net::LDAP needed to parse LDAP urls\n$@\n";
         }
  
         require Net::LDAP;
         require Log::Log4perl::Config::LDAPConfigurator;
  
         return Log::Log4perl::Config::LDAPConfigurator->new->parse($config);
  
      } else {
  
          if ($config =~ /^(https?|ftp|wais|gopher|file):/){
              my ($result, $ua);
      
              die "LWP::UserAgent not available" unless
                  Log::Log4perl::Util::module_available("LWP::UserAgent");
  
              require LWP::UserAgent;
              unless (defined $LWP_USER_AGENT) {
                  $LWP_USER_AGENT = LWP::UserAgent->new;
      
                  # Load proxy settings from environment variables, i.e.:
                  # http_proxy, ftp_proxy, no_proxy etc (see LWP::UserAgent)
                  # You need these to go thru firewalls.
                  $LWP_USER_AGENT->env_proxy;
              }
              $ua = $LWP_USER_AGENT;
  
              my $req = new HTTP::Request GET => $config;
              my $res = $ua->request($req);
  
              if ($res->is_success) {
                  @text = split(/\n/, $res->content);
              } else {
                  die "Log4perl couln't get $config, ".
                       $res->message." ";
              }
          } else {
              print "Reading config from file '$config'\n" if _INTERNAL_DEBUG;
              print "Reading ", -s $config, " bytes.\n" if _INTERNAL_DEBUG;
                # Use the BaseConfigurator's file reader to avoid duplicating
                # utf8 handling here.
              $base_configurator->file( $config );
              @text = @{ $base_configurator->text() };
          }
      }
      
      print "Reading $config: [@text]\n" if _INTERNAL_DEBUG;
  
      if(! grep /\S/, @text) {
          return $data;
      }
  
      if ($text[0] =~ /^<\?xml /) {
  
          die "XML::DOM not available" unless
                  Log::Log4perl::Util::module_available("XML::DOM");
  
          require XML::DOM; 
          require Log::Log4perl::Config::DOMConfigurator;
  
          XML::DOM->VERSION($Log::Log4perl::DOM_VERSION_REQUIRED);
          $parser = Log::Log4perl::Config::DOMConfigurator->new();
          $data = $parser->parse(\@text);
      } else {
          $parser = Log::Log4perl::Config::PropertyConfigurator->new();
          $data = $parser->parse(\@text);
      }
  
      $data = $parser->parse_post_process( $data, leaf_paths($data) );
  
      return $data;
  }
  
  ###########################################
  sub unlog4j {
  ###########################################
      my ($string) = @_;
  
      $string =~ s#^org\.apache\.##;
      $string =~ s#^log4j\.##;
      $string =~ s#^l4p\.##;
      $string =~ s#^log4perl\.##i;
  
      $string =~ s#\.#::#g;
  
      return $string;
  }
  
  ############################################################
  sub leaf_paths {
  ############################################################
  # Takes a reference to a hash of hashes structure of 
  # arbitrary depth, walks the tree and returns a reference
  # to an array of all possible leaf paths (each path is an 
  # array again).
  # Example: { a => { b => { c => d }, e => f } } would generate
  #          [ [a, b, c, d], [a, e, f] ]
  ############################################################
      my ($root) = @_;
  
      my @stack  = ();
      my @result = ();
  
      push @stack, [$root, []];  
      
      while(@stack) {
          my $item = pop @stack;
  
          my($node, $path) = @$item;
  
          if(ref($node) eq "HASH") { 
              for(sort keys %$node) {
                  push @stack, [$node->{$_}, [@$path, $_]];
              }
          } else {
              push @result, [@$path, $node];
          }
      }
      return \@result;
  }
  
  ###########################################
  sub leaf_path_to_hash {
  ###########################################
      my($leaf_path, $data) = @_;
  
      my $ref = \$data;
  
      for my $part ( @$leaf_path[0..$#$leaf_path-1] ) {
          $ref = \$$ref->{ $part };
      }
  
      return $ref;
  }
  
  ###########################################
  sub eval_if_perl {
  ###########################################
      my($value) = @_;
  
      if(my $cref = compile_if_perl($value)) {
          return $cref->();
      }
  
      return $value;
  }
  
  ###########################################
  sub compile_if_perl {
  ###########################################
      my($value) = @_;
  
      if($value =~ /^\s*sub\s*{/ ) {
          my $mask;
          unless( Log::Log4perl::Config->allow_code() ) {
              die "\$Log::Log4perl::Config->allow_code() setting " .
                  "prohibits Perl code in config file";
          }
          if( defined( $mask = Log::Log4perl::Config->allowed_code_ops() ) ) {
              return compile_in_safe_cpt($value, $mask );
          }
          elsif( $mask = Log::Log4perl::Config->allowed_code_ops_convenience_map(
                               Log::Log4perl::Config->allow_code()
                            ) ) {
              return compile_in_safe_cpt($value, $mask );
          }
          elsif( Log::Log4perl::Config->allow_code() == 1 ) {
  
              # eval without restriction
              my $cref = eval "package main; $value" or 
                  die "Can't evaluate '$value' ($@)";
              return $cref;
          }
          else {
              die "Invalid value for \$Log::Log4perl::Config->allow_code(): '".
                  Log::Log4perl::Config->allow_code() . "'";
          }
      }
  
      return undef;
  }
  
  ###########################################
  sub compile_in_safe_cpt {
  ###########################################
      my($value, $allowed_ops) = @_;
  
      # set up a Safe compartment
      require Safe;
      my $safe = Safe->new();
      $safe->permit_only( @{ $allowed_ops } );
   
      # share things with the compartment
      for( sort keys %{ Log::Log4perl::Config->vars_shared_with_safe_compartment() } ) {
          my $toshare = Log::Log4perl::Config->vars_shared_with_safe_compartment($_);
          $safe->share_from( $_, $toshare )
              or die "Can't share @{ $toshare } with Safe compartment";
      }
      
      # evaluate with restrictions
      my $cref = $safe->reval("package main; $value") or
          die "Can't evaluate '$value' in Safe compartment ($@)";
      return $cref;
      
  }
  
  ###########################################
  sub boolean_to_perlish {
  ###########################################
      my($value) = @_;
  
          # Translate boolean to perlish
      $value = 1 if $value =~ /^true$/i;
      $value = 0 if $value =~ /^false$/i;
  
      return $value;
  }
  
  ###########################################
  sub vars_shared_with_safe_compartment {
  ###########################################
      my($class, @args) = @_;
  
          # Allow both for ...::Config::foo() and ...::Config->foo()
      if(defined $class and $class ne __PACKAGE__) {
          unshift @args, $class;
      }
     
      # handle different invocation styles
      if(@args == 1 && ref $args[0] eq 'HASH' ) {
          # replace entire hash of vars
          %Log::Log4perl::VARS_SHARED_WITH_SAFE_COMPARTMENT = %{$args[0]};
      }
      elsif( @args == 1 ) {
          # return vars for given package
          return $Log::Log4perl::VARS_SHARED_WITH_SAFE_COMPARTMENT{
                 $args[0]};
      }
      elsif( @args == 2 ) {
          # add/replace package/var pair
          $Log::Log4perl::VARS_SHARED_WITH_SAFE_COMPARTMENT{
             $args[0]} = $args[1];
      }
  
      return wantarray ? %Log::Log4perl::VARS_SHARED_WITH_SAFE_COMPARTMENT
                       : \%Log::Log4perl::VARS_SHARED_WITH_SAFE_COMPARTMENT;
      
  }
  
  ###########################################
  sub allowed_code_ops {
  ###########################################
      my($class, @args) = @_;
  
          # Allow both for ...::Config::foo() and ...::Config->foo()
      if(defined $class and $class ne __PACKAGE__) {
          unshift @args, $class;
      }
     
      if(@args) {
          @Log::Log4perl::ALLOWED_CODE_OPS_IN_CONFIG_FILE = @args;
      }
      else {
          # give back 'undef' instead of an empty arrayref
          unless( @Log::Log4perl::ALLOWED_CODE_OPS_IN_CONFIG_FILE ) {
              return;
          }
      }
  
      return wantarray ? @Log::Log4perl::ALLOWED_CODE_OPS_IN_CONFIG_FILE
                       : \@Log::Log4perl::ALLOWED_CODE_OPS_IN_CONFIG_FILE;
  }
  
  ###########################################
  sub allowed_code_ops_convenience_map {
  ###########################################
      my($class, @args) = @_;
  
          # Allow both for ...::Config::foo() and ...::Config->foo()
      if(defined $class and $class ne __PACKAGE__) {
          unshift @args, $class;
      }
  
      # handle different invocation styles
      if( @args == 1 && ref $args[0] eq 'HASH' ) {
          # replace entire map
          %Log::Log4perl::ALLOWED_CODE_OPS = %{$args[0]};
      }
      elsif( @args == 1 ) {
          # return single opcode mask
          return $Log::Log4perl::ALLOWED_CODE_OPS{
                     $args[0]};
      }
      elsif( @args == 2 ) {
          # make sure the mask is an array ref
          if( ref $args[1] ne 'ARRAY' ) {
              die "invalid mask (not an array ref) for convenience name '$args[0]'";
          }
          # add name/mask pair
          $Log::Log4perl::ALLOWED_CODE_OPS{
              $args[0]} = $args[1];
      }
  
      return wantarray ? %Log::Log4perl::ALLOWED_CODE_OPS
                       : \%Log::Log4perl::ALLOWED_CODE_OPS
  }
  
  ###########################################
  sub allow_code {
  ###########################################
      my($class, @args) = @_;
  
          # Allow both for ...::Config::foo() and ...::Config->foo()
      if(defined $class and $class ne __PACKAGE__) {
          unshift @args, $class;
      }
     
      if(@args) {
          $Log::Log4perl::ALLOW_CODE_IN_CONFIG_FILE = 
              $args[0];
      }
  
      return $Log::Log4perl::ALLOW_CODE_IN_CONFIG_FILE;
  }
  
  ################################################
  sub var_subst {
  ################################################
      my($varname, $subst_hash) = @_;
  
          # Throw out blanks
      $varname =~ s/\s+//g;
  
      if(exists $subst_hash->{$varname}) {
          print "Replacing variable: '$varname' => '$subst_hash->{$varname}'\n" 
              if _INTERNAL_DEBUG;
          return $subst_hash->{$varname};
  
      } elsif(exists $ENV{$varname}) {
          print "Replacing ENV variable: '$varname' => '$ENV{$varname}'\n" 
              if _INTERNAL_DEBUG;
          return $ENV{$varname};
  
      }
  
      die "Undefined Variable '$varname'";
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Config - Log4perl configuration file syntax
  
  =head1 DESCRIPTION
  
  In C<Log::Log4perl>, configuration files are used to describe how the
  system's loggers ought to behave. 
  
  The format is the same as the one as used for C<log4j>, just with
  a few perl-specific extensions, like enabling the C<Bar::Twix>
  syntax instead of insisting on the Java-specific C<Bar.Twix>.
  
  Comment lines and blank lines (all whitespace or empty) are ignored.
  
  Comment lines may start with arbitrary whitespace followed by one of:
  
  =over 4
  
  =item # - Common comment delimiter
  
  =item ! - Java .properties file comment delimiter accepted by log4j
  
  =item ; - Common .ini file comment delimiter
  
  =back
  
  Comments at the end of a line are not supported. So if you write
  
      log4perl.appender.A1.filename=error.log #in current dir
  
  you will find your messages in a file called C<error.log #in current dir>.
  
  Also, blanks between syntactical entities are ignored, it doesn't 
  matter if you write
  
      log4perl.logger.Bar.Twix=WARN,Screen
  
  or 
  
      log4perl.logger.Bar.Twix = WARN, Screen
  
  C<Log::Log4perl> will strip the blanks while parsing your input.
  
  Assignments need to be on a single line. However, you can break the
  line if you want to by using a continuation character at the end of the
  line. Instead of writing
  
      log4perl.appender.A1.layout=Log::Log4perl::Layout::SimpleLayout
  
  you can break the line at any point by putting a backslash at the very (!)
  end of the line to be continued:
  
      log4perl.appender.A1.layout=\
          Log::Log4perl::Layout::SimpleLayout
  
  Watch out for trailing blanks after the backslash, which would prevent
  the line from being properly concatenated.
  
  =head2 Loggers
  
  Loggers are addressed by category:
  
      log4perl.logger.Bar.Twix      = WARN, Screen
  
  This sets all loggers under the C<Bar::Twix> hierarchy on priority
  C<WARN> and attaches a later-to-be-defined C<Screen> appender to them.
  Settings for the root appender (which doesn't have a name) can be
  accomplished by simply omitting the name:
  
      log4perl.logger = FATAL, Database, Mailer 
  
  This sets the root appender's level to C<FATAL> and also attaches the 
  later-to-be-defined appenders C<Database> and C<Mailer> to it. Alternatively,
  the root logger can be addressed as C<rootLogger>:
  
      log4perl.rootLogger = FATAL, Database, Mailer
  
  The additivity flag of a logger is set or cleared via the 
  C<additivity> keyword:
  
      log4perl.additivity.Bar.Twix = 0|1
  
  (Note the reversed order of keyword and logger name, resulting
  from the dilemma that a logger name could end in C<.additivity>
  according to the log4j documentation).
  
  =head2 Appenders and Layouts
  
  Appender names used in Log4perl configuration file
  lines need to be resolved later on, in order to
  define the appender's properties and its layout. To specify properties
  of an appender, just use the C<appender> keyword after the
  C<log4perl> intro and the appender's name:
  
          # The Bar::Twix logger and its appender
      log4perl.logger.Bar.Twix = DEBUG, A1
      log4perl.appender.A1=Log::Log4perl::Appender::File
      log4perl.appender.A1.filename=test.log
      log4perl.appender.A1.mode=append
      log4perl.appender.A1.layout=Log::Log4perl::Layout::SimpleLayout
  
  This sets a priority of C<DEBUG> for loggers in the C<Bar::Twix>
  hierarchy and assigns the C<A1> appender to it, which is later on
  resolved to be an appender of type C<Log::Log4perl::Appender::File>, simply
  appending to a log file. According to the C<Log::Log4perl::Appender::File>
  manpage, the C<filename> parameter specifies the name of the log file
  and the C<mode> parameter can be set to C<append> or C<write> (the
  former will append to the logfile if one with the specified name
  already exists while the latter would clobber and overwrite it).
  
  The order of the entries in the configuration file is not important,
  C<Log::Log4perl> will read in the entire file first and try to make
  sense of the lines after it knows the entire context.
  
  You can very well define all loggers first and then their appenders
  (you could even define your appenders first and then your loggers,
  but let's not go there):
  
      log4perl.logger.Bar.Twix = DEBUG, A1
      log4perl.logger.Bar.Snickers = FATAL, A2
  
      log4perl.appender.A1=Log::Log4perl::Appender::File
      log4perl.appender.A1.filename=test.log
      log4perl.appender.A1.mode=append
      log4perl.appender.A1.layout=Log::Log4perl::Layout::SimpleLayout
  
      log4perl.appender.A2=Log::Log4perl::Appender::Screen
      log4perl.appender.A2.stderr=0
      log4perl.appender.A2.layout=Log::Log4perl::Layout::PatternLayout
      log4perl.appender.A2.layout.ConversionPattern = %d %m %n
  
  Note that you have to specify the full path to the layout class
  and that C<ConversionPattern> is the keyword to specify the printf-style
  formatting instructions.
  
  =head1 Configuration File Cookbook
  
  Here's some examples of often-used Log4perl configuration files:
  
  =head2 Append to STDERR
  
      log4perl.category.Bar.Twix      = WARN, Screen
      log4perl.appender.Screen        = Log::Log4perl::Appender::Screen
      log4perl.appender.Screen.layout = \
          Log::Log4perl::Layout::PatternLayout
      log4perl.appender.Screen.layout.ConversionPattern = %d %m %n
  
  =head2 Append to STDOUT
  
      log4perl.category.Bar.Twix      = WARN, Screen
      log4perl.appender.Screen        = Log::Log4perl::Appender::Screen
      log4perl.appender.Screen.stderr = 0
      log4perl.appender.Screen.layout = \
          Log::Log4perl::Layout::PatternLayout
      log4perl.appender.Screen.layout.ConversionPattern = %d %m %n
  
  =head2 Append to a log file
  
      log4perl.logger.Bar.Twix = DEBUG, A1
      log4perl.appender.A1=Log::Log4perl::Appender::File
      log4perl.appender.A1.filename=test.log
      log4perl.appender.A1.mode=append
      log4perl.appender.A1.layout = \
          Log::Log4perl::Layout::PatternLayout
      log4perl.appender.A1.layout.ConversionPattern = %d %m %n
  
  Note that you could even leave out 
  
      log4perl.appender.A1.mode=append
  
  and still have the logger append to the logfile by default, although
  the C<Log::Log4perl::Appender::File> module does exactly the opposite.
  This is due to some nasty trickery C<Log::Log4perl> performs behind 
  the scenes to make sure that beginner's CGI applications don't clobber 
  the log file every time they're called.
  
  =head2 Write a log file from scratch
  
  If you loathe the Log::Log4perl's append-by-default strategy, you can
  certainly override it:
  
      log4perl.logger.Bar.Twix = DEBUG, A1
      log4perl.appender.A1=Log::Log4perl::Appender::File
      log4perl.appender.A1.filename=test.log
      log4perl.appender.A1.mode=write
      log4perl.appender.A1.layout=Log::Log4perl::Layout::SimpleLayout
  
  C<write> is the C<mode> that has C<Log::Log4perl::Appender::File>
  explicitly clobber the log file if it exists.
  
  =head2 Configuration files encoded in utf-8
  
  If your configuration file is encoded in utf-8 (which matters if you 
  e.g. specify utf8-encoded appender filenames in it), then you need to 
  tell Log4perl before running init():
  
      use Log::Log4perl::Config;
      Log::Log4perl::Config->utf( 1 );
  
      Log::Log4perl->init( ... );
  
  This makes sure Log4perl interprets utf8-encoded config files correctly.
  This setting might become the default at some point.
  
  =head1 SEE ALSO
  
  Log::Log4perl::Config::PropertyConfigurator
  
  Log::Log4perl::Config::DOMConfigurator
  
  Log::Log4perl::Config::LDAPConfigurator (coming soon!)
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_CONFIG

$fatpacked{"Log/Log4perl/Config/BaseConfigurator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_CONFIG_BASECONFIGURATOR';
  package Log::Log4perl::Config::BaseConfigurator;
  
  use warnings;
  use strict;
  use constant _INTERNAL_DEBUG => 0;
  
  *eval_if_perl      = \&Log::Log4perl::Config::eval_if_perl;
  *compile_if_perl   = \&Log::Log4perl::Config::compile_if_perl;
  *leaf_path_to_hash = \&Log::Log4perl::Config::leaf_path_to_hash;
  
  ################################################
  sub new {
  ################################################
      my($class, %options) = @_;
  
      my $self = { 
          utf8 => 0,
          %options,
      };
  
      bless $self, $class;
  
      $self->file($self->{file}) if exists $self->{file};
      $self->text($self->{text}) if exists $self->{text};
  
      return $self;
  }
  
  ################################################
  sub text {
  ################################################
      my($self, $text) = @_;
  
          # $text is an array of scalars (lines)
      if(defined $text) {
          if(ref $text eq "ARRAY") {
              $self->{text} = $text;
          } else {
              $self->{text} = [split "\n", $text];
          }
      }
  
      return $self->{text};
  }
  
  ################################################
  sub file {
  ################################################
      my($self, $filename) = @_;
  
      open my $fh, "$filename" or die "Cannot open $filename ($!)";
  
      if( $self->{ utf8 } ) {
          binmode $fh, ":utf8";
      }
  
      $self->file_h_read( $fh );
      close $fh;
  }
  
  ################################################
  sub file_h_read {
  ################################################
      my($self, $fh) = @_;
  
          # Dennis Gregorovic <dgregor@redhat.com> added this
          # to protect apps which are tinkering with $/ globally.
      local $/ = "\n";
  
      $self->{text} = [<$fh>];
  }
  
  ################################################
  sub parse {
  ################################################
      die __PACKAGE__ . "::parse() is a virtual method. " .
          "It must be implemented " .
          "in a derived class (currently: ", ref(shift), ")";
  }
  
  ################################################
  sub parse_post_process {
  ################################################
      my($self, $data, $leaf_paths) = @_;
      
      #   [
      #     'category',
      #     'value',
      #     'WARN, Logfile'
      #   ],
      #   [
      #     'appender',
      #     'Logfile',
      #     'value',
      #     'Log::Log4perl::Appender::File'
      #   ],
      #   [
      #     'appender',
      #     'Logfile',
      #     'filename',
      #     'value',
      #     'test.log'
      #   ],
      #   [
      #     'appender',
      #     'Logfile',
      #     'layout',
      #     'value',
      #     'Log::Log4perl::Layout::PatternLayout'
      #   ],
      #   [
      #     'appender',
      #     'Logfile',
      #     'layout',
      #     'ConversionPattern',
      #     'value',
      #     '%d %F{1} %L> %m %n'
      #   ]
  
      for my $path ( @{ Log::Log4perl::Config::leaf_paths( $data )} ) {
  
          print "path=@$path\n" if _INTERNAL_DEBUG;
  
          if(0) {
          } elsif( 
              $path->[0] eq "appender" and
              $path->[2] eq "trigger"
            ) {
              my $ref = leaf_path_to_hash( $path, $data );
              my $code = compile_if_perl( $$ref );
  
              if(_INTERNAL_DEBUG) {
                  if($code) {
                      print "Code compiled: $$ref\n";
                  } else {
                      print "Not compiled: $$ref\n";
                  }
              }
  
              $$ref = $code if defined $code;
          } elsif (
              $path->[0] eq "filter"
            ) {
              # do nothing
          } elsif (
              $path->[0] eq "appender" and
              $path->[2] eq "warp_message"
            ) {
              # do nothing
          } elsif (
              $path->[0] eq "appender" and
              $path->[3] eq "cspec" or
              $path->[1] eq "cspec"
            ) {
                # could be either
                #    appender appndr layout cspec
                # or 
                #    PatternLayout cspec U value ...
                #
              # do nothing
          } else {
              my $ref = leaf_path_to_hash( $path, $data );
  
              if(_INTERNAL_DEBUG) {
                  print "Calling eval_if_perl on $$ref\n";
              }
  
              $$ref = eval_if_perl( $$ref );
          }
      }
  
      return $data;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Config::BaseConfigurator - Configurator Base Class
  
  =head1 SYNOPSIS
  
  This is a virtual base class, all configurators should be derived from it.
  
  =head1 DESCRIPTION
  
  =head2 METHODS
  
  =over 4
  
  =item C<< new >>
  
  Constructor, typically called like
  
      my $config_parser = SomeConfigParser->new(
          file => $file,
      );
  
      my $data = $config_parser->parse();
  
  Instead of C<file>, the derived class C<SomeConfigParser> may define any 
  type of configuration input medium (e.g. C<url =E<gt> 'http://foobar'>).
  It just has to make sure its C<parse()> method will later pull the input
  data from the medium specified.
  
  The base class accepts a filename or a reference to an array
  of text lines:
  
  =over 4
  
  =item C<< file >>
  
  Specifies a file which the C<parse()> method later parses.
  
  =item C<< text >>
  
  Specifies a reference to an array of scalars, representing configuration
  records (typically lines of a file). Also accepts a simple scalar, which it 
  splits at its newlines and transforms it into an array:
  
      my $config_parser = MyYAMLParser->new(
          text => ['foo: bar',
                   'baz: bam',
                  ],
      );
  
      my $data = $config_parser->parse();
  
  =back
  
  If either C<file> or C<text> parameters have been specified in the 
  constructor call, a later call to the configurator's C<text()> method
  will return a reference to an array of configuration text lines.
  This will typically be used by the C<parse()> method to process the 
  input.
  
  =item C<< parse >>
  
  Virtual method, needs to be defined by the derived class.
  
  =back
  
  =head2 Parser requirements
  
  =over 4
  
  =item *
  
  If the parser provides variable substitution functionality, it has
  to implement it.
  
  =item *
  
  The parser's C<parse()> method returns a reference to a hash of hashes (HoH). 
  The top-most hash contains the
  top-level keywords (C<category>, C<appender>) as keys, associated
  with values which are references to more deeply nested hashes.
  
  =item *
  
  The C<log4perl.> prefix (e.g. as used in the PropertyConfigurator class)
  is stripped, it's not part in the HoH structure.
  
  =item *
  
  Each Log4perl config value is indicated by the C<value> key, as in
  
      $data->{category}->{Bar}->{Twix}->{value} = "WARN, Logfile"
  
  =back
  
  =head2 EXAMPLES
  
  The following Log::Log4perl configuration:
  
      log4perl.category.Bar.Twix        = WARN, Screen
      log4perl.appender.Screen          = Log::Log4perl::Appender::File
      log4perl.appender.Screen.filename = test.log
      log4perl.appender.Screen.layout   = Log::Log4perl::Layout::SimpleLayout
  
  needs to be transformed by the parser's C<parse()> method 
  into this data structure:
  
      { appender => {
          Screen  => {
            layout => { 
              value  => "Log::Log4perl::Layout::SimpleLayout" },
              value  => "Log::Log4perl::Appender::Screen",
          },
        },
        category => { 
          Bar => { 
            Twix => { 
              value => "WARN, Screen" } 
          } }
      }
  
  For a full-fledged example, check out the sample YAML parser implementation 
  in C<eg/yamlparser>. It uses a simple YAML syntax to specify the Log4perl 
  configuration to illustrate the concept.
  
  =head1 SEE ALSO
  
  Log::Log4perl::Config::PropertyConfigurator
  
  Log::Log4perl::Config::DOMConfigurator
  
  Log::Log4perl::Config::LDAPConfigurator (tbd!)
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_CONFIG_BASECONFIGURATOR

$fatpacked{"Log/Log4perl/Config/DOMConfigurator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_CONFIG_DOMCONFIGURATOR';
  package Log::Log4perl::Config::DOMConfigurator;
  use Log::Log4perl::Config::BaseConfigurator;
  
  our @ISA = qw(Log::Log4perl::Config::BaseConfigurator);
  
  #todo
  # DONE(param-text) some params not attrs but values, like <sql>...</sql>
  # DONE see DEBUG!!!  below
  # NO, (really is only used for AsyncAppender) appender-ref in <appender>
  # DONE check multiple appenders in a category
  # DONE in Config.pm re URL loading, steal from XML::DOM
  # DONE, OK see PropConfigurator re importing unlog4j, eval_if_perl
  # NO (is specified in DTD) - need to handle 0/1, true/false?
  # DONE see Config, need to check version of XML::DOM
  # OK user defined levels? see parse_level
  # OK make sure 2nd test is using log4perl constructs, not log4j
  # OK handle new filter stuff
  # make sure sample code actually works
  # try removing namespace prefixes in the xml
  
  use XML::DOM;
  use Log::Log4perl::Level;
  use strict;
  
  use constant _INTERNAL_DEBUG => 0;
  
  our $VERSION = 0.03;
  
  our $APPENDER_TAG = qr/^((log4j|log4perl):)?appender$/;
  
  our $FILTER_TAG = qr/^(log4perl:)?filter$/;
  our $FILTER_REF_TAG = qr/^(log4perl:)?filter-ref$/;
  
  #can't use ValParser here because we're using namespaces? 
  #doesn't seem to work - kg 3/2003 
  our $PARSER_CLASS = 'XML::DOM::Parser';
  
  our $LOG4J_PREFIX = 'log4j';
  our $LOG4PERL_PREFIX = 'log4perl';
      
  
  #poor man's export
  *eval_if_perl = \&Log::Log4perl::Config::eval_if_perl;
  *unlog4j      = \&Log::Log4perl::Config::unlog4j;
  
  
  ###################################################
  sub parse {
  ###################################################
      my($self, $newtext) = @_;
  
      $self->text($newtext) if defined $newtext;
      my $text = $self->{text};
  
      my $parser = $PARSER_CLASS->new;
      my $doc = $parser->parse (join('',@$text));
  
  
      my $l4p_tree = {};
      
      my $config = $doc->getElementsByTagName("$LOG4J_PREFIX:configuration")->item(0)||
                   $doc->getElementsByTagName("$LOG4PERL_PREFIX:configuration")->item(0);
  
      my $threshold = uc(subst($config->getAttribute('threshold')));
      if ($threshold) {
          $l4p_tree->{threshold}{value} = $threshold;
      }
  
      if (subst($config->getAttribute('oneMessagePerAppender')) eq 'true') {
          $l4p_tree->{oneMessagePerAppender}{value} = 1;
      }
  
      for my $kid ($config->getChildNodes){
  
          next unless $kid->getNodeType == ELEMENT_NODE;
  
          my $tag_name = $kid->getTagName;
  
          if ($tag_name =~ $APPENDER_TAG) {
              &parse_appender($l4p_tree, $kid);
  
          }elsif ($tag_name eq 'category' || $tag_name eq 'logger'){
              &parse_category($l4p_tree, $kid);
              #Treating them the same is not entirely accurate, 
              #the dtd says 'logger' doesn't accept
              #a 'class' attribute while 'category' does.
              #But that's ok, log4perl doesn't do anything with that attribute
  
          }elsif ($tag_name eq 'root'){
              &parse_root($l4p_tree, $kid);
  
          }elsif ($tag_name =~ $FILTER_TAG){
              #parse log4perl's chainable boolean filters
              &parse_l4p_filter($l4p_tree, $kid);
  
          }elsif ($tag_name eq 'renderer'){
              warn "Log4perl: ignoring renderer tag in config, unimplemented";
              #"log4j will render the content of the log message according to 
              # user specified criteria. For example, if you frequently need 
              # to log Oranges, an object type used in your current project, 
              # then you can register an OrangeRenderer that will be invoked 
              # whenever an orange needs to be logged. "
           
          }elsif ($tag_name eq 'PatternLayout'){#log4perl only
              &parse_patternlayout($l4p_tree, $kid);
          }
      }
      $doc->dispose;
  
      return $l4p_tree;
  }
  
  #this is just for toplevel log4perl.PatternLayout tags
  #holding the custom cspecs
  sub parse_patternlayout {
      my ($l4p_tree, $node) = @_;
  
      my $l4p_branch = {};
  
      for my $child ($node->getChildNodes) {
          next unless $child->getNodeType == ELEMENT_NODE;
  
          my $name = subst($child->getAttribute('name'));
          my $value;
  
          foreach my $grandkid ($child->getChildNodes){
              if ($grandkid->getNodeType == TEXT_NODE) {
                  $value .= $grandkid->getData;
              }
          }
          $value =~ s/^ +//;  #just to make the unit tests pass
          $value =~ s/ +$//;
          $l4p_branch->{$name}{value} = subst($value);
      }
      $l4p_tree->{PatternLayout}{cspec} = $l4p_branch;
  }
  
  
  #for parsing the root logger, if any
  sub parse_root {
      my ($l4p_tree, $node) = @_;
  
      my $l4p_branch = {};
  
      &parse_children_of_logger_element($l4p_branch, $node);
  
      $l4p_tree->{category}{value} = $l4p_branch->{value};
  
  }
  
  
  #this parses a custom log4perl-specific filter set up under
  #the root element, as opposed to children of the appenders
  sub parse_l4p_filter {
      my ($l4p_tree, $node) = @_;
  
      my $l4p_branch = {};
  
      my $name = subst($node->getAttribute('name'));
  
      my $class = subst($node->getAttribute('class'));
      my $value = subst($node->getAttribute('value'));
  
      if ($class && $value) {
          die "Log4perl: only one of class or value allowed, not both, "
              ."in XMLConfig filter '$name'";
      }elsif ($class || $value){
          $l4p_branch->{value} = ($value || $class);
  
      }
  
      for my $child ($node->getChildNodes) {
  
          if ($child->getNodeType == ELEMENT_NODE){
  
              my $tag_name = $child->getTagName();
  
              if ($tag_name =~ /^(param|param-nested|param-text)$/) {
                  &parse_any_param($l4p_branch, $child);
              }
          }elsif ($child->getNodeType == TEXT_NODE){
              my $text = $child->getData;
              next unless $text =~ /\S/;
              if ($class && $value) {
                  die "Log4perl: only one of class, value or PCDATA allowed, "
                      ."in XMLConfig filter '$name'";
              }
              $l4p_branch->{value} .= subst($text); 
          }
      }
  
      $l4p_tree->{filter}{$name} = $l4p_branch;
  }
  
     
  #for parsing a category/logger element
  sub parse_category {
      my ($l4p_tree, $node) = @_;
  
      my $name = subst($node->getAttribute('name'));
  
      $l4p_tree->{category} ||= {};
   
      my $ptr = $l4p_tree->{category};
  
      for my $part (split /\.|::/, $name) {
          $ptr->{$part} = {} unless exists $ptr->{$part};
          $ptr = $ptr->{$part};
      }
  
      my $l4p_branch = $ptr;
  
      my $class = subst($node->getAttribute('class'));
      $class                       && 
         $class ne 'Log::Log4perl' &&
         $class ne 'org.apache.log4j.Logger' &&
         warn "setting category $name to class $class ignored, only Log::Log4perl implemented";
  
      #this is kind of funky, additivity has its own spot in the tree
      my $additivity = subst(subst($node->getAttribute('additivity')));
      if (length $additivity > 0) {
          $l4p_tree->{additivity} ||= {};
          my $add_ptr = $l4p_tree->{additivity};
  
          for my $part (split /\.|::/, $name) {
              $add_ptr->{$part} = {} unless exists $add_ptr->{$part};
              $add_ptr = $add_ptr->{$part};
          }
          $add_ptr->{value} = &parse_boolean($additivity);
      }
  
      &parse_children_of_logger_element($l4p_branch, $node);
  }
  
  # parses the children of a category element
  sub parse_children_of_logger_element {
      my ($l4p_branch, $node) = @_;
  
      my (@appenders, $priority);
  
      for my $child ($node->getChildNodes) {
          next unless $child->getNodeType == ELEMENT_NODE;
              
          my $tag_name = $child->getTagName();
  
          if ($tag_name eq 'param') {
              my $name = subst($child->getAttribute('name'));
              my $value = subst($child->getAttribute('value'));
              if ($value =~ /^(all|debug|info|warn|error|fatal|off|null)^/) {
                  $value = uc $value;
              }
              $l4p_branch->{$name} = {value => $value};
          
          }elsif ($tag_name eq 'appender-ref'){
              push @appenders, subst($child->getAttribute('ref'));
              
          }elsif ($tag_name eq 'level' || $tag_name eq 'priority'){
              $priority = &parse_level($child);
          }
      }
      $l4p_branch->{value} = $priority.', '.join(',', @appenders);
      
      return;
  }
  
  
  sub parse_level {
      my $node = shift;
  
      my $level = uc (subst($node->getAttribute('value')));
  
      die "Log4perl: invalid level in config: $level"
          unless Log::Log4perl::Level::is_valid($level);
  
      return $level;
  }
  
  
  
  sub parse_appender {
      my ($l4p_tree, $node) = @_;
  
      my $name = subst($node->getAttribute("name"));
  
      my $l4p_branch = {};
  
      my $class = subst($node->getAttribute("class"));
  
      $l4p_branch->{value} = $class;
  
      print "looking at $name----------------------\n"  if _INTERNAL_DEBUG;
  
      for my $child ($node->getChildNodes) {
          next unless $child->getNodeType == ELEMENT_NODE;
  
          my $tag_name = $child->getTagName();
  
          my $name = unlog4j(subst($child->getAttribute('name')));
  
          if ($tag_name =~ /^(param|param-nested|param-text)$/) {
  
              &parse_any_param($l4p_branch, $child);
  
              my $value;
  
          }elsif ($tag_name =~ /($LOG4PERL_PREFIX:)?layout/){
              $l4p_branch->{layout} = parse_layout($child);
  
          }elsif ($tag_name =~  $FILTER_TAG){
              $l4p_branch->{Filter} = parse_filter($child);
  
          }elsif ($tag_name =~ $FILTER_REF_TAG){
              $l4p_branch->{Filter} = parse_filter_ref($child);
  
          }elsif ($tag_name eq 'errorHandler'){
              die "errorHandlers not supported yet";
  
          }elsif ($tag_name eq 'appender-ref'){
              #dtd: Appenders may also reference (or include) other appenders. 
              #This feature in log4j is only for appenders who implement the 
              #AppenderAttachable interface, and the only one that does that
              #is the AsyncAppender, which writes logs in a separate thread.
              #I don't see the need to support this on the perl side any 
              #time soon.  --kg 3/2003
              die "Log4perl: in config file, <appender-ref> tag is unsupported in <appender>";
          }else{
              die "Log4perl: in config file, <$tag_name> is unsupported\n";
          }
      }
      $l4p_tree->{appender}{$name} = $l4p_branch;
  }
  
  sub parse_any_param {
      my ($l4p_branch, $child) = @_;
  
      my $tag_name = $child->getTagName();
      my $name = subst($child->getAttribute('name'));
      my $value;
  
      print "parse_any_param: <$tag_name name=$name\n" if _INTERNAL_DEBUG;
  
      #<param-nested>
      #note we don't set it to { value => $value }
      #and we don't test for multiple values
      if ($tag_name eq 'param-nested'){
          
          if ($l4p_branch->{$name}){
              die "Log4perl: in config file, multiple param-nested tags for $name not supported";
          }
          $l4p_branch->{$name} = &parse_param_nested($child); 
  
          return;
  
      #<param>
      }elsif ($tag_name eq 'param') {
  
           $value = subst($child->getAttribute('value'));
  
           print "parse_param_nested: got param $name = $value\n"  
               if _INTERNAL_DEBUG;
          
           if ($value =~ /^(all|debug|info|warn|error|fatal|off|null)$/) {
               $value = uc $value;
           }
  
           if ($name !~ /warp_message|filter/ &&
              $child->getParentNode->getAttribute('name') ne 'cspec') {
              $value = eval_if_perl($value);
           }
      #<param-text>
      }elsif ($tag_name eq 'param-text'){
  
          foreach my $grandkid ($child->getChildNodes){
              if ($grandkid->getNodeType == TEXT_NODE) {
                  $value .= $grandkid->getData;
              }
          }
          if ($name !~ /warp_message|filter/ &&
              $child->getParentNode->getAttribute('name') ne 'cspec') {
              $value = eval_if_perl($value);
          }
      }
  
      $value = subst($value);
  
       #multiple values for the same param name
       if (defined $l4p_branch->{$name}{value} ) {
           if (ref $l4p_branch->{$name}{value} ne 'ARRAY'){
               my $temp = $l4p_branch->{$name}{value};
               $l4p_branch->{$name}{value} = [$temp];
           }
           push @{$l4p_branch->{$name}{value}}, $value;
       }else{
           $l4p_branch->{$name} = {value => $value};
       }
  }
  
  #handles an appender's <param-nested> elements
  sub parse_param_nested {
      my ($node) = shift;
  
      my $l4p_branch = {};
  
      for my $child ($node->getChildNodes) {
          next unless $child->getNodeType == ELEMENT_NODE;
  
          my $tag_name = $child->getTagName();
  
          if ($tag_name =~ /^param|param-nested|param-text$/) {
              &parse_any_param($l4p_branch, $child);
          }
      }
  
      return $l4p_branch;
  }
  
  #this handles filters that are children of appenders, as opposed
  #to the custom filters that go under the root element
  sub parse_filter {
      my $node = shift;
  
      my $filter_tree = {};
  
      my $class_name = subst($node->getAttribute('class'));
  
      $filter_tree->{value} = $class_name;
  
      print "\tparsing filter on class $class_name\n"  if _INTERNAL_DEBUG;  
  
      for my $child ($node->getChildNodes) {
          next unless $child->getNodeType == ELEMENT_NODE;
  
          my $tag_name = $child->getTagName();
  
          if ($tag_name =~ 'param|param-nested|param-text') {
              &parse_any_param($filter_tree, $child);
          
          }else{
              die "Log4perl: don't know what to do with a ".$child->getTagName()
                  ."inside a filter element";
          }
      }
      return $filter_tree;
  }
  
  sub parse_filter_ref {
      my $node = shift;
  
      my $filter_tree = {};
  
      my $filter_id = subst($node->getAttribute('id'));
  
      $filter_tree->{value} = $filter_id;
  
      return $filter_tree;
  }
  
  
  
  sub parse_layout {
      my $node = shift;
  
      my $layout_tree = {};
  
      my $class_name = subst($node->getAttribute('class'));
      
      $layout_tree->{value} = $class_name;
      #
      print "\tparsing layout $class_name\n"  if _INTERNAL_DEBUG;  
      for my $child ($node->getChildNodes) {
          next unless $child->getNodeType == ELEMENT_NODE;
          if ($child->getTagName() eq 'param') {
              my $name = subst($child->getAttribute('name'));
              my $value = subst($child->getAttribute('value'));
              if ($value =~ /^(all|debug|info|warn|error|fatal|off|null)$/) {
                  $value = uc $value;
              }
              print "\tparse_layout: got param $name = $value\n"
                  if _INTERNAL_DEBUG;
              $layout_tree->{$name}{value} = $value;  
  
          }elsif ($child->getTagName() eq 'cspec') {
              my $name = subst($child->getAttribute('name'));
              my $value;
              foreach my $grandkid ($child->getChildNodes){
                  if ($grandkid->getNodeType == TEXT_NODE) {
                      $value .= $grandkid->getData;
                  }
              }
              $value =~ s/^ +//;
              $value =~ s/ +$//;
              $layout_tree->{cspec}{$name}{value} = subst($value);  
          }
      }
      return $layout_tree;
  }
  
  sub parse_boolean {
      my $a = shift;
  
      if ($a eq '0' || lc $a eq 'false') {
          return '0';
      }elsif ($a eq '1' || lc $a eq 'true'){
          return '1';
      }else{
          return $a; #probably an error, punt
      }
  }
  
  
  #this handles variable substitution
  sub subst {
      my $val = shift;
  
      $val =~ s/\$\{(.*?)}/
                        Log::Log4perl::Config::var_subst($1, {})/gex;
      return $val;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Config::DOMConfigurator - reads xml config files
  
  =head1 SYNOPSIS
  
      --------------------------
      --using the log4j DTD--
      --------------------------
  
      <?xml version="1.0" encoding="UTF-8"?>
      <!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
  
      <log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/">
  
      <appender name="FileAppndr1" class="org.apache.log4j.FileAppender">
          <layout class="Log::Log4perl::Layout::PatternLayout">
                  <param name="ConversionPattern"
                         value="%d %4r [%t] %-5p %c %t - %m%n"/>
          </layout>
          <param name="File" value="t/tmp/DOMtest"/>
          <param name="Append" value="false"/>
      </appender>
  
      <category name="a.b.c.d" additivity="false">
          <level value="warn"/>  <!-- note lowercase! -->
          <appender-ref ref="FileAppndr1"/>
      </category>
  
     <root>
          <priority value="warn"/>
          <appender-ref ref="FileAppndr1"/>
     </root>
  
     </log4j:configuration>
     
     
     
     --------------------------
     --using the log4perl DTD--
     --------------------------
     
     <?xml version="1.0" encoding="UTF-8"?>
      <!DOCTYPE log4perl:configuration SYSTEM "log4perl.dtd">
  
      <log4perl:configuration xmlns:log4perl="http://log4perl.sourceforge.net/"
          threshold="debug" oneMessagePerAppender="true">
  
      <log4perl:appender name="jabbender" class="Log::Dispatch::Jabber">
  
              <param-nested name="login">
                     <param name="hostname" value="a.jabber.server"/>
                     <param name="password" value="12345"/>
                     <param name="port"     value="5222"/>
                     <param name="resource" value="logger"/>
                     <param name="username" value="bobjones"/>
              </param-nested>
  
              <param name="to" value="bob@a.jabber.server"/>
  
              <param-text name="to">
                    mary@another.jabber.server
              </param-text>
  
              <log4perl:layout class="org.apache.log4j.PatternLayout">
                  <param name="ConversionPattern" value = "%K xx %G %U"/>
                  <cspec name="K">
                      sub { return sprintf "%1x", $$}
                  </cspec>
                  <cspec name="G">
                      sub {return 'thisistheGcspec'}
                  </cspec>
              </log4perl:layout>
      </log4perl:appender>
  
      <log4perl:appender name="DBAppndr2" class="Log::Log4perl::Appender::DBI">
                <param name="warp_message" value="0"/>
                <param name="datasource" value="DBI:CSV:f_dir=t/tmp"/>
                <param name="bufferSize" value="2"/>
                <param name="password" value="sub { $ENV{PWD} }"/>
                <param name="username" value="bobjones"/>
  
                <param-text name="sql">
                    INSERT INTO log4perltest
                              (loglevel, message, shortcaller, thingid,
                              category, pkg, runtime1, runtime2)
                    VALUES
                               (?,?,?,?,?,?,?,?)
                </param-text>
  
                 <param-nested name="params">
                      <param name="1" value="%p"/>
                      <param name="3" value="%5.5l"/>
                      <param name="5" value="%c"/>
                      <param name="6" value="%C"/>
                 </param-nested>
  
                 <layout class="Log::Log4perl::Layout::NoopLayout"/>
      </log4perl:appender>
  
      <category name="animal.dog">
                 <priority value="info"/>
                 <appender-ref ref="jabbender"/>
                 <appender-ref ref="DBAppndr2"/>
      </category>
  
      <category name="plant">
              <priority value="debug"/>
              <appender-ref ref="DBAppndr2"/>
      </category>
  
      <PatternLayout>
          <cspec name="U"><![CDATA[
              sub {
                  return "UID $< GID $(";
              }
          ]]></cspec>
      </PatternLayout>
  
      </log4perl:configuration>
      
  
  
  
  =head1 DESCRIPTION
  
  This module implements an XML config, complementing the properties-style
  config described elsewhere.
  
  =head1 WHY
  
  "Why would I want my config in XML?" you ask.  Well, there are a couple
  reasons you might want to.  Maybe you have a personal preference
  for XML.  Maybe you manage your config with other tools that have an
  affinity for XML, like XML-aware editors or automated config
  generators.  Or maybe (and this is the big one) you don't like
  having to run your application just to check the syntax of your
  config file.
  
  By using an XML config and referencing a DTD, you can use a namespace-aware
  validating parser to see if your XML config at least follows the rules set 
  in the DTD. 
  
  =head1 HOW
  
  To reference a DTD, drop this in after the <?xml...> declaration
  in your config file:
  
      <!DOCTYPE log4perl:configuration SYSTEM "log4perl.dtd">
  
  That tells the parser to validate your config against the DTD in
  "log4perl.dtd", which is available in the xml/ directory of
  the log4perl distribution.  Note that you'll also need to grab
  the log4j-1.2.dtd from there as well, since the it's included
  by log4perl.dtd.
  
  Namespace-aware validating parsers are not the norm in Perl.  
  But the Xerces project 
  (http://xml.apache.org/xerces-c/index.html --lots of binaries available, 
  even rpm's)  does provide just such a parser
  that you can use like this:
  
      StdInParse -ns -v < my-log4perl-config.xml
  
  This module itself does not use a validating parser, the obvious
  one XML::DOM::ValParser doesn't seem to handle namespaces.
  
  =head1 WHY TWO DTDs
  
  The log4j DTD is from the log4j project, they designed it to 
  handle their needs.  log4perl has added some extensions to the 
  original log4j functionality which needed some extensions to the
  log4j DTD.  If you aren't using these features then you can validate
  your config against the log4j dtd and know that you're using
  unadulterated log4j config tags.   
  
  The features added by the log4perl dtd are:
  
  =over 4
  
  =item 1 oneMessagePerAppender global setting
  
      log4perl.oneMessagePerAppender=1
  
  =item 2 globally defined user conversion specifiers
  
      log4perl.PatternLayout.cspec.G=sub { return "UID $< GID $("; }
  
  =item 3 appender-local custom conversion specifiers
  
       log4j.appender.appndr1.layout.cspec.K = sub {return sprintf "%1x", $$ }
  
  =item 4 nested options
  
       log4j.appender.jabbender          = Log::Dispatch::Jabber
       #(note how these are nested under 'login')
       log4j.appender.jabbender.login.hostname = a.jabber.server
       log4j.appender.jabbender.login.port     = 5222
       log4j.appender.jabbender.login.username = bobjones
  
  =item 5 the log4perl-specific filters, see L<Log::Log4perl::Filter>,
  lots of examples in t/044XML-Filter.t, here's a short one:
  
  
    <?xml version="1.0" encoding="UTF-8"?> 
    <!DOCTYPE log4perl:configuration SYSTEM "log4perl.dtd">
  
    <log4perl:configuration xmlns:log4perl="http://log4perl.sourceforge.net/">
     
    <appender name="A1" class="Log::Log4perl::Appender::TestBuffer">
          <layout class="Log::Log4perl::Layout::SimpleLayout"/>
          <filter class="Log::Log4perl::Filter::Boolean">
              <param name="logic" value="!Match3 &amp;&amp; (Match1 || Match2)"/> 
          </filter>
    </appender>   
    
    <appender name="A2" class="Log::Log4perl::Appender::TestBuffer">
          <layout class="Log::Log4perl::Layout::SimpleLayout"/>
          <filter-ref id="Match1"/>
    </appender>   
    
    <log4perl:filter name="Match1" value="sub { /let this through/ }" />
    
    <log4perl:filter name="Match2">
          sub { 
              /and that, too/ 
          }
     </log4perl:filter>
    
    <log4perl:filter name="Match3" class="Log::Log4perl::Filter::StringMatch">
      <param name="StringToMatch" value="suppress"/>
      <param name="AcceptOnMatch" value="true"/>
    </log4perl:filter>
    
    <log4perl:filter name="MyBoolean" class="Log::Log4perl::Filter::Boolean">
      <param name="logic" value="!Match3 &amp;&amp; (Match1 || Match2)"/>
    </log4perl:filter>
    
     
     <root>
             <priority value="info"/>
             <appender-ref ref="A1"/>
     </root>
     
     </log4perl:configuration>
  
  
  =back
  
  
  So we needed to extend the log4j dtd to cover these additions.
  Now I could have just taken a 'steal this code' approach and mixed
  parts of the log4j dtd into a log4perl dtd, but that would be
  cut-n-paste programming.  So I've used namespaces and
  
  =over 4
  
  =item * 
  
  replaced three elements:
  
  =over 4
  
  =item <log4perl:configuration>
  
  handles #1) and accepts <PatternLayout>
  
  =item <log4perl:appender> 
  
  accepts <param-nested> and <param-text>
  
  =item <log4perl:layout> 
  
  accepts custom cspecs for #3)
  
  =back
  
  =item * 
  
  added a <param-nested> element (complementing the <param> element)
      to handle #4)
  
  =item * 
  
  added a root <PatternLayout> element to handle #2)
  
  =item * 
  
  added <param-text> which lets you put things like perl code
      into escaped CDATA between the tags, so you don't have to worry
      about escaping characters and quotes
  
  =item * 
  
  added <cspec>
  
  =back
  
  See the examples up in the L<"SYNOPSIS"> for how all that gets used.
  
  =head1 WHY NAMESPACES
  
  I liked the idea of using the log4j DTD I<in situ>, so I used namespaces
  to extend it.  If you really don't like having to type <log4perl:appender>
  instead of just <appender>, you can make your own DTD combining
  the two DTDs and getting rid of the namespace prefixes.  Then you can
  validate against that, and log4perl should accept it just fine.
  
  =head1 VARIABLE SUBSTITUTION
  
  This supports variable substitution like C<${foobar}> in text and in 
  attribute values except for appender-ref.  If an environment variable is defined
  for that name, its value is substituted. So you can do stuff like
  
          <param name="${hostname}" value="${hostnameval}.foo.com"/>
          <param-text name="to">${currentsysadmin}@foo.com</param-text>
  
  
  =head1 REQUIRES
  
  To use this module you need XML::DOM installed.  
  
  To use the log4perl.dtd, you'll have to reference it in your XML config,
  and you'll also need to note that log4perl.dtd references the 
  log4j dtd as "log4j-1.2.dtd", so your validator needs to be able
  to find that file as well.  If you don't like having to schlep two
  files around, feel free
  to dump the contents of "log4j-1.2.dtd" into your "log4perl.dtd" file.
  
  =head1 CAVEATS
  
  You can't mix a multiple param-nesteds with the same name, I'm going to
  leave that for now, there's presently no need for a list of structs
  in the config.
  
  =head1 CHANGES
  
  0.03 2/26/2003 Added support for log4perl extensions to the log4j dtd
  
  =head1 SEE ALSO
  
  t/038XML-DOM1.t, t/039XML-DOM2.t for examples
  
  xml/log4perl.dtd, xml/log4j-1.2.dtd
  
  Log::Log4perl::Config
  
  Log::Log4perl::Config::PropertyConfigurator
  
  Log::Log4perl::Config::LDAPConfigurator (coming soon!)
  
  The code is brazenly modeled on log4j's DOMConfigurator class, (by 
  Christopher Taylor, Ceki Glc, and Anders Kristensen) and any
  perceived similarity is not coincidental.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_CONFIG_DOMCONFIGURATOR

$fatpacked{"Log/Log4perl/Config/PropertyConfigurator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_CONFIG_PROPERTYCONFIGURATOR';
  package Log::Log4perl::Config::PropertyConfigurator;
  use Log::Log4perl::Config::BaseConfigurator;
  
  use warnings;
  use strict;
  
  our @ISA = qw(Log::Log4perl::Config::BaseConfigurator);
  
  our %NOT_A_MULT_VALUE = map { $_ => 1 }
      qw(conversionpattern);
  
  #poor man's export
  *eval_if_perl = \&Log::Log4perl::Config::eval_if_perl;
  *compile_if_perl = \&Log::Log4perl::Config::compile_if_perl;
  *unlog4j      = \&Log::Log4perl::Config::unlog4j;
  
  use constant _INTERNAL_DEBUG => 0;
  
  our $COMMENT_REGEX = qr/[#;!]/;
  
  ################################################
  sub parse {
  ################################################
      my($self, $newtext) = @_;
  
      $self->text($newtext) if defined $newtext;
  
      my $text = $self->{text};
  
      die "Config parser has nothing to parse" unless defined $text;
  
      my $data = {};
      my %var_subst = ();
  
      while (@$text) {
          local $_ = shift @$text;
          s/^\s*$COMMENT_REGEX.*//;
          next unless /\S/;
      
          my @parts = ();
  
          while (/(.+?)\\\s*$/) {
              my $prev = $1;
              my $next = shift(@$text);
              $next =~ s/^ +//g;  #leading spaces
              $next =~ s/^$COMMENT_REGEX.*//;
              $_ = $prev. $next;
              chomp;
          }
  
          if(my($key, $val) = /(\S+?)\s*=\s*(.*)/) {
  
              my $key_org = $key;
  
              $val =~ s/\s+$//;
  
                  # Everything could potentially be a variable assignment
              $var_subst{$key} = $val;
  
                  # Substitute any variables
              $val =~ s/\$\{(.*?)\}/
                        Log::Log4perl::Config::var_subst($1, \%var_subst)/gex;
  
              $key = unlog4j($key);
  
              my $how_deep = 0;
              my $ptr = $data;
              for my $part (split /\.|::/, $key) {
                  push @parts, $part;
                  $ptr->{$part} = {} unless exists $ptr->{$part};
                  $ptr = $ptr->{$part};
                  ++$how_deep;
              }
  
              #here's where we deal with turning multiple values like this:
              # log4j.appender.jabbender.to = him@a.jabber.server
              # log4j.appender.jabbender.to = her@a.jabber.server
              #into an arrayref like this:
              #to => { value => 
              #       ["him\@a.jabber.server", "her\@a.jabber.server"] },
              # 
              # This only is allowed for properties of appenders
              # not listed in %NOT_A_MULT_VALUE (see top of file).
              if (exists $ptr->{value} && 
                  $how_deep > 2 &&
                  defined $parts[0] && lc($parts[0]) eq "appender" && 
                  defined $parts[2] && ! exists $NOT_A_MULT_VALUE{lc($parts[2])}
                 ) {
                  if (ref ($ptr->{value}) ne 'ARRAY') {
                      my $temp = $ptr->{value};
                      $ptr->{value} = [];
                      push (@{$ptr->{value}}, $temp);
                  }
                  push (@{$ptr->{value}}, $val);
              }else{
                  if(defined $ptr->{value}) {
                      if(! $Log::Log4perl::Logger::NO_STRICT) {
                          die "$key_org redefined";
                      }
                  }
                  $ptr->{value} = $val;
              }
          }
      }
      $self->{data} = $data;
      return $data;
  }
  
  ################################################
  sub value {
  ################################################
    my($self, $path) = @_;
  
    $path = unlog4j($path);
  
    my @p = split /::/, $path;
  
    my $found = 0;
    my $r = $self->{data};
  
    while (my $n = shift @p) {
        if (exists $r->{$n}) {
            $r = $r->{$n};
            $found = 1;
        } else {
            $found = 0;
        }
    }
  
    if($found and exists $r->{value}) {
        return $r->{value};
    } else {
        return undef;
    }
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Config::PropertyConfigurator - reads properties file
  
  =head1 SYNOPSIS
  
      # This class is used internally by Log::Log4perl
  
      use Log::Log4perl::Config::PropertyConfigurator;
  
      my $conf = Log::Log4perl::Config::PropertyConfigurator->new();
      $conf->file("l4p.conf");
      $conf->parse(); # will die() on error
  
      my $value = $conf->value("log4perl.appender.LOGFILE.filename");
     
      if(defined $value) {
          printf("The appender's file name is $value\n");
      } else {
          printf("The appender's file name is not defined.\n");
      }
  
  =head1 DESCRIPTION
  
  Initializes log4perl from a properties file, stuff like
  
      log4j.category.a.b.c.d = WARN, A1
      log4j.category.a.b = INFO, A1
  
  It also understands variable substitution, the following
  configuration is equivalent to the previous one:
  
      settings = WARN, A1
      log4j.category.a.b.c.d = ${settings}
      log4j.category.a.b = INFO, A1
  
  =head1 SEE ALSO
  
  Log::Log4perl::Config
  
  Log::Log4perl::Config::BaseConfigurator
  
  Log::Log4perl::Config::DOMConfigurator
  
  Log::Log4perl::Config::LDAPConfigurator (tbd!)
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_CONFIG_PROPERTYCONFIGURATOR

$fatpacked{"Log/Log4perl/Config/Watch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_CONFIG_WATCH';
  package Log::Log4perl::Config::Watch;
  
  use constant _INTERNAL_DEBUG => 0;
  
  our $NEXT_CHECK_TIME;
  our $SIGNAL_CAUGHT;
  
  our $L4P_TEST_CHANGE_DETECTED;
  our $L4P_TEST_CHANGE_CHECKED;
  
  ###########################################
  sub new {
  ###########################################
      my($class, %options) = @_;
  
      my $self = { file            => "",
                   check_interval  => 30,
                   l4p_internal    => 0,
                   signal          => undef,
                   %options,
                   _last_checked_at => 0,
                   _last_timestamp  => 0,
                 };
  
      bless $self, $class;
  
      if($self->{signal}) {
              # We're in signal mode, set up the handler
          print "Setting up signal handler for '$self->{signal}'\n" if
              _INTERNAL_DEBUG;
  
          # save old signal handlers; they belong to other appenders or
          # possibly something else in the consuming application
          my $old_sig_handler = $SIG{$self->{signal}};
          $SIG{$self->{signal}} = sub { 
              print "Caught $self->{signal} signal\n" if _INTERNAL_DEBUG;
              $self->force_next_check();
              $old_sig_handler->(@_) if $old_sig_handler and ref $old_sig_handler eq 'CODE';
          };
              # Reset the marker. The handler is going to modify it.
          $self->{signal_caught} = 0;
          $SIGNAL_CAUGHT = 0 if $self->{l4p_internal};
      } else {
              # Just called to initialize
          $self->change_detected(undef, 1);
          $self->file_has_moved(undef, 1);
      }
  
      return $self;
  }
  
  ###########################################
  sub force_next_check {
  ###########################################
      my($self) = @_;
  
      $self->{signal_caught}   = 1;
      $self->{next_check_time} = 0;
  
      if( $self->{l4p_internal} ) {
          $SIGNAL_CAUGHT = 1;
          $NEXT_CHECK_TIME = 0;
      }
  }
  
  ###########################################
  sub force_next_check_reset {
  ###########################################
      my($self) = @_;
  
      $self->{signal_caught} = 0;
      $SIGNAL_CAUGHT = 0 if $self->{l4p_internal};
  }
  
  ###########################################
  sub file {
  ###########################################
      my($self) = @_;
  
      return $self->{file};
  }
  
  ###########################################
  sub signal {
  ###########################################
      my($self) = @_;
  
      return $self->{signal};
  }
  
  ###########################################
  sub check_interval {
  ###########################################
      my($self) = @_;
  
      return $self->{check_interval};
  }
  
  ###########################################
  sub file_has_moved {
  ###########################################
      my($self, $time, $force) = @_;
  
      my $task = sub {
          my @stat = stat($self->{file});
  
          my $has_moved = 0;
  
          if(! $stat[0]) {
              # The file's gone, obviously it got moved or deleted.
              print "File is gone\n" if _INTERNAL_DEBUG;
              return 1;
          }
  
          my $current_inode = "$stat[0]:$stat[1]";
          print "Current inode: $current_inode\n" if _INTERNAL_DEBUG;
  
          if(exists $self->{_file_inode} and 
              $self->{_file_inode} ne $current_inode) {
              print "Inode changed from $self->{_file_inode} to ",
                    "$current_inode\n" if _INTERNAL_DEBUG;
              $has_moved = 1;
          }
  
          $self->{_file_inode} = $current_inode;
          return $has_moved;
      };
  
      return $self->check($time, $task, $force);
  }
  
  ###########################################
  sub change_detected {
  ###########################################
      my($self, $time, $force) = @_;
  
      my $task = sub {
          my @stat = stat($self->{file});
          my $new_timestamp = $stat[9];
  
          $L4P_TEST_CHANGE_CHECKED = 1;
  
          if(! defined $new_timestamp) {
              if($self->{l4p_internal}) {
                  # The file is gone? Let it slide, we don't want L4p to re-read
                  # the config now, it's gonna die.
                  return undef;
              }
              $L4P_TEST_CHANGE_DETECTED = 1;
              return 1;
          }
  
          if($new_timestamp > $self->{_last_timestamp}) {
              $self->{_last_timestamp} = $new_timestamp;
              print "Change detected (file=$self->{file} store=$new_timestamp)\n"
                    if _INTERNAL_DEBUG;
              $L4P_TEST_CHANGE_DETECTED = 1;
              return 1; # Has changed
          }
             
          print "$self->{file} unchanged (file=$new_timestamp ",
                "stored=$self->{_last_timestamp})!\n" if _INTERNAL_DEBUG;
          return "";  # Hasn't changed
      };
  
      return $self->check($time, $task, $force);
  }
  
  ###########################################
  sub check {
  ###########################################
      my($self, $time, $task, $force) = @_;
  
      $time = time() unless defined $time;
  
      if( $self->{signal_caught} or $SIGNAL_CAUGHT ) {
         $force = 1;
         $self->force_next_check_reset();
         print "Caught signal, forcing check\n" if _INTERNAL_DEBUG;
  
      }
  
      print "Soft check (file=$self->{file} time=$time)\n" if _INTERNAL_DEBUG;
  
          # Do we need to check?
      if(!$force and
         $self->{_last_checked_at} + 
         $self->{check_interval} > $time) {
          print "No need to check\n" if _INTERNAL_DEBUG;
          return ""; # don't need to check, return false
      }
         
      $self->{_last_checked_at} = $time;
  
      # Set global var for optimizations in case we just have one watcher
      # (like in Log::Log4perl)
      $self->{next_check_time} = $time + $self->{check_interval};
      $NEXT_CHECK_TIME = $self->{next_check_time} if $self->{l4p_internal};
  
      print "Hard check (file=$self->{file} time=$time)\n" if _INTERNAL_DEBUG;
      return $task->($time);
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Config::Watch - Detect file changes
  
  =head1 SYNOPSIS
  
      use Log::Log4perl::Config::Watch;
  
      my $watcher = Log::Log4perl::Config::Watch->new(
                            file            => "/data/my.conf",
                            check_interval  => 30,
                    );
  
      while(1) {
          if($watcher->change_detected()) {
              print "Change detected!\n";
          }
          sleep(1);
      }
  
  =head1 DESCRIPTION
  
  This module helps detecting changes in files. Although it comes with the
  C<Log::Log4perl> distribution, it can be used independently.
  
  The constructor defines the file to be watched and the check interval 
  in seconds. Subsequent calls to C<change_detected()> will 
  
  =over 4
  
  =item *
  
  return a false value immediately without doing physical file checks
  if C<check_interval> hasn't elapsed.
  
  =item *
  
  perform a physical test on the specified file if the number
  of seconds specified in C<check_interval> 
  have elapsed since the last physical check. If the file's modification
  date has changed since the last physical check, it will return a true 
  value, otherwise a false value is returned.
  
  =back
  
  Bottom line: C<check_interval> allows you to call the function
  C<change_detected()> as often as you like, without paying the performing
  a significant performance penalty because file system operations 
  are being performed (however, you pay the price of not knowing about
  file changes until C<check_interval> seconds have elapsed).
  
  The module clearly distinguishes system time from file system time. 
  If your (e.g. NFS mounted) file system is off by a constant amount
  of time compared to the executing computer's clock, it'll just
  work fine.
  
  To disable the resource-saving delay feature, just set C<check_interval> 
  to 0 and C<change_detected()> will run a physical file test on
  every call.
  
  If you already have the current time available, you can pass it
  on to C<change_detected()> as an optional parameter, like in
  
      change_detected($time)
  
  which then won't trigger a call to C<time()>, but use the value
  provided.
  
  =head2 SIGNAL MODE
  
  Instead of polling time and file changes, C<new()> can be instructed 
  to set up a signal handler. If you call the constructor like
  
      my $watcher = Log::Log4perl::Config::Watch->new(
                            file    => "/data/my.conf",
                            signal  => 'HUP'
                    );
  
  then a signal handler will be installed, setting the object's variable 
  C<$self-E<gt>{signal_caught}> to a true value when the signal arrives.
  Comes with all the problems that signal handlers go along with.
  
  =head2 TRIGGER CHECKS
  
  To trigger a physical file check on the next call to C<change_detected()>
  regardless if C<check_interval> has expired or not, call
  
      $watcher->force_next_check();
  
  on the watcher object.
  
  =head2 DETECT MOVED FILES
  
  The watcher can also be used to detect files that have moved. It will 
  not only detect if a watched file has disappeared, but also if it has
  been replaced by a new file in the meantime.
  
      my $watcher = Log::Log4perl::Config::Watch->new(
          file           => "/data/my.conf",
          check_interval => 30,
      );
  
      while(1) {
          if($watcher->file_has_moved()) {
              print "File has moved!\n";
          }
          sleep(1);
      }
  
  The parameters C<check_interval> and C<signal> limit the number of physical 
  file system checks, similarily as with C<change_detected()>.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_CONFIG_WATCH

$fatpacked{"Log/Log4perl/DateFormat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_DATEFORMAT';
  ###########################################
  package Log::Log4perl::DateFormat;
  ###########################################
  use warnings;
  use strict;
  
  use Carp qw( croak );
  
  our $GMTIME = 0;
  
  my @MONTH_NAMES = qw(
  January February March April May June July
  August September October November December);
  
  my @WEEK_DAYS = qw(
  Sunday Monday Tuesday Wednesday Thursday Friday Saturday);
  
  ###########################################
  sub new {
  ###########################################
      my($class, $format) = @_;
  
      my $self = { 
                    stack => [],
                    fmt   => undef,
                 };
  
      bless $self, $class;
  
          # Predefined formats
      if($format eq "ABSOLUTE") {
          $format = "HH:mm:ss,SSS";
      } elsif($format eq "DATE") {
          $format = "dd MMM yyyy HH:mm:ss,SSS";
      } elsif($format eq "ISO8601") {
          $format = "yyyy-MM-dd HH:mm:ss,SSS";
      } elsif($format eq "APACHE") {
          $format = "[EEE MMM dd HH:mm:ss yyyy]";
      }
  
      if($format) { 
          $self->prepare($format);
      }
  
      return $self;
  }
  
  ###########################################
  sub prepare {
  ###########################################
      my($self, $format) = @_;
  
      # the actual DateTime spec allows for literal text delimited by
      # single quotes; a single quote can be embedded in the literal
      # text by using two single quotes.
      #
      # my strategy here is to split the format into active and literal
      # "chunks"; active chunks are prepared using $self->rep() as
      # before, while literal chunks get transformed to accommodate
      # single quotes and to protect percent signs.
      #
      # motivation: the "recommended" ISO-8601 date spec for a time in
      # UTC is actually:
      #
      #     YYYY-mm-dd'T'hh:mm:ss.SSS'Z'
  
      my $fmt = "";
  
      foreach my $chunk ( split /('(?:''|[^'])*')/, $format ) {
          if ( $chunk =~ /\A'(.*)'\z/ ) {
                # literal text
              my $literal = $1;
              $literal =~ s/''/'/g;
              $literal =~ s/\%/\%\%/g;
              $fmt .= $literal;
          } elsif ( $chunk =~ /'/ ) {
                # single quotes should always be in a literal
              croak "bad date format \"$format\": " .
                    "unmatched single quote in chunk \"$chunk\"";
          } else {
              # handle active chunks just like before
              $chunk =~ s/(([GyMdhHmsSEeDFwWakKzZ])\2*)/$self->rep($1)/ge;
              $fmt .= $chunk;
          }
      }
  
      return $self->{fmt} = $fmt;
  }
  
  ###########################################
  sub rep {
  ###########################################
      my ($self, $string) = @_;
  
      my $first = substr $string, 0, 1;
      my $len   = length $string;
  
      my $time=time();
      my @g = gmtime($time);
      my @t = localtime($time);
      my $z = $t[1]-$g[1]+($t[2]-$g[2])*60+($t[7]-$g[7])*1440+
              ($t[5]-$g[5])*(525600+(abs($t[7]-$g[7])>364)*1440);
      my $offset = sprintf("%+.2d%.2d", $z/60, "00");
  
      #my ($s,$mi,$h,$d,$mo,$y,$wd,$yd,$dst) = localtime($time);
  
      # Here's how this works:
      # Detect what kind of parameter we're dealing with and determine
      # what type of sprintf-placeholder to return (%d, %02d, %s or whatever).
      # Then, we're setting up an array, specific to the current format,
      # that can be used later on to compute the components of the placeholders
      # one by one when we get the components of the current time later on
      # via localtime.
      
      # So, we're parsing the "yyyy/MM" format once, replace it by, say
      # "%04d:%02d" and store an array that says "for the first placeholder,
      # get the localtime-parameter on index #5 (which is years since the
      # epoch), add 1900 to it and pass it on to sprintf(). For the 2nd 
      # placeholder, get the localtime component at index #2 (which is hours)
      # and pass it on unmodified to sprintf.
      
      # So, the array to compute the time format at logtime contains
      # as many elements as the original SimpleDateFormat contained. Each
      # entry is a array ref, holding an array with 2 elements: The index
      # into the localtime to obtain the value and a reference to a subroutine
      # to do computations eventually. The subroutine expects the original
      # localtime() time component (like year since the epoch) and returns
      # the desired value for sprintf (like y+1900).
  
      # This way, we're parsing the original format only once (during system
      # startup) and during runtime all we do is call localtime *once* and
      # run a number of blazingly fast computations, according to the number
      # of placeholders in the format.
  
  ###########
  #G - epoch#
  ###########
      if($first eq "G") {
          # Always constant
          return "AD";
  
  ###################
  #e - epoch seconds#
  ###################
      } elsif($first eq "e") {
            # index (0) irrelevant, but we return time() which 
            # comes in as 2nd parameter
          push @{$self->{stack}}, [0, sub { return $_[1] }];
          return "%d";
  
  ##########
  #y - year#
  ##########
      } elsif($first eq "y") {
          if($len >= 4) {
              # 4-digit year
              push @{$self->{stack}}, [5, sub { return $_[0] + 1900 }];
              return "%04d";
          } else {
              # 2-digit year
              push @{$self->{stack}}, [5, sub { $_[0] % 100 }];
              return "%02d";
          }
  
  ###########
  #M - month#
  ###########
      } elsif($first eq "M") {
          if($len >= 3) {
              # Use month name
              push @{$self->{stack}}, [4, sub { return $MONTH_NAMES[$_[0]] }];
             if($len >= 4) {
                  return "%s";
              } else {
                 return "%.3s";
              }
          } elsif($len == 2) {
              # Use zero-padded month number
              push @{$self->{stack}}, [4, sub { $_[0]+1 }];
              return "%02d";
          } else {
              # Use zero-padded month number
              push @{$self->{stack}}, [4, sub { $_[0]+1 }];
              return "%d";
          }
  
  ##################
  #d - day of month#
  ##################
      } elsif($first eq "d") {
          push @{$self->{stack}}, [3, sub { return $_[0] }];
          return "%0" . $len . "d";
  
  ##################
  #h - am/pm hour#
  ##################
      } elsif($first eq "h") {
          push @{$self->{stack}}, [2, sub { ($_[0] % 12) || 12 }];
          return "%0" . $len . "d";
  
  ##################
  #H - 24 hour#
  ##################
      } elsif($first eq "H") {
          push @{$self->{stack}}, [2, sub { return $_[0] }];
          return "%0" . $len . "d";
  
  ##################
  #m - minute#
  ##################
      } elsif($first eq "m") {
          push @{$self->{stack}}, [1, sub { return $_[0] }];
          return "%0" . $len . "d";
  
  ##################
  #s - second#
  ##################
      } elsif($first eq "s") {
          push @{$self->{stack}}, [0, sub { return $_[0] }];
          return "%0" . $len . "d";
  
  ##################
  #E - day of week #
  ##################
      } elsif($first eq "E") {
          push @{$self->{stack}}, [6, sub { $WEEK_DAYS[$_[0]] }];
         if($len >= 4) {
              return "%${len}s";
          } else {
             return "%.3s";
          }
  
  ######################
  #D - day of the year #
  ######################
      } elsif($first eq "D") {
          push @{$self->{stack}}, [7, sub { $_[0] + 1}];
          return "%0" . $len . "d";
  
  ######################
  #a - am/pm marker    #
  ######################
      } elsif($first eq "a") {
          push @{$self->{stack}}, [2, sub { $_[0] < 12 ? "AM" : "PM" }];
          return "%${len}s";
  
  ######################
  #S - milliseconds    #
  ######################
      } elsif($first eq "S") {
          push @{$self->{stack}}, 
               [9, sub { substr sprintf("%06d", $_[0]), 0, $len }];
          return "%s";
  
  ###############################
  #Z - RFC 822 time zone  -0800 #
  ###############################
      } elsif($first eq "Z") {
          push @{$self->{stack}}, [10, sub { $offset }];
          return "%s";
  
  #############################
  #Something that's not defined
  #(F=day of week in month
  # w=week in year W=week in month
  # k=hour in day K=hour in am/pm
  # z=timezone
  #############################
      } else {
          return "-- '$first' not (yet) implemented --";
      }
  
      return $string;
  }
  
  ###########################################
  sub format {
  ###########################################
      my($self, $secs, $msecs) = @_;
  
      $msecs = 0 unless defined $msecs;
  
      my @time; 
  
      if($GMTIME) {
          @time = gmtime($secs);
      } else {
          @time = localtime($secs);
      }
  
          # add milliseconds
      push @time, $msecs;
  
      my @values = ();
  
      for(@{$self->{stack}}) {
          my($val, $code) = @$_;
          if($code) {
              push @values, $code->($time[$val], $secs);
          } else {
              push @values, $time[$val];
          }
      }
  
      return sprintf($self->{fmt}, @values);
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::DateFormat - Log4perl advanced date formatter helper class
  
  =head1 SYNOPSIS
  
  
        # Either in a log4j.conf file ...
      log4perl.appender.Logfile.layout = \
          Log::Log4perl::Layout::PatternLayout
      log4perl.appender.Logfile.layout.ConversionPattern = %d{MM/dd HH:mm} %m
  
        # ... or via the PatternLayout class ...
      use Log::Log4perl::Layout::PatternLayout;
      my $layout = Log::Log4perl::Layout::PatternLayout->new(
          "%d{HH:mm:ss,SSS} %m");
  
        # ... or even directly with this helper class:
      use Log::Log4perl::DateFormat;
      my $format = Log::Log4perl::DateFormat->new("HH:mm:ss,SSS");
      my $time = time();
      print $format->format($time), "\n";
          # => "17:02:39,000"
  
  =head1 DESCRIPTION
  
  C<Log::Log4perl::DateFormat> is a helper class for the 
  advanced date formatting functions in C<Log::Log4perl::Layout::PatternLayout>,
  and adheres (mostly) to the log4j SimpleDateFormat spec available on
  
      http://download.oracle.com/javase/1.4.2/docs/api/java/text/SimpleDateFormat.html
  
  It supports the following placeholders:
  
      Symbol Meaning              Presentation    Example
      ------ -------              ------------    -------
      G      era designator       (Text)          AD
      e      epoch seconds        (Number)        1315011604
      y      year                 (Number)        1996
      M      month in year        (Text & Number) July & 07
      d      day in month         (Number)        10
      h      hour in am/pm (1~12) (Number)        12
      H      hour in day (0~23)   (Number)        0
      m      minute in hour       (Number)        30
      s      second in minute     (Number)        55
      S      millisecond          (Number)        978
      E      day in week          (Text)          Tuesday
      D      day in year          (Number)        189
      F      day of week in month (Number)        2 (2nd Wed in July)
      w      week in year         (Number)        27
      W      week in month        (Number)        2
      a      am/pm marker         (Text)          PM
      k      hour in day (1~24)   (Number)        24
      K      hour in am/pm (0~11) (Number)        0
      z      time zone            (Text)          Pacific Standard Time
      Z      RFC 822 time zone    (Text)          -0800
      '      escape for text      (Delimiter)
      ''     single quote         (Literal)       '
  
      Presentation explanation:
  
      (Text): 4 or more pattern letters--use full form, < 4--use short or 
              abbreviated form if one exists. 
  
      (Number): the minimum number of digits. Shorter numbers are 
                zero-padded to this amount. Year is handled 
                specially; that is, if the count of 'y' is 2, the 
                Year will be truncated to 2 digits. 
  
      (Text & Number): 3 or over, use text, otherwise use number. 
  
  For example, if you want to format the current Unix time in C<"MM/dd HH:mm">
  format, all you have to do is specify it in the %d{...} section of the
  PatternLayout in a Log4perl configuration file:
  
      # log4j.conf
      # ...
      log4perl.appender.Logfile.layout = \
          Log::Log4perl::Layout::PatternLayout
      log4perl.appender.Logfile.layout.ConversionPattern = %d{MM/dd HH:mm} %m
  
  Same goes for Perl code defining a PatternLayout for Log4perl:
  
      use Log::Log4perl::Layout::PatternLayout;
      my $layout = Log::Log4perl::Layout::PatternLayout->new(
          "%d{MM/dd HH:mm} %m");
  
  Or, on a lower level, you can use the class directly:
  
      use Log::Log4perl::DateFormat;
      my $format = Log::Log4perl::DateFormat->new("MM/dd HH:mm");
      my $time = time();
      print $format->format($time), "\n";
  
  While the C<new()> method is expensive, because it parses the format
  strings and sets up all kinds of structures behind the scenes, 
  followup calls to C<format()> are fast, because C<DateFormat> will
  just call C<localtime()> and C<sprintf()> once to return the formatted
  date/time string.
  
  So, typically, you would initialize the formatter once and then reuse
  it over and over again to display all kinds of time values.
  
  Also, for your convenience, 
  the following predefined formats are available, just as outlined in the
  log4j spec:
  
      Format   Equivalent                     Example
      ABSOLUTE "HH:mm:ss,SSS"                 "15:49:37,459"
      DATE     "dd MMM yyyy HH:mm:ss,SSS"     "06 Nov 1994 15:49:37,459"
      ISO8601  "yyyy-MM-dd HH:mm:ss,SSS"      "1999-11-27 15:49:37,459"
      APACHE   "[EEE MMM dd HH:mm:ss yyyy]"   "[Wed Mar 16 15:49:37 2005]"
  
  So, instead of passing 
  
      Log::Log4perl::DateFormat->new("HH:mm:ss,SSS");
  
  you could just as well say
  
      Log::Log4perl::DateFormat->new("ABSOLUTE");
  
  and get the same result later on.
  
  =head2 Known Shortcomings
   
  The following placeholders are currently I<not> recognized, unless
  someone (and that could be you :) implements them:
  
      F day of week in month
      w week in year 
      W week in month
      k hour in day 
      K hour in am/pm
      z timezone (but we got 'Z' for the numeric time zone value)
  
  Also, C<Log::Log4perl::DateFormat> just knows about English week and
  month names, internationalization support has to be added.
  
  =head1 Millisecond Times
  
  More granular timestamps down to the millisecond are also supported,
  just provide the millsecond count as a second argument:
  
      # Advanced time, resultion in milliseconds
      use Time::HiRes;
      my ($secs, $msecs) = Time::HiRes::gettimeofday();
      print $format->format($secs, $msecs), "\n";
          # => "17:02:39,959"
  
  =head1 LICENSE
  
  Copyright 2002-2016 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_DATEFORMAT

$fatpacked{"Log/Log4perl/FAQ.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_FAQ';
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::FAQ - Frequently Asked Questions on Log::Log4perl
  
  =head1 DESCRIPTION
  
  This FAQ shows a wide variety of
  commonly encountered logging tasks and how to solve them
  in the most elegant way with Log::Log4perl. Most of the time, this will
  be just a matter of smartly configuring your Log::Log4perl configuration files.
  
  =head2 Why use Log::Log4perl instead of any other logging module on CPAN?
  
  That's a good question. There's dozens of logging modules on CPAN.
  When it comes to logging, people typically think: "Aha. Writing out
  debug and error messages. Debug is lower than error. Easy. I'm gonna
  write my own." Writing a logging module is like a rite of passage for
  every Perl programmer, just like writing your own templating system.
  
  Of course, after getting the basics right, features need to
  be added. You'd like to write a timestamp with every message. Then
  timestamps with microseconds. Then messages need to be written to both
  the screen and a log file.
  
  And, as your application grows in size you might wonder: Why doesn't
  my logging system scale along with it? You would like to switch on
  logging in selected parts of the application, and not all across the
  board, because this kills performance. This is when people turn to
  Log::Log4perl, because it handles all of that.
  
  Avoid this costly switch.
  
  Use C<Log::Log4perl> right from the start. C<Log::Log4perl>'s C<:easy>
  mode supports easy logging in simple scripts:
  
      use Log::Log4perl qw(:easy);
      Log::Log4perl->easy_init($DEBUG);
  
      DEBUG "A low-level message";
      ERROR "Won't make it until level gets increased to ERROR";
  
  And when your application inevitably grows, your logging system grows
  with it without you having to change any code.
  
  Please, don't re-invent logging. C<Log::Log4perl> is here, it's easy
  to use, it scales, and covers many areas you haven't thought of yet,
  but will enter soon.
  
  =head2 What's the easiest way to use Log4perl?
  
  If you just want to get all the comfort of logging, without much
  overhead, use I<Stealth Loggers>. If you use Log::Log4perl in
  C<:easy> mode like
  
      use Log::Log4perl qw(:easy);
  
  you'll have the following functions available in the current package:
  
      DEBUG("message");
      INFO("message");
      WARN("message");
      ERROR("message");
      FATAL("message");
  
  Just make sure that every package of your code where you're using them in
  pulls in C<use Log::Log4perl qw(:easy)> first, then you're set.
  Every stealth logger's category will be equivalent to the name of the
  package it's located in.
  
  These stealth loggers
  will be absolutely silent until you initialize Log::Log4perl in
  your main program with either
  
          # Define any Log4perl behavior
      Log::Log4perl->init("foo.conf");
  
  (using a full-blown Log4perl config file) or the super-easy method
  
          # Just log to STDERR
      Log::Log4perl->easy_init($DEBUG);
  
  or the parameter-style method with a complexity somewhat in between:
  
          # Append to a log file
      Log::Log4perl->easy_init( { level   => $DEBUG,
                                  file    => ">>test.log" } );
  
  For more info, please check out L<Log::Log4perl/"Stealth Loggers">.
  
  =head2 How can I simply log all my ERROR messages to a file?
  
  After pulling in the C<Log::Log4perl> module, just initialize its
  behavior by passing in a configuration to its C<init> method as a string
  reference. Then, obtain a logger instance and write out a message
  with its C<error()> method:
  
      use Log::Log4perl qw(get_logger);
  
          # Define configuration
      my $conf = q(
          log4perl.logger                    = ERROR, FileApp
          log4perl.appender.FileApp          = Log::Log4perl::Appender::File
          log4perl.appender.FileApp.filename = test.log
          log4perl.appender.FileApp.layout   = PatternLayout
          log4perl.appender.FileApp.layout.ConversionPattern = %d> %m%n
      );
  
          # Initialize logging behavior
      Log::Log4perl->init( \$conf );
  
          # Obtain a logger instance
      my $logger = get_logger("Bar::Twix");
      $logger->error("Oh my, a dreadful error!");
      $logger->warn("Oh my, a dreadful warning!");
  
  This will append something like
  
      2002/10/29 20:11:55> Oh my, a dreadful error!
  
  to the log file C<test.log>. How does this all work?
  
  While the Log::Log4perl C<init()> method typically
  takes the name of a configuration file as its input parameter like
  in
  
      Log::Log4perl->init( "/path/mylog.conf" );
  
  the example above shows how to pass in a configuration as text in a
  scalar reference.
  
  The configuration as shown
  defines a logger of the root category, which has an appender of type
  C<Log::Log4perl::Appender::File> attached. The line
  
      log4perl.logger = ERROR, FileApp
  
  doesn't list a category, defining a root logger. Compare that with
  
      log4perl.logger.Bar.Twix = ERROR, FileApp
  
  which would define a logger for the category C<Bar::Twix>,
  showing probably different behavior. C<FileApp> on
  the right side of the assignment is
  an arbitrarily defined variable name, which is only used to somehow
  reference an appender defined later on.
  
  Appender settings in the configuration are defined as follows:
  
      log4perl.appender.FileApp          = Log::Log4perl::Appender::File
      log4perl.appender.FileApp.filename = test.log
  
  It selects the file appender of the C<Log::Log4perl::Appender>
  hierarchy, which will append to the file C<test.log> if it already
  exists. If we wanted to overwrite a potentially existing file, we would
  have to explicitly set the appropriate C<Log::Log4perl::Appender::File>
  parameter C<mode>:
  
      log4perl.appender.FileApp          = Log::Log4perl::Appender::File
      log4perl.appender.FileApp.filename = test.log
      log4perl.appender.FileApp.mode     = write
  
  Also, the configuration defines a PatternLayout format, adding
  the nicely formatted current date and time, an arrow (E<gt>) and
  a space before the messages, which is then followed by a newline:
  
      log4perl.appender.FileApp.layout   = PatternLayout
      log4perl.appender.FileApp.layout.ConversionPattern = %d> %m%n
  
  Obtaining a logger instance and actually logging something is typically
  done in a different system part as the Log::Log4perl initialisation section,
  but in this example, it's just done right after init for the
  sake of compactness:
  
          # Obtain a logger instance
      my $logger = get_logger("Bar::Twix");
      $logger->error("Oh my, a dreadful error!");
  
  This retrieves an instance of the logger of the category C<Bar::Twix>,
  which, as all other categories, inherits behavior from the root logger if no
  other loggers are defined in the initialization section.
  
  The C<error()>
  method fires up a message, which the root logger catches. Its
  priority is equal to
  or higher than the root logger's priority (ERROR), which causes the root logger
  to forward it to its attached appender. By contrast, the following
  
      $logger->warn("Oh my, a dreadful warning!");
  
  doesn't make it through, because the root logger sports a higher setting
  (ERROR and up) than the WARN priority of the message.
  
  =head2 How can I install Log::Log4perl on Microsoft Windows?
  
  You can install Log::Log4perl using the CPAN client.
  
  Alternatively you can install it using
  
      ppm install Log-Log4perl
  
  if you're using ActiveState perl.
  
  
  That's it! Afterwards, just create a Perl script like
  
      use Log::Log4perl qw(:easy);
      Log::Log4perl->easy_init($DEBUG);
  
      my $logger = get_logger("Twix::Bar");
      $logger->debug("Watch me!");
  
  and run it. It should print something like
  
      2002/11/06 01:22:05 Watch me!
  
  If you find that something doesn't work, please let us know at
  log4perl-devel@lists.sourceforge.net -- we'll appreciate it. Have fun!
  
  =head2 How can I include global (thread-specific) data in my log messages?
  
  Say, you're writing a web application and want all your
  log messages to include the current client's IP address. Most certainly,
  you don't want to include it in each and every log message like in
  
      $logger->debug( $r->connection->remote_ip,
                      " Retrieving user data from DB" );
  
  do you? Instead, you want to set it in a global data structure and
  have Log::Log4perl include it automatically via a PatternLayout setting
  in the configuration file:
  
      log4perl.appender.FileApp.layout.ConversionPattern = %X{ip} %m%n
  
  The conversion specifier C<%X{ip}> references an entry under the key
  C<ip> in the global C<MDC> (mapped diagnostic context) table, which
  you've set once via
  
      Log::Log4perl::MDC->put("ip", $r->connection->remote_ip);
  
  at the start of the request handler. Note that this is a
  I<static> (class) method, there's no logger object involved.
  You can use this method with as many key/value pairs as you like as long
  as you reference them under different names.
  
  The mappings are stored in a global hash table within Log::Log4perl.
  Luckily, because the thread
  model in 5.8.0 doesn't share global variables between threads unless
  they're explicitly marked as such, there's no problem with multi-threaded
  environments.
  
  For more details on the MDC, please refer to
  L<Log::Log4perl/"Mapped Diagnostic Context (MDC)"> and
  L<Log::Log4perl::MDC>.
  
  =head2 My application is already logging to a file. How can I duplicate all messages to also go to the screen?
  
  Assuming that you already have a Log4perl configuration file like
  
      log4perl.logger                    = DEBUG, FileApp
  
      log4perl.appender.FileApp          = Log::Log4perl::Appender::File
      log4perl.appender.FileApp.filename = test.log
      log4perl.appender.FileApp.layout   = PatternLayout
      log4perl.appender.FileApp.layout.ConversionPattern = %d> %m%n
  
  and log statements all over your code,
  it's very easy with Log4perl to have the same messages both printed to
  the logfile and the screen. No reason to change your code, of course,
  just add another appender to the configuration file and you're done:
  
      log4perl.logger                    = DEBUG, FileApp, ScreenApp
  
      log4perl.appender.FileApp          = Log::Log4perl::Appender::File
      log4perl.appender.FileApp.filename = test.log
      log4perl.appender.FileApp.layout   = PatternLayout
      log4perl.appender.FileApp.layout.ConversionPattern = %d> %m%n
  
      log4perl.appender.ScreenApp          = Log::Log4perl::Appender::Screen
      log4perl.appender.ScreenApp.stderr   = 0
      log4perl.appender.ScreenApp.layout   = PatternLayout
      log4perl.appender.ScreenApp.layout.ConversionPattern = %d> %m%n
  
  The configuration file above is assuming that both appenders are
  active in the same logger hierarchy, in this case the C<root> category.
  But even if you've got file loggers defined in several parts of your system,
  belonging to different logger categories,
  each logging to different files, you can gobble up all logged messages
  by defining a root logger with a screen appender, which would duplicate
  messages from all your file loggers to the screen due to Log4perl's
  appender inheritance. Check
  
      http://www.perl.com/pub/a/2002/09/11/log4perl.html
  
  for details. Have fun!
  
  =head2 How can I make sure my application logs a message when it dies unexpectedly?
  
  Whenever you encounter a fatal error in your application, instead of saying
  something like
  
      open FILE, "<blah" or die "Can't open blah -- bailing out!";
  
  just use Log::Log4perl's fatal functions instead:
  
      my $log = get_logger("Some::Package");
      open FILE, "<blah" or $log->logdie("Can't open blah -- bailing out!");
  
  This will both log the message with priority FATAL according to your current
  Log::Log4perl configuration and then call Perl's C<die()>
  afterwards to terminate the program. It works the same with
  stealth loggers (see L<Log::Log4perl/"Stealth Loggers">),
  all you need to do is call
  
      use Log::Log4perl qw(:easy);
      open FILE, "<blah" or LOGDIE "Can't open blah -- bailing out!";
  
  What can you do if you're using some library which doesn't use Log::Log4perl
  and calls C<die()> internally if something goes wrong? Use a
  C<$SIG{__DIE__}> pseudo signal handler
  
      use Log::Log4perl qw(get_logger);
  
      $SIG{__DIE__} = sub {
          if($^S) {
              # We're in an eval {} and don't want log
              # this message but catch it later
              return;
          }
          local $Log::Log4perl::caller_depth =
                $Log::Log4perl::caller_depth + 1;
          my $logger = get_logger("");
          $logger->fatal(@_);
          die @_; # Now terminate really
      };
  
  This will catch every C<die()>-Exception of your
  application or the modules it uses. In case you want to
  It
  will fetch a root logger and pass on the C<die()>-Message to it.
  If you make sure you've configured with a root logger like this:
  
      Log::Log4perl->init(\q{
          log4perl.category         = FATAL, Logfile
          log4perl.appender.Logfile = Log::Log4perl::Appender::File
          log4perl.appender.Logfile.filename = fatal_errors.log
          log4perl.appender.Logfile.layout = \
                     Log::Log4perl::Layout::PatternLayout
          log4perl.appender.Logfile.layout.ConversionPattern = %F{1}-%L (%M)> %m%n
      });
  
  then all C<die()> messages will be routed to a file properly. The line
  
       local $Log::Log4perl::caller_depth =
             $Log::Log4perl::caller_depth + 1;
  
  in the pseudo signal handler above merits a more detailed explanation. With
  the setup above, if a module calls C<die()> in one of its functions,
  the fatal message will be logged in the signal handler and not in the
  original function -- which will cause the %F, %L and %M placeholders
  in the pattern layout to be replaced by the filename, the line number
  and the function/method name of the signal handler, not the error-throwing
  module. To adjust this, Log::Log4perl has the C<$caller_depth> variable,
  which defaults to 0, but can be set to positive integer values
  to offset the caller level. Increasing
  it by one will cause it to log the calling function's parameters, not
  the ones of the signal handler.
  See L<Log::Log4perl/"Using Log::Log4perl from wrapper classes"> for more
  details.
  
  =head2 How can I hook up the LWP library with Log::Log4perl?
  
  Or, to put it more generally: How can you utilize a third-party
  library's embedded logging and debug statements in Log::Log4perl?
  How can you make them print
  to configurable appenders, turn them on and off, just as if they
  were regular Log::Log4perl logging statements?
  
  The easiest solution is to map the third-party library logging statements
  to Log::Log4perl's stealth loggers via a typeglob assignment.
  
  As an example, let's take LWP, one of the most popular Perl modules,
  which makes handling WWW requests and responses a breeze.
  Internally, LWP uses its own logging and debugging system,
  utilizing the following calls
  inside the LWP code (from the LWP::Debug man page):
  
          # Function tracing
      LWP::Debug::trace('send()');
  
          # High-granular state in functions
      LWP::Debug::debug('url ok');
  
          # Data going over the wire
      LWP::Debug::conns("read $n bytes: $data");
  
  First, let's assign Log::Log4perl priorities
  to these functions: I'd suggest that
  C<debug()> messages have priority C<INFO>,
  C<trace()> uses C<DEBUG> and C<conns()> also logs with C<DEBUG> --
  although your mileage may certainly vary.
  
  Now, in order to transparently hook up LWP::Debug with Log::Log4perl,
  all we have to do is say
  
      package LWP::Debug;
      use Log::Log4perl qw(:easy);
  
      *trace = *INFO;
      *conns = *DEBUG;
      *debug = *DEBUG;
  
      package main;
      # ... go on with your regular program ...
  
  at the beginning of our program. In this way, every time the, say,
  C<LWP::UserAgent> module calls C<LWP::Debug::trace()>, it will implicitly
  call INFO(), which is the C<info()> method of a stealth logger defined for
  the Log::Log4perl category C<LWP::Debug>. Is this cool or what?
  
  Here's a complete program:
  
      use LWP::UserAgent;
      use HTTP::Request::Common;
      use Log::Log4perl qw(:easy);
  
      Log::Log4perl->easy_init(
          { category => "LWP::Debug",
            level    => $DEBUG,
            layout   => "%r %p %M-%L %m%n",
          });
  
      package LWP::Debug;
      use Log::Log4perl qw(:easy);
      *trace = *INFO;
      *conns = *DEBUG;
      *debug = *DEBUG;
  
      package main;
      my $ua = LWP::UserAgent->new();
      my $resp = $ua->request(GET "http://amazon.com");
  
      if($resp->is_success()) {
          print "Success: Received ",
                length($resp->content()), "\n";
      } else {
          print "Error: ", $resp->code(), "\n";
      }
  
  This will generate the following output on STDERR:
  
      174 INFO LWP::UserAgent::new-164 ()
      208 INFO LWP::UserAgent::request-436 ()
      211 INFO LWP::UserAgent::send_request-294 GET http://amazon.com
      212 DEBUG LWP::UserAgent::_need_proxy-1123 Not proxied
      405 INFO LWP::Protocol::http::request-122 ()
      859 DEBUG LWP::Protocol::collect-206 read 233 bytes
      863 DEBUG LWP::UserAgent::request-443 Simple response: Found
      869 INFO LWP::UserAgent::request-436 ()
      871 INFO LWP::UserAgent::send_request-294
       GET http://www.amazon.com:80/exec/obidos/gateway_redirect
      872 DEBUG LWP::UserAgent::_need_proxy-1123 Not proxied
      873 INFO LWP::Protocol::http::request-122 ()
      1016 DEBUG LWP::UserAgent::request-443 Simple response: Found
      1020 INFO LWP::UserAgent::request-436 ()
      1022 INFO LWP::UserAgent::send_request-294
       GET http://www.amazon.com/exec/obidos/subst/home/home.html/
      1023 DEBUG LWP::UserAgent::_need_proxy-1123 Not proxied
      1024 INFO LWP::Protocol::http::request-122 ()
      1382 DEBUG LWP::Protocol::collect-206 read 632 bytes
      ...
      2605 DEBUG LWP::Protocol::collect-206 read 77 bytes
      2607 DEBUG LWP::UserAgent::request-443 Simple response: OK
      Success: Received 42584
  
  Of course, in this way, the embedded logging and debug statements within
  LWP can be utilized in any Log::Log4perl way you can think of. You can
  have them sent to different appenders, block them based on the
  category and everything else Log::Log4perl has to offer.
  
  Only drawback of this method: Steering logging behavior via category
  is always based on the C<LWP::Debug> package. Although the logging
  statements reflect the package name of the issuing module properly,
  the stealth loggers in C<LWP::Debug> are all of the category C<LWP::Debug>.
  This implies that you can't control the logging behavior based on the
  package that's I<initiating> a log request (e.g. LWP::UserAgent) but only
  based on the package that's actually I<executing> the logging statement,
  C<LWP::Debug> in this case.
  
  To work around this conundrum, we need to write a wrapper function and
  plant it into the C<LWP::Debug> package. It will determine the caller and
  create a logger bound to a category with the same name as the caller's
  package:
  
      package LWP::Debug;
  
      use Log::Log4perl qw(:levels get_logger);
  
      sub l4p_wrapper {
          my($prio, @message) = @_;
          $Log::Log4perl::caller_depth += 2;
          get_logger(scalar caller(1))->log($prio, @message);
          $Log::Log4perl::caller_depth -= 2;
      }
  
      no warnings 'redefine';
      *trace = sub { l4p_wrapper($INFO, @_); };
      *debug = *conns = sub { l4p_wrapper($DEBUG, @_); };
  
      package main;
      # ... go on with your main program ...
  
  This is less performant than the previous approach, because every
  log request will request a reference to a logger first, then call
  the wrapper, which will in turn call the appropriate log function.
  
  This hierarchy shift has to be compensated for by increasing
  C<$Log::Log4perl::caller_depth> by 2 before calling the log function
  and decreasing it by 2 right afterwards. Also, the C<l4p_wrapper>
  function shown above calls C<caller(1)> which determines the name
  of the package I<two> levels down the calling hierarchy (and
  therefore compensates for both the wrapper function and the
  anonymous subroutine calling it).
  
  C<no warnings 'redefine'> suppresses a warning Perl would generate
  otherwise
  upon redefining C<LWP::Debug>'s C<trace()>, C<debug()> and C<conns()>
  functions. In case you use a perl prior to 5.6.x, you need
  to manipulate C<$^W> instead.
  
  To make things easy for you when dealing with LWP, Log::Log4perl 0.47
  introduces C<Log::Log4perl-E<gt>infiltrate_lwp()> which does exactly the
  above.
  
  =head2 What if I need dynamic values in a static Log4perl configuration file?
  
  Say, your application uses Log::Log4perl for logging and
  therefore comes with a Log4perl configuration file, specifying the logging
  behavior.
  But, you also want it to take command line parameters to set values
  like the name of the log file.
  How can you have
  both a static Log4perl configuration file and a dynamic command line
  interface?
  
  As of Log::Log4perl 0.28, every value in the configuration file
  can be specified as a I<Perl hook>. So, instead of saying
  
      log4perl.appender.Logfile.filename = test.log
  
  you could just as well have a Perl subroutine deliver the value
  dynamically:
  
      log4perl.appender.Logfile.filename = sub { logfile(); };
  
  given that C<logfile()> is a valid function in your C<main> package
  returning a string containing the path to the log file.
  
  Or, think about using the value of an environment variable:
  
      log4perl.appender.DBI.user = sub { $ENV{USERNAME} };
  
  When C<Log::Log4perl-E<gt>init()> parses the configuration
  file, it will notice the assignment above because of its
  C<sub {...}> pattern and treat it in a special way:
  It will evaluate the subroutine (which can contain
  arbitrary Perl code) and take its return value as the right side
  of the assignment.
  
  A typical application would be called like this on the command line:
  
      app                # log file is "test.log"
      app -l mylog.txt   # log file is "mylog.txt"
  
  Here's some sample code implementing the command line interface above:
  
      use Log::Log4perl qw(get_logger);
      use Getopt::Std;
  
      getopt('l:', \our %OPTS);
  
      my $conf = q(
      log4perl.category.Bar.Twix         = WARN, Logfile
      log4perl.appender.Logfile          = Log::Log4perl::Appender::File
      log4perl.appender.Logfile.filename = sub { logfile(); };
      log4perl.appender.Logfile.layout   = SimpleLayout
      );
  
      Log::Log4perl::init(\$conf);
  
      my $logger = get_logger("Bar::Twix");
      $logger->error("Blah");
  
      ###########################################
      sub logfile {
      ###########################################
          if(exists $OPTS{l}) {
              return $OPTS{l};
          } else {
              return "test.log";
          }
      }
  
  Every Perl hook may contain arbitrary perl code,
  just make sure to fully qualify eventual variable names
  (e.g. C<%main::OPTS> instead of C<%OPTS>).
  
  B<SECURITY NOTE>: this feature means arbitrary perl code
  can be embedded in the config file.  In the rare case
  where the people who have access to your config file
  are different from the people who write your code and
  shouldn't have execute rights, you might want to call
  
      $Log::Log4perl::Config->allow_code(0);
  
  before you call init(). This will prevent Log::Log4perl from
  executing I<any> Perl code in the config file (including
  code for custom conversion specifiers
  (see L<Log::Log4perl::Layout::PatternLayout/"Custom cspecs">).
  
  =head2 How can I roll over my logfiles automatically at midnight?
  
  Long-running applications tend to produce ever-increasing logfiles.
  For backup and cleanup purposes, however, it is often desirable to move
  the current logfile to a different location from time to time and
  start writing a new one.
  
  This is a non-trivial task, because it has to happen in sync with
  the logging system in order not to lose any messages in the process.
  
  Luckily, I<Mark Pfeiffer>'s C<Log::Dispatch::FileRotate> appender
  works well with Log::Log4perl to rotate your logfiles in a variety of ways.
  
  Note, however, that having the application deal with rotating a log
  file is not cheap. Among other things, it requires locking the log file
  with every write to avoid race conditions.
  There are good reasons to use external rotators like C<newsyslog>
  instead.
  See the entry C<How can I rotate a logfile with newsyslog?> in the
  FAQ for more information on how to configure it.
  
  When using C<Log::Dispatch::FileRotate>,
  all you have to do is specify it in your Log::Log4perl configuration file
  and your logfiles will be rotated automatically.
  
  You can choose between rolling based on a maximum size ("roll if greater
  than 10 MB") or based on a date pattern ("roll everyday at midnight").
  In both cases, C<Log::Dispatch::FileRotate> allows you to define a
  number C<max> of saved files to keep around until it starts overwriting
  the oldest ones. If you set the C<max> parameter to 2 and the name of
  your logfile is C<test.log>, C<Log::Dispatch::FileRotate> will
  move C<test.log> to C<test.log.1> on the first rollover. On the second
  rollover, it will move C<test.log.1> to C<test.log.2> and then C<test.log>
  to C<test.log.1>. On the third rollover, it will move C<test.log.1> to
  C<test.log.2> (therefore discarding the old C<test.log.2>) and
  C<test.log> to C<test.log.1>. And so forth. This way, there's always
  going to be a maximum of 2 saved log files around.
  
  Here's an example of a Log::Log4perl configuration file, defining a
  daily rollover at midnight (date pattern C<yyyy-MM-dd>), keeping
  a maximum of 5 saved logfiles around:
  
      log4perl.category         = WARN, Logfile
      log4perl.appender.Logfile = Log::Dispatch::FileRotate
      log4perl.appender.Logfile.filename    = test.log
      log4perl.appender.Logfile.max         = 5
      log4perl.appender.Logfile.DatePattern = yyyy-MM-dd
      log4perl.appender.Logfile.TZ          = PST
      log4perl.appender.Logfile.layout = \
          Log::Log4perl::Layout::PatternLayout
      log4perl.appender.Logfile.layout.ConversionPattern = %d %m %n
  
  Please see the C<Log::Dispatch::FileRotate> documentation for details.
  C<Log::Dispatch::FileRotate> is available on CPAN.
  
  =head2 What's the easiest way to turn off all logging, even with a lengthy Log4perl configuration file?
  
  In addition to category-based levels and appender thresholds,
  Log::Log4perl supports system-wide logging thresholds. This is the
  minimum level the system will require of any logging events in order for them
  to make it through to any configured appenders.
  
  For example, putting the line
  
      log4perl.threshold = ERROR
  
  anywhere in your configuration file will limit any output to any appender
  to events with priority of ERROR or higher (ERROR or FATAL that is).
  
  However, in order to suppress all logging entirely, you need to use a
  priority that's higher than FATAL: It is simply called C<OFF>, and it is never
  used by any logger. By definition, it is higher than the highest
  defined logger level.
  
  Therefore, if you keep the line
  
      log4perl.threshold = OFF
  
  somewhere in your Log::Log4perl configuration, the system will be quiet
  as a graveyard. If you deactivate the line (e.g. by commenting it out),
  the system will, upon config reload, snap back to normal operation, providing
  logging messages according to the rest of the configuration file again.
  
  =head2 How can I log DEBUG and above to the screen and INFO and above to a file?
  
  You need one logger with two appenders attached to it:
  
      log4perl.logger = DEBUG, Screen, File
  
      log4perl.appender.Screen   = Log::Log4perl::Appender::Screen
      log4perl.appender.Screen.layout = SimpleLayout
  
      log4perl.appender.File   = Log::Log4perl::Appender::File
      log4perl.appender.File.filename = test.log
      log4perl.appender.File.layout = SimpleLayout
      log4perl.appender.Screen.Threshold = INFO
  
  Since the file logger isn't supposed to get any messages with a priority
  less than INFO, the appender's C<Threshold> setting blocks those out,
  although the logger forwards them.
  
  It's a common mistake to think you can define two loggers for this, but
  it won't work unless those two loggers have different categories. If you
  wanted to log all DEBUG and above messages from the Foo::Bar module to a file
  and all INFO and above messages from the Quack::Schmack module to the
  screen, then you could have defined two loggers with different levels
  C<log4perl.logger.Foo.Bar> (level INFO)
  and C<log4perl.logger.Quack.Schmack> (level DEBUG) and assigned the file
  appender to the former and the screen appender to the latter. But what we
  wanted to accomplish was to route all messages, regardless of which module
  (or category) they came from, to both appenders. The only
  way to accomplish this is to define the root logger with the lower
  level (DEBUG), assign both appenders to it, and block unwanted messages at
  the file appender (C<Threshold> set to INFO).
  
  =head2 I keep getting duplicate log messages! What's wrong?
  
  Having several settings for related categories in the Log4perl
  configuration file sometimes leads to a phenomenon called
  "message duplication". It can be very confusing at first,
  but if thought through properly, it turns out that Log4perl behaves
  as advertised. But, don't despair, of course there's a number of
  ways to avoid message duplication in your logs.
  
  Here's a sample Log4perl configuration file that produces the
  phenomenon:
  
      log4perl.logger.Cat        = ERROR, Screen
      log4perl.logger.Cat.Subcat = WARN, Screen
  
      log4perl.appender.Screen   = Log::Log4perl::Appender::Screen
      log4perl.appender.Screen.layout = SimpleLayout
  
  It defines two loggers, one for category C<Cat> and one for
  C<Cat::Subcat>, which is obviously a subcategory of C<Cat>.
  The parent logger has a priority setting of ERROR, the child
  is set to the lower C<WARN> level.
  
  Now imagine the following code in your program:
  
      my $logger = get_logger("Cat.Subcat");
      $logger->warn("Warning!");
  
  What do you think will happen? An unexperienced Log4perl user
  might think: "Well, the message is being sent with level WARN, so the
  C<Cat::Subcat> logger will accept it and forward it to the
  attached C<Screen> appender. Then, the message will percolate up
  the logger hierarchy, find
  the C<Cat> logger, which will suppress the message because of its
  ERROR setting."
  But, perhaps surprisingly, what you'll get with the
  code snippet above is not one but two log messages written
  to the screen:
  
      WARN - Warning!
      WARN - Warning!
  
  What happened? The culprit is that once the logger C<Cat::Subcat>
  decides to fire, it will forward the message I<unconditionally>
  to all directly or indirectly attached appenders. The C<Cat> logger
  will never be asked if it wants the message or not -- the message
  will just be pushed through to the appender attached to C<Cat>.
  
  One way to prevent the message from bubbling up the logger
  hierarchy is to set the C<additivity> flag of the subordinate logger to
  C<0>:
  
      log4perl.logger.Cat            = ERROR, Screen
      log4perl.logger.Cat.Subcat     = WARN, Screen
      log4perl.additivity.Cat.Subcat = 0
  
      log4perl.appender.Screen   = Log::Log4perl::Appender::Screen
      log4perl.appender.Screen.layout = SimpleLayout
  
  The message will now be accepted by the C<Cat::Subcat> logger,
  forwarded to its appender, but then C<Cat::Subcat> will suppress
  any further action. While this setting avoids duplicate messages
  as seen before, it is often not the desired behavior. Messages
  percolating up the hierarchy are a useful Log4perl feature.
  
  If you're defining I<different> appenders for the two loggers,
  one other option is to define an appender threshold for the
  higher-level appender. Typically it is set to be
  equal to the logger's level setting:
  
      log4perl.logger.Cat           = ERROR, Screen1
      log4perl.logger.Cat.Subcat    = WARN, Screen2
  
      log4perl.appender.Screen1   = Log::Log4perl::Appender::Screen
      log4perl.appender.Screen1.layout = SimpleLayout
      log4perl.appender.Screen1.Threshold = ERROR
  
      log4perl.appender.Screen2   = Log::Log4perl::Appender::Screen
      log4perl.appender.Screen2.layout = SimpleLayout
  
  Since the C<Screen1> appender now blocks every message with
  a priority less than ERROR, even if the logger in charge
  lets it through, the message percolating up the hierarchy is
  being blocked at the last minute and I<not> appended to C<Screen1>.
  
  So far, we've been operating well within the boundaries of the
  Log4j standard, which Log4perl adheres to. However, if
  you would really, really like to use a single appender
  and keep the message percolation intact without having to deal
  with message duplication, there's a non-standard solution for you:
  
      log4perl.logger.Cat        = ERROR, Screen
      log4perl.logger.Cat.Subcat = WARN, Screen
  
      log4perl.appender.Screen   = Log::Log4perl::Appender::Screen
      log4perl.appender.Screen.layout = SimpleLayout
  
      log4perl.oneMessagePerAppender = 1
  
  The C<oneMessagePerAppender> flag will suppress duplicate messages
  to the same appender. Again, that's non-standard. But way cool :).
  
  =head2 How can I configure Log::Log4perl to send me email if something happens?
  
  Some incidents require immediate action. You can't wait until someone
  checks the log files, you need to get notified on your pager right away.
  
  The easiest way to do that is by using the C<Log::Dispatch::Email::MailSend>
  module as an appender. It comes with the C<Log::Dispatch> bundle and
  allows you to specify recipient and subject of outgoing emails in the Log4perl
  configuration file:
  
      log4perl.category = FATAL, Mailer
      log4perl.appender.Mailer         = Log::Dispatch::Email::MailSend
      log4perl.appender.Mailer.to      = drone@pageme.net
      log4perl.appender.Mailer.subject = Something's broken!
      log4perl.appender.Mailer.layout  = SimpleLayout
  
  The message of every log incident this appender gets
  will then be forwarded to the given
  email address. Check the C<Log::Dispatch::Email::MailSend> documentation
  for details. And please make sure there's not a flood of email messages
  sent out by your application, filling up the recipient's inbox.
  
  There's one caveat you need to know about: The C<Log::Dispatch::Email>
  hierarchy of appenders turns on I<buffering> by default. This means that
  the appender will not send out messages right away but wait until a
  certain threshold has been reached. If you'd rather have your alerts
  sent out immediately, use
  
      log4perl.appender.Mailer.buffered = 0
  
  to turn buffering off.
  
  =head2 How can I write my own appender?
  
  First off, Log::Log4perl comes with a set of standard appenders. Then,
  there's a lot of Log4perl-compatible appenders already
  available on CPAN: Just run a search for C<Log::Dispatch> on
  http://search.cpan.org and chances are that what you're looking for
  has already been developed, debugged and been used successfully
  in production -- no need for you to reinvent the wheel.
  
  Also, Log::Log4perl ships with a nifty database appender named
  Log::Log4perl::Appender::DBI -- check it out if talking to databases is your
  desire.
  
  But if you're up for a truly exotic task, you might have to write
  an appender yourself. That's very easy -- it takes no longer
  than a couple of minutes.
  
  Say, we wanted to create an appender of the class
  C<ColorScreenAppender>, which logs messages
  to the screen in a configurable color. Just create a new class
  in C<ColorScreenAppender.pm>:
  
      package ColorScreenAppender;
  
  Now let's assume that your Log::Log4perl
  configuration file C<test.conf> looks like this:
  
      log4perl.logger = INFO, ColorApp
  
      log4perl.appender.ColorApp=ColorScreenAppender
      log4perl.appender.ColorApp.color=blue
  
      log4perl.appender.ColorApp.layout = PatternLayout
      log4perl.appender.ColorApp.layout.ConversionPattern=%d %m %n
  
  This will cause Log::Log4perl on C<init()> to look for a class
  ColorScreenAppender and call its constructor new(). Let's add
  new() to ColorScreenAppender.pm:
  
      sub new {
          my($class, %options) = @_;
  
          my $self = { %options };
          bless $self, $class;
  
          return $self;
      }
  
  To initialize this appender, Log::Log4perl will call
  and pass all attributes of the appender as defined in the configuration
  file to the constructor as name/value pairs (in this case just one):
  
      ColorScreenAppender->new(color => "blue");
  
  The new() method listed above stores the contents of the
  %options hash in the object's
  instance data hash (referred to by $self).
  That's all for initializing a new appender with Log::Log4perl.
  
  Second, ColorScreenAppender needs to expose a
  C<log()> method, which will be called by Log::Log4perl
  every time it thinks the appender should fire. Along with the
  object reference (as usual in Perl's object world), log()
  will receive a list of name/value pairs, of which only the one
  under the key C<message> shall be of interest for now since it is the
  message string to be logged. At this point, Log::Log4perl has already taken
  care of joining the message to be a single string.
  
  For our special appender ColorScreenAppender, we're using the
  Term::ANSIColor module to colorize the output:
  
      use Term::ANSIColor;
  
      sub log {
          my($self, %params) = @_;
  
          print colored($params{message},
                        $self->{color});
      }
  
  The color (as configured in the Log::Log4perl configuration file)
  is available as $self-E<gt>{color} in the appender object. Don't
  forget to return
  
      1;
  
  at the end of ColorScreenAppender.pm and you're done. Install the new appender
  somewhere where perl can find it and try it with a test script like
  
      use Log::Log4perl qw(:easy);
      Log::Log4perl->init("test.conf");
      ERROR("blah");
  
  to see the new colored output. Is this cool or what?
  
  And it gets even better: You can write dynamically generated appender
  classes using the C<Class::Prototyped> module. Here's an example of
  an appender prepending every outgoing message with a configurable
  number of bullets:
  
      use Class::Prototyped;
  
      my $class = Class::Prototyped->newPackage(
        "MyAppenders::Bulletizer",
        bullets => 1,
        log     => sub {
          my($self, %params) = @_;
          print "*" x $self->bullets(),
                $params{message};
        },
      );
  
      use Log::Log4perl qw(:easy);
  
      Log::Log4perl->init(\ q{
        log4perl.logger = INFO, Bully
  
        log4perl.appender.Bully=MyAppenders::Bulletizer
        log4perl.appender.Bully.bullets=3
  
        log4perl.appender.Bully.layout = PatternLayout
        log4perl.appender.Bully.layout.ConversionPattern=%m %n
      });
  
          # ... prints: "***Boo!\n";
      INFO "Boo!";
  
  =head2 How can I drill down on references before logging them?
  
  If you've got a reference to a nested structure or object, then
  you probably don't want to log it as C<HASH(0x81141d4)> but rather
  dump it as something like
  
      $VAR1 = {
                'a' => 'b',
                'd' => 'e'
              };
  
  via a module like Data::Dumper. While it's syntactically correct to say
  
      $logger->debug(Data::Dumper::Dumper($ref));
  
  this call imposes a huge performance penalty on your application
  if the message is suppressed by Log::Log4perl, because Data::Dumper
  will perform its expensive operations in any case, because it doesn't
  know that its output will be thrown away immediately.
  
  As of Log::Log4perl 0.28, there's a better way: Use the
  message output filter format as in
  
      $logger->debug( {filter => \&Data::Dumper::Dumper,
                       value  => $ref} );
  
  and Log::Log4perl won't call the filter function unless the message really
  gets written out to an appender. Just make sure to pass the whole slew as a
  reference to a hash specifying a filter function (as a sub reference)
  under the key C<filter> and the value to be passed to the filter function in
  C<value>).
  When it comes to logging, Log::Log4perl will call the filter function,
  pass the C<value> as an argument and log the return value.
  Saves you serious cycles.
  
  =head2 How can I collect all FATAL messages in an extra log file?
  
  Suppose you have employed Log4perl all over your system and you've already
  activated logging in various subsystems. On top of that, without disrupting
  any other settings, how can you collect all FATAL messages all over the system
  and send them to a separate log file?
  
  If you define a root logger like this:
  
      log4perl.logger                  = FATAL, File
      log4perl.appender.File           = Log::Log4perl::Appender::File
      log4perl.appender.File.filename  = /tmp/fatal.txt
      log4perl.appender.File.layout    = PatternLayout
      log4perl.appender.File.layout.ConversionPattern= %d %m %n
          # !!! Something's missing ...
  
  you'll be surprised to not only receive all FATAL messages
  issued anywhere in the system,
  but also everything else -- gazillions of
  ERROR, WARN, INFO and even DEBUG messages will end up in
  your fatal.txt logfile!
  Reason for this is Log4perl's (or better: Log4j's) appender additivity.
  Once a
  lower-level logger decides to fire, the message is going to be forwarded
  to all appenders upstream -- without further priority checks with their
  attached loggers.
  
  There's a way to prevent this, however: If your appender defines a
  minimum threshold, only messages of this priority or higher are going
  to be logged. So, just add
  
      log4perl.appender.File.Threshold = FATAL
  
  to the configuration above, and you'll get what you wanted in the
  first place: An overall system FATAL message collector.
  
  =head2 How can I bundle several log messages into one?
  
  Would you like to tally the messages arriving at your appender and
  dump out a summary once they're exceeding a certain threshold?
  So that something like
  
      $logger->error("Blah");
      $logger->error("Blah");
      $logger->error("Blah");
  
  won't be logged as
  
      Blah
      Blah
      Blah
  
  but as
  
      [3] Blah
  
  instead? If you'd like to hold off on logging a message until it has been
  sent a couple of times, you can roll that out by creating a buffered
  appender.
  
  Let's define a new appender like
  
      package TallyAppender;
  
      sub new {
          my($class, %options) = @_;
  
          my $self = { maxcount => 5,
                       %options
                     };
  
          bless $self, $class;
  
          $self->{last_message}        = "";
          $self->{last_message_count}  = 0;
  
          return $self;
      }
  
  with two additional instance variables C<last_message> and
  C<last_message_count>, storing the content of the last message sent
  and a counter of how many times this has happened. Also, it features
  a configuration parameter C<maxcount> which defaults to 5 in the
  snippet above but can be set in the Log4perl configuration file like this:
  
      log4perl.logger = INFO, A
      log4perl.appender.A=TallyAppender
      log4perl.appender.A.maxcount = 3
  
  The main tallying logic lies in the appender's C<log> method,
  which is called every time Log4perl thinks a message needs to get logged
  by our appender:
  
      sub log {
          my($self, %params) = @_;
  
              # Message changed? Print buffer.
          if($self->{last_message} and
             $params{message} ne $self->{last_message}) {
              print "[$self->{last_message_count}]: " .
                    "$self->{last_message}";
              $self->{last_message_count} = 1;
              $self->{last_message} = $params{message};
              return;
          }
  
          $self->{last_message_count}++;
          $self->{last_message} = $params{message};
  
              # Threshold exceeded? Print, reset counter
          if($self->{last_message_count} >=
             $self->{maxcount}) {
              print "[$self->{last_message_count}]: " .
                    "$params{message}";
              $self->{last_message_count} = 0;
              $self->{last_message}       = "";
              return;
          }
      }
  
  We basically just check if the oncoming message in C<$param{message}>
  is equal to what we've saved before in the C<last_message> instance
  variable. If so, we're increasing C<last_message_count>.
  We print the message in two cases: If the new message is different
  than the buffered one, because then we need to dump the old stuff
  and store the new. Or, if the counter exceeds the threshold, as
  defined by the C<maxcount> configuration parameter.
  
  Please note that the appender always gets the fully rendered message and
  just compares it as a whole -- so if there's a date/timestamp in there,
  that might confuse your logic. You can work around this by specifying
  %m %n as a layout and add the date later on in the appender. Or, make
  the comparison smart enough to omit the date.
  
  At last, don't forget what happens if the program is being shut down.
  If there's still messages in the buffer, they should be printed out
  at that point. That's easy to do in the appender's DESTROY method,
  which gets called at object destruction time:
  
      sub DESTROY {
          my($self) = @_;
  
          if($self->{last_message_count}) {
              print "[$self->{last_message_count}]: " .
                    "$self->{last_message}";
              return;
          }
      }
  
  This will ensure that none of the buffered messages are lost.
  Happy buffering!
  
  =head2 I want to log ERROR and WARN messages to different files! How can I do that?
  
  Let's assume you wanted to have each logging statement written to a
  different file, based on the statement's priority. Messages with priority
  C<WARN> are supposed to go to C</tmp/app.warn>, events prioritized
  as C<ERROR> should end up in C</tmp/app.error>.
  
  Now, if you define two appenders C<AppWarn> and C<AppError>
  and assign them both to the root logger,
  messages bubbling up from any loggers below will be logged by both
  appenders because of Log4perl's message propagation feature. If you limit
  their exposure via the appender threshold mechanism and set
  C<AppWarn>'s threshold to C<WARN> and C<AppError>'s to C<ERROR>, you'll
  still get C<ERROR> messages in C<AppWarn>, because C<AppWarn>'s C<WARN>
  setting will just filter out messages with a I<lower> priority than
  C<WARN> -- C<ERROR> is higher and will be allowed to pass through.
  
  What we need for this is a Log4perl I<Custom Filter>, available with
  Log::Log4perl 0.30.
  
  Both appenders need to verify that
  the priority of the oncoming messages exactly I<matches> the priority
  the appender is supposed to log messages of. To accomplish this task,
  let's define two custom filters, C<MatchError> and C<MatchWarn>, which,
  when attached to their appenders, will limit messages passed on to them
  to those matching a given priority:
  
      log4perl.logger = WARN, AppWarn, AppError
  
          # Filter to match level ERROR
      log4perl.filter.MatchError = Log::Log4perl::Filter::LevelMatch
      log4perl.filter.MatchError.LevelToMatch  = ERROR
      log4perl.filter.MatchError.AcceptOnMatch = true
  
          # Filter to match level WARN
      log4perl.filter.MatchWarn  = Log::Log4perl::Filter::LevelMatch
      log4perl.filter.MatchWarn.LevelToMatch  = WARN
      log4perl.filter.MatchWarn.AcceptOnMatch = true
  
          # Error appender
      log4perl.appender.AppError = Log::Log4perl::Appender::File
      log4perl.appender.AppError.filename = /tmp/app.err
      log4perl.appender.AppError.layout   = SimpleLayout
      log4perl.appender.AppError.Filter   = MatchError
  
          # Warning appender
      log4perl.appender.AppWarn = Log::Log4perl::Appender::File
      log4perl.appender.AppWarn.filename = /tmp/app.warn
      log4perl.appender.AppWarn.layout   = SimpleLayout
      log4perl.appender.AppWarn.Filter   = MatchWarn
  
  The appenders C<AppWarn> and C<AppError> defined above are logging to C</tmp/app.warn> and
  C</tmp/app.err> respectively and have the custom filters C<MatchWarn> and C<MatchError>
  attached.
  This setup will direct all WARN messages, issued anywhere in the system, to /tmp/app.warn (and
  ERROR messages to /tmp/app.error) -- without any overlaps.
  
  =head2 On our server farm, Log::Log4perl configuration files differ slightly from host to host. Can I roll them all into one?
  
  You sure can, because Log::Log4perl allows you to specify attribute values
  dynamically. Let's say that one of your appenders expects the host's IP address
  as one of its attributes. Now, you could certainly roll out different
  configuration files for every host and specify the value like
  
      log4perl.appender.MyAppender    = Log::Log4perl::Appender::SomeAppender
      log4perl.appender.MyAppender.ip = 10.0.0.127
  
  but that's a maintenance nightmare. Instead, you can have Log::Log4perl
  figure out the IP address at configuration time and set the appender's
  value correctly:
  
          # Set the IP address dynamically
      log4perl.appender.MyAppender    = Log::Log4perl::Appender::SomeAppender
      log4perl.appender.MyAppender.ip = sub { \
         use Sys::Hostname; \
         use Socket; \
         return inet_ntoa(scalar gethostbyname hostname); \
      }
  
  If Log::Log4perl detects that an attribute value starts with something like
  C<"sub {...">, it will interpret it as a perl subroutine which is to be executed
  once at configuration time (not runtime!) and its return value is
  to be used as the attribute value. This comes in handy
  for rolling out applications where Log::Log4perl configuration files
  show small host-specific differences, because you can deploy the unmodified
  application distribution on all instances of the server farm.
  
  =head2 Log4perl doesn't interpret my backslashes correctly!
  
  If you're using Log4perl's feature to specify the configuration as a
  string in your program (as opposed to a separate configuration file),
  chances are that you've written it like this:
  
      # *** WRONG! ***
  
      Log::Log4perl->init( \ <<END_HERE);
          log4perl.logger = WARN, A1
          log4perl.appender.A1 = Log::Log4perl::Appender::Screen
          log4perl.appender.A1.layout = \
              Log::Log4perl::Layout::PatternLayout
          log4perl.appender.A1.layout.ConversionPattern = %m%n
      END_HERE
  
      # *** WRONG! ***
  
  and you're getting the following error message:
  
      Layout not specified for appender A1 at .../Config.pm line 342.
  
  What's wrong? The problem is that you're using a here-document with
  substitution enabled (C<E<lt>E<lt>END_HERE>) and that Perl won't
  interpret backslashes at line-ends as continuation characters but
  will essentially throw them out. So, in the code above, the layout line
  will look like
  
      log4perl.appender.A1.layout =
  
  to Log::Log4perl which causes it to report an error. To interpret the backslash
  at the end of the line correctly as a line-continuation character, use
  the non-interpreting mode of the here-document like in
  
      # *** RIGHT! ***
  
      Log::Log4perl->init( \ <<'END_HERE');
          log4perl.logger = WARN, A1
          log4perl.appender.A1 = Log::Log4perl::Appender::Screen
          log4perl.appender.A1.layout = \
              Log::Log4perl::Layout::PatternLayout
          log4perl.appender.A1.layout.ConversionPattern = %m%n
      END_HERE
  
      # *** RIGHT! ***
  
  (note the single quotes around C<'END_HERE'>) or use C<q{...}>
  instead of a here-document and Perl will treat the backslashes at
  line-end as intended.
  
  =head2 I want to suppress certain messages based on their content!
  
  Let's assume you've plastered all your functions with Log4perl
  statements like
  
      sub some_func {
  
          INFO("Begin of function");
  
          # ... Stuff happens here ...
  
          INFO("End of function");
      }
  
  to issue two log messages, one at the beginning and one at the end of
  each function. Now you want to suppress the message at the beginning
  and only keep the one at the end, what can you do? You can't use the category
  mechanism, because both messages are issued from the same package.
  
  Log::Log4perl's custom filters (0.30 or better) provide an interface for the
  Log4perl user to step in right before a message gets logged and decide if
  it should be written out or suppressed, based on the message content or other
  parameters:
  
      use Log::Log4perl qw(:easy);
  
      Log::Log4perl::init( \ <<'EOT' );
          log4perl.logger             = INFO, A1
          log4perl.appender.A1        = Log::Log4perl::Appender::Screen
          log4perl.appender.A1.layout = \
              Log::Log4perl::Layout::PatternLayout
          log4perl.appender.A1.layout.ConversionPattern = %m%n
  
          log4perl.filter.M1 = Log::Log4perl::Filter::StringMatch
          log4perl.filter.M1.StringToMatch = Begin
          log4perl.filter.M1.AcceptOnMatch = false
  
          log4perl.appender.A1.Filter = M1
  EOT
  
  The last four statements in the configuration above are defining a custom
  filter C<M1> of type C<Log::Log4perl::Filter::StringMatch>, which comes with
  Log4perl right out of the box and allows you to define a text pattern to match
  (as a perl regular expression) and a flag C<AcceptOnMatch> indicating
  if a match is supposed to suppress the message or let it pass through.
  
  The last line then assigns this filter to the C<A1> appender, which will
  call it every time it receives a message to be logged and throw all
  messages out I<not> matching the regular expression C<Begin>.
  
  Instead of using the standard C<Log::Log4perl::Filter::StringMatch> filter,
  you can define your own, simply using a perl subroutine:
  
      log4perl.filter.ExcludeBegin  = sub { !/Begin/ }
      log4perl.appender.A1.Filter   = ExcludeBegin
  
  For details on custom filters, check L<Log::Log4perl::Filter>.
  
  =head2 My new module uses Log4perl -- but what happens if the calling program didn't configure it?
  
  If a Perl module uses Log::Log4perl, it will typically rely on the
  calling program to initialize it. If it is using Log::Log4perl in C<:easy>
  mode, like in
  
      package MyMod;
      use Log::Log4perl qw(:easy);
  
      sub foo {
          DEBUG("In foo");
      }
  
      1;
  
  and the calling program doesn't initialize Log::Log4perl at all (e.g. because
  it has no clue that it's available), Log::Log4perl will silently
  ignore all logging messages. However, if the module is using Log::Log4perl
  in regular mode like in
  
      package MyMod;
      use Log::Log4perl qw(get_logger);
  
      sub foo {
          my $logger = get_logger("");
          $logger->debug("blah");
      }
  
      1;
  
  and the main program is just using the module like in
  
      use MyMode;
      MyMode::foo();
  
  then Log::Log4perl will also ignore all logging messages but
  issue a warning like
  
      Log4perl: Seems like no initialization happened.
      Forgot to call init()?
  
  (only once!) to remind novice users to not forget to initialize
  the logging system before using it.
  However, if you want to suppress this message, just
  add the C<:nowarn> target to the module's C<use Log::Log4perl> call:
  
      use Log::Log4perl qw(get_logger :nowarn);
  
  This will have Log::Log4perl silently ignore all logging statements if
  no initialization has taken place. If, instead of using init(), you're
  using Log4perl's API to define loggers and appenders, the same
  notification happens if no call to add_appenders() is made, i.e. no
  appenders are defined.
  
  If the module wants to figure out if some other program part has
  already initialized Log::Log4perl, it can do so by calling
  
      Log::Log4perl::initialized()
  
  which will return a true value in case Log::Log4perl has been initialized
  and a false value if not.
  
  =head2 How can I synchronize access to an appender?
  
  If you're using the same instance of an appender in multiple processes,
  and each process is passing on messages to the appender in parallel,
  you might end up with overlapping log entries.
  
  Typical scenarios include a file appender that you create in the main
  program, and which will then be shared between the parent and a
  forked child process. Or two separate processes, each initializing a
  Log4perl file appender on the same logfile.
  
  Log::Log4perl won't synchronize access to the shared logfile by
  default. Depending on your operating system's flush mechanism,
  buffer size and the size of your messages, there's a small chance of
  an overlap.
  
  The easiest way to prevent overlapping messages in logfiles written to
  by multiple processes is setting the
  file appender's C<syswrite> flag along with a file write mode of C<"append">.
  This makes sure that
  C<Log::Log4perl::Appender::File> uses C<syswrite()> (which is guaranteed
  to run uninterrupted) instead of C<print()> which might buffer
  the message or get interrupted by the OS while it is writing. And in
  C<"append"> mode, the OS kernel ensures that multiple processes share
  one end-of-file marker, ensuring that each process writes to the I<real>
  end of the file. (The value of C<"append">
  for the C<mode> parameter is the default setting in Log4perl's file
  appender so you don't have to set it explicitly.)
  
        # Guarantees atomic writes
  
      log4perl.category.Bar.Twix          = WARN, Logfile
  
      log4perl.appender.Logfile           = Log::Log4perl::Appender::File
      log4perl.appender.Logfile.mode      = append
      log4perl.appender.Logfile.syswrite  = 1
      log4perl.appender.Logfile.filename  = test.log
      log4perl.appender.Logfile.layout    = SimpleLayout
  
  Another guaranteed way of having messages separated with any kind of
  appender is putting a Log::Log4perl::Appender::Synchronized composite
  appender in between Log::Log4perl and the real appender. It will make
  sure to let messages pass through this virtual gate one by one only.
  
  Here's a sample configuration to synchronize access to a file appender:
  
      log4perl.category.Bar.Twix          = WARN, Syncer
  
      log4perl.appender.Logfile           = Log::Log4perl::Appender::File
      log4perl.appender.Logfile.autoflush = 1
      log4perl.appender.Logfile.filename  = test.log
      log4perl.appender.Logfile.layout    = SimpleLayout
  
      log4perl.appender.Syncer            = Log::Log4perl::Appender::Synchronized
      log4perl.appender.Syncer.appender   = Logfile
  
  C<Log::Log4perl::Appender::Synchronized> uses
  the C<IPC::Shareable> module and its semaphores, which will slow down writing
  the log messages, but ensures sequential access featuring atomic checks.
  Check L<Log::Log4perl::Appender::Synchronized> for details.
  
  =head2 Can I use Log::Log4perl with log4j's Chainsaw?
  
  Yes, Log::Log4perl can be configured to send its events to log4j's
  graphical log UI I<Chainsaw>.
  
  =for html
  <p>
  <TABLE><TR><TD>
  <A HREF="http://log4perl.sourceforge.net/images/chainsaw2.jpg"><IMG SRC="http://log4perl.sourceforge.net/images/chainsaw2s.jpg"></A>
  <TR><TD>
  <I>Figure 1: Chainsaw receives Log::Log4perl events</I>
  </TABLE>
  <p>
  
  =for text
  Figure1: Chainsaw receives Log::Log4perl events
  
  Here's how it works:
  
  =over 4
  
  =item *
  
  Get Guido Carls' E<lt>gcarls@cpan.orgE<gt> Log::Log4perl extension
  C<Log::Log4perl::Layout::XMLLayout> from CPAN and install it:
  
      perl -MCPAN -eshell
      cpan> install Log::Log4perl::Layout::XMLLayout
  
  =item *
  
  Install and start Chainsaw, which is part of the C<log4j> distribution now
  (see http://jakarta.apache.org/log4j ). Create a configuration file like
  
    <log4j:configuration debug="true">
      <plugin name="XMLSocketReceiver"
              class="org.apache.log4j.net.XMLSocketReceiver">
        <param name="decoder" value="org.apache.log4j.xml.XMLDecoder"/>
        <param name="Port" value="4445"/>
      </plugin>
      <root> <level value="debug"/> </root>
    </log4j:configuration>
  
  and name it e.g. C<config.xml>. Then start Chainsaw like
  
    java -Dlog4j.debug=true -Dlog4j.configuration=config.xml \
      -classpath ".:log4j-1.3alpha.jar:log4j-chainsaw-1.3alpha.jar" \
      org.apache.log4j.chainsaw.LogUI
  
  and watch the GUI coming up.
  
  =item *
  
  Configure Log::Log4perl to use a socket appender with an XMLLayout, pointing
  to the host/port where Chainsaw (as configured above) is waiting with its
  XMLSocketReceiver:
  
    use Log::Log4perl qw(get_logger);
    use Log::Log4perl::Layout::XMLLayout;
  
    my $conf = q(
      log4perl.category.Bar.Twix          = WARN, Appender
      log4perl.appender.Appender          = Log::Log4perl::Appender::Socket
      log4perl.appender.Appender.PeerAddr = localhost
      log4perl.appender.Appender.PeerPort = 4445
      log4perl.appender.Appender.layout   = Log::Log4perl::Layout::XMLLayout
    );
  
    Log::Log4perl::init(\$conf);
  
      # Nasty hack to suppress encoding header
    my $app = Log::Log4perl::appenders->{"Appender"};
    $app->layout()->{enc_set} = 1;
  
    my $logger = get_logger("Bar.Twix");
    $logger->error("One");
  
  The nasty hack shown in the code snippet above is currently (October 2003)
  necessary, because Chainsaw expects XML messages to arrive in a format like
  
    <log4j:event logger="Bar.Twix"
                 timestamp="1066794904310"
                 level="ERROR"
                 thread="10567">
      <log4j:message><![CDATA[Two]]></log4j:message>
      <log4j:NDC><![CDATA[undef]]></log4j:NDC>
      <log4j:locationInfo class="main"
        method="main"
        file="./t"
        line="32">
      </log4j:locationInfo>
    </log4j:event>
  
  without a preceding
  
    <?xml version = "1.0" encoding = "iso8859-1"?>
  
  which Log::Log4perl::Layout::XMLLayout applies to the first event sent
  over the socket.
  
  =back
  
  See figure 1 for a screenshot of Chainsaw in action, receiving events from
  the Perl script shown above.
  
  Many thanks to Chainsaw's
  Scott Deboy <sdeboy@comotivsystems.com> for his support!
  
  =head2 How can I run Log::Log4perl under mod_perl?
  
  In persistent environments it's important to play by the rules outlined
  in section L<Log::Log4perl/"Initialize once and only once">.
  If you haven't read this yet, please go ahead and read it right now. It's
  very important.
  
  And no matter if you use a startup handler to init() Log::Log4perl or use the
  init_once() strategy (added in 0.42), either way you're very likely to have
  unsynchronized writes to logfiles.
  
  If Log::Log4perl is configured with a log file appender, and it is
  initialized via
  the Apache startup handler, the file handle created initially will be
  shared among all Apache processes. Similarly, with the init_once()
  approach: although every process has a separate L4p configuration,
  processes are gonna share the appender file I<names> instead, effectively
  opening several different file handles on the same file.
  
  Now, having several appenders using the same file handle or having
  several appenders logging to the same file unsynchronized, this might
  result in overlapping messages. Sometimes, this is acceptable. If it's
  not, here's two strategies:
  
  =over 4
  
  =item *
  
  Use the L<Log::Log4perl::Appender::Synchronized> appender to connect to
  your file appenders. Here's the writeup:
  http://log4perl.sourceforge.net/releases/Log-Log4perl/docs/html/Log/Log4perl/FAQ.html#23804
  
  =item *
  
  Use a different logfile for every process like in
  
       #log4perl.conf
       ...
       log4perl.appender.A1.filename = sub { "mylog.$$.log" }
  
  =back
  
  =head2 My program already uses warn() and die(). How can I switch to Log4perl?
  
  If your program already uses Perl's C<warn()> function to spew out
  error messages and you'd like to channel those into the Log4perl world,
  just define a C<__WARN__> handler where your program or module resides:
  
      use Log::Log4perl qw(:easy);
  
      $SIG{__WARN__} = sub {
          local $Log::Log4perl::caller_depth =
              $Log::Log4perl::caller_depth + 1;
          WARN @_;
      };
  
  Why the C<local> setting of C<$Log::Log4perl::caller_depth>?
  If you leave that out,
  C<PatternLayout> conversion specifiers like C<%M> or C<%F> (printing
  the current function/method and source filename) will refer
  to where the __WARN__ handler resides, not the environment
  Perl's C<warn()> function was issued from. Increasing C<caller_depth>
  adjusts for this offset. Having it C<local>, makes sure the level
  gets set back after the handler exits.
  
  Once done, if your program does something like
  
      sub some_func {
          warn "Here's a warning";
      }
  
  you'll get (depending on your Log::Log4perl configuration) something like
  
      2004/02/19 20:41:02-main::some_func: Here's a warning at ./t line 25.
  
  in the appropriate appender instead of having a screen full of STDERR
  messages. It also works with the C<Carp> module and its C<carp()>
  and C<cluck()> functions.
  
  If, on the other hand, catching C<die()> and friends is
  required, a C<__DIE__> handler is appropriate:
  
      $SIG{__DIE__} = sub {
          if($^S) {
              # We're in an eval {} and don't want log
              # this message but catch it later
              return;
          }
          local $Log::Log4perl::caller_depth =
              $Log::Log4perl::caller_depth + 1;
          LOGDIE @_;
      };
  
  This will call Log4perl's C<LOGDIE()> function, which will log a fatal
  error and then call die() internally, causing the program to exit. Works
  equally well with C<Carp>'s C<croak()> and C<confess()> functions.
  
  =head2 Some module prints messages to STDERR. How can I funnel them to Log::Log4perl?
  
  If a module you're using doesn't use Log::Log4perl but prints logging
  messages to STDERR instead, like
  
      ########################################
      package IgnorantModule;
      ########################################
  
      sub some_method {
          print STDERR "Parbleu! An error!\n";
      }
  
      1;
  
  there's still a way to capture these messages and funnel them
  into Log::Log4perl, even without touching the module. What you need is
  a trapper module like
  
      ########################################
      package Trapper;
      ########################################
  
      use Log::Log4perl qw(:easy);
  
      sub TIEHANDLE {
          my $class = shift;
          bless [], $class;
      }
  
      sub PRINT {
          my $self = shift;
          $Log::Log4perl::caller_depth++;
          DEBUG @_;
          $Log::Log4perl::caller_depth--;
      }
  
      1;
  
  and a C<tie> command in the main program to tie STDERR to the trapper
  module along with regular Log::Log4perl initialization:
  
      ########################################
      package main;
      ########################################
  
      use Log::Log4perl qw(:easy);
  
      Log::Log4perl->easy_init(
          {level  => $DEBUG,
           file   => 'stdout',   # make sure not to use stderr here!
           layout => "%d %M: %m%n",
          });
  
      tie *STDERR, "Trapper";
  
  Make sure not to use STDERR as Log::Log4perl's file appender
  here (which would be the default in C<:easy> mode), because it would
  end up in an endless recursion.
  
  Now, calling
  
      IgnorantModule::some_method();
  
  will result in the desired output
  
      2004/05/06 11:13:04 IgnorantModule::some_method: Parbleu! An error!
  
  =head2 How come PAR (Perl Archive Toolkit) creates executables which then can't find their Log::Log4perl appenders?
  
  If not instructed otherwise, C<Log::Log4perl> dynamically pulls in
  appender classes found in its configuration. If you specify
  
      #!/usr/bin/perl
      # mytest.pl
  
      use Log::Log4perl qw(get_logger);
  
      my $conf = q(
        log4perl.category.Bar.Twix = WARN, Logfile
        log4perl.appender.Logfile  = Log::Log4perl::Appender::Screen
        log4perl.appender.Logfile.layout = SimpleLayout
      );
  
      Log::Log4perl::init(\$conf);
      my $logger = get_logger("Bar::Twix");
      $logger->error("Blah");
  
  then C<Log::Log4perl::Appender::Screen> will be pulled in while the program
  runs, not at compile time. If you have PAR compile the script above to an
  executable binary via
  
      pp -o mytest mytest.pl
  
  and then run C<mytest> on a machine without having Log::Log4perl installed,
  you'll get an error message like
  
      ERROR: can't load appenderclass 'Log::Log4perl::Appender::Screen'
      Can't locate Log/Log4perl/Appender/Screen.pm in @INC ...
  
  Why? At compile time, C<pp> didn't realize that
  C<Log::Log4perl::Appender::Screen> would be needed later on and didn't
  wrap it into the executable created. To avoid this, either say
  C<use Log::Log4perl::Appender::Screen> in the script explicitly or
  compile it with
  
      pp -o mytest -M Log::Log4perl::Appender::Screen mytest.pl
  
  to make sure the appender class gets included.
  
  =head2 How can I access a custom appender defined in the configuration?
  
  Any appender defined in the configuration file or somewhere in the code
  can be accessed later via
  C<Log::Log4perl-E<gt>appender_by_name("appender_name")>,
  which returns a reference of the appender object.
  
  Once you've got a hold of the object, it can be queried or modified to
  your liking. For example, see the custom C<IndentAppender> defined below:
  After calling C<init()> to define the Log4perl settings, the
  appender object is retrieved to call its C<indent_more()> and C<indent_less()>
  methods to control indentation of messages:
  
      package IndentAppender;
  
      sub new {
          bless { indent => 0 }, $_[0];
      }
  
      sub indent_more  { $_[0]->{indent}++ }
      sub indent_less  { $_[0]->{indent}-- }
  
      sub log {
          my($self, %params) = @_;
          print " " x $self->{indent}, $params{message};
      }
  
      package main;
  
      use Log::Log4perl qw(:easy);
  
      my $conf = q(
      log4perl.category          = DEBUG, Indented
      log4perl.appender.Indented = IndentAppender
      log4perl.appender.Indented.layout = Log::Log4perl::Layout::SimpleLayout
      );
  
      Log::Log4perl::init(\$conf);
  
      my $appender = Log::Log4perl->appender_by_name("Indented");
  
      DEBUG "No identation";
      $appender->indent_more();
      DEBUG "One more";
      $appender->indent_more();
      DEBUG "Two more";
      $appender->indent_less();
      DEBUG "One less";
  
  As you would expect, this will print
  
      DEBUG - No identation
       DEBUG - One more
        DEBUG - Two more
       DEBUG - One less
  
  because the very appender used by Log4perl is modified dynamically at
  runtime.
  
  =head2 I don't know if Log::Log4perl is installed. How can I prepare my script?
  
  In case your script needs to be prepared for environments that may or may
  not have Log::Log4perl installed, there's a trick.
  
  If you put the following BEGIN blocks at the top of the program,
  you'll be able to use the DEBUG(), INFO(), etc. macros in
  Log::Log4perl's C<:easy> mode.
  If Log::Log4perl
  is installed in the target environment, the regular Log::Log4perl rules
  apply. If not, all of DEBUG(), INFO(), etc. are "stubbed" out, i.e. they
  turn into no-ops:
  
      use warnings;
      use strict;
  
      BEGIN {
          eval { require Log::Log4perl; };
  
          if($@) {
              print "Log::Log4perl not installed - stubbing.\n";
              no strict qw(refs);
              *{"main::$_"} = sub { } for qw(DEBUG INFO WARN ERROR FATAL);
          } else {
              no warnings;
              print "Log::Log4perl installed - life is good.\n";
              require Log::Log4perl::Level;
              Log::Log4perl::Level->import(__PACKAGE__);
              Log::Log4perl->import(qw(:easy));
              Log::Log4perl->easy_init($main::DEBUG);
          }
      }
  
          # The regular script begins ...
      DEBUG "Hey now!";
  
  This snippet will first probe for Log::Log4perl, and if it can't be found,
  it will alias DEBUG(), INFO(), with empty subroutines via typeglobs.
  If Log::Log4perl is available, its level constants are first imported
  (C<$DEBUG>, C<$INFO>, etc.) and then C<easy_init()> gets called to initialize
  the logging system.
  
  =head2 Can file appenders create files with different permissions?
  
  Typically, when C<Log::Log4perl::Appender::File> creates a new file,
  its permissions are set to C<rw-r--r-->. Why? Because your
  environment's I<umask> most likely defaults to
  C<0022>, that's the standard setting.
  
  What's a I<umask>, you're asking? It's a template that's applied to
  the permissions of all newly created files. While calls like
  C<open(FILE, "E<gt>foo")> will always try to create files in C<rw-rw-rw-
  > mode, the system will apply the current I<umask> template to
  determine the final permission setting. I<umask> is a bit mask that's
  inverted and then applied to the requested permission setting, using a
  bitwise AND:
  
      $request_permission &~ $umask
  
  So, a I<umask> setting of 0000 (the leading 0 simply indicates an
  octal value) will create files in C<rw-rw-rw-> mode, a setting of 0277
  will use C<r-------->, and the standard 0022 will use C<rw-r--r-->.
  
  As an example, if you want your log files to be created with
  C<rw-r--rw-> permissions, use a I<umask> of C<0020> before
  calling Log::Log4perl->init():
  
      use Log::Log4perl;
  
      umask 0020;
          # Creates log.out in rw-r--rw mode
      Log::Log4perl->init(\ q{
          log4perl.logger = WARN, File
          log4perl.appender.File = Log::Log4perl::Appender::File
          log4perl.appender.File.filename = log.out
          log4perl.appender.File.layout = SimpleLayout
      });
  
  =head2 Using Log4perl in an END block causes a problem!
  
  It's not easy to get to this error, but if you write something like
  
      END { Log::Log4perl::get_logger()->debug("Hey there."); }
  
      use Log::Log4perl qw(:easy);
      Log::Log4perl->easy_init($DEBUG);
  
  it won't work. The reason is that C<Log::Log4perl> defines an
  END block that cleans up all loggers. And perl will run END blocks
  in the reverse order as they're encountered in the compile phase,
  so in the scenario above, the END block will run I<after> Log4perl
  has cleaned up its loggers.
  
  Placing END blocks using Log4perl I<after>
  a C<use Log::Log4perl> statement fixes the problem:
  
      use Log::Log4perl qw(:easy);
      Log::Log4perl->easy_init($DEBUG);
  
      END { Log::Log4perl::get_logger()->debug("Hey there."); }
  
  In this scenario, the shown END block is executed I<before> Log4perl
  cleans up and the debug message will be processed properly.
  
  =head2 Help! My appender is throwing a "Wide character in print" warning!
  
  This warning shows up when Unicode strings are printed without
  precautions. The warning goes away if the complaining appender is
  set to utf-8 mode:
  
        # Either in the log4perl configuration file:
    log4perl.appender.Logfile.filename = test.log
    log4perl.appender.Logfile.utf8     = 1
  
        # Or, in easy mode:
    Log::Log4perl->easy_init( {
      level => $DEBUG,
      file  => ":utf8> test.log"
    } );
  
  If the complaining appender is a screen appender, set its C<utf8> option:
  
        log4perl.appender.Screen.stderr = 1
        log4perl.appender.Screen.utf8   = 1
  
  Alternatively, C<binmode> does the trick:
  
        # Either STDOUT ...
      binmode(STDOUT, ":utf8);
  
        # ... or STDERR.
      binmode(STDERR, ":utf8);
  
  Some background on this: Perl's strings are either byte strings or
  Unicode strings. C<"Mike"> is a byte string.
  C<"\x{30DE}\x{30A4}\x{30AF}"> is a Unicode string. Unicode strings are
  marked specially and are UTF-8 encoded internally.
  
  If you print a byte string to STDOUT,
  all is well, because STDOUT is by default set to byte mode. However,
  if you print a Unicode string to STDOUT without precautions, C<perl>
  will try to transform the Unicode string back to a byte string before
  printing it out. This is troublesome if the Unicode string contains
  'wide' characters which can't be represented in Latin-1.
  
  For example, if you create a Unicode string with three japanese Katakana
  characters as in
  
      perl -le 'print "\x{30DE}\x{30A4}\x{30AF}"'
  
  (coincidentally pronounced Ma-i-ku, the japanese pronunciation of
  "Mike"), STDOUT is in byte mode and the warning
  
      Wide character in print at ./script.pl line 14.
  
  appears. Setting STDOUT to UTF-8 mode as in
  
      perl -le 'binmode(STDOUT, ":utf8"); print "\x{30DE}\x{30A4}\x{30AF}"'
  
  will silently print the Unicode string to STDOUT in UTF-8. To see the
  characters printed, you'll need a UTF-8 terminal with a font including
  japanese Katakana characters.
  
  =head2 How can I send errors to the screen, and debug messages to a file?
  
  Let's assume you want to maintain a detailed DEBUG output in a file
  and only messages of level ERROR and higher should be printed on the
  screen. Often times, developers come up with something like this:
  
       # Wrong!!!
      log4perl.logger = DEBUG, FileApp
      log4perl.logger = ERROR, ScreenApp
       # Wrong!!!
  
  This won't work, however. Logger definitions aren't additive, and the
  second statement will overwrite the first one. Log4perl versions
  below 1.04 were silently accepting this, leaving people confused why
  it wouldn't work as expected.
  As of 1.04, this will throw a I<fatal error> to notify the user of
  the problem.
  
  What you want to do instead, is this:
  
      log4perl.logger                    = DEBUG, FileApp, ScreenApp
  
      log4perl.appender.FileApp          = Log::Log4perl::Appender::File
      log4perl.appender.FileApp.filename = test.log
      log4perl.appender.FileApp.layout   = SimpleLayout
  
      log4perl.appender.ScreenApp          = Log::Log4perl::Appender::Screen
      log4perl.appender.ScreenApp.stderr   = 0
      log4perl.appender.ScreenApp.layout   = SimpleLayout
         ### limiting output to ERROR messages
      log4perl.appender.ScreenApp.Threshold = ERROR
         ###
  
  Note that without the second appender's C<Threshold> setting, both appenders
  would receive all messages prioritized DEBUG and higher. With the
  threshold set to ERROR, the second appender will filter the messages
  as required.
  
  =head2 Where should I put my logfiles?
  
  Your log files may go anywhere you want them, but the effective
  user id of the calling process must have write access.
  
  If the log file doesn't exist at program start, Log4perl's file appender
  will create it. For this, it needs write access to the directory where
  the new file will be located in. If the log file already exists at startup,
  the process simply needs write access to the file. Note that it will
  need write access to the file's directory if you're encountering situations
  where the logfile gets recreated, e.g. during log rotation.
  
  If Log::Log4perl is used by a web server application (e.g. in a CGI script
  or mod_perl), then the webserver's user (usually C<nobody> or C<www>)
  must have the permissions mentioned above.
  
  To prepare your web server to use log4perl, we'd recommend:
  
      webserver:~$ su -
      webserver:~# mkdir /var/log/cgiapps
      webserver:~# chown nobody:root /var/log/cgiapps/
      webserver:~# chown nobody:root -R /var/log/cgiapps/
      webserver:~# chmod 02755 -R /var/log/cgiapps/
  
  Then set your /etc/log4perl.conf file to include:
  
      log4perl.appender.FileAppndr1.filename =
          /var/log/cgiapps/<app-name>.log
  
  =head2 How can my file appender deal with disappearing log files?
  
  The file appender that comes with Log4perl, L<Log::Log4perl::Appender::File>,
  will open a specified log file at initialization time and will
  keep writing to it via a file handle.
  
  In case the associated file goes way, messages written by a
  long-running process will still be written
  to the file handle. In case the file has been moved to a different
  location on the same file system, the writer will keep writing to
  it under the new filename. In case the file has been removed from
  the file system, the log messages will end up in nowhere land. This
  is not a bug in Log4perl, this is how Unix works. There is
  no error message in this case, because the writer has no idea that
  the file handle is not associated with a visible file.
  
  To prevent the loss of log messages when log files disappear, the
  file appender's C<recreate> option needs to be set to a true value:
  
      log4perl.appender.Logfile.recreate = 1
  
  This will instruct the file appender to check in regular intervals
  (default: 30 seconds) if the log file is still there. If it finds
  out that the file is missing, it will recreate it.
  
  Continuously checking if the log file still exists is fairly
  expensive. For this reason it is only performed every 30 seconds. To
  change this interval, the option C<recreate_check_interval> can be set
  to the number of seconds between checks. In the extreme case where the
  check should be performed before every write, it can even be set to 0:
  
      log4perl.appender.Logfile.recreate = 1
      log4perl.appender.Logfile.recreate_check_interval = 0
  
  To avoid having to check the file system so frequently, a signal
  handler can be set up:
  
      log4perl.appender.Logfile.recreate = 1
      log4perl.appender.Logfile.recreate_check_signal = USR1
  
  This will install a signal handler which will recreate a missing log file
  immediately when it receives the defined signal.
  
  Note that the init_and_watch() method for Log4perl's initialization
  can also be instructed to install a signal handler, usually using the
  HUP signal. Make sure to use a different signal if you're using both
  of them at the same time.
  
  =head2 How can I rotate a logfile with newsyslog?
  
  Here's a few things that need to be taken care of when using the popular
  log file rotating utility C<newsyslog>
  (http://www.courtesan.com/newsyslog) with Log4perl's file appender
  in long-running processes.
  
  For example, with a newsyslog configuration like
  
      # newsyslog.conf
      /tmp/test.log 666  12  5  *  B
  
  and a call to
  
      # newsyslog -f /path/to/newsyslog.conf
  
  C<newsyslog> will take action if C</tmp/test.log> is larger than the
  specified 5K in size. It will move the current log file C</tmp/test.log> to
  C</tmp/test.log.0> and create a new and empty C</tmp/test.log> with
  the specified permissions (this is why C<newsyslog> needs to run as root).
  An already existing C</tmp/test.log.0> would be moved to
  C</tmp/test.log.1>, C</tmp/test.log.1> to C</tmp/test.log.2>, and so
  forth, for every one of a max number of 12 archived logfiles that have
  been configured in C<newsyslog.conf>.
  
  Although a new file has been created, from Log4perl's appender's point
  of view, this situation is identical to the one described in the
  previous FAQ entry, labeled C<How can my file appender deal with
  disappearing log files>.
  
  To make sure that log messages are written to the new log file and not
  to an archived one or end up in nowhere land,
  the appender's C<recreate> and C<recreate_check_interval> have to be
  configured to deal with the 'disappearing' log file.
  
  The situation gets interesting when C<newsyslog>'s option
  to compress archived log files is enabled. This causes the
  original log file not to be moved, but to disappear. If the
  file appender isn't configured to recreate the logfile in this situation,
  log messages will actually be lost without warning. This also
  applies for the short time frame of C<recreate_check_interval> seconds
  in between the recreator's file checks.
  
  To make sure that no messages get lost, one option is to set the
  interval to
  
      log4perl.appender.Logfile.recreate_check_interval = 0
  
  However, this is fairly expensive. A better approach is to define
  a signal handler:
  
      log4perl.appender.Logfile.recreate = 1
      log4perl.appender.Logfile.recreate_check_signal  = USR1
      log4perl.appender.Logfile.recreate_pid_write = /tmp/myappid
  
  As a service for C<newsyslog> users, Log4perl's file appender writes
  the current process ID to a PID file specified by the C<recreate_pid_write>
  option.  C<newsyslog> then needs to be configured as in
  
      # newsyslog.conf configuration for compressing archive files and
      # sending a signal to the Log4perl-enabled application
      /tmp/test.log 666  12  5  *  B /tmp/myappid 30
  
  to send the defined signal (30, which is USR1 on FreeBSD) to the
  application process at rotation time. Note that the signal number
  is different on Linux, where USR1 denotes as 10. Check C<man signal>
  for details.
  
  =head2 How can a process under user id A log to a file under user id B?
  
  This scenario often occurs in configurations where processes run under
  various user IDs but need to write to a log file under a fixed, but
  different user id.
  
  With a traditional file appender, the log file will probably be created
  under one user's id and appended to under a different user's id. With
  a typical umask of 0002, the file will be created with -rw-rw-r--
  permissions. If a user who's not in the first user's group
  subsequently appends to the log file, it will fail because of a
  permission problem.
  
  Two potential solutions come to mind:
  
  =over 4
  
  =item *
  
  Creating the file with a umask of 0000 will allow all users to append
  to the log file. Log4perl's file appender C<Log::Log4perl::Appender::File>
  has an C<umask> option that can be set to support this:
  
      log4perl.appender.File = Log::Log4perl::Appender::File
      log4perl.appender.File.umask = sub { 0000 };
  
  This way, the log file will be created with -rw-rw-rw- permissions and
  therefore has world write permissions. This might open up the logfile
  for unwanted manipulations by arbitrary users, though.
  
  =item *
  
  Running the process under an effective user id of C<root> will allow
  it to write to the log file, no matter who started the process.
  However, this is not a good idea, because of security concerns.
  
  =back
  
  Luckily, under Unix, there's the syslog daemon which runs as root and
  takes log requests from user processes over a socket and writes them
  to log files as configured in C</etc/syslog.conf>.
  
  By modifying C</etc/syslog.conf> and HUPing the syslog daemon, you can
  configure new log files:
  
      # /etc/syslog.conf
      ...
      user.* /some/path/file.log
  
  Using the C<Log::Dispatch::Syslog> appender, which comes with the
  C<Log::Log4perl> distribution, you can then send messages via syslog:
  
      use Log::Log4perl qw(:easy);
  
      Log::Log4perl->init(\<<EOT);
          log4perl.logger = DEBUG, app
          log4perl.appender.app=Log::Dispatch::Syslog
          log4perl.appender.app.Facility=user
          log4perl.appender.app.layout=SimpleLayout
      EOT
  
          # Writes to /some/path/file.log
      ERROR "Message!";
  
  This way, the syslog daemon will solve the permission problem.
  
  Note that while it is possible to use syslog() without Log4perl (syslog
  supports log levels, too), traditional syslog setups have a
  significant drawback.
  
  Without Log4perl's ability to activate logging in only specific
  parts of a system, complex systems will trigger log events all over
  the place and slow down execution to a crawl at high debug levels.
  
  Remote-controlling logging in the hierarchical parts of an application
  via Log4perl's categories is one of its most distinguished features.
  It allows for enabling high debug levels in specified areas without
  noticeable performance impact.
  
  =head2 I want to use UTC instead of the local time!
  
  If a layout defines a date, Log::Log4perl uses local time to populate it.
  If you want UTC instead, set
  
      log4perl.utcDateTimes = 1
  
  in your configuration. Alternatively, you can set
  
      $Log::Log4perl::DateFormat::GMTIME = 1;
  
  in your program before the first log statement.
  
  =head2 Can Log4perl intercept messages written to a filehandle?
  
  You have a function that prints to a filehandle. You want to tie
  into that filehandle and forward all arriving messages to a
  Log4perl logger.
  
  First, let's write a package that ties a file handle and forwards it
  to a Log4perl logger:
  
      package FileHandleLogger;
      use Log::Log4perl qw(:levels get_logger);
  
      sub TIEHANDLE {
         my($class, %options) = @_;
  
         my $self = {
             level    => $DEBUG,
             category => '',
             %options
         };
  
         $self->{logger} = get_logger($self->{category}),
         bless $self, $class;
      }
  
      sub PRINT {
          my($self, @rest) = @_;
          $Log::Log4perl::caller_depth++;
          $self->{logger}->log($self->{level}, @rest);
          $Log::Log4perl::caller_depth--;
      }
  
      sub PRINTF {
          my($self, $fmt, @rest) = @_;
          $Log::Log4perl::caller_depth++;
          $self->PRINT(sprintf($fmt, @rest));
          $Log::Log4perl::caller_depth--;
      }
  
      1;
  
  Now, if you have a function like
  
      sub function_printing_to_fh {
          my($fh) = @_;
          printf $fh "Hi there!\n";
      }
  
  which takes a filehandle and prints something to it, it can be used
  with Log4perl:
  
      use Log::Log4perl qw(:easy);
      usa FileHandleLogger;
  
      Log::Log4perl->easy_init($DEBUG);
  
      tie *SOMEHANDLE, 'FileHandleLogger' or
          die "tie failed ($!)";
  
      function_printing_to_fh(*SOMEHANDLE);
          # prints "2007/03/22 21:43:30 Hi there!"
  
  If you want, you can even specify a different log level or category:
  
      tie *SOMEHANDLE, 'FileHandleLogger',
          level => $INFO, category => "Foo::Bar" or die "tie failed ($!)";
  
  =head2 I want multiline messages rendered line-by-line!
  
  With the standard C<PatternLayout>, if you send a multiline message to
  an appender as in
  
      use Log::Log4perl qw(:easy);
      Log
  
  it gets rendered this way:
  
      2007/04/04 23:23:39 multi
      line
      message
  
  If you want each line to be rendered separately according to
  the layout use C<Log::Log4perl::Layout::PatternLayout::Multiline>:
  
      use Log::Log4perl qw(:easy);
  
      Log::Log4perl->init(\<<EOT);
        log4perl.category         = DEBUG, Screen
        log4perl.appender.Screen = Log::Log4perl::Appender::Screen
        log4perl.appender.Screen.layout = \\
          Log::Log4perl::Layout::PatternLayout::Multiline
        log4perl.appender.Screen.layout.ConversionPattern = %d %m %n
      EOT
  
      DEBUG "some\nmultiline\nmessage";
  
  and you'll get
  
      2007/04/04 23:23:39 some
      2007/04/04 23:23:39 multiline
      2007/04/04 23:23:39 message
  
  instead.
  
  =head2 I'm on Windows and I'm getting all these 'redefined' messages!
  
  If you're on Windows and are getting warning messages like
  
    Constant subroutine Log::Log4perl::_INTERNAL_DEBUG redefined at
      C:/Programme/Perl/lib/constant.pm line 103.
    Subroutine import redefined at
      C:/Programme/Perl/site/lib/Log/Log4Perl.pm line 69.
    Subroutine initialized redefined at
      C:/Programme/Perl/site/lib/Log/Log4Perl.pm line 207.
  
  then chances are that you're using 'Log::Log4Perl' (wrong uppercase P)
  instead of the correct 'Log::Log4perl'. Perl on Windows doesn't
  handle this error well and spits out a slew of confusing warning
  messages. But now you know, just use the correct module name and
  you'll be fine.
  
  =head2 Log4perl complains that no initialization happened during shutdown!
  
  If you're using Log4perl log commands in DESTROY methods of your objects,
  you might see confusing messages like
  
      Log4perl: Seems like no initialization happened. Forgot to call init()?
      Use of uninitialized value in subroutine entry at
      /home/y/lib/perl5/site_perl/5.6.1/Log/Log4perl.pm line 134 during global
      destruction. (in cleanup) Undefined subroutine &main:: called at
      /home/y/lib/perl5/site_perl/5.6.1/Log/Log4perl.pm line 134 during global
      destruction.
  
  when the program shuts down. What's going on?
  
  This phenomenon happens if you have circular references in your objects,
  which perl can't clean up when an object goes out of scope but waits
  until global destruction instead. At this time, however, Log4perl has
  already shut down, so you can't use it anymore.
  
  For example, here's a simple class which uses a logger in its DESTROY
  method:
  
      package A;
      use Log::Log4perl qw(:easy);
      sub new { bless {}, shift }
      sub DESTROY { DEBUG "Waaah!"; }
  
  Now, if the main program creates a self-referencing object, like in
  
      package main;
      use Log::Log4perl qw(:easy);
      Log::Log4perl->easy_init($DEBUG);
  
      my $a = A->new();
      $a->{selfref} = $a;
  
  then you'll see the error message shown above during global destruction.
  How to tackle this problem?
  
  First, you should clean up your circular references before global
  destruction. They will not only cause objects to be destroyed in an order
  that's hard to predict, but also eat up memory until the program shuts
  down.
  
  So, the program above could easily be fixed by putting
  
      $a->{selfref} = undef;
  
  at the end or in an END handler. If that's hard to do, use weak references:
  
      package main;
      use Scalar::Util qw(weaken);
      use Log::Log4perl qw(:easy);
      Log::Log4perl->easy_init($DEBUG);
  
      my $a = A->new();
      $a->{selfref} = weaken $a;
  
  This allows perl to clean up the circular reference when the object
  goes out of scope, and doesn't wait until global destruction.
  
  =head2 How can I access POE heap values from Log4perl's layout?
  
  POE is a framework for creating multitasked applications running in a
  single process and a single thread. POE's threads equivalents are
  'sessions' and since they run quasi-simultaneously, you can't use
  Log4perl's global NDC/MDC to hold session-specific data.
  
  However, POE already maintains a data store for every session. It is called
  'heap' and is just a hash storing session-specific data in key-value pairs.
  To access this per-session heap data from a Log4perl layout, define a
  custom cspec and reference it with the newly defined pattern in the layout:
  
      use strict;
      use POE;
      use Log::Log4perl qw(:easy);
  
      Log::Log4perl->init( \ q{
          log4perl.logger = DEBUG, Screen
          log4perl.appender.Screen = Log::Log4perl::Appender::Screen
          log4perl.appender.Screen.layout = PatternLayout
          log4perl.appender.Screen.layout.ConversionPattern = %U %m%n
          log4perl.PatternLayout.cspec.U = \
              sub { POE::Kernel->get_active_session->get_heap()->{ user } }
      } );
  
      for (qw( Huey Lewey Dewey )) {
          POE::Session->create(
              inline_states => {
                  _start    => sub {
                      $_[HEAP]->{user} = $_;
                      POE::Kernel->yield('hello');
                  },
                  hello     => sub {
                      DEBUG "I'm here now";
                  }
              }
          );
      }
  
      POE::Kernel->run();
      exit;
  
  The code snippet above defines a new layout placeholder (called
  'cspec' in Log4perl) %U which calls a subroutine, retrieves the active
  session, gets its heap and looks up the entry specified ('user').
  
  Starting with Log::Log4perl 1.20, cspecs also support parameters in
  curly braces, so you can say
  
      log4perl.appender.Screen.layout.ConversionPattern = %U{user} %U{id} %m%n
      log4perl.PatternLayout.cspec.U = \
              sub { POE::Kernel->get_active_session-> \
                    get_heap()->{ $_[0]->{curlies} } }
  
  and print the POE session heap entries 'user' and 'id' with every logged
  message. For more details on cpecs, read the PatternLayout manual.
  
  =head2 I want to print something unconditionally!
  
  Sometimes it's a script that's supposed to log messages regardless if
  Log4perl has been initialized or not. Or there's a logging statement that's
  not going to be suppressed under any circumstances -- many people want to
  have the final word, make the executive decision, because it seems like
  the only logical choice.
  
  But think about it:
  First off, if a messages is supposed to be printed, where is it supposed
  to end up at? STDOUT? STDERR? And are you sure you want to set in stone
  that this message needs to be printed, while someone else might
  find it annoying and wants to get rid of it?
  
  The truth is, there's always going to be someone who wants to log a
  messages at all cost, but also another person who wants to suppress it
  with equal vigilance. There's no good way to serve these two conflicting
  desires, someone will always want to win at the cost of leaving
  the other party disappointed.
  
  So, the best Log4perl offers is the ALWAYS level for a message that even
  fires if the system log level is set to $OFF:
  
      use Log::Log4perl qw(:easy);
  
      Log::Log4perl->easy_init( $OFF );
      ALWAYS "This gets logged always. Well, almost always";
  
  The logger won't fire, though, if Log4perl hasn't been initialized or
  if someone defines a custom log hurdle that's higher than $OFF.
  
  Bottom line: Leave the setting of the logging level to the initial Perl
  script -- let their owners decided what they want, no matter how tempting
  it may be to decide it for them.
  
  =head2 Why doesn't my END handler remove my log file on Win32?
  
  If you have code like
  
      use Log::Log4perl qw( :easy );
      Log::Log4perl->easy_init( { level => $DEBUG, file => "my.log" } );
      END { unlink "my.log" or die };
  
  then you might be in for a surprise when you're running it on
  Windows, because the C<unlink()> call in the END handler will complain that
  the file is still in use.
  
  What happens in Perl if you have something like
  
      END { print "first end in main\n"; }
      use Module;
      END { print "second end in main\n"; }
  
  and
  
      package Module;
      END { print "end in module\n"; }
      1;
  
  is that you get
  
      second end in main
      end in module
      first end in main
  
  because perl stacks the END handlers in reverse order in which it
  encounters them in the compile phase.
  
  Log4perl defines an END handler that cleans up left-over appenders (e.g.
  file appenders which still hold files open), because those appenders have
  circular references and therefore aren't cleaned up otherwise.
  
  Now if you define an END handler after "use Log::Log4perl", it'll
  trigger before Log4perl gets a chance to clean up, which isn't a 
  problem on Unix where you can delete a file even if some process has a 
  handle to it open, but it's a problem on Win32, where the OS won't 
  let you do that.
  
  The solution is easy, just place the END handler I<before> Log4perl
  gets loaded, like in
  
      END { unlink "my.log" or die };
      use Log::Log4perl qw( :easy );
      Log::Log4perl->easy_init( { level => $DEBUG, file => "my.log" } );
  
  which will call the END handlers in the intended order.
  
  =cut
  
  =head1 SEE ALSO
  
  Log::Log4perl
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt>
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches):
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull,
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter,
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope,
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_FAQ

$fatpacked{"Log/Log4perl/Filter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_FILTER';
  ##################################################
  package Log::Log4perl::Filter;
  ##################################################
  
  use 5.006;
  use strict;
  use warnings;
  
  use Log::Log4perl::Level;
  use Log::Log4perl::Config;
  
  use constant _INTERNAL_DEBUG => 0;
  
  our %FILTERS_DEFINED = ();
  
  ##################################################
  sub new {
  ##################################################
      my($class, $name, $action) = @_;
    
      print "Creating filter $name\n" if _INTERNAL_DEBUG;
  
      my $self = { name => $name };
      bless $self, $class;
  
      if(ref($action) eq "CODE") {
          # it's a code ref
          $self->{ok} = $action;
      } else {
          # it's something else
          die "Code for ($name/$action) not properly defined";
      }
  
      return $self;
  }
  
  ##################################################
  sub register {         # Register a filter by name
                         # (Passed on to subclasses)
  ##################################################
      my($self) = @_;
  
      by_name($self->{name}, $self);
  }
  
  ##################################################
  sub by_name {        # Get/Set a filter object by name
  ##################################################
      my($name, $value) = @_;
  
      if(defined $value) {
          $FILTERS_DEFINED{$name} = $value;
      }
  
      if(exists $FILTERS_DEFINED{$name}) {
          return $FILTERS_DEFINED{$name};
      } else {
          return undef;
      }
  }
  
  ##################################################
  sub reset {
  ##################################################
      %FILTERS_DEFINED = ();
  }
  
  ##################################################
  sub ok {
  ##################################################
      my($self, %p) = @_;
  
      print "Calling $self->{name}'s ok method\n" if _INTERNAL_DEBUG;
  
          # Force filter classes to define their own
          # ok(). Exempt are only sub {..} ok functions,
          # defined in the conf file.
      die "This is to be overridden by the filter" unless
           defined $self->{ok};
  
      # What should we set the message in $_ to? The most logical
      # approach seems to be to concat all parts together. If some
      # filter wants to dissect the parts, it still can examine %p,
      # which gets passed to the subroutine and contains the chunks
      # in $p{message}.
          # Split because of CVS
      local($_) = join $
                       Log::Log4perl::JOIN_MSG_ARRAY_CHAR, @{$p{message}};
      print "\$_ is '$_'\n" if _INTERNAL_DEBUG;
  
      my $decision = $self->{ok}->(%p);
  
      print "$self->{name}'s ok'ed: ", 
            ($decision ? "yes" : "no"), "\n" if _INTERNAL_DEBUG;
  
      return $decision;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Filter - Log4perl Custom Filter Base Class
  
  =head1 SYNOPSIS
  
    use Log::Log4perl;
  
    Log::Log4perl->init(\ <<'EOT');
      log4perl.logger = INFO, Screen
      log4perl.filter.MyFilter        = sub { /let this through/ }
      log4perl.appender.Screen        = Log::Log4perl::Appender::Screen
      log4perl.appender.Screen.Filter = MyFilter
      log4perl.appender.Screen.layout = Log::Log4perl::Layout::SimpleLayout
    EOT
  
        # Define a logger
    my $logger = Log::Log4perl->get_logger("Some");
  
        # Let this through
    $logger->info("Here's the info, let this through!");
  
        # Suppress this
    $logger->info("Here's the info, suppress this!");
  
    #################################################################
    # StringMatch Filter:
    #################################################################
    log4perl.filter.M1               = Log::Log4perl::Filter::StringMatch
    log4perl.filter.M1.StringToMatch = let this through
    log4perl.filter.M1.AcceptOnMatch = true
  
    #################################################################
    # LevelMatch Filter:
    #################################################################
    log4perl.filter.M1               = Log::Log4perl::Filter::LevelMatch
    log4perl.filter.M1.LevelToMatch  = INFO
    log4perl.filter.M1.AcceptOnMatch = true
  
  =head1 DESCRIPTION
  
  Log4perl allows the use of customized filters in its appenders
  to control the output of messages. These filters might grep for
  certain text chunks in a message, verify that its priority
  matches or exceeds a certain level or that this is the 10th
  time the same message has been submitted -- and come to a log/no log 
  decision based upon these circumstantial facts.
  
  Filters have names and can be specified in two different ways in the Log4perl
  configuration file: As subroutines or as filter classes. Here's a 
  simple filter named C<MyFilter> which just verifies that the 
  oncoming message matches the regular expression C</let this through/i>:
  
      log4perl.filter.MyFilter        = sub { /let this through/i }
  
  It exploits the fact that when the subroutine defined
  above is called on a message,
  Perl's special C<$_> variable will be set to the message text (prerendered,
  i.e. concatenated but not layouted) to be logged. 
  The subroutine is expected to return a true value 
  if it wants the message to be logged or a false value if doesn't.
  
  Also, Log::Log4perl will pass a hash to the subroutine,
  containing all key/value pairs that it would pass to the corresponding 
  appender, as specified in Log::Log4perl::Appender. Here's an
  example of a filter checking the priority of the oncoming message:
  
    log4perl.filter.MyFilter        = sub {    \
         my %p = @_;                           \
         if($p{log4p_level} eq "WARN" or       \
            $p{log4p_level} eq "INFO") {       \
             return 1;                         \
         }                                     \
         return 0;                             \
    }     
  
  If the message priority equals C<WARN> or C<INFO>, 
  it returns a true value, causing
  the message to be logged.
  
  =head2 Predefined Filters
  
  For common tasks like verifying that the message priority matches
  a certain priority, there's already a 
  set of predefined filters available. To perform an exact level match, it's
  much cleaner to use Log4perl's C<LevelMatch> filter instead:
  
    log4perl.filter.M1               = Log::Log4perl::Filter::LevelMatch
    log4perl.filter.M1.LevelToMatch  = INFO
    log4perl.filter.M1.AcceptOnMatch = true
  
  This will let the message through if its priority is INFO and suppress
  it otherwise. The statement can be negated by saying
  
    log4perl.filter.M1.AcceptOnMatch = false
  
  instead. This way, the message will be logged if its priority is
  anything but INFO.
  
  On a similar note, Log4perl's C<StringMatch> filter will check the 
  oncoming message for strings or regular expressions:
  
    log4perl.filter.M1               = Log::Log4perl::Filter::StringMatch
    log4perl.filter.M1.StringToMatch = bl.. bl..
    log4perl.filter.M1.AcceptOnMatch = true
  
  This will open the gate for messages like C<blah blah> because the 
  regular expression in the C<StringToMatch> matches them. Again,
  the setting of C<AcceptOnMatch> determines if the filter is defined
  in a positive or negative way.
  
  All class filter entries in the configuration file
  have to adhere to the following rule:
  Only after a filter has been defined by name and class/subroutine,
  its attribute values can be
  assigned, just like the C<true> value above gets assigned to the
  C<AcceptOnMatch> attribute I<after> the
  filter C<M1> has been defined.
  
  =head2 Attaching a filter to an appender
  
  Attaching a filter to an appender is as easy as assigning its name to
  the appender's C<Filter> attribute:
  
      log4perl.appender.MyAppender.Filter = MyFilter
  
  This will cause C<Log::Log4perl> to call the filter subroutine/method
  every time a message is supposed to be passed to the appender. Depending
  on the filter's return value, C<Log::Log4perl> will either continue as
  planned or withdraw immediately.
  
  =head2 Combining filters with Log::Log4perl::Filter::Boolean
  
  Sometimes, it's useful to combine the output of various filters to
  arrive at a log/no log decision. While Log4j, Log4perl's mother ship,
  has chosen to implement this feature as a filter chain, similar to Linux' IP chains,
  Log4perl tries a different approach. 
  
  Typically, filter results will not need to be bumped along chains but 
  combined in a programmatic manner using boolean logic. "Log if
  this filter says 'yes' and that filter says 'no'" 
  is a fairly common requirement, but hard to implement as a chain.
  
  C<Log::Log4perl::Filter::Boolean> is a specially predefined custom filter
  for Log4perl. It combines the results of other custom filters 
  in arbitrary ways, using boolean expressions:
  
      log4perl.logger = WARN, AppWarn, AppError
  
      log4perl.filter.Match1       = sub { /let this through/ }
      log4perl.filter.Match2       = sub { /and that, too/ }
      log4perl.filter.MyBoolean       = Log::Log4perl::Filter::Boolean
      log4perl.filter.MyBoolean.logic = Match1 || Match2
  
      log4perl.appender.Screen        = Log::Log4perl::Appender::Screen
      log4perl.appender.Screen.Filter = MyBoolean
      log4perl.appender.Screen.layout = Log::Log4perl::Layout::SimpleLayout
  
  C<Log::Log4perl::Filter::Boolean>'s boolean expressions allow for combining
  different appenders by name using AND (&& or &), OR (|| or |) and NOT (!) as
  logical expressions. Also, parentheses can be used for defining precedences. 
  Operator precedence follows standard Perl conventions. Here's a bunch of examples:
  
      Match1 && !Match2            # Match1 and not Match2
      !(Match1 || Match2)          # Neither Match1 nor Match2
      (Match1 && Match2) || Match3 # Both Match1 and Match2 or Match3
  
  =head2 Writing your own filter classes
  
  If none of Log::Log4perl's predefined filter classes fits your needs,
  you can easily roll your own: Just define a new class,
  derive it from the baseclass C<Log::Log4perl::Filter>,
  and define its C<new> and C<ok> methods like this:
  
      package Log::Log4perl::Filter::MyFilter;
  
      use base Log::Log4perl::Filter;
  
      sub new {
          my ($class, %options) = @_;
  
          my $self = { %options,
                     };
       
          bless $self, $class;
  
          return $self;
      }
  
      sub ok {
           my ($self, %p) = @_;
  
           # ... decide and return 1 or 0
      }
  
      1;
  
  Log4perl will call the ok() method to determine if the filter
  should let the message pass or not. A true return value indicates
  the message will be logged by the appender, a false value blocks it.
  
  Values you've defined for its attributes in Log4perl's configuration file,
  will be received through its C<new> method:
  
      log4perl.filter.MyFilter       = Log::Log4perl::Filter::MyFilter
      log4perl.filter.MyFilter.color = red
  
  will cause C<Log::Log4perl::Filter::MyFilter>'s constructor to be called
  like this:
  
      Log::Log4perl::Filter::MyFilter->new( name  => "MyFilter",
                                            color => "red" );
  
  The custom filter class should use this to set the object's attributes, 
  to have them available later to base log/nolog decisions on it.
  
  C<ok()> is the filter's method to tell if it agrees or disagrees with logging
  the message. It will be called by Log::Log4perl whenever it needs the
  filter to decide. A false value returned by C<ok()> will block messages,
  a true value will let them through.
  
  =head2 A Practical Example: Level Matching
  
  See L<Log::Log4perl::FAQ> for this.
  
  =head1 SEE ALSO
  
  L<Log::Log4perl::Filter::LevelMatch>,
  L<Log::Log4perl::Filter::LevelRange>,
  L<Log::Log4perl::Filter::StringRange>,
  L<Log::Log4perl::Filter::Boolean>
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_FILTER

$fatpacked{"Log/Log4perl/Filter/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_FILTER_BOOLEAN';
  ##################################################
  package Log::Log4perl::Filter::Boolean;
  ##################################################
  
  use 5.006;
  
  use strict;
  use warnings;
  
  use Log::Log4perl::Level;
  use Log::Log4perl::Config;
  
  use constant _INTERNAL_DEBUG => 0;
  
  use base qw(Log::Log4perl::Filter);
  
  ##################################################
  sub new {
  ##################################################
      my ($class, %options) = @_;
  
      my $self = { params => {},
                   %options,
                 };
       
      bless $self, $class;
       
      print "Compiling '$options{logic}'\n" if _INTERNAL_DEBUG;
  
          # Set up meta-decider for later
      $self->compile_logic($options{logic});
  
      return $self;
  }
  
  ##################################################
  sub ok {
  ##################################################
       my ($self, %p) = @_;
  
       return $self->eval_logic(\%p);
  }
  
  ##################################################
  sub compile_logic {
  ##################################################
      my ($self, $logic) = @_;
  
         # Extract Filter placeholders in logic as defined
         # in configuration file.
      while($logic =~ /([\w_-]+)/g) {
              # Get the corresponding filter object
          my $filter = Log::Log4perl::Filter::by_name($1);
          die "Filter $1 required by Boolean filter, but not defined" 
              unless $filter;
  
          $self->{params}->{$1} = $filter;
      }
  
          # Fabricate a parameter list: A1/A2/A3 => $A1, $A2, $A3
      my $plist = join ', ', map { '$' . $_ } keys %{$self->{params}};
  
          # Replace all the (dollar-less) placeholders in the code with
          # calls to their respective coderefs.  
          $logic =~ s/([\w_-]+)/\&\$$1/g;
  
          # Set up the meta decider, which transforms the config file
          # logic into compiled perl code
      my $func = <<EOT;
          sub { 
              my($plist) = \@_;
              $logic;
          }
  EOT
  
      print "func=$func\n" if _INTERNAL_DEBUG;
  
      my $eval_func = eval $func;
  
      if(! $eval_func) {
          die "Syntax error in Boolean filter logic: $eval_func";
      }
  
      $self->{eval_func} = $eval_func;
  }
  
  ##################################################
  sub eval_logic {
  ##################################################
      my($self, $p) = @_;
  
      my @plist = ();
  
          # Eval the results of all filters referenced
          # in the code (although the order of keys is
          # not predictable, it is consistent :)
      for my $param (keys %{$self->{params}}) {
          # Pass a coderef as a param that will run the filter's ok method and
          # return a 1 or 0.  
          print "Passing filter $param\n" if _INTERNAL_DEBUG;
          push(@plist, sub {
              return $self->{params}->{$param}->ok(%$p) ? 1 : 0
          });
      }
  
          # Now pipe the parameters into the canned function,
          # have it evaluate the logic and return the final
          # decision
      print "Passing in (", join(', ', @plist), ")\n" if _INTERNAL_DEBUG;
      return $self->{eval_func}->(@plist);
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Filter::Boolean - Special filter to combine the results of others
  
  =head1 SYNOPSIS
  
      log4perl.logger = WARN, AppWarn, AppError
  
      log4perl.filter.Match1       = sub { /let this through/ }
      log4perl.filter.Match2       = sub { /and that, too/ }
      log4perl.filter.MyBoolean       = Log::Log4perl::Filter::Boolean
      log4perl.filter.MyBoolean.logic = Match1 || Match2
  
      log4perl.appender.Screen        = Log::Dispatch::Screen
      log4perl.appender.Screen.Filter = MyBoolean
      log4perl.appender.Screen.layout = Log::Log4perl::Layout::SimpleLayout
  
  =head1 DESCRIPTION
  
  Sometimes, it's useful to combine the output of various filters to
  arrive at a log/no log decision. While Log4j, Log4perl's mother ship,
  chose to implement this feature as a filter chain, similar to Linux' IP chains,
  Log4perl tries a different approach. 
  
  Typically, filter results will not need to be passed along in chains but 
  combined in a programmatic manner using boolean logic. "Log if
  this filter says 'yes' and that filter says 'no'" 
  is a fairly common requirement but hard to implement as a chain.
  
  C<Log::Log4perl::Filter::Boolean> is a special predefined custom filter
  for Log4perl which combines the results of other custom filters 
  in arbitrary ways, using boolean expressions:
  
      log4perl.logger = WARN, AppWarn, AppError
  
      log4perl.filter.Match1       = sub { /let this through/ }
      log4perl.filter.Match2       = sub { /and that, too/ }
      log4perl.filter.MyBoolean       = Log::Log4perl::Filter::Boolean
      log4perl.filter.MyBoolean.logic = Match1 || Match2
  
      log4perl.appender.Screen        = Log::Dispatch::Screen
      log4perl.appender.Screen.Filter = MyBoolean
      log4perl.appender.Screen.layout = Log::Log4perl::Layout::SimpleLayout
  
  C<Log::Log4perl::Filter::Boolean>'s boolean expressions allow for combining
  different appenders by name using AND (&& or &), OR (|| or |) and NOT (!) as
  logical expressions. Parentheses are used for grouping. Precedence follows
  standard Perl. Here's a bunch of examples:
  
      Match1 && !Match2            # Match1 and not Match2
      !(Match1 || Match2)          # Neither Match1 nor Match2
      (Match1 && Match2) || Match3 # Both Match1 and Match2 or Match3
  
  =head1 SEE ALSO
  
  L<Log::Log4perl::Filter>,
  L<Log::Log4perl::Filter::LevelMatch>,
  L<Log::Log4perl::Filter::LevelRange>,
  L<Log::Log4perl::Filter::MDC>,
  L<Log::Log4perl::Filter::StringRange>
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_FILTER_BOOLEAN

$fatpacked{"Log/Log4perl/Filter/LevelMatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_FILTER_LEVELMATCH';
  ##################################################
  package Log::Log4perl::Filter::LevelMatch;
  ##################################################
  
  use 5.006;
  
  use strict;
  use warnings;
  
  use Log::Log4perl::Level;
  use Log::Log4perl::Config;
  use Log::Log4perl::Util qw( params_check );
  
  use constant _INTERNAL_DEBUG => 0;
  
  use base qw(Log::Log4perl::Filter);
  
  ##################################################
  sub new {
  ##################################################
      my ($class, %options) = @_;
  
      my $self = { LevelToMatch  => '',
                   AcceptOnMatch => 1,
                   %options,
                 };
       
      params_check( $self,
                    [ qw( LevelToMatch ) ], 
                    [ qw( name AcceptOnMatch ) ] 
                  );
  
      $self->{AcceptOnMatch} = Log::Log4perl::Config::boolean_to_perlish(
                                                  $self->{AcceptOnMatch});
  
      bless $self, $class;
  
      return $self;
  }
  
  ##################################################
  sub ok {
  ##################################################
       my ($self, %p) = @_;
  
       if($self->{LevelToMatch} eq $p{log4p_level}) {
           print "Levels match\n" if _INTERNAL_DEBUG;
           return $self->{AcceptOnMatch};
       } else {
           print "Levels don't match\n" if _INTERNAL_DEBUG;
           return !$self->{AcceptOnMatch};
       }
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Filter::LevelMatch - Filter to match the log level exactly
  
  =head1 SYNOPSIS
  
      log4perl.filter.Match1               = Log::Log4perl::Filter::LevelMatch
      log4perl.filter.Match1.LevelToMatch  = ERROR
      log4perl.filter.Match1.AcceptOnMatch = true
  
  =head1 DESCRIPTION
  
  This Log4perl custom filter checks if the currently submitted message
  matches a predefined priority, as set in C<LevelToMatch>.
  The additional parameter C<AcceptOnMatch> defines if the filter
  is supposed to pass or block the message (C<true> or C<false>)
  on a match.
  
  =head1 SEE ALSO
  
  L<Log::Log4perl::Filter>,
  L<Log::Log4perl::Filter::Boolean>,
  L<Log::Log4perl::Filter::LevelRange>,
  L<Log::Log4perl::Filter::MDC>,
  L<Log::Log4perl::Filter::StringMatch>
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_FILTER_LEVELMATCH

$fatpacked{"Log/Log4perl/Filter/LevelRange.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_FILTER_LEVELRANGE';
  ##################################################
  package Log::Log4perl::Filter::LevelRange;
  ##################################################
  
  use 5.006;
  
  use strict;
  use warnings;
  
  use Log::Log4perl::Level;
  use Log::Log4perl::Config;
  use Log::Log4perl::Util qw( params_check );
  
  use constant _INTERNAL_DEBUG => 0;
  
  use base "Log::Log4perl::Filter";
  
  ##################################################
  sub new {
  ##################################################
      my ($class, %options) = @_;
  
      my $self = { LevelMin      => 'DEBUG',
                   LevelMax      => 'FATAL',
                   AcceptOnMatch => 1,
                   %options,
                 };
       
      params_check( $self,
                    [ qw( LevelMin LevelMax ) ], 
                    [ qw( name AcceptOnMatch ) ] 
                  );
  
      $self->{AcceptOnMatch} = Log::Log4perl::Config::boolean_to_perlish(
                                                  $self->{AcceptOnMatch});
  
      bless $self, $class;
  
      return $self;
  }
  
  ##################################################
  sub ok {
  ##################################################
       my ($self, %p) = @_;
  
       if(Log::Log4perl::Level::to_priority($self->{LevelMin}) <= 
          Log::Log4perl::Level::to_priority($p{log4p_level}) and
          Log::Log4perl::Level::to_priority($self->{LevelMax}) >= 
          Log::Log4perl::Level::to_priority($p{log4p_level})) {
           return $self->{AcceptOnMatch};
       } else {
           return ! $self->{AcceptOnMatch};
       }
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Filter::LevelRange - Filter for a range of log levels
  
  =head1 SYNOPSIS
  
      log4perl.filter.Match1               = Log::Log4perl::Filter::LevelRange
      log4perl.filter.Match1.LevelMin      = INFO
      log4perl.filter.Match1.LevelMax      = ERROR
      log4perl.filter.Match1.AcceptOnMatch = true
  
  =head1 DESCRIPTION
  
  This Log4perl custom filter checks if the current message
  has a priority matching a predefined range. 
  The C<LevelMin> and C<LevelMax> parameters define the levels
  (choose from C<DEBUG>, C<INFO>, C<WARN>, C<ERROR>, C<FATAL>) marking
  the window of allowed messages priorities.
  
  C<LevelMin> defaults to C<DEBUG>, and C<LevelMax> to C<FATAL>.
  
  The additional parameter C<AcceptOnMatch> defines if the filter
  is supposed to pass or block the message (C<true> or C<false>).
  
  =head1 SEE ALSO
  
  L<Log::Log4perl::Filter>,
  L<Log::Log4perl::Filter::Boolean>,
  L<Log::Log4perl::Filter::LevelMatch>,
  L<Log::Log4perl::Filter::MDC>,
  L<Log::Log4perl::Filter::StringMatch>
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_FILTER_LEVELRANGE

$fatpacked{"Log/Log4perl/Filter/MDC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_FILTER_MDC';
  package Log::Log4perl::Filter::MDC;
  use strict;
  use warnings;
  
  use Log::Log4perl::Util qw( params_check );
  
  use base "Log::Log4perl::Filter";
  
  sub new {
      my ( $class, %options ) = @_;
  
      my $self = {%options};
  
      params_check( $self, [qw( KeyToMatch RegexToMatch )] );
  
      $self->{RegexToMatch} = qr/$self->{RegexToMatch}/;
  
      bless $self, $class;
  
      return $self;
  }
  
  sub ok {
      my ( $self, %p ) = @_;
  
      my $context = Log::Log4perl::MDC->get_context;
  
      my $value = $context->{ $self->{KeyToMatch} };
      return 1
          if defined $value && $value =~ $self->{RegexToMatch};
  
      return 0;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Filter::MDC - Filter to match on values of a MDC key
  
  =head1 SYNOPSIS
  
      log4perl.filter.Match1               = Log::Log4perl::Filter::MDC
      log4perl.filter.Match1.KeyToMatch    = foo
      log4perl.filter.Match1.RegexToMatch  = bar
  
  =head1 DESCRIPTION
  
  This Log4perl filter checks if a predefined MDC key, as set in C<KeyToMatch>,
  of the currently submitted message matches a predefined regex, as set in
  C<RegexToMatch>.
  
  =head1 SEE ALSO
  
  L<Log::Log4perl::Filter>,
  L<Log::Log4perl::Filter::Boolean>,
  L<Log::Log4perl::Filter::LevelMatch>,
  L<Log::Log4perl::Filter::LevelRange>,
  L<Log::Log4perl::Filter::MDC>,
  L<Log::Log4perl::Filter::StringMatch>
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_FILTER_MDC

$fatpacked{"Log/Log4perl/Filter/StringMatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_FILTER_STRINGMATCH';
  ##################################################
  package Log::Log4perl::Filter::StringMatch;
  ##################################################
  
  use 5.006;
  
  use strict;
  use warnings;
  
  use Log::Log4perl::Config;
  use Log::Log4perl::Util qw( params_check );
  
  use constant _INTERNAL_DEBUG => 0;
  
  use base "Log::Log4perl::Filter";
  
  ##################################################
  sub new {
  ##################################################
       my ($class, %options) = @_;
  
       print join('-', %options) if _INTERNAL_DEBUG;
  
       my $self = { StringToMatch => undef,
                    AcceptOnMatch => 1,
                    %options,
                  };
       
       params_check( $self,
                    [ qw( StringToMatch ) ], 
                    [ qw( name AcceptOnMatch ) ] 
                  );
  
       $self->{AcceptOnMatch} = Log::Log4perl::Config::boolean_to_perlish(
                                                   $self->{AcceptOnMatch});
  
       $self->{StringToMatch} = qr($self->{StringToMatch});
  
       bless $self, $class;
  
       return $self;
  }
  
  ##################################################
  sub ok {
  ##################################################
       my ($self, %p) = @_;
  
       local($_) = join $
                       Log::Log4perl::JOIN_MSG_ARRAY_CHAR, @{$p{message}};
  
       if($_ =~ $self->{StringToMatch}) {
           print "Strings match\n" if _INTERNAL_DEBUG;
           return $self->{AcceptOnMatch};
       } else {
           print "Strings don't match ($_/$self->{StringToMatch})\n" 
               if _INTERNAL_DEBUG;
           return !$self->{AcceptOnMatch};
       }
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Filter::StringMatch - Filter on log message string
  
  =head1 SYNOPSIS
  
      log4perl.filter.Match1               = Log::Log4perl::Filter::StringMatch
      log4perl.filter.Match1.StringToMatch = blah blah
      log4perl.filter.Match1.AcceptOnMatch = true
  
  =head1 DESCRIPTION
  
  This Log4perl custom filter checks if the currently submitted message
  matches a predefined regular expression, as set in the C<StringToMatch>
  parameter. It uses common Perl 5 regexes.
  
  The additional parameter C<AcceptOnMatch> defines if the filter
  is supposed to pass or block the message on a match (C<true> or C<false>).
  
  =head1 SEE ALSO
  
  L<Log::Log4perl::Filter>,
  L<Log::Log4perl::Filter::Boolean>,
  L<Log::Log4perl::Filter::LevelMatch>,
  L<Log::Log4perl::Filter::LevelRange>,
  L<Log::Log4perl::Filter::MDC>
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_FILTER_STRINGMATCH

$fatpacked{"Log/Log4perl/InternalDebug.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_INTERNALDEBUG';
  package Log::Log4perl::InternalDebug;
  use warnings;
  use strict;
  
  use File::Temp qw(tempfile);
  use File::Spec;
  
  require Log::Log4perl::Resurrector;
  
  ###########################################
  sub enable {
  ###########################################
      unshift @INC, \&internal_debug_loader;
  }
  
  ##################################################
  sub internal_debug_fh {
  ##################################################
      my($file) = @_;
  
      local($/) = undef;
      open FILE, "<$file" or die "Cannot open $file";
      my $text = <FILE>;
      close FILE;
  
      my($tmp_fh, $tmpfile) = tempfile( UNLINK => 1 );
  
      $text =~ s/_INTERNAL_DEBUG(?!\s*=>)/1/g;
  
      print $tmp_fh $text;
      seek $tmp_fh, 0, 0;
  
      return $tmp_fh;
  }
  
  ###########################################
  sub internal_debug_loader {
  ###########################################
      my ($code, $module) = @_;
  
        # Skip non-Log4perl modules
      if($module !~ m#^Log/Log4perl#) {
          return undef;
      }
  
      my $path = $module;
      if(!-f $path) {
          $path = Log::Log4perl::Resurrector::pm_search( $module );
      }
  
      my $fh = internal_debug_fh($path);
  
      my $abs_path = File::Spec->rel2abs( $path );
      $INC{$module} = $abs_path;
  
      return $fh;
  }
  
  ###########################################
  sub resurrector_init {
  ###########################################
      unshift @INC, \&resurrector_loader;
  }
  
  ###########################################
  sub import {
  ###########################################
      # enable it on import
    enable();
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::InternalDebug - Dark Magic to enable _INTERNAL_DEBUG
  
  =head1 DESCRIPTION
  
  When called with
  
      perl -MLog::Log4perl::InternalDebug t/001Test.t
  
  scripts will run with _INTERNAL_DEBUG set to a true value and hence
  print internal Log4perl debugging information.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_INTERNALDEBUG

$fatpacked{"Log/Log4perl/JavaMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_JAVAMAP';
  package Log::Log4perl::JavaMap;
  
  use Carp;
  use strict;
  
  use constant _INTERNAL_DEBUG => 0;
  
  our %translate = (
      'org.apache.log4j.ConsoleAppender' => 
          'Log::Log4perl::JavaMap::ConsoleAppender',
      'org.apache.log4j.FileAppender'    => 
          'Log::Log4perl::JavaMap::FileAppender',
      'org.apache.log4j.RollingFileAppender'    => 
          'Log::Log4perl::JavaMap::RollingFileAppender',
      'org.apache.log4j.TestBuffer'    => 
          'Log::Log4perl::JavaMap::TestBuffer',
       'org.apache.log4j.jdbc.JDBCAppender'    => 
          'Log::Log4perl::JavaMap::JDBCAppender',
       'org.apache.log4j.SyslogAppender'    => 
          'Log::Log4perl::JavaMap::SyslogAppender',
       'org.apache.log4j.NTEventLogAppender'    => 
          'Log::Log4perl::JavaMap::NTEventLogAppender',
  );
  
  our %user_defined;
  
  sub get {
      my ($appender_name, $appender_data) = @_;
  
      print "Trying to map $appender_name\n" if _INTERNAL_DEBUG;
  
      $appender_data->{value} ||
              die "ERROR: you didn't tell me how to implement your appender " .
                  "'$appender_name'";
  
      my $perl_class = $translate{$appender_data->{value}} || 
                       $user_defined{$appender_data->{value}} ||
              die "ERROR:  I don't know how to make a '$appender_data->{value}' " .
                  "to implement your appender '$appender_name', that's not a " .
                  "supported class\n";
      eval {
          eval "require $perl_class";  #see 'perldoc -f require' for why two evals
          die $@ if $@;
      };
      $@ and die "ERROR: trying to set appender for $appender_name to " .
                 "$appender_data->{value} using $perl_class failed\n$@  \n";
  
      my $app = $perl_class->new($appender_name, $appender_data);
      return $app;
  }
  
  #an external api to the two hashes
  sub translate {
      my $java_class = shift;
  
      return $translate{$java_class} || 
              $user_defined{$java_class};
  }
  
  1;
  
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::JavaMap - maps java log4j appenders to Log::Dispatch classes
  
  =head1 SYNOPSIS
  
       ###############################
       log4j.appender.FileAppndr1        = org.apache.log4j.FileAppender
       log4j.appender.FileAppndr1.File   = /var/log/onetime.log
       log4j.appender.FileAppndr1.Append = false
  
       log4j.appender.FileAppndr1.layout = org.apache.log4j.PatternLayout
       log4j.appender.FileAppndr1.layout.ConversionPattern=%d %4r [%t] %-5p %c %x - %m%n
       ###############################
  
  
  =head1 DESCRIPTION
  
  If somebody wants to create an appender called C<org.apache.log4j.ConsoleAppender>,
  we want to translate it to Log::Dispatch::Screen, and then translate
  the log4j options into Log::Dispatch parameters..
  
  =head2 What's Implemented
  
  (Note that you can always use the Log::Dispatch::* module.  By 'implemented'
  I mean having a translation class that translates log4j options into
  the Log::Dispatch options so you can use log4j rather than log4perl 
  syntax in your config file.)
  
  Here's the list of appenders I see on the current (6/2002) log4j site.
  
  These are implemented
  
      ConsoleAppender     - Log::Dispatch::Screen
      FileAppender        - Log::Dispatch::File
      RollingFileAppender - Log::Dispatch::FileRotate (by Mark Pfeiffer)
      JDBCAppender        - Log::Log4perl::Appender::DBI
      SyslogAppender      - Log::Dispatch::Syslog
      NTEventLogAppender  - Log::Dispatch::Win32EventLog
  
  
  These should/will/might be implemented
      
      DailyRollingFileAppender - 
      SMTPAppender     - Log::Dispatch::Email::MailSender
      
  
  These might be implemented but they don't have corresponding classes
  in Log::Dispatch (yet):
  
      NullAppender
      TelnetAppender
  
  These might be simulated
  
      LF5Appender - use Tk?
      ExternallyRolledFileAppender - catch a HUP instead?
  
  These will probably not be implemented
  
      AsyncAppender
      JMSAppender
      SocketAppender - (ships a serialized LoggingEvent to the server side)
      SocketHubAppender
  
  =head1 ROLL YOUR OWN
  
  Let's say you've in a mixed Java/Perl environment and you've
  come up with some custom Java appender with behavior you want to 
  use in both worlds, C<myorg.customAppender>.  You write a
  Perl appender with the same behavior C<Myorg::CustomAppender>. You
  want to use one config file across both applications, so the
  config file will have to say 'myorg.customAppender'.  But
  the mapping from C<myorg.customAppender> to C<Myorg::CustomAppender>
  isn't in this JavaMap class, so what do you do?
  
  In  your Perl code, before you call Log::Log4perl::init(), do this:
  
      $Log::Log4perl::JavaMap::user_defined{'myorg.customAppender'} = 
          'Myorg::CustomAppender';
  
  and you can use 'myorg.customAppender' in your config file with
  impunity.
  
  =head1 SEE ALSO
  
  http://jakarta.apache.org/log4j/docs/
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_JAVAMAP

$fatpacked{"Log/Log4perl/JavaMap/ConsoleAppender.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_JAVAMAP_CONSOLEAPPENDER';
  package Log::Log4perl::JavaMap::ConsoleAppender;
  
  use Carp;
  use strict;
  use Log::Dispatch::Screen;
  
  
  sub new {
      my ($class, $appender_name, $data) = @_;
      my $stderr;
  
      if (my $t = $data->{Target}{value}) {
          if ($t eq 'System.out') {
              $stderr = 0;
          }elsif ($t eq 'System.err') {
              $stderr = 1;
          }else{
              die "ERROR: illegal value '$t' for $data->{value}.Target' in appender $appender_name\n";
          }
      }elsif (defined $data->{stderr}{value}){
          $stderr = $data->{stderr}{value};
      }else{
          $stderr = 0;
      }
  
      return Log::Log4perl::Appender->new("Log::Dispatch::Screen",
          name   => $appender_name,
          stderr => $stderr );
  }
  
  
  1;
  
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::JavaMap::ConsoleAppender - wraps Log::Dispatch::Screen
  
  =head1 SYNOPSIS
  
  
  =head1 DESCRIPTION
  
  Possible config properties for log4j ConsoleAppender are 
  
      Target (System.out, System.err, default is System.out)
  
  Possible config properties for Log::Dispatch::Screen are
  
      stderr (0 or 1)
  
  =head1 SEE ALSO
  
  http://jakarta.apache.org/log4j/docs/
  
  Log::Log4perl::Javamap
  
  Log::Dispatch::Screen
  
  =cut 
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_JAVAMAP_CONSOLEAPPENDER

$fatpacked{"Log/Log4perl/JavaMap/FileAppender.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_JAVAMAP_FILEAPPENDER';
  package Log::Log4perl::JavaMap::FileAppender;
  
  use Carp;
  use strict;
  use Log::Dispatch::File;
  
  
  sub new {
      my ($class, $appender_name, $data) = @_;
      my $stderr;
  
      my $filename =  $data->{File}{value} || 
                  $data->{filename}{value} || 
                  die "'File' not supplied for appender '$appender_name', required for a '$data->{value}'\n";
  
      my $mode;
      if (defined($data->{Append}{value})){
          if (lc $data->{Append}{value} eq 'true' || $data->{Append}{value} == 1){
              $mode = 'append';
          }elsif (lc $data->{Append}{value} eq 'false' || $data->{Append}{value} == 0) {
              $mode = 'write';
          }elsif($data->{Append} =~ /^(write|append)$/){
              $mode = $data->{Append}
          }else{
              die "'$data->{Append}' is not a legal value for Append for appender '$appender_name', '$data->{value}'\n";
          }
      }else{
          $mode = 'append';
      }
  
      my $autoflush;
      if (defined($data->{BufferedIO}{value})){
          if (lc $data->{BufferedIO}{value} eq 'true' || $data->{BufferedIO}{value}){
              $autoflush = 1;
          }elsif (lc $data->{BufferedIO}{value} eq 'true' || ! $data->{BufferedIO}{value}) {
              $autoflush = 0;
          }else{
              die "'$data->{BufferedIO}' is not a legal value for BufferedIO for appender '$appender_name', '$data->{value}'\n";
          }
      }else{
          $autoflush = 1;
      }
  
  
      return Log::Log4perl::Appender->new("Log::Dispatch::File",
          name      => $appender_name,
          filename  => $filename,
          mode      => $mode,
          autoflush => $autoflush,
      );
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::JavaMap::FileAppender - wraps Log::Dispatch::File
  
  =head1 SYNOPSIS
  
  
  =head1 DESCRIPTION
  
  Possible config properties for log4j ConsoleAppender are 
  
      File
      Append      "true|false|1|0" default=true
      BufferedIO  "true|false|1|0" default=false (i.e. autoflush is on)
  
  Possible config properties for Log::Dispatch::File are
  
      filename
      mode  "write|append"
      autoflush 0|1
  
  =head1 SEE ALSO
  
  http://jakarta.apache.org/log4j/docs/
  
  Log::Log4perl::Javamap
  
  Log::Dispatch::File
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_JAVAMAP_FILEAPPENDER

$fatpacked{"Log/Log4perl/JavaMap/JDBCAppender.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_JAVAMAP_JDBCAPPENDER';
  package Log::Log4perl::JavaMap::JDBCAppender;
  
  use Carp;
  use strict;
  
  sub new {
      my ($class, $appender_name, $data) = @_;
      my $stderr;
  
      my $pwd =  $data->{password}{value} || 
                  die "'password' not supplied for appender '$appender_name', required for a '$data->{value}'\n";
  
      my $username =  $data->{user}{value} || 
                  $data->{username}{value} || 
                  die "'user' not supplied for appender '$appender_name', required for a '$data->{value}'\n";
  
  
      my $sql =  $data->{sql}{value} || 
                  die "'sql' not supplied for appender '$appender_name', required for a '$data->{value}'\n";
  
  
      my $dsn;
  
      my $databaseURL = $data->{URL}{value};
      if ($databaseURL) {
          $databaseURL =~ m|^jdbc:(.+?):(.+?)://(.+?):(.+?);(.+)|;
          my $driverName = $1;
          my $databaseName = $2;
          my $hostname = $3;
          my $port = $4;
          my $params = $5;
          $dsn = "dbi:$driverName:database=$databaseName;host=$hostname;port=$port;$params";
      }elsif ($data->{datasource}{value}){
          $dsn = $data->{datasource}{value};
      }else{
          die "'databaseURL' not supplied for appender '$appender_name', required for a '$data->{value}'\n";
      }
  
  
      #this part isn't supported by log4j, it's my Log4perl
      #hack, but I think it's so useful I'm going to implement it
      #anyway
      my %bind_value_params;
      foreach my $p (keys %{$data->{params}}){
          $bind_value_params{$p} =  $data->{params}{$p}{value};
      }
  
      return Log::Log4perl::Appender->new("Log::Log4perl::Appender::DBI",
          datasource    => $dsn,
          username      => $username,
          password      => $pwd, 
          sql           => $sql,
          params        => \%bind_value_params,
              #warp_message also not a log4j thing, but see above
          warp_message=> $data->{warp_message}{value},  
      );
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::JavaMap::JDBCAppender - wraps Log::Log4perl::Appender::DBI
  
  =head1 SYNOPSIS
  
  
  =head1 DESCRIPTION
  
  Possible config properties for log4j JDBCAppender are 
  
      bufferSize 
      sql
      password
      user
      URL - attempting to translate a JDBC URL into DBI parameters,
          let me know if you find problems
  
  Possible config properties for Log::Log4perl::Appender::DBI are
  
      bufferSize 
      sql
      password
      username
      datasource
      
      usePreparedStmt 0|1
      
      (patternLayout).dontCollapseArrayRefs 0|1
      
      
  =head1 SEE ALSO
  
  http://jakarta.apache.org/log4j/docs/
  
  Log::Log4perl::Javamap
  
  Log::Log4perl::Appender::DBI
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_JAVAMAP_JDBCAPPENDER

$fatpacked{"Log/Log4perl/JavaMap/NTEventLogAppender.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_JAVAMAP_NTEVENTLOGAPPENDER';
  package Log::Log4perl::JavaMap::NTEventLogAppender;
  
  use Carp;
  use strict;
  
  
  
  sub new {
      my ($class, $appender_name, $data) = @_;
      my $stderr;
  
      my ($source,   #        
          );
  
      if (defined $data->{Source}{value}) {
          $source = $data->{Source}{value}
      }elsif (defined $data->{source}{value}){
          $source = $data->{source}{value};
      }else{
          $source = 'user';
      }
  
      
      return Log::Log4perl::Appender->new("Log::Dispatch::Win32EventLog",
          name      => $appender_name,
          source    => $source,
          min_level => 'debug',
      );
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::JavaMap::NTEventLogAppender - wraps Log::Dispatch::Win32EventLog
  
  
  =head1 DESCRIPTION
  
  This maps log4j's NTEventLogAppender to Log::Dispatch::Win32EventLog
  
  Possible config properties for log4j NTEventLogAppender are 
  
      Source
  
  Possible config properties for Log::Dispatch::Win32EventLog are
  
      source
  
  Boy, that was hard.
  
  =head1 SEE ALSO
  
  http://jakarta.apache.org/log4j/docs/
  
  Log::Log4perl::Javamap
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_JAVAMAP_NTEVENTLOGAPPENDER

$fatpacked{"Log/Log4perl/JavaMap/RollingFileAppender.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_JAVAMAP_ROLLINGFILEAPPENDER';
  package Log::Log4perl::JavaMap::RollingFileAppender;
  
  use Carp;
  use strict;
  use Log::Dispatch::FileRotate 1.10;
  
  
  sub new {
      my ($class, $appender_name, $data) = @_;
      my $stderr;
  
      my $filename =  $data->{File}{value} || 
                  $data->{filename}{value} || 
                  die "'File' not supplied for appender '$appender_name', required for a '$data->{value}'\n";
  
      my $mode;
      if (defined($data->{Append}{value})){
          if (lc $data->{Append}{value} eq 'true' || $data->{Append}{value} == 1){
              $mode = 'append';
          }elsif (lc $data->{Append}{value} eq 'false' || $data->{Append}{value} == 0) {
              $mode = 'write';
          }elsif($data->{Append} =~ /^(write|append)$/){
              $mode = $data->{Append}
          }else{
              die "'$data->{Append}' is not a legal value for Append for appender '$appender_name', '$data->{value}'\n";
          }
      }else{
          $mode = 'append';
      }
  
      my $autoflush;
      if (defined($data->{BufferedIO}{value})){
          if (lc $data->{BufferedIO}{value} eq 'true' || $data->{BufferedIO}{value}){
              $autoflush = 1;
          }elsif (lc $data->{BufferedIO}{value} eq 'true' || ! $data->{BufferedIO}{value}) {
              $autoflush = 0;
          }else{
              die "'$data->{BufferedIO}' is not a legal value for BufferedIO for appender '$appender_name', '$data->{value}'\n";
          }
      }else{
          $autoflush = 1;
      }
  
      my $max;
      if (defined $data->{MaxBackupIndex}{value}) {
          $max = $data->{MaxBackupIndex}{value};
      }elsif (defined $data->{max}{value}){
          $max = $data->{max}{value};
      }else{
          $max = 1;
  
      }
  
      my $size;
      if (defined $data->{MaxFileSize}{value}) {
          $size = $data->{MaxFileSize}{value}
      }elsif (defined $data->{size}{value}){
          $size = $data->{size}{value};
      }else{
          $size = 10_000_000;
      }
  
  
      return Log::Log4perl::Appender->new("Log::Dispatch::FileRotate",
          name      => $appender_name,
          filename  => $filename,
          mode      => $mode,
          autoflush => $autoflush,
          size      => $size,
          max       => $max,
      );
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::JavaMap::RollingFileAppender - wraps Log::Dispatch::FileRotate
  
  =head1 SYNOPSIS
  
  
  =head1 DESCRIPTION
  
  This maps log4j's RollingFileAppender to Log::Dispatch::FileRotate 
  by Mark Pfeiffer, <markpf@mlp-consulting.com.au>.
  
  Possible config properties for log4j ConsoleAppender are 
  
      File
      Append      "true|false|1|0" default=true
      BufferedIO  "true|false|1|0" default=false (i.e. autoflush is on)
      MaxFileSize default 10_000_000
      MaxBackupIndex default is 1
  
  Possible config properties for Log::Dispatch::FileRotate are
  
      filename
      mode  "write|append"
      autoflush 0|1
      size
      max
  
  =head1 SEE ALSO
  
  http://jakarta.apache.org/log4j/docs/
  
  Log::Log4perl::Javamap
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_JAVAMAP_ROLLINGFILEAPPENDER

$fatpacked{"Log/Log4perl/JavaMap/SyslogAppender.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_JAVAMAP_SYSLOGAPPENDER';
  package Log::Log4perl::JavaMap::SyslogAppender;
  
  use Carp;
  use strict;
  use Log::Dispatch::Syslog;
  
  
  sub new {
      my ($class, $appender_name, $data) = @_;
      my $stderr;
  
      my ($ident,    #defaults to $0
          $logopt,   #Valid options are 'cons', 'pid', 'ndelay', and 'nowait'.
          $facility, #Valid options are 'auth', 'authpriv',
                     #  'cron', 'daemon', 'kern', 'local0' through 'local7',
                     #   'mail, 'news', 'syslog', 'user', 'uucp'.  Defaults to
                     #   'user'
          $socket,   #Valid options are 'unix' or 'inet'. Defaults to 'inet'
          );
  
      if (defined $data->{Facility}{value}) {
          $facility = $data->{Facility}{value}
      }elsif (defined $data->{facility}{value}){
          $facility = $data->{facility}{value};
      }else{
          $facility = 'user';
      }
  
      if (defined $data->{Ident}{value}) {
          $ident = $data->{Ident}{value}
      }elsif (defined $data->{ident}{value}){
          $ident = $data->{ident}{value};
      }else{
          $ident = $0;
      }
      
      return Log::Log4perl::Appender->new("Log::Dispatch::Syslog",
          name      => $appender_name,
          facility  => $facility,
          ident     => $ident,
          min_level => 'debug',
      );
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::JavaMap::SysLogAppender - wraps Log::Dispatch::Syslog
  
  
  =head1 DESCRIPTION
  
  This maps log4j's SyslogAppender to Log::Dispatch::Syslog
  
  Possible config properties for log4j SyslogAppender are 
  
      SyslogHost (Log::Dispatch::Syslog only accepts 'localhost')
      Facility
  
  Possible config properties for Log::Dispatch::Syslog are
  
      min_level (debug)
      max_level
      ident    (defaults to $0)
      logopt
      facility 
      socket   (defaults to 'inet')
  
  =head1 SEE ALSO
  
  http://jakarta.apache.org/log4j/docs/
  
  Log::Log4perl::Javamap
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_JAVAMAP_SYSLOGAPPENDER

$fatpacked{"Log/Log4perl/JavaMap/TestBuffer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_JAVAMAP_TESTBUFFER';
  package Log::Log4perl::JavaMap::TestBuffer;
  
  use Carp;
  use strict;
  use Log::Log4perl::Appender::TestBuffer;
  
  use constant _INTERNAL_DEBUG => 0;
  
  sub new {
      my ($class, $appender_name, $data) = @_;
      my $stderr;
  
      return Log::Log4perl::Appender->new("Log::Log4perl::Appender::TestBuffer",
                                          name => $appender_name);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::JavaMap::TestBuffer - wraps Log::Log4perl::Appender::TestBuffer
  
  =head1 SYNOPSIS
  
  =head1 DESCRIPTION
  
  Just for testing the Java mapping.
  
  =head1 SEE ALSO
  
  http://jakarta.apache.org/log4j/docs/
  
  Log::Log4perl::Javamap
  
  Log::Dispatch::Screen
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_JAVAMAP_TESTBUFFER

$fatpacked{"Log/Log4perl/Layout.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_LAYOUT';
  package Log::Log4perl::Layout;
  
  
  use Log::Log4perl::Layout::SimpleLayout;
  use Log::Log4perl::Layout::PatternLayout;
  use Log::Log4perl::Layout::PatternLayout::Multiline;
  
  
  ####################################################
  sub appender_name {
  ####################################################
      my ($self, $arg) = @_;
  
      if ($arg) {
          die "setting appender_name unimplemented until it makes sense";
      }
      return $self->{appender_name};
  }
  
  
  ##################################################
  sub define {
  ##################################################
      ;  #subclasses may implement
  }
  
  
  ##################################################
  sub render {
  ##################################################
      die "subclass must implement render";
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Layout - Log4perl Layout Virtual Base Class
  
  =head1 SYNOPSIS
  
      # Not to be used directly, see below
  
  =head1 DESCRIPTION
  
  C<Log::Log4perl::Layout> is a virtual base class for the two currently 
  implemented layout types
  
      Log::Log4perl::Layout::SimpleLayout
      Log::Log4perl::Layout::PatternLayout
  
  Unless you're implementing a new layout class for Log4perl, you shouldn't
  use this class directly, but rather refer to
  L<Log::Log4perl::Layout::SimpleLayout> or 
  L<Log::Log4perl::Layout::PatternLayout>.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_LAYOUT

$fatpacked{"Log/Log4perl/Layout/NoopLayout.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_LAYOUT_NOOPLAYOUT';
  ##################################################
  package Log::Log4perl::Layout::NoopLayout;
  ##################################################
  
  
  ##################################################
  sub new {
  ##################################################
      my $class = shift;
      $class = ref ($class) || $class;
  
      my $self = {
          format      => undef,
          info_needed => {},
          stack       => [],
      };
  
      bless $self, $class;
  
      return $self;
  }
  
  ##################################################
  sub render {
  ##################################################
      #my($self, $message, $category, $priority, $caller_level) = @_;
      return $_[1];;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Layout::NoopLayout - Pass-thru Layout
  
  =head1 SYNOPSIS
  
    use Log::Log4perl::Layout::NoopLayout;
    my $layout = Log::Log4perl::Layout::NoopLayout->new();
  
  =head1 DESCRIPTION
  
  This is a no-op layout, returns the logging message unaltered,
  useful for implementing the DBI logger.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_LAYOUT_NOOPLAYOUT

$fatpacked{"Log/Log4perl/Layout/PatternLayout.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_LAYOUT_PATTERNLAYOUT';
  ##################################################
  package Log::Log4perl::Layout::PatternLayout;
  ##################################################
  
  use 5.006;
  use strict;
  use warnings;
  
  use constant _INTERNAL_DEBUG => 0;
  
  use Carp;
  use Log::Log4perl::Util;
  use Log::Log4perl::Level;
  use Log::Log4perl::DateFormat;
  use Log::Log4perl::NDC;
  use Log::Log4perl::MDC;
  use Log::Log4perl::Util::TimeTracker;
  use File::Spec;
  use File::Basename;
  
  our $TIME_HIRES_AVAILABLE_WARNED = 0;
  our $HOSTNAME;
  our %GLOBAL_USER_DEFINED_CSPECS = ();
  
  our $CSPECS = 'cCdFHIlLmMnpPrRtTxX%';
  
  BEGIN {
      # Check if we've got Sys::Hostname. If not, just punt.
      $HOSTNAME = "unknown.host";
      if(Log::Log4perl::Util::module_available("Sys::Hostname")) {
          require Sys::Hostname;
          $HOSTNAME = Sys::Hostname::hostname();
      }
  }
  
  use base qw(Log::Log4perl::Layout);
  
  no strict qw(refs);
  
  ##################################################
  sub new {
  ##################################################
      my $class = shift;
      $class = ref ($class) || $class;
  
      my $options       = ref $_[0] eq "HASH" ? shift : {};
      my $layout_string = @_ ? shift : '%m%n';
      
      my $self = {
          format                => undef,
          info_needed           => {},
          stack                 => [],
          CSPECS                => $CSPECS,
          dontCollapseArrayRefs => $options->{dontCollapseArrayRefs}{value},
          last_time             => undef,
          undef_column_value    => 
              (exists $options->{ undef_column_value } 
                  ? $options->{ undef_column_value } 
                  : "[undef]"),
      };
  
      $self->{timer} = Log::Log4perl::Util::TimeTracker->new(
          time_function => $options->{time_function}
      );
  
      if(exists $options->{ConversionPattern}->{value}) {
          $layout_string = $options->{ConversionPattern}->{value};
      }
  
      if(exists $options->{message_chomp_before_newline}) {
          $self->{message_chomp_before_newline} = 
            $options->{message_chomp_before_newline}->{value};
      } else {
          $self->{message_chomp_before_newline} = 1;
      }
  
      bless $self, $class;
  
      #add the global user-defined cspecs
      foreach my $f (keys %GLOBAL_USER_DEFINED_CSPECS){
              #add it to the list of letters
          $self->{CSPECS} .= $f;
               #for globals, the coderef is already evaled, 
          $self->{USER_DEFINED_CSPECS}{$f} = $GLOBAL_USER_DEFINED_CSPECS{$f};
      }
  
      #add the user-defined cspecs local to this appender
      foreach my $f (keys %{$options->{cspec}}){
          $self->add_layout_cspec($f, $options->{cspec}{$f}{value});
      }
  
      # non-portable line breaks
      $layout_string =~ s/\\n/\n/g;
      $layout_string =~ s/\\r/\r/g;
  
      $self->define($layout_string);
  
      return $self;
  }
  
  ##################################################
  sub define {
  ##################################################
      my($self, $format) = @_;
  
          # If the message contains a %m followed by a newline,
          # make a note of that so that we can cut a superfluous 
          # \n off the message later on
      if($self->{message_chomp_before_newline} and $format =~ /%m%n/) {
          $self->{message_chompable} = 1;
      } else {
          $self->{message_chompable} = 0;
      }
  
      # Parse the format
      $format =~ s/%(-?\d*(?:\.\d+)?) 
                         ([$self->{CSPECS}])
                         (?:{(.*?)})*/
                         rep($self, $1, $2, $3);
                        /gex;
  
      $self->{printformat} = $format;
  }
  
  ##################################################
  sub rep {
  ##################################################
      my($self, $num, $op, $curlies) = @_;
  
      return "%%" if $op eq "%";
  
      # If it's a %d{...} construct, initialize a simple date
      # format formatter, so that we can quickly render later on.
      # If it's just %d, assume %d{yyyy/MM/dd HH:mm:ss}
      if($op eq "d") {
          if(defined $curlies) {
              $curlies = Log::Log4perl::DateFormat->new($curlies);
          } else {
              $curlies = Log::Log4perl::DateFormat->new("yyyy/MM/dd HH:mm:ss");
          }
      } elsif($op eq "m") {
          $curlies = $self->curlies_csv_parse($curlies);
      }
  
      push @{$self->{stack}}, [$op, $curlies];
  
      $self->{info_needed}->{$op}++;
  
      return "%${num}s";
  }
  
  ###########################################
  sub curlies_csv_parse {
  ###########################################
      my($self, $curlies) = @_;
  
      my $data = {};
  
      if(defined $curlies and length $curlies) {
          $curlies =~ s/\s//g;
  
          for my $field (split /,/, $curlies) {
              my($key, $value) = split /=/, $field;
              $data->{$key} = $value;
          }
      }
  
      return $data;
  }
  
  ##################################################
  sub render {
  ##################################################
      my($self, $message, $category, $priority, $caller_level) = @_;
  
      $caller_level = 0 unless defined  $caller_level;
  
      my %info    = ();
  
      $info{m}    = $message;
          # See 'define'
      chomp $info{m} if $self->{message_chompable};
  
      my @results = ();
  
      my $caller_offset = Log::Log4perl::caller_depth_offset( $caller_level );
  
      if($self->{info_needed}->{L} or
         $self->{info_needed}->{F} or
         $self->{info_needed}->{C} or
         $self->{info_needed}->{l} or
         $self->{info_needed}->{M} or
         $self->{info_needed}->{T} or
         0
        ) {
  
          my ($package, $filename, $line, 
              $subroutine, $hasargs,
              $wantarray, $evaltext, $is_require, 
              $hints, $bitmask) = caller($caller_offset);
  
          # If caller() choked because of a whacko caller level,
          # correct undefined values to '[undef]' in order to prevent 
          # warning messages when interpolating later
          unless(defined $bitmask) {
              for($package, 
                  $filename, $line,
                  $subroutine, $hasargs,
                  $wantarray, $evaltext, $is_require,
                  $hints, $bitmask) {
                  $_ = '[undef]' unless defined $_;
              }
          }
  
          $info{L} = $line;
          $info{F} = $filename;
          $info{C} = $package;
  
          if($self->{info_needed}->{M} or
             $self->{info_needed}->{l} or
             0) {
              # To obtain the name of the subroutine which triggered the 
              # logger, we need to go one additional level up.
              my $levels_up = 1; 
              {
                  my @callinfo = caller($caller_offset+$levels_up);
  
                  if(_INTERNAL_DEBUG) {
                      callinfo_dump( $caller_offset, \@callinfo );
                  }
  
                  $subroutine = $callinfo[3];
                      # If we're inside an eval, go up one level further.
                  if(defined $subroutine and
                     $subroutine eq "(eval)") {
                      print "Inside an eval, one up\n" if _INTERNAL_DEBUG;
                      $levels_up++;
                      redo;
                  }
              }
              $subroutine = "main::" unless $subroutine;
              print "Subroutine is '$subroutine'\n" if _INTERNAL_DEBUG;
              $info{M} = $subroutine;
              $info{l} = "$subroutine $filename ($line)";
          }
      }
  
      $info{X} = "[No curlies defined]";
      $info{x} = Log::Log4perl::NDC->get() if $self->{info_needed}->{x};
      $info{c} = $category;
      $info{d} = 1; # Dummy value, corrected later
      $info{n} = "\n";
      $info{p} = $priority;
      $info{P} = $$;
      $info{H} = $HOSTNAME;
  
      my $current_time;
  
      if($self->{info_needed}->{r} or $self->{info_needed}->{R}) {
          if(!$TIME_HIRES_AVAILABLE_WARNED++ and 
             !$self->{timer}->hires_available()) {
              warn "Requested %r/%R pattern without installed Time::HiRes\n";
          }
          $current_time = [$self->{timer}->gettimeofday()];
      }
  
      if($self->{info_needed}->{r}) {
          $info{r} = $self->{timer}->milliseconds( $current_time );
      }
      if($self->{info_needed}->{R}) {
          $info{R} = $self->{timer}->delta_milliseconds( $current_time );
      }
  
          # Stack trace wanted?
      if($self->{info_needed}->{T}) {
          local $Carp::CarpLevel =
                $Carp::CarpLevel + $caller_offset;
          my $mess = Carp::longmess(); 
          chomp($mess);
          # $mess =~ s/(?:\A\s*at.*\n|^\s*Log::Log4perl.*\n|^\s*)//mg;
          $mess =~ s/(?:\A\s*at.*\n|^\s*)//mg;
          $mess =~ s/\n/, /g;
          $info{T} = $mess;
      }
  
          # As long as they're not implemented yet ..
      $info{t} = "N/A";
  
          # Iterate over all info fields on the stack
      for my $e (@{$self->{stack}}) {
          my($op, $curlies) = @$e;
  
          my $result;
  
          if(exists $self->{USER_DEFINED_CSPECS}->{$op}) {
              next unless $self->{info_needed}->{$op};
              $self->{curlies} = $curlies;
              $result = $self->{USER_DEFINED_CSPECS}->{$op}->($self, 
                                $message, $category, $priority, 
                                $caller_offset+1);
          } elsif(exists $info{$op}) {
              $result = $info{$op};
              if($curlies) {
                  $result = $self->curly_action($op, $curlies, $info{$op},
                                                $self->{printformat}, \@results);
              } else {
                  # just for %d
                  if($op eq 'd') {
                      $result = $info{$op}->format($self->{timer}->gettimeofday());
                  }
              }
          } else {
              warn "Format %'$op' not implemented (yet)";
              $result = "FORMAT-ERROR";
          }
  
          $result = $self->{undef_column_value} unless defined $result;
          push @results, $result;
      }
  
        # dbi appender needs that
      if( scalar @results == 1 and
          !defined $results[0] ) {
          return undef;
      }
  
      return (sprintf $self->{printformat}, @results);
  }
  
  ##################################################
  sub curly_action {
  ##################################################
      my($self, $ops, $curlies, $data, $printformat, $results) = @_;
  
      if($ops eq "c") {
          $data = shrink_category($data, $curlies);
      } elsif($ops eq "C") {
          $data = shrink_category($data, $curlies);
      } elsif($ops eq "X") {
          $data = Log::Log4perl::MDC->get($curlies);
      } elsif($ops eq "d") {
          $data = $curlies->format( $self->{timer}->gettimeofday() );
      } elsif($ops eq "M") {
          $data = shrink_category($data, $curlies);
      } elsif($ops eq "m") {
          if(exists $curlies->{chomp}) {
              chomp $data;
          }
          if(exists $curlies->{indent}) {
              if(defined $curlies->{indent}) {
                    # fixed indent
                  $data =~ s/\n/ "\n" . (" " x $curlies->{indent})/ge;
              } else {
                    # indent on the lead-in
                  no warnings; # trailing array elements are undefined
                  my $indent = length sprintf $printformat, @$results;
                  $data =~ s/\n/ "\n" . (" " x $indent)/ge;
              }
          }
      } elsif($ops eq "F") {
          my @parts = File::Spec->splitdir($data);
              # Limit it to max curlies entries
          if(@parts > $curlies) {
              splice @parts, 0, @parts - $curlies;
          }
          $data = File::Spec->catfile(@parts);
      } elsif($ops eq "p") {
          $data = substr $data, 0, $curlies;
      }
  
      return $data;
  }
  
  ##################################################
  sub shrink_category {
  ##################################################
      my($category, $len) = @_;
  
      my @components = split /\.|::/, $category;
  
      if(@components > $len) {
          splice @components, 0, @components - $len;
          $category = join '.', @components;
      } 
  
      return $category;
  }
  
  ##################################################
  sub add_global_cspec {
  ##################################################
  # This is a Class method.
  # Accepts a coderef or text
  ##################################################
  
      unless($Log::Log4perl::ALLOW_CODE_IN_CONFIG_FILE) {
          die "\$Log::Log4perl::ALLOW_CODE_IN_CONFIG_FILE setting " .
              "prohibits user defined cspecs";
      }
  
      my ($letter, $perlcode) = @_;
  
      croak "Illegal value '$letter' in call to add_global_cspec()"
          unless ($letter =~ /^[a-zA-Z]$/);
  
      croak "Missing argument for perlcode for 'cspec.$letter' ".
            "in call to add_global_cspec()"
          unless $perlcode;
  
      croak "Please don't redefine built-in cspecs [$CSPECS]\n".
            "like you do for \"cspec.$letter\"\n "
          if ($CSPECS =~/$letter/);
  
      if (ref $perlcode eq 'CODE') {
          $GLOBAL_USER_DEFINED_CSPECS{$letter} = $perlcode;
  
      }elsif (! ref $perlcode){
          
          $GLOBAL_USER_DEFINED_CSPECS{$letter} = 
              Log::Log4perl::Config::compile_if_perl($perlcode);
  
          if ($@) {
              die qq{Compilation failed for your perl code for }.
                  qq{"log4j.PatternLayout.cspec.$letter":\n}.
                  qq{This is the error message: \t$@\n}.
                  qq{This is the code that failed: \n$perlcode\n};
          }
  
          croak "eval'ing your perlcode for 'log4j.PatternLayout.cspec.$letter' ".
                "doesn't return a coderef \n".
                "Here is the perl code: \n\t$perlcode\n "
              unless (ref $GLOBAL_USER_DEFINED_CSPECS{$letter} eq 'CODE');
  
      }else{
          croak "I don't know how to handle perlcode=$perlcode ".
                "for 'cspec.$letter' in call to add_global_cspec()";
      }
  }
  
  ##################################################
  sub add_layout_cspec {
  ##################################################
  # object method
  # adds a cspec just for this layout
  ##################################################
      my ($self, $letter, $perlcode) = @_;
  
      unless($Log::Log4perl::ALLOW_CODE_IN_CONFIG_FILE) {
          die "\$Log::Log4perl::ALLOW_CODE_IN_CONFIG_FILE setting " .
              "prohibits user defined cspecs";
      }
  
      croak "Illegal value '$letter' in call to add_layout_cspec()"
          unless ($letter =~ /^[a-zA-Z]$/);
  
      croak "Missing argument for perlcode for 'cspec.$letter' ".
            "in call to add_layout_cspec()"
          unless $perlcode;
  
      croak "Please don't redefine built-in cspecs [$CSPECS] \n".
            "like you do for 'cspec.$letter'"
          if ($CSPECS =~/$letter/);
  
      if (ref $perlcode eq 'CODE') {
  
          $self->{USER_DEFINED_CSPECS}{$letter} = $perlcode;
  
      }elsif (! ref $perlcode){
          
          $self->{USER_DEFINED_CSPECS}{$letter} =
              Log::Log4perl::Config::compile_if_perl($perlcode);
  
          if ($@) {
              die qq{Compilation failed for your perl code for }.
                  qq{"cspec.$letter":\n}.
                  qq{This is the error message: \t$@\n}.
                  qq{This is the code that failed: \n$perlcode\n};
          }
          croak "eval'ing your perlcode for 'cspec.$letter' ".
                "doesn't return a coderef \n".
                "Here is the perl code: \n\t$perlcode\n "
              unless (ref $self->{USER_DEFINED_CSPECS}{$letter} eq 'CODE');
  
  
      }else{
          croak "I don't know how to handle perlcode=$perlcode ".
                "for 'cspec.$letter' in call to add_layout_cspec()";
      }
  
      $self->{CSPECS} .= $letter;
  }
  
  ###########################################
  sub callinfo_dump {
  ###########################################
      my($level, $info) = @_;
  
      my @called_by = caller(0);
  
      # Just for internal debugging
      $called_by[1] = basename $called_by[1];
      print "caller($level) at $called_by[1]-$called_by[2] returned ";
  
      my @by_idx;
  
      # $info->[1] = basename $info->[1] if defined $info->[1];
  
      my $i = 0;
      for my $field (qw(package filename line subroutine hasargs
                        wantarray evaltext is_require hints bitmask)) {
          $by_idx[$i] = $field;
          $i++;
      }
  
      $i = 0;
      for my $value (@$info) {
          my $field = $by_idx[ $i ];
          print "$field=", 
                (defined $info->[$i] ? $info->[$i] : "[undef]"),
                " ";
          $i++;
      }
  
      print "\n";
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Layout::PatternLayout - Pattern Layout
  
  =head1 SYNOPSIS
  
    use Log::Log4perl::Layout::PatternLayout;
  
    my $layout = Log::Log4perl::Layout::PatternLayout->new(
                                                     "%d (%F:%L)> %m");
  
  =head1 DESCRIPTION
  
  Creates a pattern layout according to
  http://jakarta.apache.org/log4j/docs/api/org/apache/log4j/PatternLayout.html
  and a couple of Log::Log4perl-specific extensions.
  
  The C<new()> method creates a new PatternLayout, specifying its log
  format. The format
  string can contain a number of placeholders which will be
  replaced by the logging engine when it's time to log the message:
  
      %c Category of the logging event.
      %C Fully qualified package (or class) name of the caller
      %d Current date in yyyy/MM/dd hh:mm:ss format
      %d{...} Current date in customized format (see below)
      %F File where the logging event occurred
      %H Hostname (if Sys::Hostname is available)
      %l Fully qualified name of the calling method followed by the
         callers source the file name and line number between 
         parentheses.
      %L Line number within the file where the log statement was issued
      %m The message to be logged
      %m{chomp} Log message, stripped off a trailing newline
      %m{indent} Log message, multi-lines indented so they line up with first
      %m{indent=n} Log message, multi-lines indented by n spaces
      %M Method or function where the logging request was issued
      %n Newline (OS-independent)
      %p Priority/level of the logging event (%p{1} shows the first letter)
      %P pid of the current process
      %r Number of milliseconds elapsed from program start to logging 
         event
      %R Number of milliseconds elapsed from last logging event to
         current logging event 
      %T A stack trace of functions called
      %x The topmost NDC (see below)
      %X{key} The entry 'key' of the MDC (see below)
      %% A literal percent (%) sign
  
  NDC and MDC are explained in L<Log::Log4perl/"Nested Diagnostic Context (NDC)">
  and L<Log::Log4perl/"Mapped Diagnostic Context (MDC)">.
  
  The granularity of time values is milliseconds if Time::HiRes is available.
  If not, only full seconds are used.
  
  Every once in a while, someone uses the "%m%n" pattern and
  additionally provides an extra newline in the log message (e.g.
  C<-E<gt>log("message\n")>. To avoid printing an extra newline in
  this case, the PatternLayout will chomp the message, printing only
  one newline. This option can be controlled by PatternLayout's
  C<message_chomp_before_newline> option. See L<Advanced options>
  for details.
  
  =head2 Quantify placeholders
  
  All placeholders can be extended with formatting instructions,
  just like in I<printf>:
  
      %20c   Reserve 20 chars for the category, right-justify and fill
             with blanks if it is shorter
      %-20c  Same as %20c, but left-justify and fill the right side 
             with blanks
      %09r   Zero-pad the number of milliseconds to 9 digits
      %.8c   Specify the maximum field with and have the formatter
             cut off the rest of the value
  
  =head2 Fine-tuning with curlies
  
  Some placeholders have special functions defined if you add curlies 
  with content after them:
  
      %c{1}  Just show the right-most category compontent, useful in large
             class hierarchies (Foo::Baz::Bar -> Bar)
      %c{2}  Just show the two right most category components
             (Foo::Baz::Bar -> Baz::Bar)
  
      %F     Display source file including full path
      %F{1}  Just display filename
      %F{2}  Display filename and last path component (dir/test.log)
      %F{3}  Display filename and last two path components (d1/d2/test.log)
  
      %M     Display fully qualified method/function name
      %M{1}  Just display method name (foo)
      %M{2}  Display method name and last path component (main::foo)
  
  In this way, you're able to shrink the displayed category or
  limit file/path components to save space in your logs.
  
  =head2 Fine-tune the date
  
  If you're not happy with the default %d format for the date which 
  looks like
  
      yyyy/MM/DD HH:mm:ss
  
  (which is slightly different from Log4j which uses C<yyyy-MM-dd HH:mm:ss,SSS>)
  you're free to fine-tune it in order to display only certain characteristics
  of a date, according to the SimpleDateFormat in the Java World
  (http://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html):
  
      %d{HH:mm}     "23:45" -- Just display hours and minutes
      %d{yy, EEEE}  "02, Monday" -- Just display two-digit year 
                                    and spelled-out weekday
      %d{e}         "1473741760" -- Epoch seconds
      %d{h a}       "12 PM"      -- Hour and am/pm marker
      ... and many more
  
  For an exhaustive list of all supported date features, look at
  L<Log::Log4perl::DateFormat>.
  
  =head2 Custom cspecs
  
  First of all, "cspecs" is short for "conversion specifiers", which is 
  the log4j and the printf(3) term for what Mike is calling "placeholders."
  I suggested "cspecs" for this part of the api before I saw that Mike was 
  using "placeholders" consistently in the log4perl documentation.  Ah, the
  joys of collaboration ;=) --kg
  
  If the existing corpus of placeholders/cspecs isn't good enough for you,
  you can easily roll your own:
  
      #'U' a global user-defined cspec     
      log4j.PatternLayout.cspec.U = sub { return "UID: $< "}
      
      #'K' cspec local to appndr1                 (pid in hex)
      log4j.appender.appndr1.layout.cspec.K = sub { return sprintf "%1x", $$}
      
      #and now you can use them
      log4j.appender.appndr1.layout.ConversionPattern = %K %U %m%n
  
  The benefit of this approach is that you can define and use the cspecs 
  right next to each other in the config file.
  
  If you're an API kind of person, there's also this call:
  
      Log::Log4perl::Layout::PatternLayout::
                      add_global_cspec('Z', sub {'zzzzzzzz'}); #snooze?
  
  When the log message is being put together, your anonymous sub 
  will be called with these arguments:
  
      ($layout, $message, $category, $priority, $caller_level);
      
      layout: the PatternLayout object that called it
      message: the logging message (%m)
      category: e.g. groceries.beverages.adult.beer.schlitz
      priority: e.g. DEBUG|WARN|INFO|ERROR|FATAL
      caller_level: how many levels back up the call stack you have 
          to go to find the caller
  
  Please note that the subroutines you're defining in this way are going
  to be run in the C<main> namespace, so be sure to fully qualify functions
  and variables if they're located in different packages. I<Also make sure
  these subroutines aren't using Log4perl, otherwise Log4perl will enter 
  an infinite recursion.>
  
  With Log4perl 1.20 and better, cspecs can be written with parameters in
  curly braces. Writing something like
  
      log4perl.appender.Screen.layout.ConversionPattern = %U{user} %U{id} %m%n
  
  will cause the cspec function defined for %U to be called twice, once
  with the parameter 'user' and then again with the parameter 'id', 
  and the placeholders in the cspec string will be replaced with
  the respective return values.
  
  The parameter value is available in the 'curlies' entry of the first
  parameter passed to the subroutine (the layout object reference). 
  So, if you wanted to map %U{xxx} to entries in the POE session hash, 
  you'd write something like:
  
     log4perl.PatternLayout.cspec.U = sub { \
       POE::Kernel->get_active_session->get_heap()->{ $_[0]->{curlies} } }
                                            
  B<SECURITY NOTE>
    
  This feature means arbitrary perl code can be embedded in the config file. 
  In the rare case where the people who have access to your config file are
  different from the people who write your code and shouldn't have execute
  rights, you might want to set
  
      $Log::Log4perl::Config->allow_code(0);
  
  before you call init().  Alternatively you can supply a restricted set of
  Perl opcodes that can be embedded in the config file as described in
  L<Log::Log4perl/"Restricting what Opcodes can be in a Perl Hook">.
    
  =head2 Advanced Options
  
  The constructor of the C<Log::Log4perl::Layout::PatternLayout> class
  takes an optional hash reference as a first argument to specify
  additional options in order to (ab)use it in creative ways:
  
    my $layout = Log::Log4perl::Layout::PatternLayout->new(
      { time_function       => \&my_time_func,
      }, 
      "%d (%F:%L)> %m");
  
  Here's a list of parameters:
  
  =over 4
  
  =item time_function
  
  Takes a reference to a function returning the time for the time/date
  fields, either in seconds
  since the epoch or as an array, carrying seconds and 
  microseconds, just like C<Time::HiRes::gettimeofday> does.
  
  =item message_chomp_before_newline
  
  If a layout contains the pattern "%m%n" and the message ends with a newline,
  PatternLayout will chomp the message, to prevent printing two newlines. 
  If this is not desired, and you want two newlines in this case, 
  the feature can be turned off by setting the
  C<message_chomp_before_newline> option to a false value:
  
    my $layout = Log::Log4perl::Layout::PatternLayout->new(
        { message_chomp_before_newline => 0
        }, 
        "%d (%F:%L)> %m%n");
  
  In a Log4perl configuration file, the feature can be turned off like this:
  
      log4perl.appender.App.layout   = PatternLayout
      log4perl.appender.App.layout.ConversionPattern = %d %m%n
        # Yes, I want two newlines
      log4perl.appender.App.layout.message_chomp_before_newline = 0
  
  =back
  
  =head2 Getting rid of newlines
  
  If your code contains logging statements like 
  
        # WRONG, don't do that!
      $logger->debug("Some message\n");
  
  then it's usually best to strip the newlines from these calls. As explained
  in L<Log::Log4perl/Logging newlines>, logging statements should never contain
  newlines, but rely on appender layouts to add necessary newlines instead.
  
  If changing the code is not an option, use the special PatternLayout 
  placeholder %m{chomp} to refer to the message excluding a trailing 
  newline:
  
      log4perl.appender.App.layout.ConversionPattern = %d %m{chomp}%n
  
  This will add a single newline to every message, regardless if it
  complies with the Log4perl newline guidelines or not (thanks to 
  Tim Bunce for this idea).
  
  =head2 Multi Lines
  
  If a log message consists of several lines, like
  
      $logger->debug("line1\nline2\nline3");
  
  then by default, they get logged like this (assuming the the layout is
  set to "%d>%m%n"):
  
        # layout %d>%m%n
      2014/07/27 12:46:16>line1
      line2
      line3
  
  If you'd rather have the messages aligned like
  
        # layout %d>%m{indent}%n
      2014/07/27 12:46:16>line1
                          line2
                          line3
  
  then use the C<%m{indent}> option for the %m specifier. This option
  can also take a fixed value, as in C<%m{indent=2}>, which indents
  subsequent lines by two spaces:
  
        # layout %d>%m{indent=2}%n
      2014/07/27 12:46:16>line1
        line2
        line3
  
  Note that you can still add the C<chomp> option for the C<%m> specifier
  in this case (see above what it does), simply add it after a 
  separating comma, like in C<%m{indent=2,chomp}>.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_LAYOUT_PATTERNLAYOUT

$fatpacked{"Log/Log4perl/Layout/PatternLayout/Multiline.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_LAYOUT_PATTERNLAYOUT_MULTILINE';
  #!/usr/bin/perl
  
  package Log::Log4perl::Layout::PatternLayout::Multiline;
  use base qw(Log::Log4perl::Layout::PatternLayout);
  
  ###########################################
  sub render {
  ###########################################
      my($self, $message, $category, $priority, $caller_level) = @_;
  
      my @messages = split /\r?\n/, $message;
  
      $caller_level = 0 unless defined $caller_level;
  
      my $result = '';
  
      for my $msg ( @messages ) {
          $result .= $self->SUPER::render(
              $msg, $category, $priority, $caller_level + 1
          );
      }
      return $result;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Layout::PatternLayout::Multiline
  
  =head1 SYNOPSIS
  
      use Log::Log4perl::Layout::PatternLayout::Multiline;
  
      my $layout = Log::Log4perl::Layout::PatternLayout::Multiline->new(
          "%d (%F:%L)> %m");
  
  =head1 DESCRIPTION
  
  C<Log::Log4perl::Layout::PatternLayout::Multiline> is a subclass
  of Log4perl's PatternLayout and is helpful if you send multiline
  messages to your appenders which appear as
  
      2007/04/04 23:59:01 This is
      a message with
      multiple lines
  
  and you want them to appear as 
  
      2007/04/04 23:59:01 This is
      2007/04/04 23:59:01 a message with
      2007/04/04 23:59:01 multiple lines
  
  instead. This layout class simply splits up the incoming message into
  several chunks split by line breaks and renders them with PatternLayout
  just as if it had arrived in separate chunks in the first place.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_LAYOUT_PATTERNLAYOUT_MULTILINE

$fatpacked{"Log/Log4perl/Layout/SimpleLayout.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_LAYOUT_SIMPLELAYOUT';
  ##################################################
  package Log::Log4perl::Layout::SimpleLayout;
  ##################################################
  # as documented in
  # http://jakarta.apache.org/log4j/docs/api/org/apache/log4j/SimpleLayout.html
  ##################################################
  
  use 5.006;
  use strict;
  use warnings;
  use Log::Log4perl::Level;
  
  no strict qw(refs);
  use base qw(Log::Log4perl::Layout);
  
  ##################################################
  sub new {
  ##################################################
      my $class = shift;
      $class = ref ($class) || $class;
  
      my $self = {
          format      => undef,
          info_needed => {},
          stack       => [],
      };
  
      bless $self, $class;
  
      return $self;
  }
  
  ##################################################
  sub render {
  ##################################################
      my($self, $message, $category, $priority, $caller_level) = @_;
  
      return "$priority - $message\n";
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Layout::SimpleLayout - Simple Layout
  
  =head1 SYNOPSIS
  
    use Log::Log4perl::Layout::SimpleLayout;
    my $layout = Log::Log4perl::Layout::SimpleLayout->new();
  
  =head1 DESCRIPTION
  
  This class implements the C<log4j> simple layout format -- it basically 
  just prints the message priority and the message, that's all.
  Check 
  http://jakarta.apache.org/log4j/docs/api/org/apache/log4j/SimpleLayout.html
  for details.
  
  =head1 SEE ALSO
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_LAYOUT_SIMPLELAYOUT

$fatpacked{"Log/Log4perl/Level.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_LEVEL';
  ###############r###################################
  package Log::Log4perl::Level;
  ##################################################
  
  use 5.006;
  use strict;
  use warnings;
  use Carp;
  
  # log4j, for whatever reason, puts 0 as all and MAXINT as OFF.
  # this seems less optimal, as more logging would imply a higher
  # level. But oh well. Probably some brokenness that has persisted. :)
  use constant ALL_INT   => 0;
  use constant TRACE_INT =>  5000;
  use constant DEBUG_INT => 10000;
  use constant INFO_INT  => 20000;
  use constant WARN_INT  => 30000;
  use constant ERROR_INT => 40000;
  use constant FATAL_INT => 50000;
  use constant OFF_INT   => (2 ** 31) - 1;
  
  no strict qw(refs);
  use vars qw(%PRIORITY %LEVELS %SYSLOG %L4P_TO_LD);
  
  %PRIORITY = (); # unless (%PRIORITY);
  %LEVELS = () unless (%LEVELS);
  %SYSLOG = () unless (%SYSLOG);
  %L4P_TO_LD = () unless (%L4P_TO_LD);
  
  sub add_priority {
    my ($prio, $intval, $syslog, $log_dispatch_level) = @_;
    $prio = uc($prio); # just in case;
  
    $PRIORITY{$prio}    = $intval;
    $LEVELS{$intval}    = $prio;
  
    # Set up the mapping between Log4perl integer levels and 
    # Log::Dispatch levels
    # Note: Log::Dispatch uses the following levels:
    # 0 debug
    # 1 info
    # 2 notice
    # 3 warning
    # 4 error
    # 5 critical
    # 6 alert
    # 7 emergency
  
        # The equivalent Log::Dispatch level is optional, set it to 
        # the highest value (7=emerg) if it's not provided.
    $log_dispatch_level = 7 unless defined $log_dispatch_level;
    
    $L4P_TO_LD{$prio}  = $log_dispatch_level;
  
    $SYSLOG{$prio}      = $syslog if defined($syslog);
  }
  
  # create the basic priorities
  add_priority("OFF",   OFF_INT,   -1, 7);
  add_priority("FATAL", FATAL_INT,  0, 7);
  add_priority("ERROR", ERROR_INT,  3, 4);
  add_priority("WARN",  WARN_INT,   4, 3);
  add_priority("INFO",  INFO_INT,   6, 1);
  add_priority("DEBUG", DEBUG_INT,  7, 0);
  add_priority("TRACE", TRACE_INT,  8, 0);
  add_priority("ALL",   ALL_INT,    8, 0);
  
  # we often sort numerically, so a helper func for readability
  sub numerically {$a <=> $b}
  
  ###########################################
  sub import {
  ###########################################
      my($class, $namespace) = @_;
             
      if(defined $namespace) {
          # Export $OFF, $FATAL, $ERROR etc. to
          # the given namespace
          $namespace .= "::" unless $namespace =~ /::$/;
      } else {
          # Export $OFF, $FATAL, $ERROR etc. to
          # the caller's namespace
          $namespace = caller(0) . "::";
      }
  
      for my $key (keys %PRIORITY) {
          my $name  = "$namespace$key";
          my $value = $PRIORITY{$key};
          *{"$name"} = \$value;
  	my $nameint = "$namespace${key}_INT";
  	my $func = uc($key) . "_INT";
  	*{"$nameint"} = \&$func;
      }
  }
  
  ##################################################
  sub new { 
  ##################################################
      # We don't need any of this class nonsense
      # in Perl, because we won't allow subclassing
      # from this. We're optimizing for raw speed.
  }
  
  ##################################################
  sub to_priority {
  # changes a level name string to a priority numeric
  ##################################################
      my($string) = @_;
  
      if(exists $PRIORITY{$string}) {
          return $PRIORITY{$string};
      }else{
          croak "level '$string' is not a valid error level (".join ('|', keys %PRIORITY),')';
      }
  }
  
  ##################################################
  sub to_level {
  # changes a priority numeric constant to a level name string 
  ##################################################
      my ($priority) = @_;
      if (exists $LEVELS{$priority}) {
          return $LEVELS{$priority}
      }else {
        croak("priority '$priority' is not a valid error level number (",
  	  join("|", sort numerically keys %LEVELS), "
            )");
      }
  
  }
  
  ##################################################
  sub to_LogDispatch_string {
  # translates into strings that Log::Dispatch recognizes
  ##################################################
      my($priority) = @_;
  
      confess "do what? no priority?" unless defined $priority;
  
      my $string;
  
      if(exists $LEVELS{$priority}) {
          $string = $LEVELS{$priority};
      }
  
          # Log::Dispatch idiosyncrasies
      if($priority == $PRIORITY{WARN}) {
          $string = "WARNING";
      }
           
      if($priority == $PRIORITY{FATAL}) {
          $string = "EMERGENCY";
      }
           
      return $string;
  }
  
  ###################################################
  sub is_valid {
  ###################################################
      my $q = shift;
  
      if ($q =~ /[A-Z]/) {
          return exists $PRIORITY{$q};
      }else{
          return $LEVELS{$q};
      }
      
  }
  
  sub get_higher_level {
      my ($old_priority, $delta) = @_;
  
      $delta ||= 1;
  
      my $new_priority = 0;
  
      foreach (1..$delta){
          #so the list is TRACE, DEBUG, INFO, WARN, ERROR, FATAL
        # but remember, the numbers go in reverse order!
          foreach my $p (sort numerically keys %LEVELS){
              if ($p > $old_priority) {
                  $new_priority = $p;
                  last;
              }
          }
          $old_priority = $new_priority;
      }
      return $new_priority;
  }
  
  sub get_lower_level {
      my ($old_priority, $delta) = @_;
  
      $delta ||= 1;
  
      my $new_priority = 0;
  
      foreach (1..$delta){
          #so the list is FATAL, ERROR, WARN, INFO, DEBUG, TRACE
        # but remember, the numbers go in reverse order!
          foreach my $p (reverse sort numerically keys %LEVELS){
              if ($p < $old_priority) {
                  $new_priority = $p;
                  last;
              }
          }
          $old_priority = $new_priority;
      }
      return $new_priority;
  }
  
  sub isGreaterOrEqual {
    my $lval = shift;
    my $rval = shift;
    
    # in theory, we should check if the above really ARE valid levels.
    # but we just use numeric comparison, since they aren't really classes.
  
    # oh, yeah, and 'cuz level ints go from 0 .. N with 0 being highest,
    # these are reversed.
    return $lval <= $rval;
  }
  
  ######################################################################
  # 
  # since the integer representation of levels is reversed from what
  # we normally want, we don't want to use < and >... instead, we
  # want to use this comparison function
  
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Level - Predefined log levels
  
  =head1 SYNOPSIS
  
    use Log::Log4perl::Level;
    print $ERROR, "\n";
  
    # -- or --
  
    use Log::Log4perl qw(:levels);
    print $ERROR, "\n";
  
  =head1 DESCRIPTION
  
  C<Log::Log4perl::Level> simply exports a predefined set of I<Log4perl> log
  levels into the caller's name space. It is used internally by 
  C<Log::Log4perl>. The following scalars are defined:
  
      $OFF
      $FATAL
      $ERROR
      $WARN
      $INFO
      $DEBUG
      $TRACE
      $ALL
  
  C<Log::Log4perl> also exports these constants into the caller's namespace
  if you pull it in providing the C<:levels> tag:
  
      use Log::Log4perl qw(:levels);
  
  This is the preferred way, there's usually no need to call 
  C<Log::Log4perl::Level> explicitly.
  
  The numerical values assigned to these constants are purely virtual,
  only used by Log::Log4perl internally and can change at any time,
  so please don't make any assumptions. You can test for numerical equality
  by directly comparing two level values, that's ok:
  
      if( get_logger()->level() == $DEBUG ) {
          print "The logger's level is DEBUG\n";
      }
  
  But if you want to figure out which of two levels is more verbose, use
  Log4perl's own comparator:
  
      if( Log::Log4perl::Level::isGreaterOrEqual( $level1, $level2 ) ) {
          print Log::Log4perl::Level::to_level( $level1 ), 
              " is equal or more verbose than ", 
              Log::Log4perl::Level::to_level( $level2 ), "\n";
      }
  
  If the caller wants to import level constants into a different namespace,
  it can be provided with the C<use> command:
  
      use Log::Log4perl::Level qw(MyNameSpace);
  
  After this C<$MyNameSpace::ERROR>, C<$MyNameSpace::INFO> etc. 
  will be defined accordingly.
  
  =head2 Numeric levels and Strings
  
  Level variables like $DEBUG or $WARN have numeric values that are 
  internal to Log4perl. Transform them to strings that can be used
  in a Log4perl configuration file, use the c<to_level()> function
  provided by Log::Log4perl::Level:
  
      use Log::Log4perl qw(:easy);
      use Log::Log4perl::Level;
  
          # prints "DEBUG"
      print Log::Log4perl::Level::to_level( $DEBUG ), "\n";
  
  To perform the reverse transformation, which takes a string like
  "DEBUG" and converts it into a constant like C<$DEBUG>, use the
  to_priority() function:
  
      use Log::Log4perl qw(:easy);
      use Log::Log4perl::Level;
  
      my $numval = Log::Log4perl::Level::to_priority( "DEBUG" );
  
  after which $numval could be used where a numerical value is required:
  
      Log::Log4perl->easy_init( $numval );
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_LEVEL

$fatpacked{"Log/Log4perl/Logger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_LOGGER';
  ##################################################
  package Log::Log4perl::Logger;
  ##################################################
  
  use 5.006;
  use strict;
  use warnings;
  
  use Log::Log4perl;
  use Log::Log4perl::Level;
  use Log::Log4perl::Layout;
  use Log::Log4perl::Appender;
  use Log::Log4perl::Appender::String;
  use Log::Log4perl::Filter;
  use Carp;
  
  $Carp::Internal{"Log::Log4perl"}++;
  $Carp::Internal{"Log::Log4perl::Logger"}++;
  
  use constant _INTERNAL_DEBUG => 0;
  
      # Initialization
  our $ROOT_LOGGER;
  our $LOGGERS_BY_NAME = {};
  our %APPENDER_BY_NAME = ();
  our $INITIALIZED = 0;
  our $NON_INIT_WARNED;
  our $DIE_DEBUG = 0;
  our $DIE_DEBUG_BUFFER = "";
      # Define the default appender that's used for formatting
      # warn/die/croak etc. messages.
  our $STRING_APP_NAME = "_l4p_warn";
  our $STRING_APP      = Log::Log4perl::Appender->new(
                            "Log::Log4perl::Appender::String",
                            name => $STRING_APP_NAME);
  $STRING_APP->layout(Log::Log4perl::Layout::PatternLayout->new("%m"));
  our $STRING_APP_CODEREF = generate_coderef([[$STRING_APP_NAME, $STRING_APP]]);
  
  __PACKAGE__->reset();
  
  ###########################################
  sub warning_render {
  ###########################################
      my($logger, @message) = @_;
  
      $STRING_APP->string("");
      $STRING_APP_CODEREF->($logger, 
                            @message, 
                            Log::Log4perl::Level::to_level($ALL));
      return $STRING_APP->string();
  }
  
  ##################################################
  sub cleanup {
  ##################################################
      # warn "Logger cleanup";
  
      # Nuke all convenience loggers to avoid them causing cleanup to 
      # be delayed until global destruction. Problem is that something like
      #     *{"DEBUG"} = sub { $logger->debug };
      # ties up a reference to $logger until global destruction, so we 
      # need to clean up all :easy shortcuts, hence freeing the last
      # logger references, to then rely on the garbage collector for cleaning
      # up the loggers.
      Log::Log4perl->easy_closure_global_cleanup();
  
      # Delete all loggers
      $LOGGERS_BY_NAME = {};
  
      # Delete the root logger
      undef $ROOT_LOGGER;
  
      # Delete all appenders
      %APPENDER_BY_NAME   = ();
  
      undef $INITIALIZED;
  }
  
  ##################################################
  sub DESTROY {
  ##################################################
      CORE::warn "Destroying logger $_[0] ($_[0]->{category})" 
              if $Log::Log4perl::CHATTY_DESTROY_METHODS;
  }
  
  ##################################################
  sub reset {
  ##################################################
      $ROOT_LOGGER        = __PACKAGE__->_new("", $OFF);
  #    $LOGGERS_BY_NAME    = {};  #leave this alone, it's used by 
                                  #reset_all_output_methods when 
                                  #the config changes
  
      %APPENDER_BY_NAME   = ();
      undef $INITIALIZED;
      undef $NON_INIT_WARNED;
      Log::Log4perl::Appender::reset();
  
      #clear out all the existing appenders
      foreach my $logger (values %$LOGGERS_BY_NAME){
          $logger->{appender_names} = [];
  
  	#this next bit deals with an init_and_watch case where a category
  	#is deleted from the config file, we need to zero out the existing
  	#loggers so ones not in the config file not continue with their old
  	#behavior --kg
          next if $logger eq $ROOT_LOGGER;
          $logger->{level} = undef;
          $logger->level();  #set it from the hierarchy
      }
  
      # Clear all filters
      Log::Log4perl::Filter::reset();
  }
  
  ##################################################
  sub _new {
  ##################################################
      my($class, $category, $level) = @_;
  
      print("_new: $class/$category/", defined $level ? $level : "undef",
            "\n") if _INTERNAL_DEBUG;
  
      die "usage: __PACKAGE__->_new(category)" unless
          defined $category;
      
      $category  =~ s/::/./g;
  
         # Have we created it previously?
      if(exists $LOGGERS_BY_NAME->{$category}) {
          print "_new: exists already\n" if _INTERNAL_DEBUG;
          return $LOGGERS_BY_NAME->{$category};
      }
  
      my $self  = {
          category  => $category,
          num_appenders => 0,
          additivity    => 1,
          level         => $level,
          layout        => undef,
                  };
  
     bless $self, $class;
  
     $level ||= $self->level();
  
          # Save it in global structure
     $LOGGERS_BY_NAME->{$category} = $self;
  
     $self->set_output_methods;
  
     print("Created logger $self ($category)\n") if _INTERNAL_DEBUG;
  
     return $self;
  }
  
  ##################################################
  sub category {
  ##################################################
     my ($self) = @_;
  
     return $self->{ category };
  }
  
  ##################################################
  sub reset_all_output_methods {
  ##################################################
      print "reset_all_output_methods: \n" if _INTERNAL_DEBUG;
  
      foreach my $loggername ( keys %$LOGGERS_BY_NAME){
          $LOGGERS_BY_NAME->{$loggername}->set_output_methods;
      }
      $ROOT_LOGGER->set_output_methods;
  }
  
  ##################################################
  sub set_output_methods {
  # Here's a big performance increase.  Instead of having the logger
  # calculate whether to log and whom to log to every time log() is called,
  # we calculate it once when the logger is created, and recalculate
  # it if the config information ever changes.
  #
  ##################################################
     my ($self) = @_;
      
     my (@appenders, %seen);
  
     my ($level) = $self->level();
  
     print "set_output_methods: $self->{category}/$level\n" if _INTERNAL_DEBUG;
  
     #collect the appenders in effect for this category    
  
     for(my $logger = $self; $logger; $logger = parent_logger($logger)) {
  
          foreach my $appender_name (@{$logger->{appender_names}}){
  
                  #only one message per appender, (configurable)
              next if $seen{$appender_name} ++ && 
                      $Log::Log4perl::one_message_per_appender;
  
              push (@appenders,     
                     [$appender_name,
                      $APPENDER_BY_NAME{$appender_name},
                     ]
              );
          }
          last unless $logger->{additivity};
      }
  
          #make a no-op coderef for inactive levels
      my $noop = generate_noop_coderef();
  
         #make a coderef
      my $coderef = (! @appenders ? $noop : &generate_coderef(\@appenders)); 
  
      my %priority = %Log::Log4perl::Level::PRIORITY; #convenience and cvs
  
     # changed to >= from <= as level ints were reversed
      foreach my $levelname (keys %priority){
          if (Log::Log4perl::Level::isGreaterOrEqual($level,
  						   $priority{$levelname}
  						   )) {
              print "  ($priority{$levelname} <= $level)\n"
                    if _INTERNAL_DEBUG;
              $self->{$levelname}      = $coderef;
              $self->{"is_$levelname"} = generate_is_xxx_coderef("1");
              print "Setting is_$levelname to 1\n" if _INTERNAL_DEBUG;
          }else{
              print "  ($priority{$levelname} > $level)\n" if _INTERNAL_DEBUG;
              $self->{$levelname}      = $noop;
              $self->{"is_$levelname"} = generate_is_xxx_coderef("0");
              print "Setting is_$levelname to 0\n" if _INTERNAL_DEBUG;
          }
  
          print("  Setting [$self] $self->{category}.$levelname to ",
                ($self->{$levelname} == $noop ? "NOOP" : 
                ("Coderef [$coderef]: " . scalar @appenders . " appenders")), 
                "\n") if _INTERNAL_DEBUG;
      }
  }
  
  ##################################################
  sub generate_coderef {
  ##################################################
      my $appenders = shift;
                      
      print "generate_coderef: ", scalar @$appenders, 
            " appenders\n" if _INTERNAL_DEBUG;
  
      my $watch_check_code = generate_watch_code("logger", 1);
  
      return sub {
        my $logger = shift;
        my $level  = pop;
  
        my $message;
        my $appenders_fired = 0;
        
        # Evaluate all parameters that need to be evaluated. Two kinds:
        #
        # (1) It's a hash like { filter => "filtername",
        #                        value  => "value" }
        #     => filtername(value)
        #
        # (2) It's a code ref
        #     => coderef()
        #
  
        $message   = [map { ref $_ eq "HASH" && 
                             exists $_->{filter} && 
                             ref $_->{filter} eq 'CODE' ?
                                 $_->{filter}->($_->{value}) :
                             ref $_ eq "CODE" ?
                                 $_->() : $_ 
                            } @_];                  
  
        print("coderef: $logger->{category}\n") if _INTERNAL_DEBUG;
  
        if(defined $Log::Log4perl::Config::WATCHER) {
            return unless $watch_check_code->($logger, @_, $level);
        }
  
        foreach my $a (@$appenders) {   #note the closure here
            my ($appender_name, $appender) = @$a;
  
            print("  Sending message '<$message->[0]>' ($level) " .
                  "to $appender_name\n") if _INTERNAL_DEBUG;
                  
            $appender->log(
                #these get passed through to Log::Dispatch
                { name    => $appender_name,
                  level   => $Log::Log4perl::Level::L4P_TO_LD{
                                 $level},   
                  message => $message,
                },
                #these we need
                $logger->{category},
                $level,
            ) and $appenders_fired++;
                # Only counting it if it returns a true value. Otherwise
                # the appender threshold might have suppressed it after all.
      
        } #end foreach appenders
      
        return $appenders_fired;
  
      }; #end coderef
  }
  
  ##################################################
  sub generate_noop_coderef {
  ##################################################
      my $watch_delay_code;
  
      # This might seem crazy at first, but even in a Log4perl noop, we
      # need to check if the configuration changed in a init_and_watch 
      # situation. Why? Say, an application is running in a loop that
      # constantly tries to issue debug() messages, but they're suppressed by
      # the current Log4perl configuration. If debug() (which is a noop
      # here) wasn't watching the configuration for changes, it would never
      # catch the case where someone bumps up the log level and expects
      # the application to pick it up and start logging debug() statements.
  
      my $watch_check_code = generate_watch_code("logger", 1);
  
      my $coderef;
  
      if(defined $Log::Log4perl::Config::WATCHER) {
          $coderef = $watch_check_code;
      } else {
          $coderef = sub { undef };
      }
  
      return $coderef;
  }
  
  ##################################################
  sub generate_is_xxx_coderef {
  ##################################################
      my($return_token) = @_;
  
      return generate_watch_code("checker", $return_token);
  }
  
  ##################################################
  sub generate_watch_code {
  ##################################################
      my($type, $return_token) = @_;
  
      print "generate_watch_code:\n" if _INTERNAL_DEBUG;
  
        # No watcher configured, return a no-op as watch code.
      if(! defined $Log::Log4perl::Config::WATCHER) {
          return sub { $return_token };
      }
  
      my $cond = generate_watch_conditional();
  
      return sub {
          print "exe_watch_code:\n" if _INTERNAL_DEBUG;
  
         if(_INTERNAL_DEBUG) {
             print "Next check: ",
               "$Log::Log4perl::Config::Watch::NEXT_CHECK_TIME ",
               " Now: ", time(), " Mod: ",
               (stat($Log::Log4perl::Config::WATCHER->file()))[9],
               "\n";
         }
  
         if( $cond->() ) {
             my $init_permitted = 1;
  
             if(exists $Log::Log4perl::Config::OPTS->{ preinit_callback } ) {
                 print "Calling preinit_callback\n" if _INTERNAL_DEBUG;
                 $init_permitted = 
                 $Log::Log4perl::Config::OPTS->{ preinit_callback }->( 
                     Log::Log4perl::Config->watcher()->file() );
                 print "Callback returned $init_permitted\n" if _INTERNAL_DEBUG;
             }
  
             if( $init_permitted ) {
                 Log::Log4perl->init_and_watch();
             } else {
                 # It was time to reinit, but init wasn't permitted.
                 # Return true, so that the logger continues as if
                 # it wasn't time to reinit.
                 return 1;
             }
  
             my $logger = shift;
             my $level  = pop;
  
             # Forward call to new configuration
             if($type eq "checker") {
                 return $logger->$level();
  
             } elsif( $type eq "logger") {
                 my $methodname = lc($level);
  
                 # Bump up the caller level by three, since
                 # we've artificially introduced additional levels.
                 local $Log::Log4perl::caller_depth =
                       $Log::Log4perl::caller_depth + 3;
  
                 # Get a new logger for the same category (the old
                 # logger might be obsolete because of the re-init)
                 $logger = Log::Log4perl::get_logger( $logger->{category} );
  
                 $logger->$methodname(@_); # send the message
                 # to the new configuration
                 return undef;     # Return false, so the logger finishes
                 # prematurely and doesn't log the same 
                 # message again.
             } else {
                 die "internal error: unknown type";
             }
         } else {
             if(_INTERNAL_DEBUG) {
                 print "Conditional returned false\n";
             }
             return $return_token;
         }
     };
  }
  
  ##################################################
  sub generate_watch_conditional {
  ##################################################
  
      if(defined $Log::Log4perl::Config::Watch::SIGNAL_CAUGHT) {
          # In this mode, we just check for the variable indicating
          # that the signal has been caught
          return sub {
              return $Log::Log4perl::Config::Watch::SIGNAL_CAUGHT;
          };
      }
  
      return sub {
          return 
              ( time() > $Log::Log4perl::Config::Watch::NEXT_CHECK_TIME and 
                $Log::Log4perl::Config::WATCHER->change_detected() );
      };
  }
  
  ##################################################
  sub parent_string {
  ##################################################
      my($string) = @_;
  
      if($string eq "") {
          return undef; # root doesn't have a parent.
      }
  
      my @components = split /\./, $string;
      
      if(@components == 1) {
          return "";
      }
  
      pop @components;
  
      return join('.', @components);
  }
  
  ##################################################
  sub level {
  ##################################################
      my($self, $level, $dont_reset_all) = @_;
  
          # 'Set' function
      if(defined $level) {
          croak "invalid level '$level'" 
                  unless Log::Log4perl::Level::is_valid($level);
          if ($level =~ /\D/){
              $level = Log::Log4perl::Level::to_priority($level);
          }
          $self->{level} = $level;   
  
          &reset_all_output_methods
              unless $dont_reset_all;  #keep us from getting overworked 
                                       #if it's the config file calling us 
  
          return $level;
      }
  
          # 'Get' function
      if(defined $self->{level}) {
          return $self->{level};
      }
  
      for(my $logger = $self; $logger; $logger = parent_logger($logger)) {
  
          # Does the current logger have the level defined?
  
          if($logger->{category} eq "") {
              # It's the root logger
              return $ROOT_LOGGER->{level};
          }
              
          if(defined $LOGGERS_BY_NAME->{$logger->{category}}->{level}) {
              return $LOGGERS_BY_NAME->{$logger->{category}}->{level};
          }
      }
  
      # We should never get here because at least the root logger should
      # have a level defined
      die "We should never get here.";
  }
  
  ##################################################
  sub parent_logger {
  # Get the parent of the current logger or undef
  ##################################################
      my($logger) = @_;
  
          # Is it the root logger?
      if($logger->{category} eq "") {
          # Root has no parent
          return undef;
      }
  
          # Go to the next defined (!) parent
      my $parent_class = parent_string($logger->{category});
  
      while($parent_class ne "" and
            ! exists $LOGGERS_BY_NAME->{$parent_class}) {
          $parent_class = parent_string($parent_class);
          $logger =  $LOGGERS_BY_NAME->{$parent_class};
      }
  
      if($parent_class eq "") {
          $logger = $ROOT_LOGGER;
      } else {
          $logger = $LOGGERS_BY_NAME->{$parent_class};
      }
  
      return $logger;
  }
  
  ##################################################
  sub get_root_logger {
  ##################################################
      my($class) = @_;
      return $ROOT_LOGGER;    
  }
  
  ##################################################
  sub additivity {
  ##################################################
      my($self, $onoff, $no_reinit) = @_;
  
      if(defined $onoff) {
          $self->{additivity} = $onoff;
      }
  
      if( ! $no_reinit ) {
          $self->set_output_methods();
      }
  
      return $self->{additivity};
  }
  
  ##################################################
  sub get_logger {
  ##################################################
      my($class, $category) = @_;
  
      unless(defined $ROOT_LOGGER) {
          Carp::confess "Internal error: Root Logger not initialized.";
      }
  
      return $ROOT_LOGGER if $category eq "";
  
      my $logger = $class->_new($category);
      return $logger;
  }
  
  ##################################################
  sub add_appender {
  ##################################################
      my($self, $appender, $dont_reset_all) = @_;
  
          # We take this as an indicator that we're initialized.
      $INITIALIZED = 1;
  
      my $appender_name = $appender->name();
  
      $self->{num_appenders}++;  #should this be inside the unless?
  
        # Add newly created appender to the end of the appender array
      unless (grep{$_ eq $appender_name} @{$self->{appender_names}}){
          $self->{appender_names} = [sort @{$self->{appender_names}}, 
                                          $appender_name];
      }
  
      $APPENDER_BY_NAME{$appender_name} = $appender;
  
      reset_all_output_methods
                  unless $dont_reset_all;  # keep us from getting overworked
                                           # if it's  the config file calling us
  
          # For chaining calls ...
      return $appender;
  }
  
  ##################################################
  sub remove_appender {
  ##################################################
      my($self, $appender_name, $dont_reset_all, $sloppy) = @_;
  
      my %appender_names = map { $_ => 1 } @{$self->{appender_names}};
      
      if(!exists $appender_names{$appender_name}) {
          die "No such appender: $appender_name" unless $sloppy;
          return undef;
      }
  
      delete $appender_names{$appender_name};
      $self->{num_appenders}--;
      $self->{appender_names} = [sort keys %appender_names];
  
      &reset_all_output_methods
                  unless $dont_reset_all; 
  }
  
  ##################################################
  sub eradicate_appender {
  ##################################################
          # If someone calls Logger->... and not Logger::...
      shift if $_[0] eq __PACKAGE__;
  
      my($appender_name, $dont_reset_all) = @_;
  
      return 0 unless exists 
          $APPENDER_BY_NAME{$appender_name};
  
          # Remove the given appender from all loggers
          # and delete all references to it, causing
          # its DESTROY method to be called.
      foreach my $logger (values %$LOGGERS_BY_NAME){
          $logger->remove_appender($appender_name, 0, 1);
      }
          # Also remove it from the root logger
      $ROOT_LOGGER->remove_appender($appender_name, 0, 1);
      
      delete $APPENDER_BY_NAME{$appender_name};
  
      &reset_all_output_methods
                  unless $dont_reset_all; 
  
      return 1;
  }
  
  ##################################################
  sub has_appenders {
  ##################################################
      my($self) = @_;
  
      return $self->{num_appenders};
  }
  
  ##################################################
  sub log {
  # external api
  ##################################################
      my ($self, $priority, @messages) = @_;
  
      confess("log: No priority given!") unless defined($priority);
  
         # Just in case of 'init_and_watch' -- see Changes 0.21
      $_[0] = $LOGGERS_BY_NAME->{$_[0]->{category}} if 
          defined $Log::Log4perl::Config::WATCHER;
  
      init_warn() unless $INITIALIZED or $NON_INIT_WARNED;
  
      croak "priority $priority isn't numeric" if ($priority =~ /\D/);
  
      my $which = Log::Log4perl::Level::to_level($priority);
  
      $self->{$which}->($self, @messages, 
                      Log::Log4perl::Level::to_level($priority));
  }
  
  ######################################################################
  #
  # create_custom_level 
  # creates a custom level
  # in theory, could be used to create the default ones
  ######################################################################
  sub create_custom_level {
  ######################################################################
    my $level = shift || die("create_custom_level: " .
                             "forgot to pass in a level string!");
    my $after = shift || die("create_custom_level: " .
                             "forgot to pass in a level after which to " .
                             "place the new level!");
    my $syslog_equiv = shift; # can be undef
    my $log_dispatch_level = shift; # optional
  
    ## only let users create custom levels before initialization
  
    die("create_custom_level must be called before init or " .
        "first get_logger() call") if ($INITIALIZED);
  
    my %PRIORITY = %Log::Log4perl::Level::PRIORITY; #convenience
  
    die("create_custom_level: no such level \"$after\"! Use one of: ", 
       join(", ", sort keys %PRIORITY)) unless $PRIORITY{$after};
  
    # figure out new int value by AFTER + (AFTER+ 1) / 2
  
    my $next_prio = Log::Log4perl::Level::get_lower_level($PRIORITY{$after}, 1);
    my $cust_prio = int(($PRIORITY{$after} + $next_prio) / 2);
  
    die(qq{create_custom_level: Calculated level of $cust_prio already exists!
        This should only happen if you've made some insane number of custom
        levels (like 15 one after another)
        You can usually fix this by re-arranging your code from:
        create_custom_level("cust1", X);
        create_custom_level("cust2", X);
        create_custom_level("cust3", X);
        create_custom_level("cust4", X);
        create_custom_level("cust5", X);
        into:
        create_custom_level("cust3", X);
        create_custom_level("cust5", X);
        create_custom_level("cust4", 4);
        create_custom_level("cust2", cust3);
        create_custom_level("cust1", cust2);
     }) if (${Log::Log4perl::Level::LEVELS{$cust_prio}});
  
    Log::Log4perl::Level::add_priority($level, $cust_prio, $syslog_equiv,
                                       $log_dispatch_level);
  
    print("Adding prio $level at $cust_prio\n") if _INTERNAL_DEBUG;
  
    # get $LEVEL into namespace of Log::Log4perl::Logger to 
    # create $logger->foo nd $logger->is_foo
    my $name = "Log::Log4perl::Logger::";
    my $key = $level;
  
    no strict qw(refs);
    # be sure to use ${Log...} as CVS adds log entries for Log
    *{"$name$key"} = \${Log::Log4perl::Level::PRIORITY{$level}};
  
    # now, stick it in the caller's namespace
    $name = caller(0) . "::";
    *{"$name$key"} = \${Log::Log4perl::Level::PRIORITY{$level}};
    use strict qw(refs);
  
    create_log_level_methods($level);
  
    return 0;
  
  }
  
  ########################################
  #
  # if we were hackin' lisp (or scheme), we'd be returning some lambda
  # expressions. But we aren't. :) So we'll just create some strings and
  # eval them.
  ########################################
  sub create_log_level_methods {
  ########################################
    my $level = shift || die("create_log_level_methods: " .
                             "forgot to pass in a level string!");
    my $lclevel = lc($level);
    my $levelint = uc($level) . "_INT";
    my $initial_cap = ucfirst($lclevel);
  
    no strict qw(refs);
  
    # This is a bit better way to create code on the fly than eval'ing strings.
    # -erik
  
    *{__PACKAGE__ . "::$lclevel"} = sub {
          if(_INTERNAL_DEBUG) {
              my $level_disp = (defined $_[0]->{level} ? $_[0]->{level} 
                                                       : "[undef]");
              print "$lclevel: ($_[0]->{category}/$level_disp) [@_]\n";
          }
          init_warn() unless $INITIALIZED or $NON_INIT_WARNED;
          $_[0]->{$level}->(@_, $level) if defined $_[0]->{$level};
       };
  
    # Added these to have is_xxx functions as fast as xxx functions
    # -ms
    
    my $islevel   = "is_" . $level;
    my $islclevel = "is_" . $lclevel;
  
    *{__PACKAGE__ . "::is_$lclevel"} = sub {
        $_[0]->{$islevel}->($_[0], $islclevel);
    };
    
    # Add the isXxxEnabled() methods as identical to the is_xxx
    # functions. - dviner
    
    *{__PACKAGE__ . "::is".$initial_cap."Enabled"} = 
                             \&{__PACKAGE__ . "::is_$lclevel"};
    
    use strict qw(refs);
  
    return 0;
  }
  
  #now lets autogenerate the logger subs based on the defined priorities
  foreach my $level (keys %Log::Log4perl::Level::PRIORITY){
    create_log_level_methods($level);
  }
  
  ##################################################
  sub init_warn {
  ##################################################
      CORE::warn "Log4perl: Seems like no initialization happened. " .
                 "Forgot to call init()?\n";
      # Only tell this once;
      $NON_INIT_WARNED = 1;
  }
  
  #######################################################
  # call me from a sub-func to spew the sub-func's caller
  #######################################################
  sub callerline {
    my $message = join ('', @_);
  
    my $caller_offset = 
      Log::Log4perl::caller_depth_offset( 
          $Log::Log4perl::caller_depth + 1 );
  
    my ($pack, $file, $line) = caller($caller_offset);
  
    if (not chomp $message) {     # no newline
      $message .= " at $file line $line";
  
      # Someday, we'll use Threads. Really.
      if (defined &Thread::tid) {
        my $tid = Thread->self->tid;
        $message .= " thread $tid" if $tid;
      }
    }
  
    return ($message, "\n");
  }
  
  #######################################################
  sub and_warn {
  #######################################################
    my $self = shift;
    CORE::warn(callerline($self->warning_render(@_)));
  }
  
  #######################################################
  sub and_die {
  #######################################################
    my $self = shift;
    my $arg  = $_[0];
  
    my($msg) = callerline($self->warning_render(@_));
  
    if($DIE_DEBUG) {
        $DIE_DEBUG_BUFFER = "DIE_DEBUG: $msg";
    } else {
        if( $Log::Log4perl::STRINGIFY_DIE_MESSAGE ) {
            die("$msg\n");
        }
        die $arg;
    }
  }
  
  ##################################################
  sub logwarn {
  ##################################################
    my $self = shift;
  
    local $Log::Log4perl::caller_depth = 
          $Log::Log4perl::caller_depth + 1;
  
    if ($self->is_warn()) {
          # Since we're one caller level off now, compensate for that.
      my @chomped = @_;
      chomp($chomped[-1]);
      $self->warn(@chomped);
    }
  
    $self->and_warn(@_);
  }
  
  ##################################################
  sub logdie {
  ##################################################
    my $self = shift;
  
    local $Log::Log4perl::caller_depth = 
          $Log::Log4perl::caller_depth + 1;
  
    if ($self->is_fatal()) {
          # Since we're one caller level off now, compensate for that.
      my @chomped = @_;
      chomp($chomped[-1]);
      $self->fatal(@chomped);
    }
  
    $Log::Log4perl::LOGDIE_MESSAGE_ON_STDERR ? 
        $self->and_die(@_) : 
          exit($Log::Log4perl::LOGEXIT_CODE);
  }
  
  ##################################################
  sub logexit {
  ##################################################
    my $self = shift;
  
    local $Log::Log4perl::caller_depth = 
          $Log::Log4perl::caller_depth + 1;
  
    if ($self->is_fatal()) {
          # Since we're one caller level off now, compensate for that.
      my @chomped = @_;
      chomp($chomped[-1]);
      $self->fatal(@chomped);
    }
  
    exit $Log::Log4perl::LOGEXIT_CODE;
  }
  
  ##################################################
  # clucks and carps are WARN level
  sub logcluck {
  ##################################################
    my $self = shift;
  
    local $Log::Log4perl::caller_depth = 
          $Log::Log4perl::caller_depth + 1;
  
    local $Carp::CarpLevel = 
          $Carp::CarpLevel + 1;
  
    my $msg = $self->warning_render(@_);
  
    if ($self->is_warn()) {
      my $message = Carp::longmess($msg);
      foreach (split(/\n/, $message)) {
        $self->warn("$_\n");
      }
    }
  
    Carp::cluck($msg);
  }
  
  ##################################################
  sub logcarp {
  ##################################################
    my $self = shift;
  
    local $Carp::CarpLevel = $Carp::CarpLevel + 1;
  
    local $Log::Log4perl::caller_depth = 
          $Log::Log4perl::caller_depth + 1;
  
    my $msg = $self->warning_render(@_);
  
    if ($self->is_warn()) {
      my $message = Carp::shortmess($msg);
      foreach (split(/\n/, $message)) {
        $self->warn("$_\n");
      }
    }
  
    Carp::carp($msg);
  }
  
  ##################################################
  # croaks and confess are FATAL level
  ##################################################
  sub logcroak {
  ##################################################
    my $self = shift;
    my $arg  = $_[0];
  
    my $msg = $self->warning_render(@_);
  
    local $Carp::CarpLevel = 
          $Carp::CarpLevel + 1;
  
    local $Log::Log4perl::caller_depth = 
          $Log::Log4perl::caller_depth + 1;
  
    if ($self->is_fatal()) {
      my $message = Carp::shortmess($msg);
      foreach (split(/\n/, $message)) {
        $self->fatal("$_\n");
      }
    }
  
    my $croak_msg = $arg;
  
    if( $Log::Log4perl::STRINGIFY_DIE_MESSAGE ) {
        $croak_msg = $msg;
    }
  
    $Log::Log4perl::LOGDIE_MESSAGE_ON_STDERR ? 
        Carp::croak($croak_msg) : 
          exit($Log::Log4perl::LOGEXIT_CODE);
  }
  
  ##################################################
  sub logconfess {
  ##################################################
    my $self = shift;
    my $arg  = $_[0];
  
    local $Carp::CarpLevel = 
          $Carp::CarpLevel + 1;
  
    local $Log::Log4perl::caller_depth = 
          $Log::Log4perl::caller_depth + 1;
  
    my $msg = $self->warning_render(@_);
  
    if ($self->is_fatal()) {
      my $message = Carp::longmess($msg);
      foreach (split(/\n/, $message)) {
        $self->fatal("$_\n");
      }
    }
  
    my $confess_msg = $arg;
  
    if( $Log::Log4perl::STRINGIFY_DIE_MESSAGE ) {
        $confess_msg = $msg;
    }
  
    $Log::Log4perl::LOGDIE_MESSAGE_ON_STDERR ? 
        confess($confess_msg) :
          exit($Log::Log4perl::LOGEXIT_CODE);
  }
  
  ##################################################
  # in case people prefer to use error for warning
  ##################################################
  sub error_warn {
  ##################################################
    my $self = shift;
  
    local $Log::Log4perl::caller_depth = 
          $Log::Log4perl::caller_depth + 1;
  
    if ($self->is_error()) {
      $self->error(@_);
    }
  
    $self->and_warn(@_);
  }
  
  ##################################################
  sub error_die {
  ##################################################
    my $self = shift;
  
    local $Log::Log4perl::caller_depth = 
          $Log::Log4perl::caller_depth + 1;
  
    my $msg = $self->warning_render(@_);
  
    if ($self->is_error()) {
      $self->error($msg);
    }
  
    $Log::Log4perl::LOGDIE_MESSAGE_ON_STDERR ? 
        $self->and_die($msg) :
          exit($Log::Log4perl::LOGEXIT_CODE);
  }
  
  ##################################################
  sub more_logging {
  ##################################################
    my ($self) = shift;
    return $self->dec_level(@_);
  }
  
  ##################################################
  sub inc_level {
  ##################################################
      my ($self, $delta) = @_;
  
      $delta ||= 1;
  
      $self->level(Log::Log4perl::Level::get_higher_level($self->level(), 
                                                          $delta));
  
      $self->set_output_methods;
  }
  
  ##################################################
  sub less_logging {
  ##################################################
    my ($self) = shift;
    return $self->inc_level(@_);
  }
  
  ##################################################
  sub dec_level {
  ##################################################
      my ($self, $delta) = @_;
  
      $delta ||= 1;
  
      $self->level(Log::Log4perl::Level::get_lower_level($self->level(), $delta));
  
      $self->set_output_methods;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Logger - Main Logger Class
  
  =head1 SYNOPSIS
  
      # It's not here
  
  =head1 DESCRIPTION
  
  While everything that makes Log4perl tick is implemented here,
  please refer to L<Log::Log4perl> for documentation.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_LOGGER

$fatpacked{"Log/Log4perl/MDC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_MDC';
  ##################################################
  package Log::Log4perl::MDC;
  ##################################################
  
  use 5.006;
  use strict;
  use warnings;
  
  our %MDC_HASH = ();
  
  ###########################################
  sub get {
  ###########################################
      my($class, $key) = @_;
  
      if($class ne __PACKAGE__) {
          # Somebody called us with Log::Log4perl::MDC::get($key)
          $key = $class;
      }
  
      if(exists $MDC_HASH{$key}) {
          return $MDC_HASH{$key};
      } else {
          return undef;
      }
  }
  
  ###########################################
  sub put {
  ###########################################
      my($class, $key, $value) = @_;
  
      if($class ne __PACKAGE__) {
          # Somebody called us with Log::Log4perl::MDC::put($key, $value)
          $value = $key;
          $key   = $class;
      }
  
      $MDC_HASH{$key} = $value;
  }
  
  ###########################################
  sub remove {
  ###########################################
      %MDC_HASH = ();
  
      1;
  }
  
  ###########################################
  sub get_context {
  ###########################################
      return \%MDC_HASH;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::MDC - Mapped Diagnostic Context
  
  =head1 DESCRIPTION
  
  Log::Log4perl allows loggers to maintain global thread-specific data, 
  called the Nested Diagnostic Context (NDC) and 
  Mapped Diagnostic Context (MDC).
  
  The MDC is a simple thread-specific hash table, in which the application
  can stuff values under certain keys and retrieve them later
  via the C<"%X{key}"> placeholder in 
  C<Log::Log4perl::Layout::PatternLayout>s.
  
  =over 4
  
  =item Log::Log4perl::MDC->put($key, $value);
  
  Store a value C<$value> under key C<$key> in the map.
  
  =item my $value = Log::Log4perl::MDC->get($key);
  
  Retrieve the content of the map under the specified key.
  Typically done by C<%X{key}> in
  C<Log::Log4perl::Layout::PatternLayout>.
  If no value exists to the given key, C<undef> is returned.
  
  =item my $text = Log::Log4perl::MDC->remove();
  
  Delete all entries from the map.
  
  =item Log::Log4perl::MDC->get_context();
  
  Returns a reference to the hash table.
  
  =back
  
  Please note that all of the methods above are class methods, there's no
  instances of this class. Since the thread model in perl 5.8.0 is
  "no shared data unless explicitly requested" the data structures
  used are just global (and therefore thread-specific).
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_MDC

$fatpacked{"Log/Log4perl/NDC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_NDC';
  ##################################################
  package Log::Log4perl::NDC;
  ##################################################
  
  use 5.006;
  use strict;
  use warnings;
  
  our @NDC_STACK = ();
  our $MAX_SIZE  = 5;
  
  ###########################################
  sub get {
  ###########################################
      if(@NDC_STACK) {
          # Return elements blank separated
          return join " ", @NDC_STACK;
      } else {
          return "[undef]";
      }
  }
  
  ###########################################
  sub pop {
  ###########################################
      if(@NDC_STACK) {
          return pop @NDC_STACK;
      } else {
          return undef;
      }
  }
  
  ###########################################
  sub push {
  ###########################################
      my($self, $text) = @_;
  
      unless(defined $text) {
          # Somebody called us via Log::Log4perl::NDC::push("blah") ?
          $text = $self;
      }
  
      if(@NDC_STACK >= $MAX_SIZE) {
          CORE::pop(@NDC_STACK);
      }
  
      return push @NDC_STACK, $text;
  }
  
  ###########################################
  sub remove {
  ###########################################
      @NDC_STACK = ();
  }
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::NDC - Nested Diagnostic Context
  
  =head1 DESCRIPTION
  
  Log::Log4perl allows loggers to maintain global thread-specific data, 
  called the Nested Diagnostic Context (NDC).
  
  At some point, the application might decide to push a piece of
  data onto the NDC stack, which other parts of the application might 
  want to reuse. For example, at the beginning of a web request in a server,
  the application might decide to push the IP address of the client
  onto the stack to provide it for other loggers down the road without
  having to pass the data from function to function.
  
  The Log::Log4perl::Layout::PatternLayout class even provides the handy
  C<%x> placeholder which is replaced by the blank-separated list
  of elements currently on the stack.
  
  This module maintains a simple stack which you can push data on to, query
  what's on top, pop it off again or delete the entire stack.
  
  Its purpose is to provide a thread-specific context which all 
  Log::Log4perl loggers can refer to without the application having to
  pass around the context data between its functions.
  
  Since in 5.8.0 perl's threads don't share data only upon request,
  global data is by definition thread-specific.
  
  =over 4
  
  =item Log::Log4perl::NDC->push($text);
  
  Push an item onto the stack. If the stack grows beyond the defined
  limit (C<$Log::Log4perl::NDC::MAX_SIZE>), just the topmost element
  will be replated.
  
  This is typically done when a context is entered.
  
  =item Log::Log4perl::NDC->pop();
  
  Discard the upmost element of the stack. This is typically done when
  a context is left.
  
  =item my $text = Log::Log4perl::NDC->get();
  
  Retrieve the content of the stack as a string of blank-separated values
  without disrupting the stack structure. Typically done by C<%x>.
  If the stack is empty the value C<"[undef]"> is being returned.
  
  =item Log::Log4perl::NDC->remove();
  
  Reset the stack, remove all items.
  
  =back
  
  Please note that all of the methods above are class methods, there's no
  instances of this class.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_NDC

$fatpacked{"Log/Log4perl/Resurrector.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_RESURRECTOR';
  package Log::Log4perl::Resurrector;
  use warnings;
  use strict;
  
  # [rt.cpan.org #84818]
  use if $^O eq "MSWin32", "Win32"; 
  
  use File::Temp qw(tempfile);
  use File::Spec;
  
  use constant INTERNAL_DEBUG => 0;
  
  our $resurrecting = '';
  
  ###########################################
  sub import {
  ###########################################
      resurrector_init();
  }
  
  ##################################################
  sub resurrector_fh {
  ##################################################
      my($file) = @_;
  
      local($/) = undef;
      open FILE, "<$file" or die "Cannot open $file";
      my $text = <FILE>;
      close FILE;
  
      print "Read ", length($text), " bytes from $file\n" if INTERNAL_DEBUG;
  
      my($tmp_fh, $tmpfile) = tempfile( UNLINK => 1 );
      print "Opened tmpfile $tmpfile\n" if INTERNAL_DEBUG;
  
      $text =~ s/^\s*###l4p//mg;
  
      print "Text=[$text]\n" if INTERNAL_DEBUG;
  
      print $tmp_fh $text;
      seek $tmp_fh, 0, 0;
  
      return $tmp_fh;
  }
  
  ###########################################
  sub resurrector_loader {
  ###########################################
      my ($code, $module) = @_;
  
      print "resurrector_loader called with $module\n" if INTERNAL_DEBUG;
  
        # Avoid recursion
      if($resurrecting eq $module) {
          print "ignoring $module (recursion)\n" if INTERNAL_DEBUG;
          return undef;
      }
      
      local $resurrecting = $module;
      
      
        # Skip Log4perl appenders
      if($module =~ m#^Log/Log4perl/Appender#) {
          print "Ignoring $module (Log4perl-internal)\n" if INTERNAL_DEBUG;
          return undef;
      }
  
      my $path = $module;
  
        # Skip unknown files
      if(!-f $module) {
            # We might have a 'use lib' statement that modified the
            # INC path, search again.
          $path = pm_search($module);
          if(! defined $path) {
              print "File $module not found\n" if INTERNAL_DEBUG;
              return undef;
          }
          print "File $module found in $path\n" if INTERNAL_DEBUG;
      }
  
      print "Resurrecting module $path\n" if INTERNAL_DEBUG;
  
      my $fh = resurrector_fh($path);
  
      my $abs_path = File::Spec->rel2abs( $path );
      print "Setting %INC entry of $module to $abs_path\n" if INTERNAL_DEBUG;
      $INC{$module} = $abs_path;
  
      return $fh;
  }
  
  ###########################################
  sub pm_search {
  ###########################################
      my($pmfile) = @_;
  
      for(@INC) {
            # Skip subrefs
          next if ref($_);
          my $path = File::Spec->catfile($_, $pmfile);
          return $path if -f $path;
      }
  
      return undef;
  }
  
  ###########################################
  sub resurrector_init {
  ###########################################
      unshift @INC, \&resurrector_loader;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Resurrector - Dark Magic to resurrect hidden L4p statements
  
  =head1 DESCRIPTION
  
  Loading C<use Log::Log4perl::Resurrector> causes subsequently loaded
  modules to have their hidden
  
      ###l4p use Log::Log4perl qw(:easy);
  
      ###l4p DEBUG(...)
      ###l4p INFO(...)
      ...
  
  statements uncommented and therefore 'resurrected', i.e. activated.
  
  This allows for a module C<Foobar.pm> to be written with Log4perl
  statements commented out and running at full speed in normal mode.
  When loaded via
  
      use Foobar;
  
  all hidden Log4perl statements will be ignored.
  
  However, if a script loads the module C<Foobar> I<after> loading 
  C<Log::Log4perl::Resurrector>, as in
  
      use Log::Log4perl::Resurrector;
      use Foobar;
  
  then C<Log::Log4perl::Resurrector> will have put a source filter in place
  that will extract all hidden Log4perl statements in C<Foobar> before 
  C<Foobar> actually gets loaded. 
  
  Therefore, C<Foobar> will then behave as if the
  
      ###l4p use Log::Log4perl qw(:easy);
  
      ###l4p DEBUG(...)
      ###l4p INFO(...)
      ...
  
  statements were actually written like
  
      use Log::Log4perl qw(:easy);
  
      DEBUG(...)
      INFO(...)
      ...
  
  and the module C<Foobar> will indeed be Log4perl-enabled. Whether any
  activated Log4perl statement will actually trigger log
  messages, is up to the Log4perl configuration, of course.
  
  There's a startup cost to using C<Log::Log4perl::Resurrector> (all
  subsequently loaded modules are examined) but once the compilation
  phase has finished, the perl program will run at full speed.
  
  Some of the techniques used in this module have been stolen from the
  C<Acme::Incorporated> CPAN module, written by I<chromatic>. Long
  live CPAN!
   
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_RESURRECTOR

$fatpacked{"Log/Log4perl/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_UTIL';
  package Log::Log4perl::Util;
  
  require Exporter;
  our @EXPORT_OK = qw( params_check );
  our @ISA       = qw( Exporter );
  
  use File::Spec;
  
  ###########################################
  sub params_check {
  ###########################################
      my( $hash, $required, $optional ) = @_;
  
      my $pkg       = caller();
      my %hash_copy = %$hash;
  
      if( defined $required ) {
          for my $p ( @$required ) {
              if( !exists $hash->{ $p } or
                  !defined $hash->{ $p } ) {
                  die "$pkg: Required parameter $p missing.";
              }
              delete $hash_copy{ $p };
          }
      }
  
      if( defined $optional ) {
          for my $p ( @$optional ) {
              delete $hash_copy{ $p };
          }
          if( scalar keys %hash_copy ) {
              die "$pkg: Unknown parameter: ", join( ",", keys %hash_copy );
          }
      }
  }
  
  ##################################################
  sub module_available {  # Check if a module is available
  ##################################################
      my($full_name) = @_;
        # Weird cases like "strict;" (including the semicolon) would 
        # succeed with the eval below, so check those up front. 
        # I can't believe Perl doesn't have a proper way to check if a 
        # module is available or not!
      return 0 if $full_name =~ /[^\w:]/;
      $full_name =~ s#::#/#g;
      $full_name .= '.pm';
      return 1 if $INC{$full_name};
      eval {
          local $SIG{__DIE__} = sub {};
          require $full_name;
      };
      return !$@;
  }
  
  ##################################################
  sub tmpfile_name {  # File::Temp without the bells and whistles
  ##################################################
  
      my $name = File::Spec->catfile(File::Spec->tmpdir(), 
                                'l4p-tmpfile-' . 
                                "$$-" .
                                int(rand(9999999)));
  
          # Some crazy versions of File::Spec use backslashes on Win32
      $name =~ s#\\#/#g;
      return $name;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Util - Internal utility functions
  
  =head1 DESCRIPTION
  
  Only internal functions here. Don't peek.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_UTIL

$fatpacked{"Log/Log4perl/Util/Semaphore.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_UTIL_SEMAPHORE';
  #//////////////////////////////////////////
  package Log::Log4perl::Util::Semaphore;
  #//////////////////////////////////////////
  use IPC::SysV qw(IPC_RMID IPC_CREAT IPC_EXCL SEM_UNDO IPC_NOWAIT 
                   IPC_SET IPC_STAT SETVAL);
  use IPC::Semaphore;
  use POSIX qw(EEXIST);
  use strict;
  use warnings;
  use constant INTERNAL_DEBUG => 0;
  
  ###########################################
  sub new {
  ###########################################
      my($class, %options) = @_;
  
      my $self = {
          key           => undef,
          mode          => undef,
          uid           => undef,
          gid           => undef,
          destroy       => undef,
          semop_wait    => .1,
          semop_retries => 1,
  	creator       => $$,
          %options,
      };
  
      $self->{ikey} = unpack("i", pack("A4", $self->{key}));
  
        # Accept usernames in the uid field as well
      if(defined $self->{uid} and 
         $self->{uid} =~ /\D/) {
          $self->{uid} = (getpwnam $self->{uid})[2];
      }
  
      bless $self, $class;
      $self->init();
  
      my @values = ();
      for my $param (qw(mode uid gid)) {
          push @values, $param, $self->{$param} if defined $self->{$param};
      }
      $self->semset(@values) if @values;
  
      return $self;
  }
  
  ###########################################
  sub init {
  ###########################################
      my($self) = @_;
  
      print "Semaphore init '$self->{key}'/'$self->{ikey}'\n" if INTERNAL_DEBUG;
  
      $self->{id} = semget( $self->{ikey}, 
                            1, 
                            &IPC_EXCL|&IPC_CREAT|($self->{mode}||0777),
                    );
  
     if(! defined $self->{id} and
        $! == EEXIST) {
         print "Semaphore '$self->{key}' already exists\n" if INTERNAL_DEBUG;
         defined( $self->{id} = semget( $self->{ikey}, 1, 0 ) )
             or die "semget($self->{ikey}) failed: $!";
     } elsif($!) {
         die "Cannot create semaphore $self->{key}/$self->{ikey} ($!)";
     }
  
     print "Semaphore has id $self->{id}\n" if INTERNAL_DEBUG;
  }
  
  ###########################################
  sub status_as_string {
  ###########################################
      my($self, @values) = @_;
  
      my $sem = IPC::Semaphore->new($self->{ikey}, 1, 0);
  
      my $values  = join('/', $sem->getall());
      my $ncnt    = $sem->getncnt(0);
      my $pidlast = $sem->getpid(0);
      my $zcnt    = $sem->getzcnt(0);
      my $id      = $sem->id();
  
      return <<EOT;
  Semaphore Status
  Key ...................................... $self->{key}
  iKey ..................................... $self->{ikey}
  Id ....................................... $id
  Values ................................... $values
  Processes waiting for counter increase ... $ncnt
  Processes waiting for counter to hit 0 ... $zcnt
  Last process to perform an operation ..... $pidlast
  EOT
  }
  
  ###########################################
  sub semsetval {
  ###########################################
      my($self, %keyvalues) = @_;
  
      my $sem = IPC::Semaphore->new($self->{ikey}, 1, 0);
      $sem->setval(%keyvalues);
  }
  
  ###########################################
  sub semset {
  ###########################################
      my($self, @values) = @_;
  
      print "Setting values for semaphore $self->{key}/$self->{ikey}\n" if
          INTERNAL_DEBUG;
  
      my $sem = IPC::Semaphore->new($self->{ikey}, 1, 0);
      $sem->set(@values);
  }
  
  ###########################################
  sub semlock {
  ###########################################
      my($self) = @_;
  
      my $operation = pack("s!*", 
                            # wait until it's 0
                           0, 0, 0,
                            # increment by 1
                           0, 1, SEM_UNDO
                          );
  
      print "Locking semaphore '$self->{key}'\n" if INTERNAL_DEBUG;
      $self->semop($self->{id}, $operation);
  }
  
  ###########################################
  sub semunlock {
  ###########################################
      my($self) = @_;
  
  #    my $operation = pack("s!*", 
  #                          # decrement by 1
  #                         0, -1, SEM_UNDO
  #                        );
  #
      print "Unlocking semaphore '$self->{key}'\n" if INTERNAL_DEBUG;
  
  #      # ignore errors, as they might result from trying to unlock an
  #      # already unlocked semaphore.
  #    semop($self->{id}, $operation);
  
      semctl $self->{id}, 0, SETVAL, 0;
  }
  
  ###########################################
  sub remove {
  ###########################################
      my($self) = @_;
  
      print "Removing semaphore '$self->{key}/$self->{id}'\n" if INTERNAL_DEBUG;
  
      semctl ($self->{id}, 0, &IPC_RMID, 0) or 
          die "Removing semaphore $self->{key} failed: $!";
  }
  
  ###########################################
  sub DESTROY {
  ###########################################
      my($self) = @_;
  
      if($self->{destroy} && $$==$self->{creator}) {
          $self->remove();
      }
  }
  
  ###########################################
  sub semop {
  ###########################################
      my($self, @args) = @_;
  
      my $retries     = $self->{semop_retries};
  
      my $rc;
  
      {
          $rc = semop($args[0], $args[1]);
  
          if(!$rc and 
             $! =~ /temporarily unavailable/ and
             $retries-- > 0) {
              $rc = 'undef' unless defined $rc;
              print "semop failed (rc=$rc), retrying\n", 
                    $self->status_as_string if INTERNAL_DEBUG;
              select undef, undef, undef, $self->{semop_wait};
              redo;
          }
      }
  
      $rc or die "semop(@args) failed: $! ";
      $rc;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Util::Semaphore - Easy to use semaphores
  
  =head1 SYNOPSIS
  
      use Log::Log4perl::Util::Semaphore;
      my $sem = Log::Log4perl::Util::Semaphore->new( key => "abc" );
  
      $sem->semlock();
        # ... critical section 
      $sem->semunlock();
  
      $sem->semset( uid  => (getpwnam("hugo"))[2], 
                    gid  => 102,
                    mode => 0644
                  );
  
  =head1 DESCRIPTION
  
  Log::Log4perl::Util::Semaphore provides the synchronisation mechanism
  for the Synchronized.pm appender in Log4perl, but can be used independently
  of Log4perl.
  
  As a convenience, the C<uid> field accepts user names as well, which it 
  translates into the corresponding uid by running C<getpwnam>.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_UTIL_SEMAPHORE

$fatpacked{"Log/Log4perl/Util/TimeTracker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_UTIL_TIMETRACKER';
  ##################################################
  package Log::Log4perl::Util::TimeTracker;
  ##################################################
  
  use 5.006;
  use strict;
  use warnings;
  use Log::Log4perl::Util;
  use Carp;
  
  our $TIME_HIRES_AVAILABLE;
  
  BEGIN {
      # Check if we've got Time::HiRes. If not, don't make a big fuss,
      # just set a flag so we know later on that we can't have fine-grained
      # time stamps
      $TIME_HIRES_AVAILABLE = 0;
      if(Log::Log4perl::Util::module_available("Time::HiRes")) {
          require Time::HiRes;
          $TIME_HIRES_AVAILABLE = 1;
      }
  }
  
  ##################################################
  sub new {
  ##################################################
      my $class = shift;
      $class = ref ($class) || $class;
  
      my $self = {
          reset_time            => undef,
          @_,
      };
  
      $self->{time_function} = \&_gettimeofday unless 
          defined $self->{time_function};
  
      bless $self, $class;
  
      $self->reset();
  
      return $self;
  }
  
  ##################################################
  sub hires_available {
  ##################################################
      return $TIME_HIRES_AVAILABLE;
  }
  
  ##################################################
  sub _gettimeofday {
  ##################################################
      # Return secs and optionally msecs if we have Time::HiRes
      if($TIME_HIRES_AVAILABLE) {
          return (Time::HiRes::gettimeofday());
      } else {
          return (time(), 0);
      }
  }
  
  ##################################################
  sub gettimeofday {
  ##################################################
      my($self) = @_;
  
      my($seconds, $microseconds) = $self->{time_function}->();
  
      $microseconds = 0 if ! defined $microseconds;
      return($seconds, $microseconds);
  }
  
  ##################################################
  sub reset {
  ##################################################
      my($self) = @_;
  
      my $current_time = [$self->gettimeofday()];
      $self->{reset_time} = $current_time;
      $self->{last_call_time} = $current_time;
  
      return $current_time;
  }
  
  ##################################################
  sub time_diff {
  ##################################################
      my($time_from, $time_to) = @_;
  
      my $seconds = $time_to->[0] -
                    $time_from->[0];
  
      my $milliseconds = int(( $time_to->[1] -
                               $time_from->[1] ) / 1000);
  
      if($milliseconds < 0) {
          $milliseconds = 1000 + $milliseconds;
          $seconds--;
      }
  
      return($seconds, $milliseconds);
  }
  
  ##################################################
  sub milliseconds {
  ##################################################
      my($self, $current_time) = @_;
  
      $current_time = [ $self->gettimeofday() ] unless
          defined $current_time;
  
      my($seconds, $milliseconds) = time_diff(
              $self->{reset_time}, 
              $current_time);
  
      return $seconds*1000 + $milliseconds;
  }
  
  ##################################################
  sub delta_milliseconds {
  ##################################################
      my($self, $current_time) = @_;
  
      $current_time = [ $self->gettimeofday() ] unless
          defined $current_time;
  
      my($seconds, $milliseconds) = time_diff(
              $self->{last_call_time}, 
              $current_time);
  
      $self->{last_call_time} = $current_time;
  
      return $seconds*1000 + $milliseconds;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Util::TimeTracker - Track time elapsed
  
  =head1 SYNOPSIS
  
    use Log::Log4perl::Util::TimeTracker;
  
    my $timer = Log::Log4perl::Util::TimeTracker->new();
  
      # equivalent to Time::HiRes::gettimeofday(), regardless
      # if Time::HiRes is present or not. 
    my($seconds, $microseconds) = $timer->gettimeofday();
  
      # reset internal timer
    $timer->reset();
  
      # return milliseconds since last reset
    $msecs = $timer->milliseconds();
  
      # return milliseconds since last call
    $msecs = $timer->delta_milliseconds();
  
  =head1 DESCRIPTION
  
  This utility module helps tracking time elapsed for PatternLayout's
  date and time placeholders. Its accuracy depends on the availability
  of the Time::HiRes module. If it's available, its granularity is
  milliseconds, if not, seconds.
  
  The most common use of this module is calling the gettimeofday() 
  method:
  
    my($seconds, $microseconds) = $timer->gettimeofday();
  
  It returns seconds and microseconds of the current epoch time. If 
  Time::HiRes is installed, it will simply defer to its gettimeofday()
  function, if it's missing, time() will be called instead and $microseconds
  will always be 0.
  
  To measure time elapsed in milliseconds, use the reset() method to 
  reset the timer to the current time, followed by one or more calls to
  the milliseconds() method:
  
      # reset internal timer
    $timer->reset();
  
      # return milliseconds since last reset
    $msecs = $timer->milliseconds();
  
  On top of the time span between the last reset and the current time, 
  the module keeps track of the time between calls to delta_milliseconds():
  
    $msecs = $timer->delta_milliseconds();
  
  On the first call, this will return the number of milliseconds since the
  last reset(), on subsequent calls, it will return the time elapsed in
  milliseconds since the last call to delta_milliseconds() instead. Note
  that reset() also resets the time of the last call.
  
  The internal timer of this module gets its time input from the POSIX time() 
  function, or, if the Time::HiRes module is available, from its 
  gettimeofday() function. To figure out which one it is, use
  
      if( $timer->hires_available() ) {
          print "Hooray, we get real milliseconds!\n";
      } else {
          print "Milliseconds are just bogus\n";
      }
  
  For testing purposes, a different time source can be provided, so test
  suites can simulate time passing by without actually having to wait:
  
    my $start_time = time();
  
    my $timer = Log::Log4perl::Util::TimeTracker->new(
            time_function => sub {
                return $start_time++;
            },
    );
  
  Every call to $timer->epoch() will then return a time value that is one
  second ahead of the value returned on the previous call. This also means
  that every call to delta_milliseconds() will return a value that exceeds
  the value returned on the previous call by 1000.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_UTIL_TIMETRACKER

$fatpacked{"Net/OpenSSH.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH';
  package Net::OpenSSH;
  
  our $VERSION = '0.82';
  
  use strict;
  use warnings;
  
  our $debug ||= 0;
  our $debug_fh ||= \*STDERR;
  
  our $FACTORY;
  
  use Carp qw(carp croak);
  use POSIX qw(:sys_wait_h);
  use Socket;
  use File::Spec;
  use Cwd ();
  use Scalar::Util ();
  use Errno ();
  use Net::OpenSSH::Constants qw(:error :_state);
  use Net::OpenSSH::ModuleLoader;
  use Net::OpenSSH::ShellQuoter;
  use Digest::MD5;
  
  my $thread_generation = 0;
  
  sub CLONE { $thread_generation++ };
  
  sub _debug {
      local ($!, $@);
      print {$debug_fh} '# ', (map { defined($_) ? $_ : '<undef>' } @_), "\n"
  }
  
  sub _debug_dump {
      local ($!, $@);
      require Data::Dumper;
      local $Data::Dumper::Terse = 1;
      local $Data::Dumper::Indent = 0;
      my $head = shift;
      _debug("$head: ", Data::Dumper::Dumper(@_));
  }
  
  sub _hexdump {
      no warnings qw(uninitialized);
      my $data = shift;
      while ($data =~ /(.{1,32})/smg) {
          my $line=$1;
          my @c= (( map { sprintf "%02x",$_ } unpack('C*', $line)),
                  (("  ") x 32))[0..31];
          $line=~s/(.)/ my $c=$1; unpack("c",$c)>=32 ? $c : '.' /egms;
          print {$debug_fh} "#> ", join(" ", @c, '|', $line), "\n";
      }
  }
  
  {
      my %good;
  
      sub _sub_options {
          my $sub = shift;
          $good{__PACKAGE__ . "::$sub"} = { map { $_ => 1 } @_ };
      }
  
      sub _croak_bad_options (\%) {
          my $opts = shift;
          if (%$opts) {
  	    my $sub = (caller 1)[3];
              my $good = $good{$sub};
              my @keys = grep defined($opts->{$_}), ( $good ? grep !$good->{$_}, keys %$opts : keys %$opts);
              if (@keys) {
                  croak "Invalid or bad combination of options ('" . CORE::join("', '", @keys) . "')";
              }
          }
      }
  }
  
  sub _croak_scalar_context {
      my ($sub, $wantarray) = (caller 1)[3, 5];
      unless ($wantarray) {
          $sub =~ s/^.*:://;
          croak "method '$sub' called in scalar context";
      }
  }
  
  sub _tcroak {
      if (${^TAINT} > 0) {
  	push @_, " while running with -T switch";
          goto &croak;
      }
      if (${^TAINT} < 0) {
  	push @_, " while running with -t switch";
          goto &carp;
      }
  }
  
  sub _catch_tainted_args {
      my $i;
      for (@_) {
          next unless $i++;
          if (Scalar::Util::tainted($_)) {
              my (undef, undef, undef, $subn) = caller 1;
              my $msg = ( $subn =~ /::([a-z]\w*)$/
                          ? "Insecure argument '$_' on '$1' method call"
                          : "Insecure argument '$_' on method call" );
              _tcroak($msg);
          }
          elsif (ref($_) eq 'HASH') {
              for (grep Scalar::Util::tainted($_), values %$_) {
  		my (undef, undef, undef, $subn) = caller 1;
  		my $msg = ( $subn =~ /::([a-z]\w*)$/
  			    ? "Insecure argument on '$1' method call"
  			    : "Insecure argument on method call" );
  		_tcroak($msg);
              }
          }
      }
  }
  
  sub _set_error {
      my $self = shift;
      my $code = shift || 0;
      my @extra = grep defined, @_;
      my $err = $self->{_error} = ( $code
                                    ? Scalar::Util::dualvar($code, join(': ', @{$self->{_error_prefix}},
                                                                        (@extra ? @extra : "Unknown error $code")))
                                    : 0 );
      $debug and $debug & 1 and _debug "set_error($code - $err)";
      return $err
  }
  
  my $check_eval_re = do {
      my $path = quotemeta $INC{"Net/OpenSSH.pm"};
      qr/at $path line \d+.$/
  };
  
  sub _check_eval_ok {
      my ($self, $code) = @_;
      if ($@) {
          my $err = $@;
          $err =~ s/$check_eval_re//;
          $self->_set_error($code, $err);
          return;
      }
      1
  }
  
  sub _or_set_error {
      my $self = shift;
      $self->{_error} or $self->_set_error(@_);
  }
  
  sub _first_defined { defined && return $_ for @_; return }
  
  my $obfuscate = sub {
      # just for the casual observer...
      my $txt = shift;
      $txt =~ s/(.)/chr(ord($1) ^ 47)/ges
          if defined $txt;
      $txt;
  };
  
  my $deobfuscate = $obfuscate;
  
  # regexp from Regexp::IPv6
  my $IPv6_re = qr((?-xism::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))));
  
  sub parse_connection_opts {
      my ($class, $opts) = @_;
      my ($user, $passwd, $ipv6, $host, $port, $host_squared);
  
      my $target = delete $opts->{host};
      defined $target or croak "mandatory host argument missing";
  
      ($user, $passwd, $ipv6, $host, $port) =
          $target =~ m{^
                         \s*               # space
                         (?:
                           ([^:]+)         # username
                           (?::(.*))?      # : password
                           \@              # @
                         )?
                         (?:               # host
                            (              #   IPv6...
                              \[$IPv6_re(?:\%[^\[\]]*)\] #     [IPv6]
                              |            #     or
                              $IPv6_re     #     IPv6
                            )
                            |              #   or
                            ([^\[\]\@:]+)  #   hostname / ipv4
                         )
                         (?::([^\@:]+))?   # port
                         \s*               # space
                       $}ix
                  or croak "bad host/target '$target' specification";
  
      if (defined $ipv6) {
          ($host) = $ipv6 =~ /^\[?(.*?)\]?$/;
          $host_squared = "[$host]";
      }
      else {
          $host_squared = $host;
      }
  
      $user = delete $opts->{user} unless defined $user;
      $port = delete $opts->{port} unless defined $port;
      $passwd = delete $opts->{passwd} unless defined $passwd;
      $passwd = delete $opts->{password} unless defined $passwd;
  
      wantarray and return ($host, $port, $user, $passwd, $host_squared);
  
      my %r = ( user => $user,
                password => $passwd,
                host => $host,
                host_squared => $host_squared,
                port => $port );
      $r{ipv6} = 1 if defined $ipv6;
      return \%r;
  }
  
  my $sizeof_sun_path = ($^O eq 'linux' ? 108 :
                         $^O =~ /bsd/i  ? 104 :
                         $^O eq 'hpux'  ? 92  : undef);
  
  sub new {
      ${^TAINT} and &_catch_tainted_args;
  
      my $class = shift;
      @_ & 1 and unshift @_, 'host';
  
      return $FACTORY->($class, @_) if defined $FACTORY;
  
      my %opts = @_;
  
      my $external_master = delete $opts{external_master};
      # reuse_master is an obsolete alias:
      $external_master = delete $opts{reuse_master} unless defined $external_master;
  
      if (not defined $opts{host} and defined $external_master) {
          $opts{host} = '0.0.0.0';
      }
  
      my ($host, $port, $user, $passwd, $host_squared) = $class->parse_connection_opts(\%opts);
  
      my ($passphrase, $key_path, $login_handler);
      unless (defined $passwd) {
          $key_path = delete $opts{key_path};
          $passwd = delete $opts{passphrase};
          if (defined $passwd) {
              $passphrase = 1;
          }
          else {
              $login_handler = delete $opts{login_handler};
          }
      }
  
      my $ssh_version = delete $opts{ssh_version};
      my $batch_mode = delete $opts{batch_mode};
      my $ctl_path = delete $opts{ctl_path};
      my $ctl_dir = delete $opts{ctl_dir};
      my $proxy_command = delete $opts{proxy_command};
      my $gateway = delete $opts{gateway} unless defined $proxy_command;
      my $ssh_cmd = _first_defined delete $opts{ssh_cmd}, 'ssh';
      my $rsync_cmd = _first_defined delete $opts{rsync_cmd}, 'rsync';
      my $scp_cmd = delete $opts{scp_cmd};
      my $sshfs_cmd = _first_defined delete $opts{sshfs_cmd}, 'sshfs';
      my $sftp_server_cmd = _first_defined delete $opts{sftp_server_cmd},
                                           '/usr/lib/openssh/sftp-server';
      my $timeout = delete $opts{timeout};
      my $kill_ssh_on_timeout = delete $opts{kill_ssh_on_timeout};
      my $strict_mode = _first_defined delete $opts{strict_mode}, 1;
      my $connect = _first_defined delete $opts{connect}, 1;
      my $async = delete $opts{async};
      my $remote_shell = _first_defined delete $opts{remote_shell}, 'POSIX';
      my $expand_vars = delete $opts{expand_vars};
      my $vars = _first_defined delete $opts{vars}, {};
      my $default_encoding = delete $opts{default_encoding};
      my $default_stream_encoding =
          _first_defined delete $opts{default_stream_encoding}, $default_encoding;
      my $default_argument_encoding =
          _first_defined delete $opts{default_argument_encoding}, $default_encoding;
      my $forward_agent = delete $opts{forward_agent};
      $forward_agent and $passphrase and
          croak "agent forwarding can not be used when a passphrase has also been given";
      my $forward_X11 = delete $opts{forward_X11};
      my $passwd_prompt = delete $opts{password_prompt};
      my $master_pty_force = delete $opts{master_pty_force};
      $passwd_prompt = delete $opts{passwd_prompt} unless defined $passwd_prompt;
  
      my ($master_opts, @master_opts,
          $master_stdout_fh, $master_stderr_fh,
  	$master_stdout_discard, $master_stderr_discard,
          $master_setpgrp);
      unless ($external_master) {
          ($master_stdout_fh = delete $opts{master_stdout_fh} or
           $master_stdout_discard = delete $opts{master_stdout_discard});
  
          ($master_stderr_fh = delete $opts{master_stderr_fh} or
           $master_stderr_discard = delete $opts{master_stderr_discard});
  
          $master_opts = delete $opts{master_opts};
          if (defined $master_opts) {
              if (ref $master_opts) {
                  @master_opts = @$master_opts;
              }
              else {
                  carp "'master_opts' argument looks like if it should be splited first"
                      if $master_opts =~ /^-\w\s+\S/;
                  @master_opts = $master_opts;
              }
          }
          $master_setpgrp = delete $opts{master_setpgrp};
  
          # when a password/passphrase is given, calling setpgrp is
          # useless because the process runs attached to a different tty
          undef $master_setpgrp if $login_handler or defined $passwd;
      }
  
      my $default_ssh_opts = delete $opts{default_ssh_opts};
      carp "'default_ssh_opts' argument looks like if it should be splited first"
          if defined $default_ssh_opts and not ref $default_ssh_opts and $default_ssh_opts =~ /^-\w\s+\S/;
  
      my ($default_stdout_fh, $default_stderr_fh, $default_stdin_fh,
  	$default_stdout_file, $default_stderr_file, $default_stdin_file,
  	$default_stdout_discard, $default_stderr_discard, $default_stdin_discard);
  
      $default_stdout_file = (delete $opts{default_stdout_discard}
  			    ? '/dev/null'
  			    : delete $opts{default_stdout_file});
      $default_stdout_fh = delete $opts{default_stdout_fh}
  	unless defined $default_stdout_file;
  
      $default_stderr_file = (delete $opts{default_stderr_discard}
  			    ? '/dev/null'
  			    : delete $opts{default_stderr_file});
      $default_stderr_fh = delete $opts{default_stderr_fh}
  	unless defined $default_stderr_file;
  
      $default_stdin_file = (delete $opts{default_stdin_discard}
  			    ? '/dev/null'
  			    : delete $opts{default_stdin_file});
      $default_stdin_fh = delete $opts{default_stdin_fh}
  	unless defined $default_stdin_file;
  
      _croak_bad_options %opts;
  
      my @ssh_opts;
      # TODO: are those options really requiered or just do they eat on
      # the command line limited length?
      push @ssh_opts, -l => $user if defined $user;
      push @ssh_opts, -p => $port if defined $port;
  
      my $home = do {
  	local ($@, $SIG{__DIE__});
  	eval { Cwd::realpath((getpwuid $>)[7]) }
      };
  
      if (${^TAINT}) {
  	($home) = $home =~ /^(.*)$/;
  	Scalar::Util::tainted($ENV{PATH}) and
  		_tcroak('Insecure $ENV{PATH}');
      }
  
      my $self = { _error => 0,
  		 _error_prefix => [],
  		 _perl_pid => $$,
                   _thread_generation => $thread_generation,
                   _ssh_version => $ssh_version,
                   _ssh_cmd => $ssh_cmd,
  		 _scp_cmd => $scp_cmd,
  		 _rsync_cmd => $rsync_cmd,
                   _sshfs_cmd => $sshfs_cmd,
                   _sftp_server_cmd => $sftp_server_cmd,
                   _pid => undef,
                   _host => $host,
  		 _host_squared => $host_squared,
                   _user => $user,
                   _port => $port,
                   _passwd => $obfuscate->($passwd),
                   _passwd_prompt => $passwd_prompt,
                   _passphrase => $passphrase,
                   _key_path => $key_path,
                   _login_handler => $login_handler,
                   _timeout => $timeout,
                   _proxy_command => $proxy_command,
                   _gateway_args => $gateway,
                   _kill_ssh_on_timeout => $kill_ssh_on_timeout,
                   _batch_mode => $batch_mode,
                   _home => $home,
                   _forward_agent => $forward_agent,
                   _forward_X11 => $forward_X11,
                   _external_master => $external_master,
                   _default_ssh_opts => $default_ssh_opts,
  		 _default_stdin_fh => $default_stdin_fh,
  		 _default_stdout_fh => $default_stdout_fh,
  		 _default_stderr_fh => $default_stderr_fh,
  		 _master_stdout_fh => $master_stdout_fh,
  		 _master_stderr_fh => $master_stderr_fh,
  		 _master_stdout_discard => $master_stdout_discard,
  		 _master_stderr_discard => $master_stderr_discard,
                   _master_setpgrp => $master_setpgrp,
                   _master_pty_force => $master_pty_force,
  		 _remote_shell => $remote_shell,
                   _default_stream_encoding => $default_stream_encoding,
                   _default_argument_encoding => $default_argument_encoding,
  		 _expand_vars => $expand_vars,
  		 _vars => $vars,
                   _master_state => _STATE_START,
                 };
      bless $self, $class;
  
      $self->_detect_ssh_version;
  
      # default file handles are opened so late in order to have the
      # $self object to report errors
      $self->{_default_stdout_fh} = $self->_open_file('>', $default_stdout_file)
  	if defined $default_stdout_file;
      $self->{_default_stderr_fh} = $self->_open_file('>', $default_stderr_file)
  	if defined $default_stderr_file;
      $self->{_default_stdin_fh} = $self->_open_file('<', $default_stdin_file)
  	if defined $default_stdin_file;
  
      if ($self->{_error} == OSSH_SLAVE_PIPE_FAILED) {
          $self->_master_fail($async, "Unable to create default slave stream", $self->{_error});
          return $self;
      }
  
      $self->{_ssh_opts} = [$self->_expand_vars(@ssh_opts)];
      $self->{_master_opts} = [$self->_expand_vars(@master_opts)];
  
      $ctl_path = $self->_expand_vars($ctl_path);
      $ctl_dir = $self->_expand_vars($ctl_dir);
  
      if  (defined $ctl_path) {
          if ($external_master) {
              unless (-S $ctl_path) {
                  $self->_master_fail($async, "ctl_path $ctl_path does not point to a socket");
                  return $self;
              }
          }
          else {
              if (-e $ctl_path) {
                  $self->_master_fail($async, "unable to use ctl_path $ctl_path, a file object already exists there");
                  return $self;
              }
          }
      }
      else {
          $external_master and croak "external_master is set but ctl_path is not defined";
  
          unless (defined $ctl_dir) {
              unless (defined $self->{_home}) {
                  $self->_master_fail($async, "unable to determine home directory for uid $>");
                  return $self;
              }
  
              $ctl_dir = File::Spec->catdir($self->{_home}, ".libnet-openssh-perl");
          }
  
          mkdir $ctl_dir, 0700;
          unless (-d $ctl_dir) {
              $self->_master_fail($async, "unable to create ctl_dir $ctl_dir");
              return $self;
          }
  
          my $target = join('-', grep defined, $user, $host, $port);
  
          for (1..10) {
              my $ctl_file = Digest::MD5::md5_hex(sprintf "%s-%d-%d-%d", $target, $$, time, rand 1e6);
              $ctl_path = File::Spec->join($ctl_dir, $ctl_file);
              last unless -e $ctl_path
          }
          if (-e $ctl_path) {
              $self->_master_fail($async, "unable to find unused name for ctl_path inside ctl_dir $ctl_dir");
              return $self;
          }
      }
  
      if (defined $sizeof_sun_path and length $ctl_path > $sizeof_sun_path) {
          $self->_master_fail($async, "ctl_path $ctl_path is too long (max permissible size for $^O is $sizeof_sun_path)");
          return $self;
      }
  
      $ctl_dir = File::Spec->catpath((File::Spec->splitpath($ctl_path))[0,1], "");
      $debug and $debug & 2 and _debug "ctl_path: $ctl_path, ctl_dir: $ctl_dir";
  
      if ($strict_mode and !$self->_is_secure_path($ctl_dir)) {
   	$self->_master_fail($async, "ctl_dir $ctl_dir is not secure");
   	return $self;
      }
  
      $self->{_ctl_path} = $ctl_path;
  
      $self->_master_wait($async) if $connect;
  
      $self;
  }
  
  sub get_user { shift->{_user} }
  sub get_host { shift->{_host} }
  sub get_port { shift->{_port} }
  sub get_master_pid { shift->{_pid} }
  sub get_ctl_path { shift->{_ctl_path} }
  sub get_expand_vars { shift->{_expand_vars} }
  
  sub get_master_pty_log { shift->{_master_pty_log} }
  
  sub set_expand_vars {
      my $self = shift;
      $self->{_expand_vars} = (shift(@_) ? 1 : 0);
  }
  
  sub set_var {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my $k = shift;
      $k =~ /^(?:USER|HOST|PORT)$/
  	and croak "internal variable %$k% can not be set";
      $self->{_vars}{$k} = shift;
  }
  
  sub get_var {
      my ($self, $k) = @_;
      my $v = ( $k =~ /^(?:USER|HOST|PORT)$/
  	      ? $self->{lc "_$k"}
  	      : $self->{_vars}{$k} );
      (defined $v ? $v : '');
  }
  
  sub _expand_vars {
      my ($self, @str) = @_;
      if (ref $self and $self->{_expand_vars}) {
  	for (@str) {
  	    s{%(\w*)%}{length ($1) ? $self->get_var($1) : '%'}ge
  		if defined $_;
  	}
      }
      wantarray ? @str : $str[0]
  }
  
  sub error { shift->{_error} }
  
  sub die_on_error {
      my $ssh = shift;
      $ssh->{_error} and croak(@_ ? "@_: $ssh->{_error}" : $ssh->{_error});
  }
  
  
  sub _is_secure_path {
      my ($self, $path) = @_;
      my @parts = File::Spec->splitdir(Cwd::realpath($path));
      my $home = $self->{_home};
      for my $last (reverse 0..$#parts) {
          my $dir = File::Spec->catdir(@parts[0..$last]);
          unless (-d $dir) {
              $debug and $debug & 2 and _debug "$dir is not a directory";
              return undef;
          }
          my ($mode, $uid) = (stat $dir)[2, 4];
          $debug and $debug & 2 and _debug "_is_secure_path(dir: $dir, file mode: $mode, file uid: $uid, euid: $>";
          return undef unless(($uid == $> or $uid == 0 ) and (($mode & 022) == 0 or ($mode & 01000)));
          return 1 if (defined $home and $home eq $dir);
      }
      return 1;
  }
  
  sub _detect_ssh_version {
      my $self = shift;
      if (defined $self->{_ssh_version}) {
          $debug and $debug & 4 and _debug "ssh version given as $self->{_ssh_version}";
      }
      else {
          my (undef, $out, undef, $pid) = $self->open_ex({_cmd => 'raw',
                                                          _no_master_required => 1,
                                                          stdout_pipe => 1,
                                                          stdin_discard => 1,
                                                          stderr_to_stdout => 1 },
                                                         $self->{_ssh_cmd}, '-V');
          my ($txt) = $self->_io3($out, undef, undef, undef, 10, 'bytes');
          local $self->{_kill_ssh_on_timeout} = 1;
          $self->_waitpid($pid, 10);
          if (my ($full, $num) = $txt =~ /^OpenSSH_((\d+\.\d+)\S*)/mi) {
              $debug and $debug & 4 and _debug "OpenSSH version is $full";
              $self->{_ssh_version} = $num;
          }
          else {
              $self->{_ssh_version} = 0;
              $debug and $debug & 4 and _debug "unable to determine version, '$self->{_ssh_cmd} -V', output:\n$txt"
          }
      }
  }
  
  sub _make_ssh_call {
      my $self = shift;
      my @before = @{shift || []};
      my @args = ($self->{_ssh_cmd}, @before,
  		-S => $self->{_ctl_path},
                  @{$self->{_ssh_opts}}, $self->{_host},
                  '--',
                  (@_ ? "@_" : ()));
      $debug and $debug & 8 and _debug_dump 'call args' => \@args;
      @args;
  }
  
  sub _scp_cmd {
      my $self = shift;
      $self->{_scp_cmd} ||= do {
  	my $scp = $self->{_ssh_cmd};
  	$scp =~ s/ssh$/scp/i or croak "scp command name not set";
  	$scp;
      }
  }
  
  sub _make_scp_call {
      my $self = shift;
      my @before = @{shift || []};
      my @args = ($self->_scp_cmd, @before,
  		-o => "ControlPath=$self->{_ctl_path}",
                  -S => $self->{_ssh_cmd},
                  (defined $self->{_port} ? (-P => $self->{_port}) : ()),
                  '--', @_);
  
      $debug and $debug & 8 and _debug_dump 'scp call args' => \@args;
      @args;
  }
  
  sub _rsync_quote {
      my ($self, @args) = @_;
      for (@args) {
  	if (/['"\s]/) {
  	    s/"/""/g;
  	    $_ = qq|"$_"|;
  	}
  	s/%/%%/;
      }
      wantarray ? @args : join(' ', @args);
  }
  
  sub _make_rsync_call {
      my $self = shift;
      my $before = shift;
      my @transport = ($self->{_ssh_cmd}, @$before,
                      -S => $self->{_ctl_path});
      my $transport = $self->_rsync_quote(@transport);
      my @args = ( $self->{_rsync_cmd},
  		 -e => $transport,
  		 @_);
  
      $debug and $debug & 8 and _debug_dump 'rsync call args' => \@args;
      @args;
  }
  
  sub _make_W_option {
      my $self = shift;
      if (@_ == 1) {
          my $path = shift;
          $path = "./$path" unless $path =~ m|/|;
          $path =~ s/([\\:])/\\$1/g;
          return "-W$path";
      }
      if (@_ == 2) {
          return "-W" . join(':', @_);
      }
      croak "bad number of arguments for creating a tunnel"
  }
  
  sub _make_tunnel_call {
      my $self = shift;
      my @before = @{shift||[]};
      push @before, $self->_make_W_option(@_);
      my @args = $self->_make_ssh_call(\@before);
      $debug and $debug & 8 and _debug_dump 'tunnel call args' => \@args;
      @args;
  }
  
  sub master_exited {
      my $self = shift;
      $self->_master_gone(1)
  }
  
  sub _master_gone {
      my $self = shift;
      my $async = shift;
      delete $self->{_pid};
      $self->_master_fail($async, (@_ ? @_ : "master process exited unexpectedly"));
  }
  
  my @kill_signal = qw(0 0 TERM TERM TERM KILL);
  
  sub __has_sigchld_handle {
      my $h = $SIG{CHLD};
      defined $h and $h ne 'IGNORE' and $h ne 'DEFAULT'
  }
  
  sub _master_kill {
      my ($self, $async) = @_;
  
      if (my $pid = $self->_my_master_pid) {
          $debug and $debug & 32 and _debug '_master_kill: ', $pid;
  
          my $now = time;
          my $start = $self->{_master_kill_start} ||= $now;
          $self->{_master_kill_last} ||= $now;
          $self->{_master_kill_count} ||= 0;
  
          local $SIG{CHLD} = sub {} unless $async or __has_sigchld_handle;
          while (1) {
              if ($self->{_master_kill_last} < $now) {
                  $self->{_master_kill_last} = $now;
                  my $sig = $kill_signal[$self->{_master_kill_count}++];
                  $sig = 'KILL' unless defined $sig;
                  $debug and $debug & 32 and _debug "killing master $$ with signal $sig";
                  kill $sig, $pid;
              }
              my $deceased = waitpid($pid, WNOHANG);
              $debug and $debug & 32 and _debug "waitpid(master: $pid) => pid: $deceased, rc: $!";
              last if $deceased == $pid or ($deceased < 0 and $! == Errno::ECHILD());
              if ($self->{_master_kill_count} > 20) {
                  # FIXME: remove the hard-coded 20 retries?
                  $debug and $debug & 32 and _debug "unable to kill SSH master process, giving up";
                  last;
              }
              return if $async;
              select(undef, undef, undef, 0.2);
              $now = time;
          }
      }
      else {
          $debug and $debug & 32 and _debug("not killing master SSH (", $self->{_pid}, ") started from " .
                                            "process ", $self->{_perl_pid}, "/", $self->{_thread_generation},
                                            ", current ", $$, "/", $thread_generation, ")");
      }
      $self->_master_gone($async);
  }
  
  sub disconnect {
      my ($self, $async) = @_;
      @_ <= 2 or croak 'Usage: $self->disconnect([$async])';
      $self->_disconnect($async, 1);
  }
  
  sub disown_master {
      my $self = shift;
      if (my $pid = $self->_my_master_pid) {
          if ($self->wait_for_master) {
              $self->{_external_master} = 1;
              return $pid;
          }
      }
      undef;
  }
  
  sub restart {
      my ($self, $async) = @_;
      $self->{_external_master} and croak "Can restart SSH connection when using external master";
  
      # user is responsible for calling us in STATE_GONE in async mode
      $self->_disconnect($async, 1) unless $async;
  
      if ($self->{_master_state} != _STATE_GONE) {
  	croak "restart method called in wrong state (terminate the connection first!)" if $async;
  	return $self->_master_fail($async, "Unable to restart SSH session from state $self->{_master_state}")
      }
  
      # These slots should be deleted when exiting the KILLING state but
      # I like keeping them around for throubleshoting purposes.
      delete $self->{_master_kill_start};
      delete $self->{_master_kill_last};
      delete $self->{_master_kill_count};
      $self->_master_jump_state(_STATE_START, $async);
  }
  
  sub _my_master_pid {
      my $self = shift;
      unless ($self->{_external_master}) {
          my $pid = $self->{_pid};
          return $pid if
              $pid and $self->{_perl_pid} == $$ and $self->{_thread_generation} == $thread_generation;
      }
      ()
  }
  
  sub _disconnect {
      my ($self, $async, $send_ctl) = @_;
      return if $self->{_master_state} == _STATE_GONE;
  
      if (!$async and
          $self->{_master_state} == _STATE_RUNNING and
          ($send_ctl or $self->_my_master_pid)) {
          # we have successfully created the master connection so we
          # can send control commands:
          $debug and $debug & 32 and _debug("sending exit control to master");
          $self->_master_ctl('exit');
      }
      $self->_master_fail($async, 'aborted')
  }
  
  sub _check_is_system_fh {
      my ($name, $fh) = @_;
      my $fn = fileno(defined $fh ? $fh : $name);
      defined $fn and $fn >= 0 and return;
      croak "child process $name is not a real system file handle";
  }
  
  sub _master_redirect {
      my $self = shift;
      my $uname = uc shift;
      my $name = lc $uname;
  
      no strict 'refs';
      if ($self->{"_master_${name}_discard"}) {
  	open *$uname, '>>', '/dev/null';
      }
      else {
  	my $fh = $self->{"_master_${name}_fh"};
  	$fh = $self->{"_default_${name}_fh"} unless defined $fh;
  	if (defined $fh) {
  	    _check_is_system_fh $uname => $fh;
  	    if (fileno $fh != fileno *$uname) {
  		open *$uname, '>>&', $fh or POSIX::_exit(255);
  	    }
  	}
      }
  }
  
  sub _waitpid {
      my ($self, $pid, $timeout) = @_;
      $? = 0;
      if ($pid) {
          $timeout = $self->{_timeout} unless defined $timeout;
  
          my $time_limit;
          if (defined $timeout and $self->{_kill_ssh_on_timeout}) {
              $timeout = 0 if $self->{_error} == OSSH_SLAVE_TIMEOUT;
              $time_limit = time + $timeout;
          }
          local $SIG{CHLD} = sub {} unless __has_sigchld_handle;
  	while (1) {
              my $deceased;
              if (defined $time_limit) {
                  while (1) {
                      # TODO: we assume that all OSs return 0 when the
                      # process is still running, that may be wrong!
                      $deceased = waitpid($pid, WNOHANG) and last;
                      my $remaining = $time_limit - time;
                      if ($remaining <= 0) {
                          $debug and $debug & 16 and _debug "killing SSH slave, pid: $pid";
                          kill TERM => $pid;
                          $self->_or_set_error(OSSH_SLAVE_TIMEOUT, "ssh slave failed", "timed out");
                      }
                      # There is a race condition here. We try to
                      # minimize it keeping the waitpid and the select
                      # together and limiting the sleep time to 1s:
                      my $sleep = ($remaining < 0.1 ? 0.1 : 1);
                      $debug and $debug & 16 and
                          _debug "waiting for slave, timeout: $timeout, remaining: $remaining, sleep: $sleep";
                      $deceased = waitpid($pid, WNOHANG) and last;
                      select(undef, undef, undef, $sleep);
                  }
              }
              else {
                  $deceased = waitpid($pid, 0);
              }
              $debug and $debug & 16 and _debug "_waitpid($pid) => pid: $deceased, rc: $?, err: $!";
  	    if ($deceased == $pid) {
  		if ($?) {
  		    my $signal = ($? & 255);
  		    my $errstr = "child exited with code " . ($? >> 8);
  		    $errstr .= ", signal $signal" if $signal;
  		    $self->_or_set_error(OSSH_SLAVE_CMD_FAILED, $errstr);
  		    return undef;
  		}
  		return 1;
  	    }
  	    elsif ($deceased < 0) {
  		# at this point $deceased < 0 and so, $! has a valid error value.
  		next if $! == Errno::EINTR();
  		if ($! == Errno::ECHILD()) {
  		    $self->_or_set_error(OSSH_SLAVE_FAILED, "child process $pid does not exist", $!);
  		    return undef
  		}
  		warn "Internal error: unexpected error (".($!+0).": $!) from waitpid($pid) = $deceased. Report it, please!";
  	    }
  	    elsif ($deceased > 0) {
  		warn "Internal error: spurious process $deceased exited"
  	    }
  
  	    # wait a bit before trying again
  	    select(undef, undef, undef, 0.1);
  	}
      }
      else {
  	$self->_or_set_error(OSSH_SLAVE_FAILED, "spawning of new process failed");
  	return undef;
      }
  }
  
  sub check_master {
      my $self = shift;
      @_ and croak 'Usage: $ssh->check_master()';
      $self->_master_check(0);
  }
  
  sub wait_for_master {
      my ($self, $async) = @_;
      @_ <= 2 or croak 'Usage: $ssh->wait_for_master([$async])';
      $self->{_error} = 0
          unless $self->{_error} == OSSH_MASTER_FAILED;
      $self->_master_wait($async);
  }
  
  sub _master_start {
      my ($self, $async) = @_;
      $self->_set_error;
  
      my $timeout = int((($self->{_timeout} || 90) + 2)/3);
      my $ssh_flags= '-2MN';
      $ssh_flags .= ($self->{_forward_agent} ? 'A' : 'a') if defined $self->{_forward_agent};
      $ssh_flags .= ($self->{_forward_X11} ? 'X' : 'x');
      my @master_opts = (@{$self->{_master_opts}},
                         -o => "ServerAliveInterval=$timeout",
                         ($self->{_ssh_version} >= 5.6 ? (-o => "ControlPersist=no") : ()),
                        $ssh_flags);
  
      my ($mpty, $use_pty, $pref_auths);
      $use_pty = 1 if ( $self->{_master_pty_force} or
                        defined $self->{_login_handler} );
      if (defined $self->{_passwd}) {
          $use_pty = 1;
          $pref_auths = ($self->{_passphrase}
                         ? 'publickey'
                         : 'keyboard-interactive,password');
          push @master_opts, -o => 'NumberOfPasswordPrompts=1';
      }
      elsif ($self->{_batch_mode}) {
          push @master_opts, -o => 'BatchMode=yes';
      }
  
      if (defined $self->{_key_path}) {
          $pref_auths = 'publickey';
          push @master_opts, -i => $self->{_key_path};
      }
  
      my $proxy_command = $self->{_proxy_command};
  
      my $gateway;
      if (my $gateway_args = $self->{_gateway_args}) {
          if (ref $gateway_args eq 'HASH') {
              _load_module('Net::OpenSSH::Gateway');
              my $errors;
              unless ($gateway = Net::OpenSSH::Gateway->find_gateway(errors => $errors,
                                                                     host => $self->{_host}, port => $self->{_port},
                                                                     %$gateway_args)) {
                  return $self->_master_fail($async, 'Unable to build gateway object', join(', ', @$errors));
              }
          }
          else {
              $gateway = $gateway_args
          }
          $self->{_gateway} = $gateway;
          $gateway->before_ssh_connect or
              return $self->_master_fail($async, 'Gateway setup failed', join(', ', $gateway->errors));
          $proxy_command = $gateway->proxy_command;
      }
  
      if (defined $proxy_command) {
          push @master_opts, -o => "ProxyCommand=$proxy_command";
      }
  
      if ($use_pty) {
          _load_module('IO::Pty');
          $self->{_mpty} = $mpty = IO::Pty->new;
      }
  
      push @master_opts, -o => "PreferredAuthentications=$pref_auths"
          if defined $pref_auths;
  
      my @call = $self->_make_ssh_call(\@master_opts);
  
      my $pid = fork;
      unless ($pid) {
          defined $pid
              or return $self->_master_fail($async, "unable to fork ssh master: $!");
  
          if ($debug and $debug & 512) {
              require Net::OpenSSH::OSTracer;
              Net::OpenSSH::OSTracer->trace;
          }
  
          $mpty->make_slave_controlling_terminal if $mpty;
  
  	$self->_master_redirect('STDOUT');
  	$self->_master_redirect('STDERR');
  
          delete $ENV{SSH_ASKPASS} if defined $self->{_passwd};
          delete $ENV{SSH_AUTH_SOCK} if defined $self->{_passphrase};
  
          setpgrp if $self->{_master_setpgrp};
  
  	local $SIG{__DIE__};
          eval { exec @call };
          POSIX::_exit(255);
      }
      $self->{_pid} = $pid;
      1;
  }
  
  sub _master_check {
      my ($self, $async) = @_;
      my $error;
      if ($async) {
          if (-S $self->{_ctl_path}) {
              delete $self->{_master_pty_log};
              return 1
          }
          $error = "master SSH connection broken";
      }
      else {
          my $out = $self->_master_ctl('check');
          $error = $self->{_error};
          unless ($error) {
              my $pid = $self->{_pid};
              if ($out =~ /pid=(\d+)/) {
                  if (!$pid or $1 == $pid) {
                      delete $self->{_master_pty_log};
                      return 1;
                  }
                  $error = "bad ssh master at $self->{_ctl_path} socket owned by pid $1 (pid $pid expected)";
              }
              else {
                  $error = ($out =~ /illegal option/i
                            ? 'OpenSSH 4.1 or later required'
                            : 'unknown error');
              }
          }
      }
      $self->_master_fail($async, $error);
  }
  
  sub _master_fail {
      my $self = shift;
      my $async = shift;
      if ($self->{_error} != OSSH_MASTER_FAILED) {
          $self->_set_error(OSSH_MASTER_FAILED, @_);
      }
      $self->_master_jump_state($self->{_pid} ? _STATE_KILLING : _STATE_GONE, $async);
  }
  
  sub _master_jump_state {
      my ($self, $state, $async) = @_;
      $debug and $debug & 4 and _debug "master state jumping from $self->{_master_state} to $state";
      if ($state == $self->{_master_state} and
          $state != _STATE_KILLING and
          $state != _STATE_GONE) {
          croak "internal error: state jump to itself ($state)!";
      }
      $self->{_master_state} = $state;
      return $self->_master_wait($async);
  }
  
  sub _master_wait {
      my ($self, $async) = @_;
  
      my $pid = $self->_my_master_pid;
      if ($pid) {
  	my $deceased = waitpid($pid, WNOHANG);
          if ($deceased == $pid or ($deceased < 0 and $! == Errno::ECHILD())) {
              $debug and $debug & 4 and _debug "master $pid exited, rc:", $?,", err: ",$!;
              return $self->_master_gone($async);
          }
      }
  
      if ($self->{_master_state} == _STATE_RUNNING) {
          return 1 if -S $self->{_ctl_path};
          return $self->_master_fail($async, "master SSH connection broken");
      }
  
      if ($self->{_master_state} == _STATE_KILLING) {
          $debug and $debug & 4 and _debug "killing master";
          return $self->_master_kill($async);
      }
  
      if ($self->{_master_state} == _STATE_START) {
          if ($self->{_external_master}) {
              return ($self->_master_jump_state(_STATE_RUNNING, $async) and
                      $self->_master_check($async))
          }
  
          $self->_master_start($async) or return;
          if ($self->{_mpty}) {
              $self->{_wfm_bout} = '';
              $self->{_master_pty_log} = '';
              if (defined $self->{_passwd} or $self->{_login_handler}) {
                  return $self->_master_jump_state(_STATE_LOGIN, $async);
              }
          }
          return $self->_master_jump_state(_STATE_AWAITING_MUX, $async);
      }
  
      if ($self->{_master_state} == _STATE_GONE) {
  	if (my $mpty = delete $self->{_mpty}) {
  	    close($mpty)
  	}
  	return 0;
      }
      if ($self->{_master_state} == _STATE_STOPPED) {
          return 0;
      }
  
      # At this point we are either in state AWAITIN_MUX or LOGIN
  
      local $self->{_error_prefix} = [@{$self->{_error_prefix}},
  				    "unable to establish master SSH connection"];
  
      $pid or return $self->_master_gone($async,
                                         "perl process was forked or threaded before SSH connection had been established");
  
      my $old_tcpgrp;
      if ($self->{_master_setpgrp} and not $async and
          not $self->{_batch_mode} and not $self->{_external_master}) {
          $old_tcpgrp = POSIX::tcgetpgrp(0);
          if ($old_tcpgrp > 0) {
              # let the master process ask for passwords at the TTY
              POSIX::tcsetpgrp(0, $pid);
          }
          else {
              undef $old_tcpgrp;
          }
      }
  
      my $mpty = $self->{_mpty};
      my $fnopty;
      my $rv = '';
      if ($mpty and 
          ( $self->{_master_state} == _STATE_LOGIN or
            $self->{_master_state} == _STATE_AWAITING_MUX )) {
          $fnopty = fileno $mpty;
          vec($rv, $fnopty, 1) = 1
      }
  
      my $timeout = $self->{_timeout};
      my $dt = ($async ? 0 : 0.02);
      my $start_time = time;
      my $error;
  
      # Loop until the mux socket appears or something goes wrong:
      while (1) {
          $dt *= 1.10 if $dt < 0.2; # adaptative delay
          if (-e $self->{_ctl_path}) {
              $debug and $debug & 4 and _debug "file object found at $self->{_ctl_path}";
              last;
          }
          $debug and $debug & 4 and _debug "file object not yet found at $self->{_ctl_path}, state:", $self->{_master_state};
  
          if (defined $timeout and (time - $start_time) > $timeout) {
              $error = "login timeout";
              last;
          }
  
  	my $deceased = waitpid($pid, WNOHANG);
          if ($deceased == $pid or ($deceased < 0 and $! == Errno::ECHILD())) {
              $error = "master process exited unexpectedly";
              $error = "bad pass" . ($self->{_passphrase} ? 'phrase' : 'word') . " or $error"
                  if defined $self->{_passwd};
              delete $self->{_pid};
              last;
          }
  
          if ($self->{_login_handler} and $self->{_master_state} == _STATE_LOGIN) {
              local ($@, $SIG{__DIE__});
              if (eval { $self->{_login_handler}->($self, $mpty, \$self->{_wfm_bout}) }) {
                  $self->{_master_state} = _STATE_AWAITING_MUX;
                  next;
              }
              if ($@) {
                  $error = "custom login handler failed: $@";
                  last;
              }
              # fallback
          }
          else {
              # we keep reading from mpty even after leaving state
              # STATE_LOGIN in order to search for additional password
              # prompts.
              my $rv1 = $rv;
              my $n = select($rv1, undef, undef, $dt);
              if ($n > 0) {
                  vec($rv1, $fnopty, 1) or die "internal error";
                  my $read = sysread($mpty, $self->{_wfm_bout}, 4096, length $self->{_wfm_bout});
                  if ($read) {
                      $self->{_master_pty_log} .= substr($self->{_wfm_bout}, -$read);
                      if ((my $remove = length($self->{_master_pty_log}) - 4096) > 0) {
                          substr($self->{_master_pty_log}, 0, $remove) = ''
                      }
  
                      if ($self->{_wfm_bout} =~ /The authenticity of host.*can't be established/si) {
                          $error = "the authenticity of the target host can't be established; the remote host " .
                              "public key is probably not present in the '~/.ssh/known_hosts' file";
                          last;
                      }
  
                      if ($self->{_wfm_bout} =~ /WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED/si) {
                          $error = "the authenticity of the target host can't be established; the remote host " .
                              "public key doesn't match the one stored locally";
                          last;
                      }
  
                      my $passwd_prompt = _first_defined $self->{_passwd_prompt}, qr/[:?]/;
                      $passwd_prompt = quotemeta $passwd_prompt unless ref $passwd_prompt;
  
                      if ($self->{_master_state} == _STATE_LOGIN) {
                          if ($self->{_wfm_bout} =~ /^(.*$passwd_prompt)/s) {
                              $debug and $debug & 4 and _debug "passwd/passphrase requested ($1)";
                              print $mpty $deobfuscate->($self->{_passwd}) . "\n";
                              $self->{_wfm_bout} = ''; # reset
                              $self->{_master_state} = _STATE_AWAITING_MUX;
                          }
                      }
                      elsif (length($passwd_prompt) and $self->{_wfm_bout} =~ /^(.*$passwd_prompt)\s*$/s) {
                          $debug and $debug & 4 and _debug "passwd/passphrase requested again ($1)";
                          $error = "password authentication failed";
                          last;
                      }
                      next; # skip delay
                  }
              }
          }
          return if $async;
          select(undef, undef, undef, $dt);
      }
  
      if (defined $old_tcpgrp) {
          $debug and $debug & 4 and
              _debug("ssh pid: $pid, pgrp: ", getpgrp($pid),
                     ", \$\$: ", $$,
                     ", tcpgrp: ", POSIX::tcgetpgrp(0),
                     ", old_tcppgrp: ", $old_tcpgrp);
          local $SIG{TTOU} = 'IGNORE';
          POSIX::tcsetpgrp(0, $old_tcpgrp);
      }
  
      if ($error) {
          return $self->_master_fail($async, $error);
      }
  
      $self->_master_jump_state(_STATE_RUNNING, $async)
          and $self->_master_check($async);
  }
  
  sub _master_ctl {
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      my $cmd = shift;
  
      local $?;
      local $self->{_error_prefix} = [@{$self->{_error_prefix}},
                                      "control command failed"];
      $self->capture({ %opts,
                       encoding => 'bytes', # don't let the encoding
  					  # stuff get in the way
  		     stdin_discard => 1, tty => 0,
                       stderr_to_stdout => 1, ssh_opts => [-O => $cmd]});
  }
  
  sub stop {
      my ($self, $timeout) = @_;
      my $pid = $self->{_pid};
      local $self->{_kill_ssh_on_timeout} = 1;
      $self->_master_ctl({timeout => $timeout}, 'stop');
      unless ($self->{_error}) {
          $self->_set_error(OSSH_MASTER_FAILED, "master stopped");
          $self->_master_jump_state(_STATE_STOPPED, 1);
      }
  }
  
  sub _make_pipe {
      my $self = shift;
      my ($r, $w);
      if (pipe $r, $w) {
          my $old = select;
          select $r; $ |= 1;
          select $w; $ |= 1;
          select $old;
          return ($r, $w);
      }
      $self->_set_error(OSSH_SLAVE_PIPE_FAILED, "unable to create pipe: $!");
      return;
  }
  
  sub _remote_quoter {
      my ($self, $remote_shell) = @_;
      if (ref $self and (!defined $remote_shell or $remote_shell eq $self->{_remote_shell})) {
          return $self->{remote_quoter} ||= Net::OpenSSH::ShellQuoter->quoter($self->{_remote_shell});
      }
      Net::OpenSSH::ShellQuoter->quoter($remote_shell);
  }
  
  sub _quote_args {
      my $self = shift;
      my $opts = shift;
      ref $opts eq 'HASH' or die "internal error";
      my $quote = delete $opts->{quote_args};
      my $quote_extended = delete $opts->{quote_args_extended};
      my $glob_quoting = delete $opts->{glob_quoting};
      $quote = (@_ > 1) unless defined $quote;
  
      if ($quote) {
          my $remote_shell = delete $opts->{remote_shell};
          my $quoter = $self->_remote_quoter($remote_shell);
          my $quote_method = ($glob_quoting ? 'quote_glob' : 'quote');
  	# foo   => $quoter
  	# \foo  => $quoter_glob
  	# \\foo => no quoting at all and disable extended quoting as it is not safe
  	my @quoted;
  	for (@_) {
  	    if (ref $_) {
  		if (ref $_ eq 'SCALAR') {
  		    push @quoted, $quoter->quote_glob($self->_expand_vars($$_));
  		}
  		elsif (ref $_ eq 'REF' and ref $$_ eq 'SCALAR') {
  		    push @quoted, $self->_expand_vars($$$_);
  		    undef $quote_extended;
  		}
  		else {
  		    croak "invalid reference in remote command argument list"
  		}
  	    }
  	    else {
  		push @quoted, $quoter->$quote_method($self->_expand_vars($_));
  	    }
  	}
  
  	if ($quote_extended) {
              my @fragments;
              if ( $opts->{stdout_discard} and
                   ( $opts->{stderr_discard} or $opts->{stderr_to_stdout} ) ) {
                  @fragments = ('stdout_and_stderr_discard');
                  push @fragments, 'stdin_discard' if $opts->{stdin_discard};
              }
              else {
                  @fragments = grep $opts->{$_}, qw(stdin_discard stdout_discard
                                                    stderr_discard stderr_to_stdout);
              }
              push @quoted, $quoter->shell_fragments(@fragments);
  	}
  	wantarray ? @quoted : join(" ", @quoted);
      }
      else {
  	croak "reference found in argument list when argument quoting is disabled"
  	    if (grep ref, @_);
  
  	my @args = $self->_expand_vars(@_);
  	wantarray ? @args : join(" ", @args);
      }
  }
  
  sub shell_quote {
      shift->_quote_args({quote_args => 1}, @_);
  }
  
  sub shell_quote_glob {
      shift->_quote_args({quote_args => 1, glob_quoting => 1}, @_);
  }
  
  sub _array_or_scalar_to_list { map { defined($_) ? (ref $_ eq 'ARRAY' ? @$_ : $_ ) : () } @_ }
  
  sub make_remote_command {
      my $self = shift;
      $self->wait_for_master or return;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      my @ssh_opts = _array_or_scalar_to_list delete $opts{ssh_opts};
      my $tty = delete $opts{tty};
      my $ssh_flags = '';
      $ssh_flags .= ($tty ? 'qtt' : 'T') if defined $tty;
      if ($self->{_forward_agent}) {
  	my $forward_always = (($self->{_forward_agent} eq 'always') ? 1 : undef);
          my $forward_agent = _first_defined(delete($opts{forward_agent}), $forward_always);
          $ssh_flags .= ($forward_agent ? 'A' : 'a') if defined $forward_agent;
      }
      if ($self->{_forward_X11}) {
          my $forward_X11 = delete $opts{forward_X11};
          $ssh_flags .= ($forward_X11 ? 'X' : 'x');
      }
      my $tunnel = delete $opts{tunnel};
      my (@args);
      if ($tunnel) {
          push @ssh_opts, $self->_make_W_option(@_);
      }
      else {
          my $subsystem = delete $opts{subsystem};
          if ($subsystem) {
              push @ssh_opts, '-s';
              @_ == 1 or croak "wrong number of arguments for subsystem command";
          }
          @args = $self->_quote_args(\%opts, @_);
      }
      _croak_bad_options %opts;
  
      push @ssh_opts, "-$ssh_flags" if length $ssh_flags;
      my @call = $self->_make_ssh_call(\@ssh_opts, @args);
      if (wantarray) {
  	$debug and $debug & 16 and _debug_dump make_remote_command => \@call;
  	return @call;
      }
      else {
  	my $call = join ' ', $self->shell_quote(@call);
  	$debug and $debug & 16 and _debug_dump 'make_remote_command (quoted)' => $call;
  	return $call
      }
  }
  
  sub _open_file {
      my ($self, $default_mode, $name_or_args) = @_;
      my ($mode, @args) = (ref $name_or_args
  			 ? @$name_or_args
  			 : ($default_mode, $name_or_args));
      @args = $self->_expand_vars(@args);
      if (open my $fh, $mode, @args) {
  	return $fh;
      }
      else {
  	$self->_set_error(OSSH_SLAVE_PIPE_FAILED,
  			  "Unable to open file '$args[0]': $!");
  	return undef;
      }
  }
  
  sub _fileno_dup_over {
      my ($good_fn, $fh) = @_;
      if (defined $fh) {
          my $fn = fileno $fh;
          for (1..5) {
              $fn >= $good_fn and return $fn;
              $fn = POSIX::dup($fn);
          }
          POSIX::_exit(255);
      }
      undef;
  }
  
  sub _exec_dpipe {
      my ($self, $cmd, $io, $err) = @_;
      my $io_fd  = _fileno_dup_over(3 => $io);
      my $err_fd = _fileno_dup_over(3 => $err);
      POSIX::dup2($io_fd, 0);
      POSIX::dup2($io_fd, 1);
      POSIX::dup2($err_fd, 2) if defined $err_fd;
      if (ref $cmd) {
          exec @$cmd;
      }
      else {
          exec $cmd;
      }
  }
  
  sub _delete_stream_encoding {
      my ($self, $opts) = @_;
      _first_defined(delete $opts->{stream_encoding},
                     $opts->{encoding},
                     $self->{_default_stream_encoding});
  }
  
  sub _delete_argument_encoding {
      my ($self, $opts) = @_;
      _first_defined(delete $opts->{argument_encoding},
                     delete $opts->{encoding},
                     $self->{_default_argument_encoding});
  }
  
  sub open_ex {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      unless (delete $opts{_no_master_required}) {
          $self->wait_for_master or return;
      }
  
      my $ssh_flags = '';
      my $tunnel = delete $opts{tunnel};
      my ($cmd, $close_slave_pty, @args);
      if ($tunnel) {
  	@args = @_;
      }
      else {
          my $argument_encoding = $self->_delete_argument_encoding(\%opts);
  	my $tty = delete $opts{tty};
  	$ssh_flags .= ($tty ? 'qtt' : 'T') if defined $tty;
  
  	$cmd = delete $opts{_cmd} || 'ssh';
  	$opts{quote_args_extended} = 1
  	    if (not defined $opts{quote_args_extended} and $cmd eq 'ssh');
          @args = $self->_quote_args(\%opts, @_);
          $self->_encode_args($argument_encoding, @args) or return;
      }
  
      my ($stdinout_socket, $stdinout_dpipe_make_parent);
      my $stdinout_dpipe = delete $opts{stdinout_dpipe};
      if ($stdinout_dpipe) {
          $stdinout_dpipe_make_parent = delete $opts{stdinout_dpipe_make_parent};
          $stdinout_socket = 1;
      }
      else {
          $stdinout_socket = delete $opts{stdinout_socket};
      }
  
      my ($stdin_discard, $stdin_pipe, $stdin_fh, $stdin_file, $stdin_pty,
          $stdout_discard, $stdout_pipe, $stdout_fh, $stdout_file, $stdout_pty,
          $stderr_discard, $stderr_pipe, $stderr_fh, $stderr_file, $stderr_to_stdout);
      unless ($stdinout_socket) {
          unless ($stdin_discard = delete $opts{stdin_discard} or
                  $stdin_pipe = delete $opts{stdin_pipe} or
                  $stdin_fh = delete $opts{stdin_fh} or
                  $stdin_file = delete $opts{stdin_file}) {
              unless ($tunnel) {
                  if ($stdin_pty = delete $opts{stdin_pty}) {
                      $close_slave_pty = _first_defined delete $opts{close_slave_pty}, 1;
                  }
              }
          }
  
          ( $stdout_discard = delete $opts{stdout_discard} or
            $stdout_pipe = delete $opts{stdout_pipe} or
            $stdout_fh = delete $opts{stdout_fh} or
            $stdout_file = delete $opts{stdout_file} or
            (not $tunnel and $stdout_pty = delete $opts{stdout_pty}) );
  
          $stdout_pty and !$stdin_pty
              and croak "option stdout_pty requires stdin_pty set";
      }
  
      ( $stderr_discard = delete $opts{stderr_discard} or
        $stderr_pipe = delete $opts{stderr_pipe} or
        $stderr_fh = delete $opts{stderr_fh} or
        $stderr_to_stdout = delete $opts{stderr_to_stdout} or
        $stderr_file = delete $opts{stderr_file} );
  
      my $ssh_opts = delete $opts{ssh_opts};
      $ssh_opts = $self->{_default_ssh_opts} unless defined $ssh_opts;
      my @ssh_opts = $self->_expand_vars(_array_or_scalar_to_list $ssh_opts);
      if ($self->{_forward_agent}) {
  	my $forward_always = (($self->{_forward_agent} eq 'always') ? 1 : undef);
          my $forward_agent = _first_defined(delete($opts{forward_agent}), $forward_always);
          $ssh_flags .= ($forward_agent ? 'A' : 'a') if defined $forward_agent;
      }
      if ($self->{_forward_X11}) {
          my $forward_X11 = delete $opts{forward_X11};
          $ssh_flags .= ($forward_X11 ? 'X' : 'x');
      }
      if (delete $opts{subsystem}) {
          $ssh_flags .= 's';
      }
  
      my $setpgrp = delete $opts{setpgrp};
      undef $setpgrp if defined $stdin_pty;
  
      _croak_bad_options %opts;
  
      if (defined $stdin_file) {
  	$stdin_fh = $self->_open_file('<', $stdin_file) or return
      }
      if (defined $stdout_file) {
  	$stdout_fh = $self->_open_file('>', $stdout_file) or return
      }
      if (defined $stderr_file) {
  	$stderr_fh = $self->_open_file('>', $stderr_file) or return
      }
  
      my ($rin, $win, $rout, $wout, $rerr, $werr);
  
      if ($stdinout_socket) {
          unless(socketpair $rin, $win, AF_UNIX, SOCK_STREAM, PF_UNSPEC) {
              $self->_set_error(OSSH_SLAVE_PIPE_FAILED, "socketpair failed: $!");
              return;
          }
          $wout = $rin;
      }
      else {
          if ($stdin_pipe) {
              ($rin, $win) = $self->_make_pipe or return;
          }
          elsif ($stdin_pty) {
              _load_module('IO::Pty');
              $win = IO::Pty->new;
              unless ($win) {
                  $self->_set_error(OSSH_SLAVE_PIPE_FAILED, "unable to allocate pseudo-tty: $!");
                  return;
              }
              $rin = $win->slave;
          }
          elsif (defined $stdin_fh) {
              $rin = $stdin_fh;
          }
          else {
              $rin = $self->{_default_stdin_fh}
          }
          _check_is_system_fh STDIN => $rin;
  
          if ($stdout_pipe) {
              ($rout, $wout) = $self->_make_pipe or return;
          }
          elsif ($stdout_pty) {
              $wout = $rin;
          }
          elsif (defined $stdout_fh) {
              $wout = $stdout_fh;
          }
          else {
              $wout = $self->{_default_stdout_fh};
          }
          _check_is_system_fh STDOUT => $wout;
      }
  
      unless ($stderr_to_stdout) {
  	if ($stderr_pipe) {
  	    ($rerr, $werr) = $self->_make_pipe or return;
  	}
  	elsif (defined $stderr_fh) {
  	    $werr = $stderr_fh;
  	}
  	else {
  	    $werr = $self->{_default_stderr_fh};
  	}
  	_check_is_system_fh STDERR => $werr;
      }
  
      push @ssh_opts, "-$ssh_flags" if length $ssh_flags;
  
      my @call = ( $tunnel         ? $self->_make_tunnel_call(\@ssh_opts, @args) :
                   $cmd eq 'ssh'   ? $self->_make_ssh_call(\@ssh_opts, @args)    :
  		 $cmd eq 'scp'   ? $self->_make_scp_call(\@ssh_opts, @args)    :
  		 $cmd eq 'rsync' ? $self->_make_rsync_call(\@ssh_opts, @args)  :
                   $cmd eq 'raw'   ? @args                                       :
  		 die "Internal error: bad _cmd protocol" );
  
      $debug and $debug & 16 and _debug_dump open_ex => \@call;
  
      my $pid = fork;
      unless ($pid) {
          unless (defined $pid) {
              $self->_set_error(OSSH_SLAVE_FAILED,
                                "unable to fork new ssh slave: $!");
              return;
          }
  
          setpgrp if $setpgrp;
  
          $stdin_discard  and (open $rin,  '<', '/dev/null' or POSIX::_exit(255));
          $stdout_discard and (open $wout, '>', '/dev/null' or POSIX::_exit(255));
          $stderr_discard and (open $werr, '>', '/dev/null' or POSIX::_exit(255));
  
          if ($stdinout_dpipe) {
              my $pid1 = fork;
              defined $pid1 or POSIX::_exit(255);
  
              unless ($pid1 xor $stdinout_dpipe_make_parent) {
                  eval { $self->_exec_dpipe($stdinout_dpipe, $win, $werr) };
                  POSIX::_exit(255);
              }
          }
  
          my $rin_fd  = _fileno_dup_over(0 => $rin);
          my $wout_fd = _fileno_dup_over(1 => $wout);
          my $werr_fd = _fileno_dup_over(2 => $werr);
  
          if (defined $rin_fd) {
              $win->make_slave_controlling_terminal if $stdin_pty;
  	    $rin_fd == 0 or POSIX::dup2($rin_fd, 0) or POSIX::_exit(255);
          }
  	if (defined $wout_fd) {
              $wout_fd == 1 or POSIX::dup2($wout_fd, 1) or POSIX::_exit(255);
          }
          if (defined $werr_fd) {
              $werr_fd == 2 or POSIX::dup2($werr_fd, 2) or POSIX::_exit(255);
          }
          elsif ($stderr_to_stdout) {
              POSIX::dup2(1, 2) or POSIX::_exit(255);
          }
          do { exec @call };
          POSIX::_exit(255);
      }
      $win->close_slave() if $close_slave_pty;
      undef $win if defined $stdinout_dpipe;
      wantarray ? ($win, $rout, $rerr, $pid) : $pid;
  }
  
  sub pipe_in {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      $self->wait_for_master or return;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      my $argument_encoding = $self->_delete_argument_encoding(\%opts);
      my @args = $self->_quote_args(\%opts, @_);
      _croak_bad_options %opts;
  
      $self->_encode_args($argument_encoding, @args) or return;
      my @call = $self->_make_ssh_call([], @args);
      $debug and $debug & 16 and _debug_dump pipe_in => @call;
      my $pid = open my $rin, '|-', @call;
      unless ($pid) {
          $self->_set_error(OSSH_SLAVE_FAILED,
                            "unable to fork new ssh slave: $!");
          return;
      }
      wantarray ? ($rin, $pid) : $rin;
  }
  
  sub pipe_out {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      $self->wait_for_master or return;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      my $argument_encoding = $self->_delete_argument_encoding(\%opts);
      my @args = $self->_quote_args(\%opts, @_);
      _croak_bad_options %opts;
  
      $self->_encode_args($argument_encoding, @args) or return;
      my @call = $self->_make_ssh_call([], @args);
      $debug and $debug & 16 and _debug_dump pipe_out => @call;
      my $pid = open my $rout, '-|', @call;
      unless ($pid) {
          $self->_set_error(OSSH_SLAVE_FAILED,
                            "unable to fork new ssh slave: $!");
          return;
      }
      wantarray ? ($rout, $pid) : $rout;
  }
  
  sub _find_encoding {
      my ($self, $encoding, $data) = @_;
      if (defined $encoding and $encoding ne 'bytes') {
  	_load_module('Encode');
          my $enc = Encode::find_encoding($encoding);
          unless (defined $enc) {
              $self->_set_error(OSSH_ENCODING_ERROR, "bad encoding '$encoding'");
              return
          }
          return $enc
      }
      return undef
  }
  
  sub _encode {
      my $self = shift;
      my $enc = shift;
      if (defined $enc and @_) {
          local ($@, $SIG{__DIE__});
          eval {
              for (@_) {
                  defined or next;
                  $_ = $enc->encode($_, Encode::FB_CROAK());
              }
          };
          $self->_check_eval_ok(OSSH_ENCODING_ERROR) or return undef;
      }
      1;
  }
  
  sub _encode_args {
      if (@_ > 2) {
          my $self = shift;
          my $encoding = shift;
  
          my $enc = $self->_find_encoding($encoding);
          if ($enc) {
              local $self->{_error_prefix} = [@{$self->{_error_prefix}}, "argument encoding failed"];
              $self->_encode($enc, @_);
          }
          return !$self->{_error};
      }
      1;
  }
  
  sub _decode {
      my $self = shift;
      my $enc = shift;
      local ($@, $SIG{__DIE__});
      eval {
          for (@_) {
              defined or next;
              $_ = $enc->decode($_, Encode::FB_CROAK());
          }
      };
      $self->_check_eval_ok(OSSH_ENCODING_ERROR);
  }
  
  my @retriable = (Errno::EINTR(), Errno::EAGAIN());
  push @retriable, Errno::EWOULDBLOCK() if Errno::EWOULDBLOCK() != Errno::EAGAIN();
  
  sub _io3 {
      my ($self, $out, $err, $in, $stdin_data, $timeout, $encoding, $keep_in_open) = @_;
      # $self->wait_for_master or return;
      my @data = _array_or_scalar_to_list $stdin_data;
      my ($cout, $cerr, $cin) = (defined($out), defined($err), defined($in));
      $timeout = $self->{_timeout} unless defined $timeout;
  
      my $has_input = grep { defined and length } @data;
      if ($cin and !$has_input) {
          close $in unless $keep_in_open;
          undef $cin;
      }
      elsif (!$cin and $has_input) {
          croak "remote input channel is not defined but data is available for sending"
      }
  
      my $enc = $self->_find_encoding($encoding);
      if ($enc and @data) {
          local $self->{_error_prefix} = [@{$self->{_error_prefix}}, "stdin data encoding failed"];
          $self->_encode($enc, @data) if $has_input;
          return if $self->{_error};
      }
  
      my $bout = '';
      my $berr = '';
      my ($fnoout, $fnoerr, $fnoin);
      local $SIG{PIPE} = 'IGNORE';
  
   MLOOP: while ($cout or $cerr or $cin) {
          $debug and $debug & 64 and _debug "io3 mloop, cin: " . ($cin || 0) .
              ", cout: " . ($cout || 0) . ", cerr: " . ($cerr || 0);
          my ($rv, $wv);
  
          if ($cout or $cerr) {
              $rv = '';
              if ($cout) {
                  $fnoout = fileno $out;
                  vec($rv, $fnoout, 1) = 1;
              }
              if ($cerr) {
                  $fnoerr = fileno $err;
                  vec($rv, $fnoerr, 1) = 1
              }
          }
  
          if ($cin) {
              $fnoin = fileno $in;
              $wv = '';
              vec($wv, $fnoin, 1) = 1;
          }
  
          my $recalc_vecs;
      FAST: until ($recalc_vecs) {
              $debug and $debug & 64 and
                  _debug "io3 fast, cin: " . ($cin || 0) .
                      ", cout: " . ($cout || 0) . ", cerr: " . ($cerr || 0);
              my ($rv1, $wv1) = ($rv, $wv);
              my $n = select ($rv1, $wv1, undef, $timeout);
              if ($n > 0) {
                  if ($cout and vec($rv1, $fnoout, 1)) {
                      my $offset = length $bout;
                      my $read = sysread($out, $bout, 20480, $offset);
                      if ($debug and $debug & 64) {
                          _debug "stdout, bytes read: ", $read, " at offset $offset";
                          $read and $debug & 128 and _hexdump substr $bout, $offset;
                      }
                      unless ($read or grep $! == $_, @retriable) {
                          close $out;
                          undef $cout;
                          $recalc_vecs = 1;
                      }
                  }
                  if ($cerr and vec($rv1, $fnoerr, 1)) {
                      my $read = sysread($err, $berr, 20480, length($berr));
                      $debug and $debug & 64 and _debug "stderr, bytes read: ", $read;
                      unless ($read or grep $! == $_, @retriable) {
                          close $err;
                          undef $cerr;
                          $recalc_vecs = 1;
                      }
                  }
                  if ($cin and vec($wv1, $fnoin, 1)) {
                      my $written = syswrite($in, $data[0], 20480);
                      if ($debug and $debug & 64) {
                          _debug "stdin, bytes written: ", $written;
                          $written and $debug & 128 and _hexdump substr $data[0], 0, $written;
                      }
                      if ($written) {
                          substr($data[0], 0, $written, '');
                          while (@data) {
                              next FAST
                                  if (defined $data[0] and length $data[0]);
                              shift @data;
                          }
                          # fallback when stdin queue is exhausted
                      }
                      elsif (grep $! == $_, @retriable) {
                          next FAST;
                      }
                      close $in unless $keep_in_open;
                      undef $cin;
                      $recalc_vecs = 1;
                  }
              }
              else {
                  next if $n < 0 and grep $! == $_, @retriable;
                  $self->_set_error(OSSH_SLAVE_TIMEOUT, 'ssh slave failed', 'timed out');
                  last MLOOP;
              }
          }
      }
      close $out if $cout;
      close $err if $cerr;
      close $in if $cin and not $keep_in_open;
  
      if ($enc) {
          local $self->{_error_prefix} = [@{$self->{_error_prefix}}, 'output decoding failed'];
          unless ($self->_decode($enc, $bout, $berr)) {
              undef $bout;
              undef $berr;
          }
      }
      $debug and $debug & 64 and _debug "leaving _io3()";
      return ($bout, $berr);
  }
  
  
  
  _sub_options spawn => qw(stderr_to_stdout stdin_discard stdin_fh stdin_file stdout_discard stdout_fh
                           stdout_file stderr_discard stderr_fh stderr_file stdinout_dpipe
                           stdinout_dpipe_make_parent quote_args quote_args_extended remote_shell
                           glob_quoting tty ssh_opts tunnel encoding argument_encoding forward_agent
                           forward_X11 setpgrp subsystem);
  sub spawn {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts =  (ref $_[0] eq 'HASH' ? %{shift()} : ());
      _croak_bad_options %opts;
  
      return scalar $self->open_ex(\%opts, @_);
  }
  
  _sub_options open2 => qw(stderr_to_stdout stderr_discard stderr_fh stderr_file quote_args quote_args_extended
                           remote_shell glob_quoting tty ssh_opts tunnel encoding argument_encoding forward_agent
                           forward_X11 setpgrp subsystem);
  sub open2 {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      _croak_bad_options %opts;
      _croak_scalar_context;
  
      my ($in, $out, undef, $pid) =
          $self->open_ex({ stdout_pipe => 1,
                           stdin_pipe => 1,
                           %opts }, @_) or return ();
      return ($in, $out, $pid);
  }
  
  _sub_options open2pty => qw(stderr_to_stdout stderr_discard stderr_fh stderr_file
                              quote_args quote_args_extended remote_shell glob_quoting tty
                              close_slave_pty ssh_opts encoding argument_encoding forward_agent
                              forward_X11 setpgrp subsystem);
  sub open2pty {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      _croak_bad_options %opts;
  
      my ($pty, undef, undef, $pid) =
          $self->open_ex({ stdout_pty => 1,
                           stdin_pty => 1,
  			 tty => 1,
                         %opts }, @_) or return ();
      wantarray ? ($pty, $pid) : $pty;
  }
  
  _sub_options open2socket => qw(stderr_to_stdout stderr_discard stderr_fh stderr_file
                                 quote_args quote_args_extended remote_shell glob_quoting tty
                                 ssh_opts tunnel encoding argument_encoding forward_agent
                                 forward_X11 setpgrp subsystem);
  sub open2socket {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      _croak_bad_options %opts;
  
      my ($socket, undef, undef, $pid) =
          $self->open_ex({ stdinout_socket => 1,
                           %opts }, @_) or return ();
      wantarray ? ($socket, $pid) : $socket;
  }
  
  _sub_options open3 => qw(quote_args quote_args_extended remote_shell glob_quoting tty ssh_opts
                           encoding argument_encoding forward_agent forward_X11 setpgrp subsystem);
  sub open3 {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      _croak_bad_options %opts;
      _croak_scalar_context;
  
      my ($in, $out, $err, $pid) =
          $self->open_ex({ stdout_pipe => 1,
                           stdin_pipe => 1,
                           stderr_pipe => 1,
  			 %opts },
                         @_) or return ();
      return ($in, $out, $err, $pid);
  }
  
  _sub_options open3pty => qw(quote_args quote_args_extended remote_shell glob_quoting tty close_slave_pty ssh_opts
                              encoding argument_encoding forward_agent forward_X11 setpgrp subsystem);
  sub open3pty {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      _croak_bad_options %opts;
      _croak_scalar_context;
  
      my ($pty, undef, $err, $pid) =
          $self->open_ex({ stdout_pty => 1,
                           stdin_pty => 1,
  			 tty => 1,
                           stderr_pipe => 1,
  			 %opts },
                         @_) or return ();
      return ($pty, $err, $pid);
  }
  
  _sub_options open3socket => qw(quote_args quote_args_extended remote_shell glob_quoting tty ssh_opts encoding
                                 argument_encoding forward_agent forward_X11 setpgrp subsystem);
  sub open3socket {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      _croak_bad_options %opts;
      _croak_scalar_context;
  
      my ($socket, undef, $err, $pid) =
          $self->open_ex({ stdinout_socket => 1,
                           stderr_pipe => 1,
  			 %opts }, @_) or return ();
      return ($socket, $err, $pid);
  }
  
  _sub_options system => qw(stdout_discard stdout_fh stdin_discard stdout_file stdin_fh stdin_file
                            quote_args quote_args_extended remote_shell glob_quoting
                            stderr_to_stdout stderr_discard stderr_fh stderr_file
                            stdinout_dpipe stdinout_dpipe_make_parent tty ssh_opts tunnel encoding
                            argument_encoding forward_agent forward_X11 setpgrp subsystem);
  sub system {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      my $stdin_data = delete $opts{stdin_data};
      my $timeout = delete $opts{timeout};
      my $async = delete $opts{async};
      my $stdin_keep_open = ($async ? undef : delete $opts{stdin_keep_open});
  
      _croak_bad_options %opts;
  
      $stdin_data = '' if $stdin_keep_open and not defined $stdin_data;
  
      my $stream_encoding;
      if (defined $stdin_data) {
          $opts{stdin_pipe} = 1;
          $stream_encoding = $self->_delete_stream_encoding(\%opts);
      }
  
      local $SIG{INT} = 'IGNORE';
      local $SIG{QUIT} = 'IGNORE';
      local $SIG{CHLD};
  
      my ($in, undef, undef, $pid) = $self->open_ex(\%opts, @_) or return undef;
  
      $self->_io3(undef, undef, $in, $stdin_data,
                  $timeout, $stream_encoding, $stdin_keep_open) if defined $stdin_data;
      return $pid if $async;
      $self->_waitpid($pid, $timeout);
  }
  
  _sub_options test => qw(stdout_discard stdout_fh stdin_discard stdout_file stdin_fh stdin_file
                          quote_args quote_args_extended remote_shell glob_quoting stderr_to_stdout
                          stderr_discard stderr_fh stderr_file stdinout_dpipe
                          stdinout_dpipe_make_parent tty ssh_opts timeout stdin_data stdin_keep_open
                          encoding stream_encoding argument_encoding forward_agent forward_X11
                          setpgrp subsystem);
  
  sub test {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      $opts{stdout_discard} = 1 unless grep defined($opts{$_}), qw(stdout_discard stdout_fh
                                                                   stdout_file stdinout_dpipe);
      $opts{stderr_discard} = 1 unless grep defined($opts{$_}), qw(stderr_discard stderr_fh
                                                                   stderr_file stderr_to_stdout);
      _croak_bad_options %opts;
  
      $self->system(\%opts, @_);
      my $error = $self->{_error};
      unless ($error) {
          return 1;
      }
      if ($error == OSSH_SLAVE_CMD_FAILED) {
          $self->_set_error(0);
          return 0;
      }
      return undef;
  }
  
  _sub_options capture => qw(stderr_to_stdout stderr_discard stderr_fh stderr_file stdin_discard
                             stdin_fh stdin_file quote_args quote_args_extended remote_shell
                             glob_quoting tty ssh_opts tunnel encoding argument_encoding forward_agent
                             forward_X11 setpgrp subsystem);
  sub capture {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      my $stdin_data = delete $opts{stdin_data};
      my $stdin_keep_open = delete $opts{stdin_keep_open};
      my $timeout = delete $opts{timeout};
      _croak_bad_options %opts;
  
      $stdin_data = '' if $stdin_keep_open and not defined $stdin_data;
  
      my $stream_encoding = $self->_delete_stream_encoding(\%opts);
      $opts{stdout_pipe} = 1;
      $opts{stdin_pipe} = 1 if defined $stdin_data;
  
      local $SIG{INT} = 'IGNORE';
      local $SIG{QUIT} = 'IGNORE';
      local $SIG{CHLD};
  
      my ($in, $out, undef, $pid) = $self->open_ex(\%opts, @_) or return ();
      my ($output) = $self->_io3($out, undef, $in, $stdin_data,
                                 $timeout, $stream_encoding, $stdin_keep_open);
      $self->_waitpid($pid, $timeout);
      if (wantarray) {
          my $pattern = quotemeta $/;
          return split /(?<=$pattern)/, $output;
      }
      $output
  }
  
  _sub_options capture2 => qw(stdin_discard stdin_fh stdin_file quote_args quote_args_extended
                              remote_shell glob_quoting tty ssh_opts encoding stream_encoding
                              argument_encoding forward_agent forward_X11 setpgrp subsystem);
  sub capture2 {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      my $stdin_data = delete $opts{stdin_data};
      my $stdin_keep_open = delete $opts{stdin_keep_open};
      my $timeout = delete $opts{timeout};
      _croak_bad_options %opts;
  
      $stdin_data = '' if $stdin_keep_open and not defined $stdin_data;
  
      my $stream_encoding = $self->_delete_stream_encoding(\%opts);
      $opts{stdout_pipe} = 1;
      $opts{stderr_pipe} = 1;
      $opts{stdin_pipe} = 1 if defined $stdin_data;
  
      local $SIG{INT} = 'IGNORE';
      local $SIG{QUIT} = 'IGNORE';
      local $SIG{CHLD};
  
      my ($in, $out, $err, $pid) = $self->open_ex( \%opts, @_) or return ();
      my @capture = $self->_io3($out, $err, $in, $stdin_data,
                                $timeout, $stream_encoding, $stdin_keep_open);
      $self->_waitpid($pid, $timeout);
      wantarray ? @capture : $capture[0];
  }
  
  _sub_options open_tunnel => qw(ssh_opts stderr_discard stderr_fh stderr_file
                                 encoding argument_encoding forward_agent setpgrp);
  sub open_tunnel {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      $opts{stderr_discard} = 1 unless grep defined $opts{$_}, qw(stderr_discard stderr_fh stderr_file);
      _croak_bad_options %opts;
      @_ == 2 or croak 'Usage: $ssh->open_tunnel(\%opts, $host, $port)';
      $opts{tunnel} = 1;
      $self->open2socket(\%opts, @_);
  }
  
  _sub_options capture_tunnel => qw(ssh_opts stderr_discard stderr_fh stderr_file stdin_discard
  				  stdin_fh stdin_file stdin_data timeout encoding stream_encoding
  				  argument_encoding forward_agent setpgrp);
  sub capture_tunnel {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      $opts{stderr_discard} = 1 unless grep defined $opts{$_}, qw(stderr_discard stderr_fh stderr_file);
      _croak_bad_options %opts;
      @_ == 2 or croak 'Usage: $ssh->capture_tunnel(\%opts, $host, $port)';
      $opts{tunnel} = 1;
      $self->capture(\%opts, @_);
  }
  
  sub _calling_method {
      my $method = (caller 2)[3];
      $method =~ s/.*:://;
      $method;
  }
  
  sub _scp_get_args {
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
  
      @_ > 0 or croak
  	'Usage: $ssh->' . _calling_method . '(\%opts, $remote_fn1, $remote_fn2, ..., $local_fn_or_dir)';
  
      my $glob = delete $opts{glob};
  
      my $target = (@_ > 1 ? pop @_ : '.');
      $target =~ m|^[^/]*:| and $target = "./$target";
  
      my $prefix = $self->{_host_squared};
      $prefix = "$self->{_user}\@$prefix" if defined $self->{_user};
  
      my $src = "$prefix:". join(" ", $self->_quote_args({quote_args => 1,
                                                          glob_quoting => $glob},
                                                         @_));
      ($self, \%opts, $target, $src);
  }
  
  sub scp_get {
      ${^TAINT} and &_catch_tainted_args;
      my ($self, $opts, $target, @src) = _scp_get_args @_;
      $self->_scp($opts, @src, $target);
  }
  
  sub rsync_get {
      ${^TAINT} and &_catch_tainted_args;
      my ($self, $opts, $target, @src) = _scp_get_args @_;
      $self->_rsync($opts, @src, $target);
  }
  
  sub _scp_put_args {
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
  
      @_ > 0 or croak
  	'Usage: $ssh->' . _calling_method . '(\%opts, $local_fn1, $local_fn2, ..., $remote_dir_or_fn)';
  
      my $glob = delete $opts{glob};
      my $glob_flags = ($glob ? delete $opts{glob_flags} || 0 : undef);
  
      my $prefix = $self->{_host_squared};
      $prefix = "$self->{_user}\@$prefix" if defined $self->{_user};
  
      my $remote_shell = delete $opts{remote_shell};
      my $target = $prefix . ':' . ( @_ > 1
                                     ? $self->_quote_args({quote_args => 1, remote_shell => $remote_shell}, pop(@_))
                                     : '');
  
      my @src = @_;
      if ($glob) {
  	require File::Glob;
  	@src = map File::Glob::bsd_glob($_, $glob_flags), @src;
  	unless (@src) {
  	    $self->_set_error(OSSH_SLAVE_FAILED,
  			      "given file name patterns did not match any file");
  	    return undef;
  	}
      }
      $_ = "./$_" for grep m|^[^/]*:|, @src;
  
      ($self, \%opts, $target, @src);
  }
  
  sub scp_put {
      ${^TAINT} and &_catch_tainted_args;
      my ($self, $opts, $target, @src) = _scp_put_args @_;
      return unless $self;
      $self->_scp($opts, @src, $target);
  }
  
  sub rsync_put {
      ${^TAINT} and &_catch_tainted_args;
      my ($self, $opts, $target, @src) = _scp_put_args @_;
      return unless $self;
      $self->_rsync($opts, @src, $target);
  }
  
  _sub_options _scp => qw(stderr_to_stdout stderr_discard stderr_fh
  			stderr_file stdout_discard stdout_fh
  			stdout_file encoding argument_encoding
                          forward_agent setpgrp);
  sub _scp {
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      my $quiet = delete $opts{quiet};
      $quiet = 1 unless defined $quiet;
      my $recursive = delete $opts{recursive};
      my $copy_attrs = delete $opts{copy_attrs};
      my $bwlimit = delete $opts{bwlimit};
      my $async = delete $opts{async};
      my $ssh_opts = delete $opts{ssh_opts};
      my $timeout = delete $opts{timeout};
      my $verbose = delete $opts{verbose};
      _croak_bad_options %opts;
  
      my @opts;
      @opts = @$ssh_opts if $ssh_opts;
      push @opts, '-q' if $quiet;
      push @opts, '-v' if $verbose;
      push @opts, '-r' if $recursive;
      push @opts, '-p' if $copy_attrs;
      push @opts, '-l', $bwlimit if $bwlimit;
  
      local $self->{_error_prefix} = [@{$self->{_error_prefix}}, 'scp failed'];
  
      my $pid = $self->open_ex({ %opts,
                                 _cmd => 'scp',
  			       ssh_opts => \@opts,
  			       quote_args => 0 },
  			     @_);
  
      return $pid if $async;
      $self->_waitpid($pid, $timeout);
  }
  
  my %rsync_opt_with_arg = map { $_ => 1 } qw(chmod suffix backup-dir rsync-path max-delete max-size min-size partial-dir
                                              timeout modify-window temp-dir compare-dest copy-dest link-dest compress-level
                                              skip-compress filter exclude exclude-from include include-from
                                              out-format log-file log-file-format bwlimit protocol iconv checksum-seed files-from);
  
  my %rsync_opt_forbidden = map { $_ => 1 } qw(rsh address port sockopts password-file write-batch
                                              only-write-batch read-batch ipv4 ipv6 version help daemon config detach
                                              protect-args list-only);
  
  $rsync_opt_forbidden{"no-$_"} = 1 for (keys %rsync_opt_with_arg, keys %rsync_opt_forbidden);
  
  my %rsync_error = (1, 'syntax or usage error',
  		   2, 'protocol incompatibility',
  		   3, 'errors selecting input/output files, dirs',
  		   4, 'requested action not supported: an attempt was made to manipulate 64-bit files on a platform '.
                        'that  cannot  support them; or an option was specified that is supported by the client and not '.
                        'by the server.',
  		   5, 'error starting client-server protocol',
  		   6, 'daemon unable to append to log-file',
  		   10, 'error in socket I/O',
  		   11, 'error in file I/O',
  		   12, 'error in rsync protocol data stream',
  		   13, 'errors with program diagnostics',
  		   14, 'error in IPC code',
  		   20, 'received SIGUSR1 or SIGINT',
  		   21, 'some error returned by waitpid()',
  		   22, 'error allocating core memory buffers',
  		   23, 'partial transfer due to error',
  		   24, 'partial transfer due to vanished source files',
  		   25, 'the --max-delete limit stopped deletions',
  		   30, 'timeout in data send/receive',
  		   35, 'timeout waiting for daemon connection');
  
  my %rsync_opt_open_ex = map { $_ => 1 } qw(stderr_to_stdout
  					   stderr_discard stderr_fh
  					   stderr_file stdout_discard
  					   stdout_fh stdout_file encoding
                                             argument_encoding);
  sub _rsync {
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      my $async = delete $opts{async};
      my $verbose = delete $opts{verbose};
      my $quiet = delete $opts{quiet};
      my $copy_attrs = delete $opts{copy_attrs};
      my $timeout = delete $opts{timeout};
      $quiet = 1 unless (defined $quiet or $verbose);
  
      my @opts;
      push @opts, '-q' if $quiet;
      push @opts, '-pt' if $copy_attrs;
      push @opts, '-' . ($verbose =~ /^\d+$/ ? 'v' x $verbose : 'v') if $verbose;
  
      my %opts_open_ex = ( _cmd => 'rsync',
  			 quote_args => 0 );
  
      for my $opt (keys %opts) {
  	my $value = $opts{$opt};
  	if (defined $value) {
  	    if ($rsync_opt_open_ex{$opt}) {
  		$opts_open_ex{$opt} = $value;
  	    }
  	    else {
  		my $opt1 = $opt;
  		$opt1 =~ tr/_/-/;
  		$rsync_opt_forbidden{$opt1} and croak "forbidden rsync option '$opt' used";
  		if ($rsync_opt_with_arg{$opt1}) {
  		    push @opts, "--$opt1=$_" for _array_or_scalar_to_list($value)
  		}
  		else {
  		    $value = !$value if $opt1 =~ s/^no-//;
  		    push @opts, ($value ? "--$opt1" : "--no-$opt1");
  		}
  	    }
  	}
      }
  
      local $self->{_error_prefix} = [@{$self->{_error_prefix}}, 'rsync failed'];
  
      my $pid = $self->open_ex(\%opts_open_ex, @opts, '--', @_);
      return $pid if $async;
      $self->_waitpid($pid, $timeout) and return 1;
  
      if ($self->{_error} == OSSH_SLAVE_CMD_FAILED and $?) {
  	my $err = ($? >> 8);
  	my $errstr = $rsync_error{$err};
  	$errstr = 'Unknown rsync error' unless defined $errstr;
  	my $signal = $? & 255;
  	my $signalstr = ($signal ? " (signal $signal)" : '');
  	$self->_set_error(OSSH_SLAVE_CMD_FAILED,
  			  "command exited with code $err$signalstr: $errstr");
      }
      return undef
  }
  
  _sub_options sftp => qw(autoflush timeout argument_encoding encoding block_size queue_size autodie
  			late_set_perm forward_agent setpgrp min_block_size read_ahead write_delay
  			dirty_cleanup remote_has_volumes autodisconnect more);
  
  sub sftp {
      ${^TAINT} and &_catch_tainted_args;
      @_ & 1 or croak 'Usage: $ssh->sftp(%sftp_opts)';
      _load_module('Net::SFTP::Foreign', '1.47');
      my ($self, %opts) = @_;
      my $stderr_fh = delete $opts{stderr_fh};
      my $stderr_discard = delete $opts{stderr_discard};
      my $fs_encoding = _first_defined(delete $opts{fs_encoding},
                                       $opts{argument_encoding},
                                       $opts{encoding},
                                       $self->{_default_argument_encoding});
      undef $fs_encoding if (defined $fs_encoding and $fs_encoding eq 'bytes');
      _croak_bad_options %opts;
      $opts{timeout} = $self->{_timeout} unless defined $opts{timeout};
      $self->wait_for_master or return undef;
      my ($in, $out, $pid) = $self->open2( { subsystem => 1,
  					   stderr_fh => $stderr_fh,
  					   stderr_discard => $stderr_discard },
  					 'sftp' )
  	or return undef;
  
      my $sftp = Net::SFTP::Foreign->new(transport => [$out, $in, $pid],
  				       dirty_cleanup => 0,
                                         fs_encoding => $fs_encoding,
  				       %opts);
      if ($sftp->error) {
  	$self->_or_set_error(OSSH_SLAVE_SFTP_FAILED, "unable to create SFTP client", $sftp->error);
  	return undef;
      }
      $sftp
  }
  
  _sub_options sshfs_import => qw(stderr_discard stderr_fh stderr_file
                                  ssh_opts argument_encoding sshfs_opts setpgrp);
  sub sshfs_import {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      @_ == 2 or croak 'Usage: $ssh->sshfs_import(\%opts, $remote, $local)';
      my ($from, $to) = @_;
      my @sshfs_opts = ( -o => 'slave',
                         _array_or_scalar_to_list delete $opts{sshfs_opts} );
      _croak_bad_options %opts;
  
      $opts{ssh_opts} = ['-s', _array_or_scalar_to_list delete $opts{ssh_opts}];
      $opts{stdinout_dpipe} = [$self->{_sshfs_cmd}, "$self->{_host_squared}:$from", $to, @sshfs_opts];
      $opts{stdinout_dpipe_make_parent} = 1;
      $self->spawn(\%opts, 'sftp');
  }
  
  _sub_options sshfs_export => qw(stderr_discard stderr_fh stderr_file
                                  ssh_opts argument_encoding sshfs_opts setpgrp);
  sub sshfs_export {
      ${^TAINT} and &_catch_tainted_args;
      my $self = shift;
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
      @_ == 2 or croak 'Usage: $ssh->sshfs_export(\%opts, $local, $remote)';
      my ($from, $to) = @_;
      my @sshfs_opts = ( -o => 'slave',
                         _array_or_scalar_to_list delete $opts{sshfs_opts} );
      _croak_bad_options %opts;
      $opts{stdinout_dpipe} = $self->{_sftp_server_cmd};
  
      my $hostname = do {
          local ($@, $SIG{__DIE__});
          eval {
              require Sys::Hostname;
              Sys::Hostname::hostname();
          };
      };
      $hostname = 'remote' if (not defined $hostname   or
                               not length $hostname    or
                               $hostname=~/^localhost\b/);
      $self->spawn(\%opts, $self->{_sshfs_cmd}, "$hostname:$from", $to, @sshfs_opts);
  }
  
  sub object_remote {
      my $self = shift;
      _load_module('Object::Remote') or return;
      _load_module('Net::OpenSSH::ObjectRemote') or return;
      my $connector = Net::OpenSSH::ObjectRemote->new(net_openssh => $self);
      $connector->connect(@_);
  }
  
  sub any {
      my $self = shift;
      _load_module('Net::SSH::Any');
      Net::SSH::Any->new($self->{_host}, user => $self->{_user}, port => $self->{_port},
                         backend => 'Net_OpenSSH',
                         backend_opts => { Net_OpenSSH => { instance => $self } });
  }
  
  sub DESTROY {
      my $self = shift;
      $debug and $debug & 2 and _debug("DESTROY($self, pid: ", $self->{_pid}, ")");
      local ($SIG{__DIE__}, $@, $?, $!);
      $self->_disconnect;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Net::OpenSSH - Perl SSH client package implemented on top of OpenSSH
  
  =head1 SYNOPSIS
  
    use Net::OpenSSH;
  
    my $ssh = Net::OpenSSH->new($host);
    $ssh->error and
      die "Couldn't establish SSH connection: ". $ssh->error;
  
    $ssh->system("ls /tmp") or
      die "remote command failed: " . $ssh->error;
  
    my @ls = $ssh->capture("ls");
    $ssh->error and
      die "remote ls command failed: " . $ssh->error;
  
    my ($out, $err) = $ssh->capture2("find /root");
    $ssh->error and
      die "remote find command failed: " . $ssh->error;
  
    my ($rin, $pid) = $ssh->pipe_in("cat >/tmp/foo") or
      die "pipe_in method failed: " . $ssh->error;
  
    print $rin "hello\n";
    close $rin;
  
    my ($rout, $pid) = $ssh->pipe_out("cat /tmp/foo") or
      die "pipe_out method failed: " . $ssh->error;
  
    while (<$rout>) { print }
    close $rout;
  
    my ($in, $out ,$pid) = $ssh->open2("foo");
    my ($pty, $pid) = $ssh->open2pty("foo");
    my ($in, $out, $err, $pid) = $ssh->open3("foo");
    my ($pty, $err, $pid) = $ssh->open3pty("login");
  
    my $sftp = $ssh->sftp();
    $sftp->error and die "SFTP failed: " . $sftp->error;
  
  
  =head1 DESCRIPTION
  
  Net::OpenSSH is a secure shell client package implemented on top of
  OpenSSH binary client (C<ssh>).
  
  =head2 Under the hood
  
  This package is implemented around the multiplexing feature found in
  later versions of OpenSSH. That feature allows one to run several
  sessions over a single SSH connection (OpenSSH 4.1 was the first
  one to provide all the required functionality).
  
  When a new Net::OpenSSH object is created, the OpenSSH C<ssh> client
  is run in master mode, establishing a persistent (for the lifetime of
  the object) connection to the server.
  
  Then, every time a new operation is requested a new C<ssh> process is
  started in slave mode, effectively reusing the master SSH connection
  to send the request to the remote side.
  
  =head2 Net::OpenSSH Vs. Net::SSH::.* modules
  
  Why should you use Net::OpenSSH instead of any of the other Perl SSH
  clients available?
  
  Well, this is my (biased) opinion:
  
  L<Net::SSH::Perl|Net::SSH::Perl> is not well maintained nowadays
  (update: a new maintainer has stepped in so this situation could
  change!!!), requires a bunch of modules (some of them very difficult
  to install) to be acceptably efficient and has an API that is limited
  in some ways.
  
  L<Net::SSH2|Net::SSH2> is much better than Net::SSH::Perl, but not
  completely stable yet. It can be very difficult to install on some
  specific operating systems and its API is also limited, in the same
  way as L<Net::SSH::Perl|Net::SSH::Perl>.
  
  Using L<Net::SSH::Expect|Net::SSH::Expect>, in general, is a bad
  idea. Handling interaction with a shell via Expect in a generic way
  just can not be reliably done.
  
  Net::SSH is just a wrapper around any SSH binary commands available on
  the machine. It can be very slow as they establish a new SSH
  connection for every operation performed.
  
  In comparison, Net::OpenSSH is a pure perl module that does not have
  any mandatory dependencies (obviously, besides requiring OpenSSH
  binaries).
  
  Net::OpenSSH has a very perlish interface. Most operations are
  performed in a fashion very similar to that of the Perl builtins and
  common modules (e.g. L<IPC::Open2|IPC::Open2>).
  
  It is also very fast. The overhead introduced by launching a new ssh
  process for every operation is not appreciable (at least on my Linux
  box). The bottleneck is the latency intrinsic to the protocol, so
  Net::OpenSSH is probably as fast as an SSH client can be.
  
  Being based on OpenSSH is also an advantage: a proved, stable, secure
  (to paranoid levels), inseparably and well maintained implementation
  of the SSH protocol is used.
  
  On the other hand, Net::OpenSSH does not work on Windows, not even
  under Cygwin.
  
  Net::OpenSSH specifically requires the OpenSSH SSH client (AFAIK, the
  multiplexing feature is not available from any other SSH
  client). However, note that it will interact with any server software,
  not just servers running OpenSSH C<sshd>.
  
  For password authentication, L<IO::Pty|IO::Pty> has to be
  installed. Other modules and binaries are also required to implement
  specific functionality (for instance
  L<Net::SFTP::Foreign|Net::SFTP::Foreign>, L<Expect|Expect> or
  L<rsync(1)|rsync(1)>).
  
  Net::OpenSSH and Net::SSH2 do not support version 1 of the SSH
  protocol.
  
  =head1 API
  
  =head2 Optional arguments
  
  Almost all methods in this package accept as first argument an
  optional reference to a hash containing parameters (C<\%opts>). For
  instance, these two method calls are equivalent:
  
    my $out1 = $ssh->capture(@cmd);
    my $out2 = $ssh->capture({}, @cmd);
  
  =head2 Error handling
  
  Most methods return undef (or an empty list) to indicate failure.
  
  The L</error> method can always be used to explicitly check for
  errors. For instance:
  
    my ($output, $errput) = $ssh->capture2({timeout => 1}, "find /");
    $ssh->error and die "ssh failed: " . $ssh->error;
  
  =head2 Net::OpenSSH methods
  
  These are the methods provided by the package:
  
  =over 4
  
  =item Net::OpenSSH->new($host, %opts)
  
  Creates a new SSH master connection
  
  C<$host> can be a hostname or an IP address. It may also
  contain the name of the user, her password and the TCP port
  number where the server is listening:
  
     my $ssh1 = Net::OpenSSH->new('jack@foo.bar.com');
     my $ssh2 = Net::OpenSSH->new('jack:secret@foo.bar.com:10022');
     my $ssh3 = Net::OpenSSH->new('jsmith@2001:db8::1428:57ab'); # IPv6
  
  IPv6 addresses may optionally be enclosed in brackets:
  
     my $ssh4 = Net::OpenSSH->new('jsmith@[::1]:1022');
  
  This method always succeeds in returning a new object. Error checking
  has to be performed explicitly afterwards:
  
    my $ssh = Net::OpenSSH->new($host, %opts);
    $ssh->error and die "Can't ssh to $host: " . $ssh->error;
  
  If you have problems getting Net::OpenSSH to connect to the remote
  host read the troubleshooting chapter near the end of this document.
  
  Accepted options:
  
  =over 4
  
  =item user => $user_name
  
  Login name
  
  =item port => $port
  
  TCP port number where the server is running
  
  =item password => $password
  
  User given password for authentication.
  
  Note that using password authentication in automated scripts is a very
  bad idea. When possible, you should use public key authentication
  instead.
  
  =item passphrase => $passphrase
  
  X<passphrase>Uses given passphrase to open private key.
  
  =item key_path => $private_key_path
  
  Uses the key stored on the given file path for authentication.
  
  =item gateway => $gateway
  
  If the given argument is a gateway object as returned by
  L<Net::OpenSSH::Gateway/find_gateway> method, use it to connect to
  the remote host.
  
  If it is a hash reference, call the C<find_gateway> method first.
  
  For instance, the following code fragments are equivalent:
  
    my $gateway = Net::OpenSSH::Gateway->find_gateway(
            proxy => 'http://proxy.corporate.com');
    $ssh = Net::OpenSSH->new($host, gateway => $gateway);
  
  and
  
    $ssh = Net::OpenSSH->new($host,
            gateway => { proxy => 'http://proxy.corporate.com'});
  
  =item proxy_command => $proxy_command
  
  Use the given command to establish the connection to the remote host
  (see C<ProxyCommand> on L<ssh_config(5)>).
  
  =item batch_mode => 1
  
  Disables querying the user for password and passphrases.
  
  =item ctl_dir => $path
  
  Directory where the SSH master control socket will be created.
  
  This directory and its parents must be writable only by the current
  effective user or root, otherwise the connection will be aborted to
  avoid insecure operation.
  
  By default C<~/.libnet-openssh-perl> is used.
  
  =item ctl_path => $path
  
  Path to the SSH master control socket.
  
  Usually this option should be avoided as the module is able to pick an unused
  socket path by itself. An exception to that rule is when the C<external_master>
  feature is enabled.
  
  Note that the length of the path is usually limited to between 92 and 108 bytes,
  depending of the underlying operating system.
  
  =item ssh_cmd => $cmd
  
  Name or full path to OpenSSH C<ssh> binary. For instance:
  
    my $ssh = Net::OpenSSH->new($host, ssh_cmd => '/opt/OpenSSH/bin/ssh');
  
  =item scp_cmd => $cmd
  
  Name or full path to OpenSSH C<scp> binary.
  
  By default it is inferred from the C<ssh> one.
  
  =item rsync_cmd => $cmd
  
  Name or full path to C<rsync> binary. Defaults to C<rsync>.
  
  =item remote_shell => $name
  
  Name of the remote shell. Used to select the argument quoter backend.
  
  =item timeout => $timeout
  
  Maximum acceptable time that can elapse without network traffic or any
  other event happening on methods that are not immediate (for instance,
  when establishing the master SSH connection or inside methods
  C<capture>, C<system>, C<scp_get>, etc.).
  
  See also L</Timeouts>.
  
  =item kill_ssh_on_timeout => 1
  
  This option tells Net::OpenSSH to kill the local slave SSH process
  when some operation times out.
  
  See also L</Timeouts>.
  
  =item strict_mode => 0
  
  By default, the connection will be aborted if the path to the socket
  used for multiplexing is found to be non-secure (for instance, when
  any of the parent directories is writable by other users).
  
  This option can be used to disable that feature. Use with care!!!
  
  =item async => 1
  
  By default, the constructor waits until the multiplexing socket is
  available. That option can be used to defer the waiting until the
  socket is actually used.
  
  For instance, the following code connects to several remote machines
  in parallel:
  
    my (%ssh, %ls);
    # multiple connections are established in parallel:
    for my $host (@hosts) {
        $ssh{$host} = Net::OpenSSH->new($host, async => 1);
    }
    # then to run some command in all the hosts (sequentially):
    for my $host (@hosts) {
        $ssh{$host}->system('ls /');
    }
  
  =item connect => 0
  
  Do not launch the master SSH process yet.
  
  =item master_opts => [...]
  
  Additional options to pass to the C<ssh> command when establishing the
  master connection. For instance:
  
    my $ssh = Net::OpenSSH->new($host,
        master_opts => [-o => "ProxyCommand corkscrew httpproxy 8080 $host"]);
  
  =item default_ssh_opts => [...]
  
  Default slave SSH command line options for L</open_ex> and derived
  methods.
  
  For instance:
  
    my $ssh = Net::OpenSSH->new($host,
        default_ssh_opts => [-o => "ConnectionAttempts=0"]);
  
  =item forward_agent => 1
  
  =item forward_agent => 'always'
  
  Enables forwarding of the authentication agent.
  
  When C<always> is passed as the argument, agent forwarding will be
  enabled by default in all the channels created from the
  object. Otherwise, it will have to be explicitly requested when
  calling the channel creating methods (i.e. C<open_ex> and its
  derivations).
  
  This option can not be used when passing a passphrase (via
  L</passphrase>) to unlock the login private key.
  
  Note that Net::OpenSSH will not run C<ssh-agent> for you. This has to
  be done ahead of time and the environment variable C<SSH_AUTH_SOCK>
  set pointing to the proper place.
  
  =item forward_X11 => 1
  
  Enables forwarding of the X11 protocol
  
  =item default_stdin_fh => $fh
  
  =item default_stdout_fh => $fh
  
  =item default_stderr_fh => $fh
  
  Default I/O streams for L</open_ex> and derived methods (currently, that
  means any method but L</pipe_in> and L</pipe_out> and I plan to remove
  those exceptions soon!).
  
  For instance:
  
    open my $stderr_fh, '>>', '/tmp/$host.err' or die ...;
    open my $stdout_fh, '>>', '/tmp/$host.log' or die ...;
  
    my $ssh = Net::OpenSSH->new($host, default_stderr_fh => $stderr_fh,
                                       default_stdout_fh => $stdout_fh);
    $ssh->error and die "SSH connection failed: " . $ssh->error;
  
    $ssh->scp_put("/foo/bar*", "/tmp")
      or die "scp failed: " . $ssh->error;
  
  =item default_stdin_file = $fn
  
  =item default_stdout_file = $fn
  
  =item default_stderr_file = $fn
  
  Opens the given file names and use them as the defaults.
  
  =item master_stdout_fh => $fh
  
  =item master_stderr_fh => $fh
  
  Redirect corresponding stdio streams of the master SSH process to
  given filehandles.
  
  =item master_stdout_discard => $bool
  
  =item master_stderr_discard => $bool
  
  Discard corresponding stdio streams.
  
  =item expand_vars => $bool
  
  Activates variable expansion inside command arguments and file paths.
  
  See L</"Variable expansion"> below.
  
  =item vars => \%vars
  
  Initial set of variables.
  
  =item external_master => 1
  
  Instead of launching a new OpenSSH client in master mode, the module
  tries to reuse an already existent one. C<ctl_path> must also be
  passed when this option is set. See also L</get_ctl_path>.
  
  Example:
  
    $ssh = Net::OpenSSH->new('foo', external_master => 1, ctl_path = $path);
  
  When C<external_master> is set, the hostname argument becomes optional
  (C<0.0.0.0> is passed to OpenSSH which does not use it at all).
  
  =item default_encoding => $encoding
  
  =item default_stream_encoding => $encoding
  
  =item default_argument_encoding => $encoding
  
  Set default encodings. See L</Data encoding>.
  
  =item password_prompt => $string
  
  =item password_prompt => $re
  
  By default, when using password authentication, the module expects the
  remote side to send a password prompt matching C</[?:]/>.
  
  This option can be used to override that default for the rare cases
  when a different prompt is used.
  
  Examples:
  
     password_prompt => ']'; # no need to escape ']'
     password_prompt => qr/[:?>]/;
  
  =item login_handler => \&custom_login_handler
  
  Some remote SSH server may require a custom login/authentication
  interaction not natively supported by Net::OpenSSH. In that cases, you
  can use this option to replace the default login logic.
  
  The callback will be invoked repeatedly as C<custom_login_handler($ssh,
  $pty, $data)> where C<$ssh> is the current Net::OpenSSH object, C<pty>
  a L<IO::Pty> object attached to the slave C<ssh> process tty and
  C<$data> a reference to an scalar you can use at will.
  
  The login handler must return 1 after the login process has completed
  successfully or 0 in case it still needs to do something else. If some
  error happens, it must die.
  
  Note, that blocking operations should not be performed inside the
  login handler (at least if you want the C<async> and C<timeout>
  features to work).
  
  See also the sample script C<login_handler.pl> in the C<examples>
  directory.
  
  Usage of this option is incompatible with the C<password> and
  C<passphrase> options, you will have to handle password or passphrases
  from the custom handler yourself.
  
  =item master_setpgrp => 1
  
  When this option is set, the master process is run as a different
  process group. As a consequence it will not die when the user presses
  Ctrl-C at the terminal.
  
  In order to allow the master SSH process to request any information
  from the user, the module may set it as the terminal controlling
  process while the connection is established (using
  L<POSIX/tcsetpgrp>). Afterwards, the terminal controlling process is
  reset.
  
  This feature is highly experimental. Report any problems you may find,
  please.
  
  =item master_pty_force => 1
  
  By default, Net::OpenSSH attaches the master SSH process to a pty only
  when some kind of interactive authentication is requested. If this
  flag is set a pty will be attached always.
  
  That allows to get better diagnostics for some kind of errors (as for
  instance, bad host keys) and also allows to retrieve the pty log using
  L<get_master_pty_log>.
  
  =back
  
  =item $ssh->error
  
  Returns the error condition for the last performed operation.
  
  The returned value is a dualvar as $! (see L<perlvar/"$!">) that
  renders an informative message when used in string context or an error
  number in numeric context (error codes appear in
  L<Net::OpenSSH::Constants|Net::OpenSSH::Constants>).
  
  =item $ssh->get_master_pty_log
  
  In order to handle password authentication or entering the passphrase
  for a private key, Net::OpenSSH may run the master SSH process attached
  to a pty.
  
  In that case and after a constructor call returns a connection failure
  error, this method can be called to retrieve the output captured at
  the pty (the log is discarded when the connection is established
  successfully).
  
  Any data consumed from the pty by custom login handlers will be
  missing from the the returned log.
  
  =item $ssh->get_user
  
  =item $ssh->get_host
  
  =item $ssh->get_port
  
  Return the corresponding SSH login parameters.
  
  =item $ssh->get_ctl_path
  
  X<get_ctl_path>Returns the path to the socket where the OpenSSH master
  process listens for new multiplexed connections.
  
  =item ($in, $out, $err, $pid) = $ssh->open_ex(\%opts, @cmd)
  
  X<open_ex>I<Note: this is a low level method which, probably, you do
  not need to use!>
  
  That method starts the command C<@cmd> on the remote machine creating
  new pipes for the IO channels as specified on the C<%opts> hash.
  
  If C<@cmd> is omitted, the remote user shell is run.
  
  Returns four values, the first three (C<$in>, C<$out> and C<$err>)
  correspond to the local side of the pipes created (they can be undef)
  and the fourth (C<$pid>) to the PID of the new SSH slave process. An
  empty list is returned on failure.
  
  Note that C<waitpid> has to be used afterwards to reap the
  slave SSH process.
  
  Accepted options:
  
  =over 4
  
  =item stdin_pipe => 1
  
  Creates a new pipe and connects the reading side to the stdin stream
  of the remote process. The writing side is returned as the first
  value (C<$in>).
  
  =item stdin_pty => 1
  
  Similar to C<stdin_pipe>, but instead of a regular pipe it uses a
  pseudo-tty (pty).
  
  Note that on some operating systems (e.g. HP-UX, AIX), ttys are not
  reliable. They can overflow when large chunks are written or when data
  is written faster than it is read.
  
  =item stdin_fh => $fh
  
  Duplicates C<$fh> and uses it as the stdin stream of the remote process.
  
  =item stdin_file => $filename
  
  =item stdin_file => \@open_args
  
  Opens the file of the given name for reading and uses it as the remote
  process stdin stream.
  
  If an array reference is passed its contents are used as the arguments
  for the underlying open call. For instance:
  
    $ssh->system({stdin_file => ['-|', 'gzip -c -d file.gz']}, $rcmd);
  
  =item stdin_discard => 1
  
  Uses /dev/null as the remote process stdin stream.
  
  =item stdout_pipe => 1
  
  Creates a new pipe and connects the writing side to the stdout stream
  of the remote process. The reading side is returned as the second
  value (C<$out>).
  
  =item stdout_pty => 1
  
  Connects the stdout stream of the remote process to the
  pseudo-pty. This option requires C<stdin_pty> to be also set.
  
  =item stdout_fh => $fh
  
  Duplicates C<$fh> and uses it as the stdout stream of the remote
  process.
  
  =item stdout_file => $filename
  
  =item stdout_file => \@open_args
  
  Opens the file of the given filename and redirect stdout there.
  
  =item stdout_discard => 1
  
  Uses /dev/null as the remote process stdout stream.
  
  =item stdinout_socket => 1
  
  Creates a new socketpair, attaches the stdin an stdout streams of the
  slave SSH process to one end and returns the other as the first value
  (C<$in>) and undef for the second (C<$out>).
  
  Example:
  
    my ($socket, undef, undef, $pid) = $ssh->open_ex({stdinout_socket => 1},
                                                     '/bin/netcat $dest');
  
  See also L</open2socket>.
  
  =item stdinout_dpipe => $cmd
  
  =item stdinout_dpipe => \@cmd
  
  Runs the given command locally attaching its stdio streams to those of
  the remote SSH command. Conceptually it is equivalent to the
  L<dpipe(1)> shell command.
  
  =item stderr_pipe => 1
  
  Creates a new pipe and connects the writing side to the stderr stream
  of the remote process. The reading side is returned as the third
  value (C<$err>).
  
  Example:
  
    my $pid = $ssh->open_ex({stdinout_dpipe => 'vncviewer -stdio'},
                            x11vnc => '-inetd');
  
  =item stderr_fh => $fh
  
  Duplicates C<$fh> and uses it as the stderr stream of the remote process.
  
  =item stderr_file => $filename
  
  Opens the file of the given name and redirects stderr there.
  
  =item stderr_to_stdout => 1
  
  Makes stderr point to stdout.
  
  =item tty => $bool
  
  Tells C<ssh> to allocate a pseudo-tty for the remote process. By
  default, a tty is allocated if remote command stdin stream is attached
  to a tty.
  
  When this flag is set and stdin is not attached to a tty, the ssh
  master and slave processes may generate spurious warnings about failed
  tty operations. This is caused by a bug present in older versions of
  OpenSSH.
  
  =item close_slave_pty => 0
  
  When a pseudo pty is used for the stdin stream, the slave side is
  automatically closed on the parent process after forking the ssh
  command.
  
  This option disables that feature, so that the slave pty can be
  accessed on the parent process as C<$pty-E<gt>slave>. It will have to
  be explicitly closed (see L<IO::Pty|IO::Pty>)
  
  =item quote_args => $bool
  
  See L</"Shell quoting"> below.
  
  =item remote_shell => $shell
  
  Sets the remote shell. Allows one to change the argument quoting
  mechanism in a per-command fashion.
  
  This may be useful when interacting with a Windows machine where
  argument parsing may be done at the command level in custom ways.
  
  Example:
  
    $ssh->system({remote_shell => 'MSWin'}, echo => $line);
    $ssh->system({remote_shell => 'MSCmd,MSWin'}, type => $file);
  
  =item forward_agent => $bool
  
  Enables/disables forwarding of the authentication agent.
  
  This option can only be used when agent forwarding has been previously
  requested on the constructor.
  
  =item forward_X11 => $bool
  
  Enables/disables forwarding of the X11 protocol.
  
  This option can only be used when X11 forwarding has been previously
  requested on the constructor.
  
  =item ssh_opts => \@opts
  
  List of extra options for the C<ssh> command.
  
  This feature should be used with care, as the given options are not
  checked in any way by the module, and they could interfere with it.
  
  =item tunnel => $bool
  
  Instead of executing a command in the remote host, this option
  instruct Net::OpenSSH to create a TCP tunnel. The arguments become the
  target IP and port or the remote path for an Unix socket.
  
  Example:
  
    my ($in, $out, undef, $pid) = $ssh->open_ex({tunnel => 1}, $IP, $port);
    my ($in, $out, undef, $pid) = $ssh->open_ex({tunnel => 1}, $socket_path);
  
  See also L</Tunnels>.
  
  =item subsystem => $bool
  
  Request a connection to a SSH subsystem. The name of the subsystem
  must be passed as an argument, as in the following example:
  
    my $s = $ssh->open2socket({subsystem => 1}, 'netconf');
  
  =item encoding => $encoding
  
  =item argument_encoding => $encoding
  
  Set encodings. See L</Data encoding>.
  
  =back
  
  Usage example:
  
    # similar to IPC::Open2 open2 function:
    my ($in_pipe, $out_pipe, undef, $pid) =
        $ssh->open_ex( { stdin_pipe => 1,
                         stdout_pipe => 1 },
                       @cmd )
        or die "open_ex failed: " . $ssh->error;
    # do some IO through $in/$out
    # ...
    waitpid($pid);
  
  =item setpgrp => 1
  
  Calls C<setpgrp> after forking the child process. As a result it will
  not die when the user presses Ctrl+C at the console. See also
  L<perlfunc/setpgrp>.
  
  Using this option without also setting C<master_setpgrp> on the
  constructor call is mostly useless as the signal will be delivered to
  the master process and all the remote commands aborted.
  
  This feature is experimental.
  
  =item $ssh->system(\%opts, @cmd)
  
  Runs the command C<@cmd> on the remote machine.
  
  Returns true on success, undef otherwise.
  
  The error status is set to C<OSSH_SLAVE_CMD_FAILED> when the remote
  command exits with a non zero code (the code is available from C<$?>,
  see L<perlvar/"$?">).
  
  Example:
  
    $ssh->system('ls -R /')
      or die "ls failed: " . $ssh->error";
  
  As for C<system> builtin, C<SIGINT> and C<SIGQUIT> signals are
  blocked.  (see L<perlfunc/system>). Also, setting C<$SIG{CHLD}> to
  C<IGNORE> or to a custom signal handler will interfere with this
  method.
  
  Accepted options:
  
  =over 4
  
  =item stdin_data => $input
  
  =item stdin_data => \@input
  
  Sends the given data through the stdin stream to the remote
  process.
  
  For example, the following code creates a file on the remote side:
  
    $ssh->system({stdin_data => \@data}, "cat >/tmp/foo")
      or die "unable to write file: " . $ssh->error;
  
  =item timeout => $timeout
  
  The operation is aborted after C<$timeout> seconds elapsed without
  network activity.
  
  See also L</Timeouts>.
  
  =item async => 1
  
  Does not wait for the child process to exit. The PID of the new
  process is returned.
  
  Note that when this option is combined with C<stdin_data>, the given
  data will be transferred to the remote side before returning control
  to the caller.
  
  See also the L</spawn> method documentation below.
  
  =item stdin_fh => $fh
  
  =item stdin_discard => $bool
  
  =item stdout_fh => $fh
  
  =item stdout_discard => $bool
  
  =item stderr_fh => $fh
  
  =item stderr_discard => $bool
  
  =item stderr_to_stdout => $bool
  
  =item stdinout_dpipe => $cmd
  
  =item tty => $bool
  
  See the L</open_ex> method documentation for an explanation of these
  options.
  
  =item stdin_keep_open => $bool
  
  When C<stdin_data> is given, the module closes the stdin stream once
  all the data has been sent. Unfortunately, some SSH buggy servers fail
  to handle this event correctly and close the channel prematurely.
  
  As a workaround, when this flag is set the stdin is left open until
  the remote process terminates.
  
  =back
  
  =item $ok = $ssh->test(\%opts, @cmd);
  
  Runs the given command and returns its success/failure exit status as
  1 or 0 respectively. Returns undef when something goes wrong in the
  SSH layer.
  
  Error status is not set to OSSH_SLAVE_CMD_FAILED when the remote
  command exits with a non-zero code.
  
  By default this method discards the remote command C<stdout> and
  C<sterr> streams.
  
  Usage example:
  
    if ($ssh->test(ps => -C => $executable)) {
      say "$executable is running on remote machine"
    }
    else {
      die "something got wrong: ". $ssh->error if $ssh->error;
  
      say "$executable is not running on remote machine"
    }
  
  This method support the same set of options as C<system>, except
  C<async> and C<tunnel>.
  
  =item $output = $ssh->capture(\%opts, @cmd);
  
  =item @output = $ssh->capture(\%opts, @cmd);
  
  This method is conceptually equivalent to the perl backquote operator
  (e.g. C<`ls`>): it runs the command on the remote machine and captures
  its output.
  
  In scalar context returns the output as a scalar. In list context
  returns the output broken into lines (it honors C<$/>, see
  L<perlvar/"$/">).
  
  The exit status of the remote command is returned in C<$?>.
  
  When an error happens while capturing (for instance, the operation
  times out), the partial captured output will be returned. Error
  conditions have to be explicitly checked using the L</error>
  method. For instance:
  
    my $output = $ssh->capture({ timeout => 10 },
                               "echo hello; sleep 20; echo bye");
    $ssh->error and
        warn "operation didn't complete successfully: ". $ssh->error;
    print $output;
  
  Setting C<$SIG{CHLD}> to a custom signal handler or to C<IGNORE> will
  interfere with this method.
  
  Accepted options:
  
  =over 4
  
  =item stdin_data => $input
  
  =item stdin_data => \@input
  
  =item stdin_keep_open => $bool
  
  See the L</system> method documentation for an explanation of these
  options.
  
  =item timeout => $timeout
  
  See L</Timeouts>.
  
  =item stdin_fh => $fh
  
  =item stdin_discard => $bool
  
  =item stderr_fh => $fh
  
  =item stderr_discard => $bool
  
  =item stderr_to_stdout => $bool
  
  =item tty => $bool
  
  See the L</open_ex> method documentation for an explanation of these
  options.
  
  =back
  
  =item ($output, $errput) = $ssh->capture2(\%opts, @cmd)
  
  captures the output sent to both stdout and stderr by C<@cmd> on the
  remote machine.
  
  Setting C<$SIG{CHLD}> to a custom signal handler or to C<IGNORE> will
  also interfere with this method.
  
  The accepted options are:
  
  =over 4
  
  =item stdin_data => $input
  
  =item stdin_data => \@input
  
  =item stdin_keep_open => $bool
  
  See the L</system> method documentation for an explanation of these
  options.
  
  =item timeout => $timeout
  
  See L</Timeouts>.
  
  =item stdin_fh => $fh
  
  =item stdin_discard => $bool
  
  =item tty => $bool
  
  See the L</open_ex> method documentation for an explanation of these
  options.
  
  =back
  
  =item ($in, $pid) = $ssh->pipe_in(\%opts, @cmd)
  
  X<pipe_in>This method is similar to the following Perl C<open> call
  
    $pid = open $in, '|-', @cmd
  
  but running @cmd on the remote machine (see L<perlfunc/open>).
  
  No options are currently accepted.
  
  There is no need to perform a waitpid on the returned PID as it will
  be done automatically by perl when C<$in> is closed.
  
  Example:
  
    my ($in, $pid) = $ssh->pipe_in('cat >/tmp/fpp')
        or die "pipe_in failed: " . $ssh->error;
    print $in $_ for @data;
    close $in or die "close failed";
  
  =item ($out, $pid) = $ssh->pipe_out(\%opts, @cmd)
  
  X<pipe_out>Reciprocal to previous method, it is equivalent to
  
    $pid = open $out, '-|', @cmd
  
  running @cmd on the remote machine.
  
  No options are currently accepted.
  
  =item ($in, $out, $pid) = $ssh->open2(\%opts, @cmd)
  
  =item ($pty, $pid) = $ssh->open2pty(\%opts, @cmd)
  
  =item ($socket, $pid) = $ssh->open2socket(\%opts, @cmd)
  
  =item ($in, $out, $err, $pid) = $ssh->open3(\%opts, @cmd)
  
  =item ($pty, $err, $pid) = $ssh->open3pty(\%opts, @cmd)
  
  Shortcuts around L</open_ex> method.
  
  =item $pid = $ssh->spawn(\%opts, @_)
  
  X<spawn>Another L</open_ex> shortcut, it launches a new remote process
  in the background and returns the PID of the local slave SSH process.
  
  At some later point in your script, C<waitpid> should be called on the
  returned PID in order to reap the slave SSH process.
  
  For instance, you can run some command on several hosts in parallel
  with the following code:
  
    my %conn = map { $_ => Net::OpenSSH->new($_, async => 1) } @hosts;
    my @pid;
    for my $host (@hosts) {
        open my($fh), '>', "/tmp/out-$host.txt"
          or die "unable to create file: $!";
        push @pid, $conn{$host}->spawn({stdout_fh => $fh}, $cmd);
    }
  
    waitpid($_, 0) for @pid;
  
  Note that C<spawn> should not be used to start detached remote
  processes that may survive the local program (see also the L</FAQ>
  about running remote processes detached).
  
  =item ($socket, $pid) = $ssh->open_tunnel(\%opts, $dest_host, $port)
  
  =item ($socket, $pid) = $ssh->open_tunnel(\%opts, $socket_path)
  
  X<open_tunnel>Similar to L</open2socket>, but instead of running a
  command, it opens a TCP tunnel to the given address. See also
  L</Tunnels>.
  
  =item $out = $ssh->capture_tunnel(\%opts, $dest_host, $port)
  
  =item @out = $ssh->capture_tunnel(\%opts, $dest_host, $port)
  
  X<capture_tunnel>Similar to L</capture>, but instead of running a command, it opens a
  TCP tunnel.
  
  Example:
  
    $out = $ssh->capture_tunnel({stdin_data => join("\r\n",
                                                    "GET / HTTP/1.0",
                                                    "Host: www.perl.org",
                                                    "", "") },
                                'www.perl.org', 80)
  
  See also L</Tunnels>.
  
  =item $ssh->scp_get(\%opts, $remote1, $remote2,..., $local_dir_or_file)
  
  =item $ssh->scp_put(\%opts, $local, $local2,..., $remote_dir_or_file)
  
  These two methods are wrappers around the C<scp> command that allow
  transfers of files to/from the remote host using the existing SSH
  master connection.
  
  When transferring several files, the target argument must point to an
  existing directory. If only one file is to be transferred, the target
  argument can be a directory or a file name or can be omitted. For
  instance:
  
    $ssh->scp_get({glob => 1}, '/var/tmp/foo*', '/var/tmp/bar*', '/tmp');
    $ssh->scp_put('/etc/passwd');
  
  Both L</scp_get> and L</scp_put> methods return a true value when all
  the files are transferred correctly, otherwise they return undef.
  
  Accepted options:
  
  =over 4
  
  =item quiet => 0
  
  By default, C<scp> is called with the quiet flag C<-q> enabled in
  order to suppress progress information. This option allows one to
  re-enable the progress indication bar.
  
  =item verbose => 1
  
  Calls C<scp> with the C<-v> flag.
  
  =item recursive => 1
  
  Copies files and directories recursively.
  
  =item glob => 1
  
  Enables expansion of shell metacharacters in the sources list so that
  wildcards can be used to select files.
  
  =item glob_flags => $flags
  
  Second argument passed to L<File::Glob::bsd_glob|File::Glob/bsd_glob>
  function. Only available for L</scp_put> method.
  
  =item copy_attrs => 1
  
  Copies modification and access times and modes from the original
  files.
  
  =item bwlimit => $Kbits
  
  Limits the used bandwidth, specified in Kbit/s.
  
  =item timeout => $secs
  
  The transfer is aborted if the connection does not finish before the
  given timeout elapses. See also L</Timeouts>.
  
  =item async => 1
  
  Does not wait for the C<scp> command to finish. When this option is
  used, the method returns the PID of the child C<scp> process.
  
  For instance, it is possible to transfer files to several hosts in
  parallel as follows:
  
    use Errno;
    my (%pid, %ssh);
    for my $host (@hosts) {
      $ssh{$host} = Net::OpenSSH->new($host, async => 1);
    }
    for my $host (@hosts) {
      $pid{$host} = $ssh{$host}->scp_put({async => 1}, $local_fn, $remote_fn)
        or warn "scp_put to $host failed: " . $ssh{$host}->error . "\n";
    }
    for my $host (@hosts) {
      if (my $pid = $pid{$host}) {
        if (waitpid($pid, 0) > 0) {
          my $exit = ($? >> 8);
          $exit and warn "transfer of file to $host failed ($exit)\n";
        }
        else {
          redo if ($! == EINTR);
          warn "waitpid($pid) failed: $!\n";
        }
      }
    }
  
  =item stdout_fh => $fh
  
  =item stderr_fh => $fh
  
  =item stderr_to_stdout => 1
  
  These options are passed unchanged to method L</open_ex>, allowing
  capture of the output of the C<scp> program.
  
  Note that C<scp> will not generate progress reports unless its stdout
  stream is attached to a tty.
  
  =item ssh_opts => \@opts
  
  List of extra options for the C<ssh> command.
  
  This feature should be used with care, as the given options are not
  checked in any way by the module, and they could interfere with it.
  
  =back
  
  =item $ssh->rsync_get(\%opts, $remote1, $remote2,..., $local_dir_or_file)
  
  =item $ssh->rsync_put(\%opts, $local1, $local2,..., $remote_dir_or_file)
  
  These methods use C<rsync> over SSH to transfer files from/to the remote
  machine.
  
  They accept the same set of options as the C<scp> ones.
  
  Any unrecognized option will be passed as an argument to the C<rsync>
  command (see L<rsync(1)>). Underscores can be used instead of dashes
  in C<rsync> option names.
  
  For instance:
  
    $ssh->rsync_get({exclude => '*~',
                     verbose => 1,
                     safe_links => 1},
                    '/remote/dir', '/local/dir');
  
  =item $sftp = $ssh->sftp(%sftp_opts)
  
  X<Net_SFTP_Foreign>Creates a new L<Net::SFTP::Foreign|Net::SFTP::Foreign> object
  for SFTP interaction that runs through the ssh master connection.
  
  =item @call = $ssh->make_remote_command(\%opts, @cmd)
  
  =item $call = $ssh->make_remote_command(\%opts, @cmd)
  
  This method returns the arguments required to execute a command on the
  remote machine via SSH. For instance:
  
    my @call = $ssh->make_remote_command(ls => "/var/log");
    system @call;
  
  In scalar context, returns the arguments quoted and joined into one
  string:
  
    my $remote = $ssh->make_remote_comand("cd /tmp/ && tar xf -");
    system "tar cf - . | $remote";
  
  The options accepted are as follows:
  
  =over 4
  
  =item tty => $bool
  
  Enables/disables allocation of a tty on the remote side.
  
  =item forward_agent => $bool
  
  Enables/disables forwarding of authentication agent.
  
  This option can only be used when agent forwarding has been previously
  requested on the constructor.
  
  =item tunnel => 1
  
  Return a command to create a connection to some TCP server reachable
  from the remote host. In that case the arguments are the destination
  address and port. For instance:
  
    $cmd = $ssh->make_remote_command({tunnel => 1}, $host, $port);
  
  =item subsystem => 1
  
  Return a command for invoking a SSH subsystem (i.e. SFTP or
  netconf). In that case the only argument is the subsystem name.
  
  =back
  
  =item $ssh->wait_for_master($async)
  
  When the connection has been established by calling the constructor
  with the C<async> option, this call allows one to advance the process.
  
  If C<$async> is true, it will perform any work that can be done
  immediately without waiting (for instance, entering the password or
  checking for the existence of the multiplexing socket) and then
  return. If a false value is given, it will finalize the connection
  process and wait until the multiplexing socket is available.
  
  It returns a true value after the connection has been successfully
  established. False is returned if the connection process fails or if
  it has not yet completed (then, the L</error> method can be used to
  distinguish between both cases).
  
  From version 0.64 upwards, undef is returned when the master is still
  in an unstable state (login, killing, etc.) and 0 when it is in a
  stable state (running, stopped or gone).
  
  =item $ssh->check_master
  
  This method runs several checks to ensure that the master connection
  is still alive.
  
  =item $ssh->shell_quote(@args)
  
  Returns the list of arguments quoted so that they will be restored to
  their original form when parsed by the remote shell.
  
  In scalar context returns the list of arguments quoted and joined.
  
  Usually this task is done automatically by the module. See L</"Shell
  quoting"> below.
  
  This method can also be used as a class method.
  
  Example:
  
    my $quoted_args = Net::OpenSSH->shell_quote(@args);
    system('ssh', '--', $host, $quoted_args);
  
  =item $ssh->shell_quote_glob(@args)
  
  This method is like the previous C<shell_quote> but leaves wildcard
  characters unquoted.
  
  It can be used as a class method also.
  
  =item $ssh->set_expand_vars($bool)
  
  Enables/disables variable expansion feature (see L</"Variable
  expansion">).
  
  =item $ssh->get_expand_vars
  
  Returns current state of variable expansion feature.
  
  =item $ssh->set_var($name, $value)
  
  =item $ssh->get_var($name, $value)
  
  These methods allow one to change and to retrieve the value of the
  given name.
  
  =item $ssh->get_master_pid
  
  Returns the PID of the master SSH process
  
  =item $ssh->master_exited
  
  This methods allows one to tell the module that the master process has
  exited when we get its PID from some external wait or waitpid
  call. For instance:
  
    my $ssh = Net::OpenSSH->new('foo', async => 1);
  
    # create new processes
    # ...
  
    # rip them...
    my $master_pid = $ssh->master_pid;
    while ((my $pid = wait) > 0) {
      if ($pid == $master_pid) {
        $ssh->master_exited;
      }
    }
  
  If your program rips the master process and this method is not called,
  the OS could reassign the PID to a new unrelated process and the
  module would try to kill it at object destruction time.
  
  =item $ssh->disconnect($async)
  
  Shuts down the SSH connection.
  
  Usually, you don't need to call this method explicitly, but just let
  the Net::OpenSSH object go out of scope.
  
  If C<async> is true, it doesn't wait for the SSH connection to
  terminate. In that case, L</wait_for_master> must be called repeatedly
  until the shutdown sequence terminates (See the L</AnyEvent>
  integration section below).
  
  =item $ssh->restart($async)
  
  Restarts the SSH session closing any open connection and creating a
  new one. Any open channel would also be killed.
  
  Note that calling this method may request again the password or
  passphrase from the user.
  
  In asynchronous mode, this method requires the connection to be
  terminated before it gets called. Afterwards, C<wait_for_master>
  should be called repeaptly until the new connection is stablished.
  For instance:
  
    my $async = 1;
    $ssh->disconnect($async);
    while (1) {
      defined $ssh->wait_for_master($async) # returns 0 when the
                                            # disconnect process
                                            # finishes
        and last;
      do_something_else();
    }
    $ssh->restart($async);
    while (1) {
      defined $ssh->wait_for_master($async)
        and last;
      do_something_else();
    }
  
  
  =item $pid = $ssh->sshfs_import(\%opts, $remote_fs, $local_mnt_point)
  
  =item $pid = $ssh->sshfs_export(\%opts, $local_fs, $remote_mnt_point)
  
  These methods use L<sshfs(1)> to import or export a file system
  through the SSH connection.
  
  They return the C<$pid> of the C<sshfs> process or of the slave C<ssh>
  process used to proxy it. Killing that process unmounts the file
  system, though, it may be probably better to use L<fusermount(1)>.
  
  The options accepted are as follows:
  
  =over
  
  =item ssh_opts => \@ssh_opts
  
  Options passed to the slave C<ssh> process.
  
  =item sshfs_opts => \@sshfs_opts
  
  Options passed to the C<sshfs> command. For instance, to mount the file
  system in read-only mode:
  
    my $pid = $ssh->sshfs_export({sshfs_opts => [-o => 'ro']},
                                 "/", "/mnt/foo");
  
  =back
  
  Note that this command requires a recent version of C<sshfs> to work (at
  the time of writing, it requires the yet unreleased version available
  from the FUSE git repository!).
  
  See also the L<sshfs(1)> man page and the C<sshfs> and FUSE web sites
  at L<https://github.com/libfuse/sshfs> and
  L<https://github.com/libfuse/libfuse> respectively.
  
  =item $or = $ssh->object_remote(@args)
  
  X<Object_Remote>Returns an L<Object::Remote::Connection> instance
  running on top of the Net::OpenSSH connection.
  
  Example:
  
     my $or = $ssh->object_remote;
     my $hostname = Sys::Hostname->can::on($or, 'hostname');
     say $hostname->();
  
  See also L<Object::Remote>.
  
  =item $any = $ssh->any(%opts)
  
  X<Net_SSH_Any>Wraps the current object inside a Net::SSH::Any one.
  
  Example:
  
    my $any = $ssh->any;
    my $content = $any->scp_get_content("my-file.txt");
  
  =item $pid = $ssh->disown_master
  
  Under normal operation Net::OpenSSH controls the life-time of the
  master C<ssh> process and when the object is destroyed the master
  process and any connection running over it are terminated.
  
  In some (rare) cases, it is desirable to let the master process and
  all the running connections survive. Calling this method does just
  that, it tells Net::OpenSSH object that the master process is not its
  own anymore.
  
  The return value is the PID of the master process.
  
  Note also that disowning the master process does not affect the
  operation of the module in any other regard.
  
  For instance:
  
    # See examples/sshfs_mount.pl for a working program
    my $ssh = Net::OpenSSH->new($host);
    my $sshfs_pid = $ssh->sshfs_import("/home/foo", "my-remote-home");
    $ssh->disown_master;
    $ssh->stop; # tells the master to stop accepting requests
    exit(0);
  
  =back
  
  =head2 Shell quoting
  
  By default, when invoking remote commands, this module tries to mimic
  perl C<system> builtin in regard to argument processing. Quoting
  L<perlfunc/system>:
  
    Argument processing varies depending on the number of arguments.  If
    there is more than one argument in LIST, or if LIST is an array with
    more than one value, starts the program given by the first element
    of the list with arguments given by the rest of the list.  If there
    is only one scalar argument, the argument is checked for shell
    metacharacters, and if there are any, the entire argument is passed
    to the system's command shell for parsing (this is "/bin/sh -c" on
    Unix platforms, but varies on other platforms).
  
  Take for example Net::OpenSSH L</system> method:
  
    $ssh->system("ls -l *");
    $ssh->system('ls', '-l', '/');
  
  The first call passes the argument unchanged to ssh and it is executed
  in the remote side through the shell which interprets metacharacters.
  
  The second call escapes any shell metacharacters so that, effectively,
  it is equivalent to calling the command directly and not through the
  shell.
  
  Under the hood, as the Secure Shell protocol does not provide for this
  mode of operation and always spawns a new shell where it runs the
  given command, Net::OpenSSH quotes any shell metacharacters in the
  command list.
  
  All the methods that invoke a remote command (system, open_ex, etc.)
  accept the option C<quote_args> that allows one to force/disable shell
  quoting.
  
  For instance:
  
    $ssh->system({quote_args => 1}, "/path with spaces/bin/foo");
  
  will correctly handle the spaces in the program path.
  
  The shell quoting mechanism implements some extensions (for instance,
  performing redirections to /dev/null on the remote side) that can be
  disabled with the option C<quote_args_extended>:
  
    $ssh->system({ stderr_discard => 1,
                   quote_args => 1, quote_args_extended => 0 },
                 @cmd);
  
  The option C<quote_args> can also be used to disable quoting when more
  than one argument is passed. For instance, to get some pattern
  expanded by the remote shell:
  
    $ssh->system({quote_args => 0}, 'ls', '-l', "/tmp/files_*.dat");
  
  The method C<shell_quote> can be used to selectively quote some
  arguments and leave others untouched:
  
    $ssh->system({quote_args => 0},
                 $ssh->shell_quote('ls', '-l'),
                 "/tmp/files_*.dat");
  
  When the glob option is set in C<scp> and C<rsync> file transfer
  methods, an alternative quoting method which knows about file
  wildcards and passes them unquoted is used. The set of wildcards
  recognized currently is the one supported by L<bash(1)>.
  
  Another way to selectively use quote globing or fully disable quoting
  for some specific arguments is to pass them as scalar references or
  double scalar references respectively. In practice, that means
  prepending them with one or two backslashes. For instance:
  
    # quote the last argument for globing:
    $ssh->system('ls', '-l', \'/tmp/my files/filed_*dat');
  
    # append a redirection to the remote command
    $ssh->system('ls', '-lR', \\'>/tmp/ls-lR.txt');
  
    # expand remote shell variables and glob in the same command:
    $ssh->system('tar', 'czf', \\'$HOME/out.tgz', \'/var/log/server.*.log');
  
  As shell quoting is a tricky matter, I expect bugs to appear in this
  area. You can see how C<ssh> is called, and the quoting used setting
  the following debug flag:
  
    $Net::OpenSSH::debug |= 16;
  
  By default, the module assumes the remote shell is some variant of a
  POSIX or Bourne shell (C<bash>, C<dash>, C<ksh>, etc.). If this is not
  the case, the construction option C<remote_shell> can be used to
  select an alternative quoting mechanism.
  
  For instance:
  
    $ssh = Net::OpenSSH->new($host, remote_shell => 'csh');
    $ssh->system(echo => "hard\n to\n  quote\n   argument!");
  
  Currently there are quoters available for POSIX (Bourne) compatible
  shells, C<csh> and the two Windows variants C<MSWin> (for servers
  using L<Win32::CreateProcess>, see
  L<Net::OpenSSH::ShellQuoter::MSWin>) and C<MSCmd> (for servers using
  C<cmd.exe>, see L<Net::OpenSSH::ShellQuoter::MSCmd>).
  
  In any case, you can always do the quoting yourself and pass the
  quoted remote command as a single string:
  
    # for VMS
    $ssh->system('DIR/SIZE NFOO::USERS:[JSMITH.DOCS]*.TXT;0');
  
  Note that the current quoting mechanism does not handle possible
  aliases defined by the remote shell. In that case, to force execution
  of the command instead of the alias, the full path to the command must
  be used.
  
  =head2 Timeouts
  
  In order to stop remote processes when they timeout, the ideal approach
  would be to send them signals through the SSH connection as specified
  by the protocol standard.
  
  Unfortunately OpenSSH does not implement that feature so Net::OpenSSH
  has to use other imperfect approaches:
  
  =over 4
  
  =item * close slave I/O streams
  
  Closing the STDIN and STDOUT streams of the unresponsive remote
  process will effectively deliver a SIGPIPE when it tries to access any
  of them.
  
  Remote processes may not access STDIN or STDOUT and even then,
  Net::OpenSSH can only close these channels when it is capturing them,
  so this approach does not always work.
  
  =item * killing the local SSH slave process
  
  This action may leave the remote process running, creating a remote
  orphan so Net::OpenSSH does not use it unless the construction option
  C<kill_ssh_on_timeout> is set.
  
  =back
  
  Luckily, future versions of OpenSSH will support signaling remote
  processes via the mux channel.
  
  =head2 Variable expansion
  
  The variable expansion feature allows one to define variables that are
  expanded automatically inside command arguments and file paths.
  
  This feature is disabled by default. It is intended to be used with
  L<Net::OpenSSH::Parallel|Net::OpenSSH::Parallel> and other similar
  modules.
  
  Variables are delimited by a pair of percent signs (C<%>), for
  instance C<%HOST%>. Also, two consecutive percent signs are replaced
  by a single one.
  
  The special variables C<HOST>, C<USER> and C<PORT> are maintained
  internally by the module and take the obvious values.
  
  Variable expansion is performed before shell quoting (see L</"Shell
  quoting">).
  
  Some usage example:
  
    my $ssh = Net::OpenSSH->new('server.foo.com', expand_vars => 1);
    $ssh->set_var(ID => 42);
    $ssh->system("ls >/tmp/ls.out-%HOST%-%ID%");
  
  will redirect the output of the C<ls> command to
  C</tmp/ls.out-server.foo.com-42> on the remote host.
  
  =head2 Tunnels
  
  Besides running commands on the remote host, Net::OpenSSH also allows
  one to tunnel TCP connections to remote machines reachable from the
  SSH server.
  
  That feature is made available through the C<tunnel> option of the
  L</open_ex> method, and also through wrapper methods L</open_tunnel>
  and L</capture_tunnel> and most others where it makes sense.
  
  Example:
  
    $ssh->system({tunnel => 1,
                  stdin_data => "GET / HTTP/1.0\r\n\r\n",
                  stdout_file => "/tmp/$server.res"},
                 $server, 80)
        or die "unable to retrieve page: " . $ssh->error;
  
  or capturing the output of several requests in parallel:
  
    my @pids;
    for (@servers) {
      my $pid = $ssh->spawn({tunnel => 1,
                             stdin_file => "/tmp/request.req",
                             stdout_file => "/tmp/$_.res"},
                            $_, 80);
      if ($pid) {
        push @pids, $pid;
      }
      else {
        warn "unable to spawn tunnel process to $_: " . $ssh->error;
      }
    }
    waitpid ($_, 0) for (@pids);
  
  Under the hood, in order to create a tunnel, a new C<ssh> process is
  spawned with the option C<-W${address}:${port}> (available from
  OpenSSH 5.4 and upwards) making it redirect its stdio streams to the
  remote given address. Unlike when C<ssh> C<-L> options is used to
  create tunnels, no TCP port is opened on the local machine at any time
  so this is a perfectly secure operation.
  
  The PID of the new process is returned by the named methods. It must
  be reaped once the pipe or socket handlers for the local side of the
  tunnel have been closed.
  
  OpenSSH 5.4 or later is required for the tunnels functionality to
  work. Also, note that tunnel forwarding may be administratively
  forbidden at the server side (see L<sshd(8)> and L<sshd_config(5)> or
  the documentation provided by your SSH server vendor).
  
  =head3 Tunnels targeting UNIX sockets
  
  When connecting to hosts running a recent version of OpenSSH sshd, it
  is also possible to open connections targeting Unix sockets.
  
  For instance:
  
    my $response = $ssh->capture({tunnel => 1, stdin_data => $request },
                                 "/tmp/socket-foo");
  
  Currently, this feature requires a patched OpenSSH ssh client. The
  patch is available as
  C<patches/openssh-fwd-stdio-to-streamlocal-1.patch>.
  
  =head3 Port forwarding
  
  L<Net::OpenSSH> does not offer direct support for handling port
  forwardings between server and client. But that can be done easily
  anyway passing custom SSH options to its methods.
  
  For instance, tunnel creation options can be passed to the constructor:
  
    my $ssh = Net::OpenSSH->new(...
                      master_opts => -Llocalhost:1234:localhost:3306');
  
  The port forwardings can also be changed for a running SSH connection
  using a Control command:
  
      # setting up a tunnel:
      $ssh->system({ssh_opts => ['-O','forward',
                                 '-L127.0.0.1:12345:127.0.0.1:3306']});
  
      # canceling it:
      $ssh->system({ssh_opts => ['-O', 'cancel',
                                 '-L127.0.0.1:12345:127.0.0.1:3306']});
  
  =head2 Data encoding
  
  Net::OpenSSH has some support for transparently converting the data send
  or received from the remote server to Perl internal unicode
  representation.
  
  The methods supporting that feature are those that move data from/to
  Perl data structures (e.g. C<capture>, C<capture2>, C<capture_tunnel>
  and methods supporting the C<stdin_data> option). Data accessed through
  pipes, sockets or redirections is not affected by the encoding options.
  
  It is also possible to set the encoding of the command and arguments
  passed to the remote server on the command line.
  
  By default, if no encoding option is given on the constructor or on the
  method calls, Net::OpenSSH will not perform any encoding transformation,
  effectively processing the data as C<latin1>.
  
  When data can not be converted between the Perl internal
  representation and the selected encoding inside some Net::OpenSSH
  method, it will fail with an C<OSSH_ENCODING_ERROR> error.
  
  The supported encoding options are as follows:
  
  =over 4
  
  =item stream_encoding => $encoding
  
  sets the encoding of the data send and received on capture methods.
  
  =item argument_encoding => $encoding
  
  sets the encoding of the command line arguments
  
  =item encoding => $encoding
  
  sets both C<argument_encoding> and C<stream_encoding>.
  
  =back
  
  The constructor also accepts C<default_encoding>,
  C<default_stream_encoding> and C<default_argument_encoding> that set the
  defaults.
  
  =head2 Diverting C<new>
  
  When a code ref is installed at C<$Net::OpenSSH::FACTORY>, calls to new
  will be diverted through it.
  
  That feature can be used to transparently implement connection
  caching, for instance:
  
    my $old_factory = $Net::OpenSSH::FACTORY;
    my %cache;
  
    sub factory {
      my ($class, %opts) = @_;
      my $signature = join("\0", $class, map { $_ => $opts{$_} }, sort keys %opts);
      my $old = $cache{signature};
      return $old if ($old and $old->error != OSSH_MASTER_FAILED);
      local $Net::OpenSSH::FACTORY = $old_factory;
      $cache{$signature} = $class->new(%opts);
    }
  
    $Net::OpenSSH::FACTORY = \&factory;
  
  ... and I am sure it can be abused in several other ways!
  
  
  =head1 3rd PARTY MODULE INTEGRATION
  
  =head2 Expect
  
  Sometimes you would like to use L<Expect> to control some program
  running in the remote host. You can do it as follows:
  
    my ($pty, $pid) = $ssh->open2pty(@cmd)
        or die "unable to run remote command @cmd";
    my $expect = Expect->init($pty);
  
  Then, you will be able to use the new Expect object in C<$expect> as
  usual.
  
  =head2 Net::Telnet
  
  This example is adapted from L<Net::Telnet> documentation:
  
    my ($pty, $pid) = $ssh->open2pty({stderr_to_stdout => 1})
      or die "unable to start remote shell: " . $ssh->error;
    my $telnet = Net::Telnet->new(-fhopen => $pty,
                                  -prompt => '/.*\$ $/',
                                  -telnetmode => 0,
                                  -cmd_remove_mode => 1,
                                  -output_record_separator => "\r");
  
    $telnet->waitfor(-match => $telnet->prompt,
                     -errmode => "return")
      or die "login failed: " . $telnet->lastline;
  
    my @lines = $telnet->cmd("who");
  
    ...
  
    $telnet->close;
    waitpid($pid, 0);
  
  =head2 mod_perl and mod_perl2
  
  L<mod_perl> and L<mod_perl2> tie STDIN and STDOUT to objects that are
  not backed up by real file descriptors at the operating system
  level. Net::OpenSSH will fail if any of these handles is used
  explicitly or implicitly when calling some remote command.
  
  The work-around is to redirect them to C</dev/null> or to some file:
  
    open my $def_in, '<', '/dev/null' or die "unable to open /dev/null";
    my $ssh = Net::OpenSSH->new($host,
                                default_stdin_fh => $def_in);
  
    my $out = $ssh->capture($cmd1);
    $ssh->system({stdout_discard => 1}, $cmd2);
    $ssh->system({stdout_to_file => '/tmp/output'}, $cmd3);
  
  Also, note that from a security stand point, running C<ssh> from
  inside the web server process is not a great idea. An attacker
  exploiting some Apache bug would be able to access the SSH keys and
  passwords and gain unlimited access to the remote systems.
  
  If you can, use a queue (as L<TheSchwartz|TheSchwartz>) or any other
  mechanism to execute the ssh commands from another process running
  under a different user account.
  
  At a minimum, ensure that C<~www-data/.ssh> (or similar) is not
  accessible through the web server!
  
  =head2 Net::SFTP::Foreign
  
  See L<method C<sftp>|/Net_SFTP_Foreign>.
  
  =head2 Net::SSH::Any
  
  See L<method C<any>|/Net_SSH_Any>.
  
  =head2 Object::Remote
  
  See L<method C<object_remote>|/Object_Remote>.
  
  =head2 AnyEvent (and similar frameworks)
  
  X<AnyEvent>Net::OpenSSH provides all the functionality required to be
  integrated inside event oriented programming framework such as
  L<AnyEvent> or L<IO::Async> in the following way:
  
  =over 4
  
  =item 1. Create a disconnected Net::OpenSSH object:
  
      my $ssh = Net::OpenSSH->new($host, async => 1, ...);
  
  =item 2. Let the object connect to the remote host:
  
  Use a timer to call the C<wait_for_master> method in async mode
  repeatedly until it returns a true value indicating success.
  
  Also, the object error state needs to be checked after every call in
  order to detect failed connections. For instance:
  
    my $ssh = Net::OpenSSH->new(..., async => 1);
    my $w;
    $w = AE::timer 0.1, 0.1, sub {
      if ($ssh->wait_for_master(1)) {
        # the connection has been established!
        # remote commands can be run now
        undef $w;
        on_ssh_success(...);
      }
      elsif ($ssh->error) {
        # connection can not be established
        undef $w;
        on_ssh_failure(...);
      }
    }
  
  =item 3. Use the event framework to launch the remote processes:
  
  Call Net::OpenSSH C<make_remote_command> to construct commands which
  can be run using the framework regular facilities for launching external
  commands.
  
  Error checking should also be performed at this point because the SSH
  connection could be broken.
  
  For instance:
  
    if (defined(my $cmd = $ssh->make_remote_command(echo => 'hello!')) {
      AnyEvent::Util::run_cmd($cmd, %run_cmd_opts);
    }
    else {
      # something went wrong!
    }
  
  Alternatively, any of the C<open*> methods provided by Net::OpenSSH
  could also be used to launch remote commands.
  
  =item 4. When finished, disconnect asynchronously
  
  After initiating an asynchronous disconnect with C<disconnect(1)>,
  repeatedly call C<wait_for_master> until you get a defined but false
  value:
  
    $ssh->disconnect(1);
  
    my $w; $w = AE::timer 0.1, 0.1, sub {
      my $res = $ssh->wait_for_master(1);
  
      if (defined $res && !$res) {
        undef $w;
        undef $ssh;
      }
    };
  
  Be careful not to let the C<$ssh> object go out of scope until the
  disconnection has finished, otherwise its destructor will wait and
  block your program until the disconnection has completed.
  
  =back
  
  =head2 Other modules
  
  CPAN contains several modules that rely on SSH to perform their duties
  as for example L<IPC::PerlSSH|IPC::PerlSSH> or
  L<GRID::Machine|GRID::Machine>.
  
  Often, it is possible to instruct them to go through a Net::OpenSSH
  multiplexed connection employing some available constructor
  option. For instance:
  
    use Net::OpenSSH;
    use IPC::PerlIPC;
    my $ssh = Net::OpenSSH->new(...);
    $ssh->error and die "unable to connect to remote host: " . $ssh->error;
    my @cmd = $ssh->make_remote_command('/usr/bin/perl');
    my $ipc = IPC::PerlSSH->new(Command => \@cmd);
    my @r = $ipc->eval('...');
  
  or...
  
    use GRID::Machine;
    ...
    my @cmd = $ssh->make_remote_command('/usr/bin/perl');
    my $grid = GRID::Machine->new(command => \@cmd);
    my $r = $grid->eval('print "hello world!\n"');
  
  In other cases, some kind of plugin mechanism is provided by the 3rd
  party modules to allow for different transports. The method C<open2>
  may be used to create a pair of pipes for transport in these cases.
  
  =head1 TROUBLESHOOTING
  
  Usually, Net::OpenSSH works out of the box, but when it fails, some
  users have a hard time finding the cause of the problem. This mini
  troubleshooting guide should help you to find and solve it.
  
  =over 4
  
  =item 1 - check the error message
  
  Add in your script, after the Net::OpenSSH constructor call, an error
  check:
  
    $ssh = Net::OpenSSH->new(...);
    $ssh->error and die "SSH connection failed: " . $ssh->error;
  
  The error message will tell what has gone wrong.
  
  =item 2 - Check the connection parameters
  
  Believe it or not, passing bad parameters to Net::OpenSSH turns to be
  one of the top causes of failures so check that you are using the
  right parameters.
  
  Specifically, if you are obtaining them from the outside, ensure that
  they don't have extra spaces or new lines attached (do you need to
  C<chomp>?).
  
  Passwords and URIs may contain C<$> or C<@> characters. If you have
  then hardcoded in your script, check that those are quoted properly
  (and BTW, use C<strict>).
  
  =item 3 - OpenSSH version
  
  Ensure that you have a version of C<ssh> recent enough:
  
    $ ssh -V
    OpenSSH_5.1p1 Debian-5, OpenSSL 0.9.8g 19 Oct 2007
  
  OpenSSH version 4.1 was the first to support the multiplexing feature
  and is the minimal required by the module to work. I advise you to use
  the latest OpenSSH (currently 7.5).
  
  The C<ssh_cmd> constructor option lets you select the C<ssh> binary to
  use. For instance:
  
    $ssh = Net::OpenSSH->new($host,
                             ssh_cmd => "/opt/OpenSSH/5.8/bin/ssh")
  
  Some hardware vendors (e.g. Sun, err... Oracle) include custom
  versions of OpenSSH bundled with the operating system. In principle,
  Net::OpenSSH should work with these SSH clients as long as they are
  derived from some version of OpenSSH recent enough. Anyway, my advise
  is to use the real OpenSSH software if you can!
  
  =item 4 - run ssh from the command line
  
  Check you can connect to the remote host using the same parameters you
  are passing to Net::OpenSSH. In particular, ensure that you are
  running C<ssh> as the same local user.
  
  If you are running your script from a web server, the user
  would probably be C<www>, C<apache> or something alike.
  
  Common problems are:
  
  =over 4
  
  =item *
  
  Remote host public key not present in known_hosts file.
  
  The SSH protocol uses public keys to identify the remote hosts so that
  they can not be supplanted by some malicious third parties.
  
  For OpenSSH, usually the server public key is stored in
  C</etc/ssh/ssh_host_dsa_key.pub> or in
  C</etc/ssh/ssh_host_rsa_key.pub> and that key should be copied into the
  C<~/.ssh/known_hosts> file in the local machine (other SSH
  implementations may use other file locations).
  
  Maintaining the server keys when several hosts and clients are
  involved may be somewhat inconvenient, so most SSH clients, by
  default, when a new connection is established to a host whose key is
  not in the C<known_hosts> file, show the key and ask the user if he
  wants the key copied there.
  
  =item *
  
  Wrong remote host public key in known_hosts file.
  
  This is another common problem that happens when some server is
  replaced or reinstalled from scratch and its public key changes
  becoming different to that installed on the C<known_hosts> file.
  
  The easiest way to solve that problem is to remove the old key from
  the C<known_hosts> file by hand using any editor and then to connect
  to the server replying C<yes> when asked to save the new key.
  
  =item *
  
  Wrong permissions for the C<~/.ssh> directory or its contents.
  
  OpenSSH client performs several checks on the access permissions of
  the C<~/.ssh> directory and its contents and refuses to use them when
  misconfigured. See the FILES section from the L<ssh(1)> man page.
  
  =item *
  
  Incorrect settings for password or public key authentication.
  
  Check that you are using the right password or that the user public
  key is correctly installed on the server.
  
  =back
  
  =item 5 - security checks on the multiplexing socket
  
  Net::OpenSSH performs some security checks on the directory where the
  multiplexing socket is going to be placed to ensure that it can not be
  accessed by other users.
  
  The default location for the multiplexing socket is under
  C<~/.libnet-openssh-perl>. It can be changed using the C<ctl_dir> and
  C<ctl_path> constructor arguments.
  
  The requirements for that directory and all its parents are:
  
  =over 4
  
  =item *
  
  They have to be owned by the user executing the script or by root
  
  =item *
  
  Their permission masks must be 0755 or more restrictive, so nobody
  else has permissions to perform write operations on them.
  
  =back
  
  The constructor option C<strict_mode> disables these security checks,
  but you should not use it unless you understand its implications.
  
  =item 6 - file system must support sockets
  
  Some file systems (as for instance FAT or AFS) do not support placing
  sockets inside them.
  
  Ensure that the C<ctl_dir> path does not lay into one of those file
  systems.
  
  =back
  
  =head1 DEBUGGING
  
  Debugging of Net::OpenSSH internals is controlled through the variable
  C<$Net::OpenSSH::debug>. Every bit of this variable activates
  debugging of some subsystem as follows:
  
  =over 4
  
  =item bit 1 - errors
  
  Dumps changes on the internal object attribute where errors are stored.
  
  =item bit 2 - ctl_path
  
  Dumps information about ctl_path calculation and the tests performed
  on that directory in order to decide if it is secure to place the
  multiplexing socket inside.
  
  =item bit 4 - connecting
  
  Dumps information about the establishment of new master connections.
  
  =item bit 8 - commands and arguments
  
  Dumps the command and arguments for every system/exec call.
  
  =item bit 16 - command execution
  
  Dumps information about the progress of command execution.
  
  =item bit 32 - destruction
  
  Dumps information about the destruction of Net::OpenSSH objects and
  the termination of the SSH master processes.
  
  =item bit 64 - IO loop
  
  Dumps information about the progress of the IO loop on capture
  operations.
  
  =item bit 128 - IO hexdumps
  
  Generates hexdumps of the information that travels through the SSH
  streams inside capture operations.
  
  =item bit 512 - OS tracing of the master process
  
  Use the module L<Net::OpenSSH::OSTracer> to trace the SSH master
  process at the OS level.
  
  =back
  
  For instance, in order to activate all the debugging flags, you can
  use:
  
    $Net::OpenSSH::debug = ~0;
  
  Note that the meaning of the flags and the information generated is
  only intended for debugging of the module and may change without
  notice between releases.
  
  If you are using password authentication, enabling debugging for
  L<IO::Tty> may also show interesting information:
  
      $IO::Tty::DEBUG = 1;
  
  Finally, by default debugging output is sent to C<STDERR>. You can
  override it pointing C<$Net::OpenSSH::debug_fh> to a different file
  handle. For instance:
  
    BEGIN {
      open my $out, '>', '/tmp/debug.txt' or warn $!;
      $Net::OpenSSH::debug_fh = $out;
      $Net::OpenSSH::debug = -1;
    }
  
  =head1 SECURITY
  
  B<Q>: Is this module secure?
  
  B<A>: Well, it tries to be!
  
  From a security standpoint the aim of this module is to be as secure
  as OpenSSH, your operating system, your shell and in general your
  environment allow it to be.
  
  It does not take any shortcut just to make your life easier if that
  means lowering the security level (for instance, disabling
  C<StrictHostKeyChecking> by default).
  
  In code supporting features that are not just proxied to OpenSSH,
  the module tries to keep the same standards of security as OpenSSH
  (for instance, checking directory and file permissions when placing
  the multiplexing socket).
  
  On the other hand, and keeping with OpenSSH philosophy, the module
  lets you disable most (all?) of those security measures. But just
  because it lets you do it it doesn't mean it is a good idea to do
  so!!!
  
  If you are a novice programmer or SSH user, and googling you have just
  found some flag that you don't understand but that seems to magically
  solve your connection problems... well, believe me, it is probably a
  bad idea to use it. Ask somebody how really knows first!
  
  Just to make thinks clear, if your code contains any of the keywords
  from the (non-exclusive) list below and you don't know why, you are
  probably wrecking the security of the SSH protocol:
  
    strict_mode
    StrictHostKeyChecking
    UserKnownHostsFile
  
  Other considerations related to security you may like to know are as
  follows:
  
  =over 4
  
  =item Taint mode
  
  The module supports working in taint mode.
  
  If you are in an exposed environment, you should probably enable it
  for your script in order to catch any unchecked command for being
  executed in the remote side.
  
  =item Web environments
  
  It is a bad idea to establish SSH connections from your webserver
  because if it becomes compromised in any way, the attacker would be
  able to use the credentials from your script to connect to the remote
  host and do anything he wishes there.
  
  =item Command quoting
  
  The module can quote commands and arguments for you in a flexible
  and powerful way.
  
  This is a feature you should use as it reduces the possibility of some
  attacker being able to inject and run arbitrary commands on the remote
  machine (and even for scripts that are not exposed it is always
  advisable to enable argument quoting).
  
  Having said that, take into consideration that argument-quoting is
  just a hack to emulate the invoke-without-a-shell feature of Perl
  builtins such as C<system> and alike. There may be bugs(*) on the
  quoting code, your particular shell may have different quoting rules
  with unhandled corner cases or whatever. If your script is exposed to
  the outside, you should check your inputs and restrict what you accept
  as valid.
  
  [* even if this is one of the parts of the module more intensively
  tested!]
  
  =item Shellshock
  
  (see L<Shellshock|http://en.wikipedia.org/wiki/Shellshock_%28software_bug%29>)
  
  When executing local commands, the module always avoids calling the
  shell so in this way it is not affected by Shellshock.
  
  Unfortunately, some commands (C<scp>, C<rsync> and C<ssh> when the
  C<ProxyCommand> option is used) invoke other commands under the hood
  using the user shell. That opens the door to local Shellshock
  exploitation.
  
  On the remote side invocation of the shell is unavoidable due to the
  protocol design.
  
  By default, SSH does not forward environment variables but some Linux
  distributions explicitly change the default OpenSSH configuration to
  enable forwarding and acceptance of some specific ones (for instance
  C<LANG> and C<LC_*> on Debian and derivatives, Fedora does alike) and
  this also opens the door to Shellshock exploitation.
  
  Note that the shell used to invoke commands is not C</bin/sh> but the
  user shell as configured in C</etc/passwd>, PAM or whatever
  authentication subsystem is used by the local or remote operating
  system. Debian users, don't think you are not affected because
  your C</bin/sh> points to C<dash>!
  
  =back
  
  =head1 FAQ
  
  Frequent questions about the module:
  
  =over
  
  =item Connecting to switches, routers, etc.
  
  B<Q>: I can not get the method C<system>, C<capture>, etc., to work
  when connecting to some router, switch, etc. What I am doing wrong?
  
  B<A>: Roughly, the SSH protocol allows for two modes of operation:
  command mode and interactive mode.
  
  Command mode is designed to run single commands on the remote host. It
  opens a SSH channel between both hosts, asks the remote computer to
  run some given command and when it finishes, the channel is closed. It
  is what you get, for instance, when you run something as...
  
    $ ssh my.unix.box cat foo.txt
  
  ... and it is also the way Net::OpenSSH runs commands on the remote
  host.
  
  Interactive mode launches a shell on the remote hosts with its stdio
  streams redirected to the local ones so that the user can
  transparently interact with it.
  
  Some devices (as probably the one you are using) do not run an
  standard, general purpose shell (e.g. C<bash>, C<csh> or C<ksh>) but
  some custom program specially targeted and limited to the task of
  configuring the device.
  
  Usually, the SSH server running on these devices does not support
  command mode. It unconditionally attaches the restricted shell to any
  incoming SSH connection and waits for the user to enter commands
  through the redirected stdin stream.
  
  The only way to work-around this limitation is to make your script
  talk to the restricted shell (1-open a new SSH session, 2-wait for the
  shell prompt, 3-send a command, 4-read the output until you get to the
  shell prompt again, repeat from 3). The best tool for this task is
  probably L<Expect>, used alone or combined with Net::OpenSSH (see
  L</Expect>).
  
  There are some devices that support command mode but that only accept
  one command per connection. In that cases, using L<Expect> is also
  probably the best option.
  
  Nowadays, there is a new player, L<Net::CLI::Interact> that may be
  more suitable than Expect, and L<Net::Appliance::Session> for working
  specifically with network devices.
  
  =item Connection fails
  
  B<Q>: I am unable to make the module connect to the remote host...
  
  B<A>: Have you read the troubleshooting section? (see
  L</TROUBLESHOOTING>).
  
  =item Disable StrictHostKeyChecking
  
  B<Q>: Why is C<ssh> not run with C<StrictHostKeyChecking=no>?
  
  B<A>: Using C<StrictHostKeyChecking=no> relaxes the default security
  level of SSH and it will be relatively easy to end with a
  misconfigured SSH (for instance, when C<known_hosts> is unwritable)
  that could be forged to connect to a bad host in order to perform
  man-in-the-middle attacks, etc.
  
  I advice you to do not use that option unless you fully understand its
  implications from a security point of view.
  
  If you want to use it anyway, past it to the constructor:
  
    $ssh = Net::OpenSSH->new($host,
             master_opts => [-o => "StrictHostKeyChecking=no"],
             ...);
  
  =item child process STDIN/STDOUT/STDERR is not a real system file
  handle
  
  B<Q>: Calls to C<system>, C<capture>, etc. fail with the previous
  error, what's happening?
  
  B<A>: The reported stdio stream is closed or is not attached to a real
  file handle (e.g. it is a tied handle). Redirect it to C</dev/null> or
  to a real file:
  
    my $out = $ssh->capture({stdin_discard => 1, stderr_to_stdout => 1},
                            $cmd);
  
  See also the L<mod_perl> entry above.
  
  =item Solaris (and AIX and probably others)
  
  B<Q>: I was trying Net::OpenSSH on Solaris and seem to be running into
  an issue...
  
  B<A>: The SSH client bundled with Solaris is an early fork of OpenSSH
  that does not provide the multiplexing functionality required by
  Net::OpenSSH. You will have to install the OpenSSH client.
  
  Precompiled packages are available from Sun Freeware
  (L<http://www.sunfreeware.com>). There, select your OS version an CPU
  architecture, download the OpenSSH package and its dependencies and
  install them. Note that you do B<not> need to configure Solaris to use
  the OpenSSH server C<sshd>.
  
  Ensure that OpenSSH client is in your path before the system C<ssh> or
  alternatively, you can hardcode the full path into your scripts
  as follows:
  
    $ssh = Net::OpenSSH->new($host,
                             ssh_cmd => '/usr/local/bin/ssh');
  
  AIX and probably some other unixen, also bundle SSH clients lacking
  the multiplexing functionality and require installation of the real
  OpenSSH.
  
  =item Can not change working directory
  
  B<Q>: I want to run some command inside a given remote directory but I
  am unable to change the working directory. For instance:
  
    $ssh->system('cd /home/foo/bin');
    $ssh->systen('ls');
  
  does not list the contents of C</home/foo/bin>.
  
  What am I doing wrong?
  
  B<A>: Net::OpenSSH (and, for that matter, all the SSH modules
  available from CPAN but L<Net::SSH::Expect>) run every command in a
  new session so most shell builtins that are run for its side effects
  become useless (e.g. C<cd>, C<export>, C<ulimit>, C<umask>, etc.,
  usually, you can list them running C<help> from the shell).
  
  A work around is to combine several commands in one, for instance:
  
    $ssh->system('cd /home/foo/bin && ls');
  
  Note the use of the shell C<&&> operator instead of C<;> in order to
  abort the command as soon as any of the subcommands fail.
  
  Also, several commands can be combined into one while still using the
  multi-argument quoting feature as follows:
  
    $ssh->system(@cmd1, \\'&&', @cmd2, \\'&&', @cmd3, ...);
  
  =item Running detached remote processes
  
  B<Q>: I need to be able to ssh into several machines from my script,
  launch a process to run in the background there, and then return
  immediately while the remote programs keep running...
  
  B<A>: If the remote systems run some Unix/Linux variant, the right
  approach is to use L<nohup(1)> that will disconnect the remote process
  from the stdio streams and to ask the shell to run the command on the
  background. For instance:
  
    $ssh->system("nohup $long_running_command &");
  
  Also, it may be possible to demonize the remote program. If it is
  written in Perl you can use L<App::Daemon> for that (actually, there
  are several CPAN modules that provided that kind of functionality).
  
  In any case, note that you should not use L</spawn> for that.
  
  =item MaxSessions server limit reached
  
  B<Q>: I created an C<$ssh> object and then fork a lot children
  processes which use this object. When the children number is bigger
  than C<MaxSessions> as defined in sshd configuration (defaults to 10),
  trying to fork new remote commands will prompt the user for the
  password.
  
  B<A>: When the slave SSH client gets a response from the remote
  servers saying that the maximum number of sessions for the current
  connection has been reached, it fall backs to open a new direct
  connection without going through the multiplexing socket.
  
  To stop that for happening, the following hack can be used:
  
    $ssh = Net::OpenSSH->new(host,
        default_ssh_opts => ['-oConnectionAttempts=0'],
        ...);
  
  =item Running remote commands with sudo
  
  B<Q>: How can I run remote commands using C<sudo> to become root first?
  
  B<A>: The simplest way is to tell C<sudo> to read the password from
  stdin with the C<-S> flag and to do not use cached credentials
  with the C<-k> flag. You may also like to use the C<-p> flag to tell
  C<sudo> to print an empty prompt. For instance:
  
    my @out = $ssh->capture({ stdin_data => "$sudo_passwd\n" },
                            'sudo', '-Sk',
                            '-p', '',
                            '--',
                            @cmd);
  
  If the version of sudo installed on the remote host does not support
  the C<-S> flag (it tells sudo to read the password from its STDIN
  stream), you can do it as follows:
  
    my @out = $ssh->capture({ tty => 1,
                              stdin_data => "$sudo_passwd\n" },
                            'sudo', '-k',
                            '-p', '',
                            '--',
                            @cmd);
  
  This may generate an spurious and harmless warning from the SSH master
  connection (because we are requesting allocation of a tty on the
  remote side and locally we are attaching it to a regular pair of
  pipes).
  
  If for whatever reason the methods described above fail, you can
  always revert to using Expect to talk to the remote C<sudo>. See the
  C<examples/expect.pl> script from this module distribution.
  
  =back
  
  =head1 SEE ALSO
  
  OpenSSH client documentation L<ssh(1)>, L<ssh_config(5)>, the project
  web L<http://www.openssh.org> and its FAQ
  L<http://www.openbsd.org/openssh/faq.html>. L<scp(1)> and
  L<rsync(1)>. The OpenSSH Wikibook
  L<http://en.wikibooks.org/wiki/OpenSSH>.
  
  L<Net::OpenSSH::Gateway> for detailed instruction about how to get
  this module to connect to hosts through proxies and other SSH gateway
  servers.
  
  Core perl documentation L<perlipc>, L<perlfunc/open>,
  L<perlfunc/waitpid>.
  
  L<IO::Pty|IO::Pty> to known how to use the pseudo tty objects returned
  by several methods on this package.
  
  L<Net::SFTP::Foreign|Net::SFTP::Foreign> provides a compatible SFTP
  implementation.
  
  L<Expect|Expect> can be used to interact with commands run through
  this module on the remote machine (see also the C<expect.pl> and
  <autosudo.pl> scripts in the examples directory).
  
  L<SSH::OpenSSH::Parallel> is an advanced scheduler that allows one to run
  commands in remote hosts in parallel. It is obviously based on
  Net::OpenSSH.
  
  L<SSH::Batch|SSH::Batch> allows one to run remote commands in parallel in
  a cluster. It is build on top on C<Net::OpenSSH> also.
  
  Other Perl SSH clients: L<Net::SSH::Perl|Net::SSH::Perl>,
  L<Net::SSH2|Net::SSH2>, L<Net::SSH|Net::SSH>,
  L<Net::SSH::Expect|Net::SSH::Expect>, L<Net::SCP|Net::SCP>,
  L<Net::SSH::Mechanize|Net::SSH::Mechanize>.
  
  L<Net::OpenSSH::Compat> is a package offering a set of compatibility
  layers for other SSH modules on top of Net::OpenSSH.
  
  L<IPC::PerlSSH|IPC::PerlSSH>, L<GRID::Machine|GRID::Machine> allow
  execution of Perl code in remote machines through SSH.
  
  L<SSH::RPC|SSH::RPC> implements an RPC mechanism on top of SSH using
  Net::OpenSSH to handle the connections.
  
  L<Net::CLI::Interact> allows one to interact with remote shells
  and other services. It is specially suited for interaction with
  network equipment. The phrasebook approach it uses is very clever. You
  may also like to check the L<other
  modules|https://metacpan.org/author/OLIVER> from its author, Oliver
  Gorwits.
  
  =head1 BUGS AND SUPPORT
  
  =head2 Experimental features
  
  Support for the C<restart> feature is experimental.
  
  L<Object::Remote> integration is highly experimental.
  
  Support for tunnels targeting Unix sockets is highly experimental.
  
  Support for the C<setpgrp> feature is highly experimental.
  
  Support for the gateway feature is highly experimental and mostly
  stalled.
  
  Support for taint mode is experimental.
  
  =head2 Known issues
  
  Net::OpenSSH does not work on Windows. OpenSSH multiplexing feature
  requires passing file handles through sockets, something that is not
  supported by any version of Windows.
  
  It does not work on VMS either... well, probably, it does not work on
  anything not resembling a modern Linux/Unix OS.
  
  Old versions of OpenSSH C<ssh> may leave stdio streams in non-blocking
  mode. That can result on failures when writing to C<STDOUT> or
  C<STDERR> after using the module. In order to work-around this issue,
  Perl L<perlfunc/fcntl> can be used to unset the non-blocking flag:
  
    use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);
    my $flags = fcntl(STDOUT, F_GETFL, 0);
    fcntl(STDOUT, F_SETFL, $flags & ~O_NONBLOCK);
  
  =head2 Reporting bugs and asking for help
  
  To report bugs send an email to the address that appear below or use
  the CPAN bug tracking system at L<http://rt.cpan.org>.
  
  B<Post questions related to how to use the module in PerlMonks>
  L<http://perlmonks.org/>, you will probably get faster responses than
  if you address me directly and I visit PerlMonks quite often, so I
  will see your question anyway.
  
  =head2 Commercial support
  
  Commercial support, professional services and custom software
  development around this module are available through my current
  company. Drop me an email with a rough description of your
  requirements and we will get back to you ASAP.
  
  =head2 My wishlist
  
  If you like this module and you are feeling generous, take a look at
  my Amazon Wish List: L<http://amzn.com/w/1WU1P6IR5QZ42>.
  
  Also consider contributing to the OpenSSH project this module builds
  upon: L<http://www.openssh.org/donations.html>.
  
  =head1 TODO
  
  - Tests for C<scp_*>, C<rsync_*> and C<sftp> methods
  
  - Make L</pipe_in> and L</pipe_out> methods L</open_ex> based
  
  - C<auto_discard_streams> feature for mod_perl2 and similar environments
  
  - Refactor open_ex support for multiple commands, maybe just keeping
    tunnel, ssh and raw
  
  Send your feature requests, ideas or any feedback, please!
  
  =head1 CONTRIBUTING CODE
  
  The source code of this module is hosted at GitHub:
  L<http://github.com/salva/p5-Net-OpenSSH>.
  
  Code contributions to the module are welcome but you should obey the
  following rules:
  
  =over 4
  
  =item Only Perl 5.8.4 required
  
  Yes, that's pretty old, but Net::OpenSSH is intended to be also used
  by system administrators that sometimes have to struggle with old
  systems. The reason to pick 5.8.4 is that it has been the default perl
  on Solaris for a long time.
  
  =item Avoid the "All the world's a Linux PC" syndrome
  
  The module should work on any (barely) sane Unix or Linux operating
  system. Specially, it should not be assumed that the over-featured GNU
  utilities and toolchain are available.
  
  =item Dependencies are optional
  
  In order to make the module very easy to install, no mandatory
  dependencies on other CPAN modules are allowed.
  
  Optional modules, that are loaded only on demand, are acceptable when
  they are used for adding new functionality (as it is done, for
  instance, with L<IO::Pty>).
  
  Glue code for integration with 3rd party modules is also allowed (as
  it is done with L<Expect>).
  
  Usage of language extension modules and alike is not acceptable.
  
  =item Tests should be lax
  
  We don't want false negatives when testing. In case of doubt tests
  should succeed.
  
  Also, in case of tests invoking some external program, it should be
  checked that the external program is available and that it works as
  expected or otherwise skip those tests.
  
  =item Backward compatibility
  
  Nowadays Net::OpenSSH is quite stable and there are lots of scripts
  out there using it that we don't want to break, so, keeping the API
  backward compatible is a top priority.
  
  Probably only security issues could now justify a backward
  incompatible change.
  
  =item Follow my coding style
  
  Look at the rest of the code.
  
  I let Emacs do the formatting for me using cperl-mode PerlStyle.
  
  =item Talk to me
  
  Before making a large change or implementing a new feature get in
  touch with me.
  
  I may have my own ideas about how things should be done. It is better
  if you know them before hand, otherwise, you risk getting your patch
  rejected.
  
  =back
  
  Well, actually you should know that I am quite good at rejecting
  patches but it is not my fault!
  
  Most of the patches I get are broken in some way: they don't follow
  the main module principles, sometimes the author didn't get the full
  picture and solved the issue in a short-sighted way, etc.
  
  In any case, you should not be discouraged to contribute. Even if your
  patch is not applied directly, seeing how it solves your requirements
  or, in the case of bugs, the underlying problem analysis may be very
  useful and help me to do it... my way.
  
  I always welcome documentation corrections and improvements.
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008-2022 by Salvador FandiE<ntilde>o
  (sfandino@yahoo.com)
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.10.0 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
NET_OPENSSH

$fatpacked{"Net/OpenSSH/ConnectionCache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_CONNECTIONCACHE';
  package Net::OpenSSH::ConnectionCache;
  
  use strict;
  use warnings;
  
  use Net::OpenSSH;
  use Net::OpenSSH::Constants qw(:error);
  
  use Data::Dumper;
  use Scalar::Util qw(weaken);
  
  our $MAX_SIZE = 20;
  our %cache;
  
  sub _factory {
      my $class = shift;
      my %opts = @_;
      my $dump = Data::Dumper->new([\%opts], ['s']);
      $dump->Indent(0);
      $dump->Sortkeys(1);
      $dump->Deepcopy(1);
      my $signature = $dump->Dump;
      my $ssh = $cache{$signature};
      if ($ssh and $ssh->error != OSSH_MASTER_FAILED) {
          if ($opts{async} or $ssh->wait_for_master) {
              return $cache{$signature} = $ssh;
          }
      }
      if ($MAX_SIZE <= keys %cache) {
          for (keys %cache) {
              $ssh = $cache{$_};
              $ssh or $ssh->error != OSSH_MASTER_FAILED or delete $cache{$_}
          }
          for (keys %cache) {
              last if ($MAX_SIZE <= keys %cache);
              weaken $cache{$_};
              if (defined $cache{$_}) {
                  $cache{$_} = $cache{$_}; # unweaken
              }
              else {
                  delete $cache{$_};
              }
          }
      }
      local $Net::OpenSSH::FACTORY;
      $cache{$signature} = $class->new(@_);
  }
  
  $Net::OpenSSH::FACTORY = \&_factory;
  
  sub clean_cache { %cache = () }
  
  END { %cache = () }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Net::OpenSSH::ConnectionCache - cache and reuse SSH connections transparently
  
  =head1 SYNOPSIS
  
    use Net::OpenSSH;
    use Net::OpenSSH::ConnectionCache;
  
    for (1..10) {
      my $ssh = Net::OpenSSH->new($host);
      $ssh->system("$cmd $_");
    }
  
  =head1 DESCRIPTION
  
  This module installs a C<$Net::OpenSSH::FACTORY> hook implementing a
  SSH connection caching scheme.
  
  C<$Net::OpenSSH::ConnectionCache::MAX_SIZE> controls the cache
  size. Once as many connections are allocated, the module will try to
  free any of them before allocating a new one.
  
  The function C<clean_cache> makes the module forget (and close) all
  the cached connections:
  
    Net::OpenSSH::ConnectionCache::clean_cache();
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2011, 2014 by Salvador FandiE<ntilde>o
  (sfandino@yahoo.com)
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.10.0 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
NET_OPENSSH_CONNECTIONCACHE

$fatpacked{"Net/OpenSSH/Constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_CONSTANTS';
  package Net::OpenSSH::Constants;
  
  our $VERSION = '0.51_07';
  
  use strict;
  use warnings;
  use Carp;
  use Scalar::Util ();
  
  require Exporter;
  our @ISA = qw(Exporter);
  our %EXPORT_TAGS = (error => [], _state => []);
  
  my %error = ( OSSH_MASTER_FAILED => 1,
                OSSH_SLAVE_FAILED => 2,
                OSSH_SLAVE_PIPE_FAILED => 3,
  	      OSSH_SLAVE_TIMEOUT => 4,
  	      OSSH_SLAVE_CMD_FAILED => 5,
  	      OSSH_SLAVE_SFTP_FAILED => 6,
                OSSH_ENCODING_ERROR => 7
              );
  
  for my $key (keys %error) {
      no strict 'refs';
      my $value = $error{$key};
      *{$key} = sub () { $value };
      push @{$EXPORT_TAGS{error}}, $key
  }
  
  my @states = qw(_STATE_START
                  _STATE_LOGIN
                  _STATE_AWAITING_MUX
                  _STATE_RUNNING
                  _STATE_KILLING
                  _STATE_GONE
                  _STATE_STOPPED);
  
  my $last_value;
  for my $state (@states) {
      no strict 'refs';
      my $value = Scalar::Util::dualvar(++$last_value, $state);
      *{$state} = sub () { $value };
      push @{$EXPORT_TAGS{_state}}, $state
  }
  
  our @EXPORT_OK = map { @{$EXPORT_TAGS{$_}} } keys %EXPORT_TAGS;
  $EXPORT_TAGS{all} = [@EXPORT_OK];
  
  1;
  
  __END__
  
  =head1 NAME
  
  Net::OpenSSH::Constants - Constant definitions for Net::OpenSSH
  
  =head1 SYNOPSIS
  
    use Net::OpenSSH::Constants qw(:error);
  
  =head1 DESCRIPTION
  
  This module exports the following constants:
  
  =over 4
  
  =item :error
  
    OSSH_MASTER_FAILED - some error related to the master SSH connection happened
    OSSH_SLAVE_FAILED - some error related to a slave SSH connection happened
    OSSH_SLAVE_PIPE_FAILED - unable to create pipe to communicate with slave process
    OSSH_SLAVE_TIMEOUT - slave process timeout
    OSSH_SLAVE_CMD_FAILED - child process exited with a non zero status
    OSSH_SLAVE_SFTP_FAILED - creation of SFTP client failed
    OSSH_ENCODING_ERROR - some error related to the encoding/decoding of strings happened
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008, 2009 by Salvador FandiE<ntilde>o (sfandino@yahoo.com)
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.10.0 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
NET_OPENSSH_CONSTANTS

$fatpacked{"Net/OpenSSH/ModuleLoader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_MODULELOADER';
  package Net::OpenSSH::ModuleLoader;
  
  use strict;
  use warnings;
  use Carp;
  
  our %loaded_module;
  
  use Exporter qw(import);
  our @EXPORT = qw(_load_module);
  
  sub _load_module {
      my ($module, $version) = @_;
      $loaded_module{$module} ||= do {
          my $err;
          do {
              local ($@, $SIG{__DIE__});
              my $ok = eval "require $module; 1";
              $err = $@;
              $ok;
          } or croak "unable to load Perl module $module: $err";
      };
      if (defined $version) {
          my $mv = do {
              local ($@, $SIG{__DIE__});
              eval "\$${module}::VERSION";
          } || 0;
  	(my $mv1 = $mv) =~ s/_\d*$//;
  	croak "$module version $version required, $mv is available"
  	    if $mv1 < $version;
      }
      1
  }
  
  1;
NET_OPENSSH_MODULELOADER

$fatpacked{"Net/OpenSSH/OSTracer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_OSTRACER';
  package Net::OpenSSH::OSTracer;
  
  our $VERSION = '0.65_06';
  
  use strict;
  use warnings;
  
  use POSIX;
  
  our $cmd;
  our $type;
  our $output;
  our $sudo;
  our $delay;
  
  our @EXTRA_ARGS;
  
  my %type_by_os = (linux   => 'strace',
                    openbsd => 'ktrace',
                    freebsd => 'ktrace',
                    netbsd  => 'ktrace',
                    bsd     => 'ktrace',
                    'hp-ux' => 'tusc',
                    aix     => 'truss',
                    solaris => 'truss');
  
  sub trace {
      my $class = shift;
      my ($cmd, $type) = ($cmd, $type); # copy globals
  
  
      if (not defined $type) {
          my $os = lc $^O;
          if ( defined $cmd and $cmd =~ /([sk]trace|k?truss|tusc)$/) {
              $type = $1;
          }
          elsif ($os =~ /(linux|openbsd|freebsd|netbsd|bsd|hp-ux|aix|solaris)/) {
              $type = $type_by_os{$1};
          }
          else {
              Net::OpenSSH::_debug("unable to determine tracer type for OS $os");
              return;
          }
      }
  
      my $output1 = (defined $output ? $output : "/tmp/net_openssh_master") . ".$$";
      my $file = "$output1.$type";
      my $err = "$output1.txt";
  
      $cmd = $type unless defined $cmd;
  
      my @args;
      if ($type eq 'strace') {
          @args = (-o => $file, -p => $$, -s => 1024, '-fx');
      }
      elsif ($type eq 'ktruss') {
          @args = (-o => $file, -p => $$, -m => 1024, '-d');
      }
      elsif ($type eq 'ktrace') {
          @args = (-f => $file, -p => $$, '-id');
      }
      elsif ($type eq 'tusc') {
          @args = (-o => $file, -b => 1024, '-fa', $$)
      }
      elsif ($type eq 'truss') {
          @args = (-o => $file, -faep => $$);
      }
      else {
          Net::OpenSSH::_debug("tracer type $type not supported");
          return
      }
  
      my @cmd = (defined $sudo ? ($sudo, '-A', $cmd) : $cmd);
  
      my $pid = fork;
      unless ($pid) {
          unless (defined $pid) {
              Net::OpenSSH::_debug("unable to launch tracer, fork failed: $!");
              return;
          }
          my ($in, $out);
          if (open $in, '</dev/null'      and
              open $out, '>', $err        and
              POSIX::dup2(fileno $in, 0)  and
              POSIX::dup2(fileno $out, 1) and
              POSIX::dup2(fileno $out, 2)) {
              exec (@cmd, @EXTRA_ARGS, @args);
          }
          else {
              eval { Net::OpenSSH::_debug("Unable to redirect tracer IO: $!") };
          }
          POSIX::_exit(1);
      }
      sleep (defined $delay ? $delay : 1); # wait for the tracer to come up
      Net::OpenSSH::_debug("tracer attached, ssh pid: $$, tracer pid: $pid");
      1;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Net::OpenSSH::OSTracer - trace ssh master process at the OS level
  
  =head1 SYNOPSIS
  
      use Net::OpenSSH;
      $Net::OpenSSH::debug |= 512;
  
      Net::OpenSSH->new($host)->system("echo hello world");
  
      system "less /tmp/net_openssh_master.*.strace";
  
  =head1 DESCRIPTION
  
  This is a Net::OpenSSH helper module that allows you to trace the
  master C<ssh> process at the operating system level using the proper
  utility available in your system (e.g., C<strace>, C<truss>,
  C<ktruss>, C<tusc>, etc.).
  
  This feature can be used when debugging your programs or to report
  bugs on the module.
  
  It is enabled setting the flag 512 on the C<$Net::OpenSSH::debug> variable:
  
    $Net::OpenSSH::debug |= 512;
  
  By default the output files of the tracer are saved as
  C</tmp/net_openssh_master.$pid.$tracer_type>.
  
  Also, the output send by the tracer to stdout/stderr is saved as
  C</tmp/net_openssh_master.$pid.txt>.
  
  The module can be configured through the following global variables:
  
  =over 4
  
  =item $Net::OpenSSH::OSTracer::type
  
  By default, the module decides which tracer to use in base to the
  operating system name. This variable allows one to select a different
  tracer.
  
  Currently accepted types are: C<strace> (Linux), C<ktrace> (*BSD),
  C<tusc> (HP-UX) and C<truss> (Solaris and AIX).
  
  =item $Net::OpenSSH::OSTracer::cmd
  
  Command to execute for tracing the C<ssh> process.
  
  By default, it infers it from the tracer type selected.
  
  =item $Net::OpenSSH::OSTracer::output
  
  Basename for the destination file. The PID of the C<ssh> process and
  the tracer type will be appended.
  
  =item $Net::OpenSSH::OSTracer::sudo
  
  This variable can be used to request the tracer to be run with C<sudo>
  (some operating systems as for example Ubuntu, do not allow one to
  attach tracers, even to your own processes, unless you do it as root).
  
  The variable has to be set with the path of the C<sudo> binary. For
  instance:
  
    $Net::OpenSSH::OSTracer::sudo = '/usr/bin/sudo';
  
  If you need to pass a password to C<sudo>, set the environment
  variable C<SUDO_ASKPASS>. For instance:
  
    SUDO_ASKPASS=/usr/bin/ssh-askpass
  
  =item $Net::OpenSSH::OSTracer::delay
  
  This variable can be used to delay the C<ssh> execution so that the
  tracer can attach the process first. This is specially handy when
  using C<sudo> with a password.
  
  =back
  
  =head1 BUGS
  
  This module has not been tested under all the operating systems is
  says to support.
  
  If you find any problem, just report it, please!
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2012 by Salvador FandiE<ntilde>o
  (sfandino@yahoo.com)
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.10.0 or,
  at your option, any later version of Perl 5 you may have available.
  
  
  =cut
NET_OPENSSH_OSTRACER

$fatpacked{"Net/OpenSSH/ObjectRemote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_OBJECTREMOTE';
  package Net::OpenSSH::ObjectRemote;
  
  use strict;
  use warnings;
  
  use Moo;
  
  with 'Object::Remote::Role::Connector::PerlInterpreter';
  
  has net_openssh => (is => 'ro', required => 1);
  
  sub final_perl_command {
      my $self = shift;
      my $perl_command = $self->perl_command;
      [ $self->net_openssh->make_remote_command(@$perl_command) ];
  }
  
  1;
NET_OPENSSH_OBJECTREMOTE

$fatpacked{"Net/OpenSSH/SSH.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_SSH';
  package Net::OpenSSH::SSH;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Net::OpenSSH::SSH - Perl SSH client package implemented on top of OpenSSH
  
  =head1 DESCRIPTION
  
  Use the real thing: L<Net::OpenSSH>.
  
  This namespace is used so that the module gets indexed under the
  C<SSH> tag on popular CPAN search engines such as
  L<http://metacpan.org> and L<http://search.cpan.org>.
  
  =cut
NET_OPENSSH_SSH

$fatpacked{"Net/OpenSSH/ShellQuoter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_SHELLQUOTER';
  package Net::OpenSSH::ShellQuoter;
  
  use strict;
  use warnings;
  use Carp;
  
  use Net::OpenSSH::ModuleLoader;
  
  my %alias = (bash  => 'POSIX',
               sh    => 'POSIX',
               ksh   => 'POSIX',
               ash   => 'POSIX',
               dash  => 'POSIX',
               pdksh => 'POSIX',
               mksh  => 'POSIX',
               lksh  => 'POSIX',
               zsh   => 'POSIX',
               fizsh => 'POSIX',
               posh  => 'POSIX',
               fish  => 'fish',
               tcsh  => 'csh');
  
  sub quoter {
      my ($class, $shell) = @_;
      $shell = 'POSIX' unless defined $shell;
      return $shell if ref $shell;
      if ($shell =~ /,/) {
          require Net::OpenSSH::ShellQuoter::Chain;
          return Net::OpenSSH::ShellQuoter::Chain->chain(split /\s*,\s*/, $shell);
      }
      else {
          $shell = $alias{$shell} if defined $alias{$shell};
          $shell =~ /^\w+$/ or croak "bad quoting style $shell";
          my $impl = "Net::OpenSSH::ShellQuoter::$shell";
          _load_module($impl);
          return $impl->new;
      }
  }
  
  1;
NET_OPENSSH_SHELLQUOTER

$fatpacked{"Net/OpenSSH/ShellQuoter/Chain.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_SHELLQUOTER_CHAIN';
  package Net::OpenSSH::ShellQuoter::Chain;
  
  use strict;
  use warnings;
  
  use Net::OpenSSH::ShellQuoter;
  
  sub chain {
      my $class = shift;
      my @quoters = map Net::OpenSSH::ShellQuoter->quoter($_), reverse @_;
      my $self = \@quoters;
      bless $self, $class;
      $self;
  }
  
  sub quote {
      my ($self, $arg) = @_;
      $arg = $_->quote($arg) for @$self;
      $arg;
  }
  
  sub quote_glob {
      my ($self, $arg) = @_;
      if (@$self) {
          $arg = $self->[0]->quote_glob($arg);
          $arg = $self->[$_]->quote($arg) for 1..$#$self;
      }
      $arg
  }
  
  sub shell_fragments {
      my $self = shift;
      @$self or return (wantarray ? () : '');
      $self->[-1]->shell_fragments(@_)
  }
  
  
  1;
NET_OPENSSH_SHELLQUOTER_CHAIN

$fatpacked{"Net/OpenSSH/ShellQuoter/MSCmd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_SHELLQUOTER_MSCMD';
  package Net::OpenSSH::ShellQuoter::MSCmd;
  
  use strict;
  use warnings;
  use Carp;
  
  sub new { shift() }
  
  sub quote {
      shift;
      my $arg = shift;
      if ($arg =~ /[\r\n\0]/) {
          croak "can't quote newlines to pass through MS cmd.exe";
      }
      $arg =~ s/([()%!^"<>&|])/^$1/g;
      $arg;
  }
  
  *quote_glob = \&quote;
  
  my %fragments = ( stdin_discard             => '<NUL:',
                    stdout_discard            => '>NUL:',
                    stderr_discard            => '2>NUL:',
                    stdout_and_stderr_discard => '>NUL: 2>&1',
                    stderr_to_stdout          => '2>&1' );
  
  sub shell_fragments {
      shift;
      my @f = grep defined, @fragments{@_};
      wantarray ? @f : join(' ', @f);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Net::OpenSSH::ShellQuoter::MSCmd - Quoter for Windows cmd.exe
  
  =head1 DESCRIPTION
  
  This quoter is intended for interaction with SSH servers running on
  Windows which invoke the requested commands through the C<cmd.exe> shell.
  
  Because of C<cmd.exe> not doing wildcard expansion (on Windows this
  task is left to the final command), glob quoting just quotes
  everything.
  
  Some Windows servers use C<Win32::CreateProcess> to run the C<cmd.exe>
  shell which runs the requested command. In that case, both the C<MSCmd>
  and C<MSWin> quoters have to be chained (and BTW, order matters):
  
     $ssh = Net::OpenSSH->new(...,
                              remote_shell => 'MSCmd,MSWin');
  
  Actually, C<cmd.exe> may require not quoting at all when the requested
  command is a builtin (for instance, C<echo>).
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008-2014 by Salvador FandiE<ntilde>o
  (sfandino@yahoo.com)
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.10.0 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
NET_OPENSSH_SHELLQUOTER_MSCMD

$fatpacked{"Net/OpenSSH/ShellQuoter/MSWin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_SHELLQUOTER_MSWIN';
  package Net::OpenSSH::ShellQuoter::MSWin;
  
  use strict;
  use warnings;
  use Carp;
  
  sub new { shift() }
  
  sub quote {
      shift;
      my $arg = shift;
      if ($arg eq '') {
          return '""';
      }
      if ($arg =~ /[ \t\n\x0b"]/) {
          $arg =~ s{(\\+)(?="|\z)}{$1$1}g;
          $arg =~ s{"}{\\"}g;
          return qq("$arg");
      }
      return $arg;
  }
  
  *quote_glob = \&quote;
  
  sub shell_fragments { wantarray ? () : '' }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Net::OpenSSH::ShellQuoter::MSWin - Quoter for Win32::CreateProcess
  
  =head1 DESCRIPTION
  
  This quoter is intended for interaction with SSH servers running on
  Windows which use the C<Win32::CreateProcess> system call to launch the
  requested command.
  
  Because of C<Win32::CreateProcess> not doing wildcard expansion, glob
  quoting just quotes everything.
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008-2014 by Salvador FandiE<ntilde>o
  (sfandino@yahoo.com)
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.10.0 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
NET_OPENSSH_SHELLQUOTER_MSWIN

$fatpacked{"Net/OpenSSH/ShellQuoter/POSIX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_SHELLQUOTER_POSIX';
  package Net::OpenSSH::ShellQuoter::POSIX;
  
  use strict;
  use warnings;
  use Carp;
  
  sub new { __PACKAGE__ }
  
  my $noquote_class = '.\\w/\\-@,:';
  my $glob_class    = '*?\\[\\],\\{\\}:!^~';
  
  sub quote {
      shift;
      my $quoted = join '',
          map { ( m|\A'\z|                  ? "\\'"    :
                  m|\A'|                    ? "\"$_\"" :
                  m|\A[$noquote_class]+\z|o ? $_       :
                                            "'$_'"   )
            } split /('+)/, $_[0];
      length $quoted ? $quoted : "''";
  }
  
  
  sub quote_glob {
      shift;
      my $arg = shift;
      my @parts;
      while ((pos $arg ||0) < length $arg) {
          if ($arg =~ m|\G('+)|gc) {
              push @parts, (length($1) > 1 ? "\"$1\"" : "\\'");
          }
          elsif ($arg =~ m|\G([$noquote_class$glob_class]+)|gco) {
              push @parts, $1;
          }
          elsif ($arg =~ m|\G(\\[$glob_class\\])|gco) {
              push @parts, $1;
          }
          elsif ($arg =~ m|\G\\|gc) {
              push @parts, '\\\\'
          }
          elsif ($arg =~ m|\G([^$glob_class\\']+)|gco) {
              push @parts, "'$1'";
          }
          else {
              require Data::Dumper;
              $arg =~ m|\G(.+)|gc;
              die "Internal error: unquotable string:\n". Data::Dumper::Dumper($1) ."\n";
          }
      }
      my $quoted = join('', @parts);
      length $quoted ? $quoted : "''";
  }
  
  my %fragments = ( stdin_discard             => '</dev/null',
                    stdout_discard            => '>/dev/null',
                    stderr_discard            => '2>/dev/null',
                    stdout_and_stderr_discard => '>/dev/null 2>&1',
                    stderr_to_stdout          => '2>&1' );
  
  sub shell_fragments {
      shift;
      my @f = grep defined, @fragments{@_};
      wantarray ? @f : join(' ', @f);
  }
  
  1;
NET_OPENSSH_SHELLQUOTER_POSIX

$fatpacked{"Net/OpenSSH/ShellQuoter/csh.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_SHELLQUOTER_CSH';
  package Net::OpenSSH::ShellQuoter::csh;
  
  use strict;
  use warnings;
  use Carp;
  
  # Fixme: copied from POSIX
  
  sub new { __PACKAGE__ }
  
  my $noquote_class = q(.\\w/\\-@,:);
  my $glob_class    = q(*?\\[\\],{}:!^~);
  my $escape_inside_single_quotes_class  = q(\!\n);
  
  sub _single_quote {
      my $arg = shift;
      $arg =~ s/([$escape_inside_single_quotes_class])/\\$1/go;
      "'$arg'"
  }
  
  sub quote {
      shift;
      my $quoted = join '',
          map { ( m|\A'\z|                  ? "\\'"             :
                  m|\A'|                    ? "\"$_\""          :
                  m|\A[$noquote_class]*\z|o ? $_                :
                                              _single_quote($_) )
            } split /(')/o, $_[0];
      length $quoted ? $quoted : "''";
  }
  
  
  sub quote_glob {
      shift;
      my $arg = shift;
      my @parts;
      while ((pos $arg ||0) < length $arg) {
          if ($arg =~ m|\G('+)|gc) {
              push @parts, (length($1) > 1 ? "\"$1\"" : "\\'");
          }
          elsif ($arg =~ m|\G([$noquote_class$glob_class]+)|gco) {
              push @parts, $1;
          }
          elsif ($arg =~ m|\G(\\[$glob_class\\])|gco) {
              push @parts, $1;
          }
          elsif ($arg =~ m|\G([^$glob_class\\']+)|gco) {
              push @parts, _single_quote($1);
          }
          else {
              require Data::Dumper;
              $arg =~ m|\G(.+)|gc;
              die "Internal error: unquotable string:\n". Data::Dumper::Dumper($1) ."\n";
          }
      }
      my $quoted = join('', @parts);
      length $quoted ? $quoted : "''";
  }
  
  my %fragments = ( stdin_discard             => '</dev/null',
                    stdout_discard            => '>/dev/null',
                    stdout_and_stderr_discard => '>&/dev/null' );
  
  sub shell_fragments {
      shift;
      my @f = grep defined, @fragments{@_};
      wantarray ? @f : join(' ', @f);
  }
  
  1;
NET_OPENSSH_SHELLQUOTER_CSH

$fatpacked{"Net/OpenSSH/ShellQuoter/fish.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_SHELLQUOTER_FISH';
  package Net::OpenSSH::ShellQuoter::fish;
  
  use strict;
  use warnings;
  use Carp;
  
  sub new { __PACKAGE__ }
  
  my $noquote_class = '.\\w/\\-@,:';
  my $glob_class    = '*?\\[\\],\\{\\}:!^~';
  
  sub quote {
      my $quoted = $_[1];
      return $quoted if $quoted =~ /\A[$noquote_class]+\z/o;
      $quoted =~ s/([\'\\])/\\$1/g;
      "'$quoted'"
  }
  
  sub quote_glob {
      shift;
      my $arg = shift;
      my @parts;
      while ((pos $arg || 0) < length $arg) {
          if ($arg =~ m|\G('+)|gc) {
              push @parts, (length($1) > 1 ? "\"$1\"" : "\\'");
          }
          elsif ($arg =~ m|\G([$noquote_class$glob_class]+)|gco) {
              push @parts, $1;
          }
          elsif ($arg =~ m|\G(\\[$glob_class\\])|gco) {
              push @parts, $1;
          }
          elsif ($arg =~ m|\G\\|gc) {
              push @parts, '\\\\'
          }
          elsif ($arg =~ m|\G([^$glob_class\\']+)|gco) {
              push @parts, "'$1'";
          }
          else {
              require Data::Dumper;
              $arg =~ m|\G(.+)|gc;
              die "Internal error: unquotable string:\n". Data::Dumper::Dumper($1) ."\n";
          }
      }
      my $quoted = join('', @parts);
      length $quoted ? $quoted : "''";
  }
  
  my %fragments = ( stdin_discard             => '</dev/null',
                    stdout_discard            => '>/dev/null',
                    stderr_discard            => '2>/dev/null',
                    stdout_and_stderr_discard => '>/dev/null 2>&1',
                    stderr_to_stdout          => '2>&1' );
  
  sub shell_fragments {
      shift;
      my @f = grep defined, @fragments{@_};
      wantarray ? @f : join(' ', @f);
  }
  
  1;
NET_OPENSSH_SHELLQUOTER_FISH

$fatpacked{"Parser/MGC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARSER_MGC';
  #  You may distribute under the terms of either the GNU General Public License
  #  or the Artistic License (the same terms as Perl itself)
  #
  #  (C) Paul Evans, 2010-2021 -- leonerd@leonerd.org.uk
  
  package Parser::MGC 0.19;
  
  use v5.14;
  use warnings;
  
  use Carp;
  use Feature::Compat::Try;
  
  use File::Slurp::Tiny qw( read_file );
  use Scalar::Util qw( blessed );
  
  =head1 NAME
  
  C<Parser::MGC> - build simple recursive-descent parsers
  
  =head1 SYNOPSIS
  
     package My::Grammar::Parser;
     use base qw( Parser::MGC );
  
     sub parse
     {
        my $self = shift;
  
        $self->sequence_of( sub {
           $self->any_of(
              sub { $self->token_int },
              sub { $self->token_string },
              sub { \$self->token_ident },
              sub { $self->scope_of( "(", \&parse, ")" ) }
           );
        } );
     }
  
     my $parser = My::Grammar::Parser->new;
  
     my $tree = $parser->from_file( $ARGV[0] );
  
     ...
  
  =head1 DESCRIPTION
  
  This base class provides a low-level framework for building recursive-descent
  parsers that consume a given input string from left to right, returning a
  parse structure. It takes its name from the C<m//gc> regexps used to implement
  the token parsing behaviour.
  
  It provides a number of token-parsing methods, which each extract a
  grammatical token from the string. It also provides wrapping methods that can
  be used to build up a possibly-recursive grammar structure, by applying a
  structure around other parts of parsing code.
  
  =head2 Backtracking
  
  Each method, both token and structural, atomically either consumes a prefix of
  the string and returns its result, or fails and consumes nothing. This makes
  it simple to implement grammars that require backtracking.
  
  Several structure-forming methods have some form of "optional" behaviour; they
  can optionally consume some amount of input or take some particular choice,
  but if the code invoked inside that subsequently fails, the structure can
  backtrack and take some different behaviour. This is usually what is required
  when testing whether the structure of the input string matches some part of
  the grammar that is optional, or has multiple choices.
  
  However, once the choice of grammar has been made, it is often useful to be
  able to fix on that one choice, thus making subsequent failures propagate up
  rather than taking that alternative behaviour. Control of this backtracking
  is given by the C<commit> method; and careful use of this method is one of the
  key advantages that C<Parser::MGC> has over more simple parsing using single
  regexps alone.
  
  =cut
  
  =head1 CONSTRUCTOR
  
  =cut
  
  =head2 new
  
     $parser = Parser::MGC->new( %args )
  
  Returns a new instance of a C<Parser::MGC> object. This must be called on a
  subclass that provides method of the name provided as C<toplevel>, by default
  called C<parse>.
  
  Takes the following named arguments
  
  =over 8
  
  =item toplevel => STRING
  
  Name of the toplevel method to use to start the parse from. If not supplied,
  will try to use a method called C<parse>.
  
  =item patterns => HASH
  
  Keys in this hash should map to quoted regexp (C<qr//>) references, to
  override the default patterns used to match tokens. See C<PATTERNS> below
  
  =item accept_0o_oct => BOOL
  
  If true, the C<token_int> method will also accept integers with a C<0o> prefix
  as octal.
  
  =back
  
  =cut
  
  =head1 PATTERNS
  
  The following pattern names are recognised. They may be passed to the
  constructor in the C<patterns> hash, or provided as a class method under the
  name C<pattern_I<name>>.
  
  =over 4
  
  =item * ws
  
  Pattern used to skip whitespace between tokens. Defaults to C</[\s\n\t]+/>
  
  =item * comment
  
  Pattern used to skip comments between tokens. Undefined by default.
  
  =item * int
  
  Pattern used to parse an integer by C<token_int>. Defaults to
  C</-?(?:0x[[:xdigit:]]+|[[:digit:]]+)/>. If C<accept_0o_oct> is given, then
  this will be expanded to match C</0o[0-7]+/> as well.
  
  =item * float
  
  Pattern used to parse a floating-point number by C<token_float>. Defaults to
  C</-?(?:\d*\.\d+|\d+\.)(?:e-?\d+)?|-?\d+e-?\d+/i>.
  
  =item * ident
  
  Pattern used to parse an identifier by C<token_ident>. Defaults to
  C</[[:alpha:]_]\w*/>
  
  =item * string_delim
  
  Pattern used to delimit a string by C<token_string>. Defaults to C</["']/>.
  
  =back
  
  =cut
  
  my @patterns = qw(
     ws
     comment
     int
     float
     ident
     string_delim
  );
  
  use constant pattern_ws      => qr/[\s\n\t]+/;
  use constant pattern_comment => undef;
  use constant pattern_int     => qr/-?(?:0x[[:xdigit:]]+|[[:digit:]]+)/;
  use constant pattern_float   => qr/-?(?:\d*\.\d+|\d+\.)(?:e-?\d+)?|-?\d+e-?\d+/i;
  use constant pattern_ident   => qr/[[:alpha:]_]\w*/;
  use constant pattern_string_delim => qr/["']/;
  
  sub new
  {
     my $class = shift;
     my %args = @_;
  
     my $toplevel = $args{toplevel} || "parse";
  
     $class->can( $toplevel ) or
        croak "Expected to be a subclass that can ->$toplevel";
  
     my $self = bless {
        toplevel => $toplevel,
        patterns => {},
        scope_level => 0,
     }, $class;
  
     $self->{patterns}{$_} = $args{patterns}{$_} || $self->${\"pattern_$_"} for @patterns;
  
     if( $args{accept_0o_oct} ) {
        $self->{patterns}{int} = qr/0o[0-7]+|$self->{patterns}{int}/;
     }
  
     if( defined $self->{patterns}{comment} ) {
        $self->{patterns}{_skip} = qr/$self->{patterns}{ws}|$self->{patterns}{comment}/;
     }
     else {
        $self->{patterns}{_skip} = $self->{patterns}{ws};
     }
  
     return $self;
  }
  
  =head1 METHODS
  
  =cut
  
  =head2 from_string
  
     $result = $parser->from_string( $str )
  
  Parse the given literal string and return the result from the toplevel method.
  
  =cut
  
  sub from_string
  {
     my $self = shift;
     my ( $str ) = @_;
  
     $self->{str} = $str;
  
     pos $self->{str} = 0;
  
     my $toplevel = $self->{toplevel};
     my $result = $self->$toplevel;
  
     $self->at_eos or
        $self->fail( "Expected end of input" );
  
     return $result;
  }
  
  =head2 from_file
  
     $result = $parser->from_file( $file, %opts )
  
  Parse the given file, which may be a pathname in a string, or an opened IO
  handle, and return the result from the toplevel method.
  
  The following options are recognised:
  
  =over 8
  
  =item binmode => STRING
  
  If set, applies the given binmode to the filehandle before reading. Typically
  this can be used to set the encoding of the file.
  
     $parser->from_file( $file, binmode => ":encoding(UTF-8)" )
  
  =back
  
  =cut
  
  sub from_file
  {
     my $self = shift;
     my ( $file, %opts ) = @_;
  
     defined $file or croak "Expected a filename to ->from_file";
  
     $self->{filename} = $file;
  
     $self->from_string( ref $file ?
        do { local $/; binmode $file, $opts{binmode} if $opts{binmode}; <$file> } :
        ( read_file $file, binmode => $opts{binmode} ) );
  }
  
  =head2 from_reader
  
     $result = $parser->from_reader( \&reader )
  
  I<Since version 0.05.>
  
  Parse the input which is read by the C<reader> function. This function will be
  called in scalar context to generate portions of string to parse, being passed
  the C<$parser> object. The function should return C<undef> when it has no more
  string to return.
  
     $reader->( $parser )
  
  Note that because it is not generally possible to detect exactly when more
  input may be required due to failed regexp parsing, the reader function is
  only invoked during searching for skippable whitespace. This makes it suitable
  for reading lines of a file in the common case where lines are considered as
  skippable whitespace, or for reading lines of input interactively from a
  user. It cannot be used in all cases (for example, reading fixed-size buffers
  from a file) because two successive invocations may split a single token
  across the buffer boundaries, and cause parse failures.
  
  =cut
  
  sub from_reader
  {
     my $self = shift;
     my ( $reader ) = @_;
  
     local $self->{reader} = $reader;
  
     $self->{str} = "";
     pos $self->{str} = 0;
  
     my $result = $self->parse;
  
     $self->at_eos or
        $self->fail( "Expected end of input" );
  
     return $result;
  }
  
  =head2 pos
  
     $pos = $parser->pos
  
  I<Since version 0.09.>
  
  Returns the current parse position, as a character offset from the beginning
  of the file or string.
  
  =cut
  
  sub pos
  {
     my $self = shift;
     return pos $self->{str};
  }
  
  =head2 take
  
     $str = $parser->take( $len )
  
  I<Since version 0.16.>
  
  Returns the next C<$len> characters directly from the input, prior to any
  whitespace or comment skipping. This does I<not> take account of any
  end-of-scope marker that may be pending. It is intended for use by parsers of
  partially-binary protocols, or other situations in which it would be incorrect
  for the end-of-scope marker to take effect at this time.
  
  =cut
  
  sub take
  {
     my $self = shift;
     my ( $len ) = @_;
  
     my $start = pos( $self->{str} );
  
     pos( $self->{str} ) += $len;
  
     return substr( $self->{str}, $start, $len );
  }
  
  =head2 where
  
     ( $lineno, $col, $text ) = $parser->where
  
  Returns the current parse position, as a line and column number, and
  the entire current line of text. The first line is numbered 1, and the first
  column is numbered 0.
  
  =cut
  
  sub where
  {
     my $self = shift;
     my ( $pos ) = @_;
  
     defined $pos or $pos = pos $self->{str};
  
     my $str = $self->{str};
  
     my $sol = $pos;
     $sol-- if $sol > 0 and substr( $str, $sol, 1 ) =~ m/^[\r\n]$/;
     $sol-- while $sol > 0 and substr( $str, $sol-1, 1 ) !~ m/^[\r\n]$/;
  
     my $eol = $pos;
     $eol++ while $eol < length($str) and substr( $str, $eol, 1 ) !~ m/^[\r\n]$/;
  
     my $line = substr( $str, $sol, $eol - $sol );
  
     my $col = $pos - $sol;
     my $lineno = ( () = substr( $str, 0, $pos ) =~ m/\n/g ) + 1;
  
     return ( $lineno, $col, $line );
  }
  
  =head2 fail
  
  =head2 fail_from
  
     $parser->fail( $message )
  
     $parser->fail_from( $pos, $message )
  
  I<C<fail_from> since version 0.09.>
  
  Aborts the current parse attempt with the given message string. The failure
  message will include the line and column position, and the line of input that
  failed at the current parse position (C<fail>), or a position earlier obtained
  using the C<pos> method (C<fail_from>).
  
  This failure will propagate up to the inner-most structure parsing method that
  has not been committed; or will cause the entire parser to fail if there are
  no further options to take.
  
  =cut
  
  sub fail
  {
     my $self = shift;
     my ( $message ) = @_;
     $self->fail_from( $self->pos, $message );
  }
  
  sub fail_from
  {
     my $self = shift;
     my ( $pos, $message ) = @_;
     die Parser::MGC::Failure->new( $message, $self, $pos );
  }
  
  sub _isa_failure { blessed $_[0] and $_[0]->isa( "Parser::MGC::Failure" ) }
  
  =head2 at_eos
  
     $eos = $parser->at_eos
  
  Returns true if the input string is at the end of the string.
  
  =cut
  
  sub at_eos
  {
     my $self = shift;
  
     # Save pos() before skipping ws so we don't break the substring_before method
     my $pos = pos $self->{str};
  
     $self->skip_ws;
  
     my $at_eos;
     if( pos( $self->{str} ) >= length $self->{str} ) {
        $at_eos = 1;
     }
     elsif( defined $self->{endofscope} ) {
        $at_eos = $self->{str} =~ m/\G$self->{endofscope}/;
     }
     else {
        $at_eos = 0;
     }
  
     pos( $self->{str} ) = $pos;
  
     return $at_eos;
  }
  
  =head2 scope_level
  
     $level = $parser->scope_level
  
  I<Since version 0.05.>
  
  Returns the number of nested C<scope_of> calls that have been made.
  
  =cut
  
  sub scope_level
  {
     my $self = shift;
     return $self->{scope_level};
  }
  
  =head1 STRUCTURE-FORMING METHODS
  
  The following methods may be used to build a grammatical structure out of the
  defined basic token-parsing methods. Each takes at least one code reference,
  which will be passed the actual C<$parser> object as its first argument.
  
  Anywhere that a code reference is expected also permits a plain string giving
  the name of a method to invoke. This is sufficient in many simple cases, such
  as
  
     $self->any_of(
        'token_int',
        'token_string',
        ...
     );
  
  =cut
  
  =head2 maybe
  
     $ret = $parser->maybe( $code )
  
  Attempts to execute the given C<$code> in scalar context, and returns what it
  returned, accepting that it might fail. C<$code> may either be a CODE
  reference or a method name given as a string.
  
  If the code fails (either by calling C<fail> itself, or by propagating a
  failure from another method it invoked) before it has invoked C<commit>, then
  none of the input string will be consumed; the current parsing position will
  be restored. C<undef> will be returned in this case.
  
  If it calls C<commit> then any subsequent failure will be propagated to the
  caller, rather than returning C<undef>.
  
  This may be considered to be similar to the C<?> regexp qualifier.
  
     sub parse_declaration
     {
        my $self = shift;
  
        [ $self->parse_type,
          $self->token_ident,
          $self->maybe( sub {
             $self->expect( "=" );
             $self->parse_expression
          } ),
        ];
     }
  
  =cut
  
  sub maybe
  {
     my $self = shift;
     my ( $code ) = @_;
  
     my $pos = pos $self->{str};
  
     my $committed = 0;
     local $self->{committer} = sub { $committed++ };
  
     try {
        return $self->$code;
     }
     catch ( $e ) {
        pos($self->{str}) = $pos;
  
        die $e if $committed or not _isa_failure( $e );
        return undef;
     }
  }
  
  =head2 scope_of
  
     $ret = $parser->scope_of( $start, $code, $stop )
  
  Expects to find the C<$start> pattern, then attempts to execute the given
  C<$code>, then expects to find the C<$stop> pattern. Returns whatever the
  code returned. C<$code> may either be a CODE reference of a method name given
  as a string.
  
  While the code is being executed, the C<$stop> pattern will be used by the
  token parsing methods as an end-of-scope marker; causing them to raise a
  failure if called at the end of a scope.
  
     sub parse_block
     {
        my $self = shift;
  
        $self->scope_of( "{", 'parse_statements', "}" );
     }
  
  If the C<$start> pattern is undefined, it is presumed the caller has already
  checked for this. This is useful when the stop pattern needs to be calculated
  based on the start pattern.
  
     sub parse_bracketed
     {
        my $self = shift;
  
        my $delim = $self->expect( qr/[\(\[\<\{]/ );
        $delim =~ tr/([<{/)]>}/;
  
        $self->scope_of( undef, 'parse_body', $delim );
     }
  
  This method does not have any optional parts to it; any failures are
  immediately propagated to the caller.
  
  =cut
  
  sub scope_of
  {
     my $self = shift;
     $self->_scope_of( 0, @_ );
  }
  
  sub _scope_of
  {
     my $self = shift;
     my ( $commit_if_started, $start, $code, $stop ) = @_;
  
     ref $stop or $stop = qr/\Q$stop/;
  
     $self->expect( $start ) if defined $start;
  
     $self->commit if $commit_if_started;
  
     local $self->{endofscope} = $stop;
     local $self->{scope_level} = $self->{scope_level} + 1;
  
     my $ret = $self->$code;
  
     $self->expect( $stop );
  
     return $ret;
  }
  
  =head2 committed_scope_of
  
     $ret = $parser->committed_scope_of( $start, $code, $stop )
  
  I<Since version 0.16.>
  
  A variant of L</scope_of> that calls L</commit> after a successful match of
  the start pattern. This is usually what you want if using C<scope_of> from
  within an C<any_of> choice, if no other alternative following this one could
  possibly match if the start pattern has.
  
  =cut
  
  sub committed_scope_of
  {
     my $self = shift;
     $self->_scope_of( 1, @_ );
  }
  
  =head2 list_of
  
     $ret = $parser->list_of( $sep, $code )
  
  Expects to find a list of instances of something parsed by C<$code>,
  separated by the C<$sep> pattern. Returns an ARRAY ref containing a list of
  the return values from the C<$code>. A single trailing delimiter is allowed,
  and does not affect the return value. C<$code> may either be a CODE reference
  or a method name given as a string. It is called in list context, and whatever
  values it returns are appended to the eventual result - similar to perl's
  C<map>.
  
  This method does not consider it an error if the returned list is empty; that
  is, that the scope ended before any item instances were parsed from it.
  
     sub parse_numbers
     {
        my $self = shift;
  
        $self->list_of( ",", 'token_int' );
     }
  
  If the code fails (either by invoking C<fail> itself, or by propagating a
  failure from another method it invoked) before it has invoked C<commit> on a
  particular item, then the item is aborted and the parsing position will be
  restored to the beginning of that failed item. The list of results from
  previous successful attempts will be returned.
  
  If it calls C<commit> within an item then any subsequent failure for that item
  will cause the entire C<list_of> to fail, propagating that to the caller.
  
  =cut
  
  sub list_of
  {
     my $self = shift;
     my ( $sep, $code ) = @_;
  
     ref $sep or $sep = qr/\Q$sep/ if defined $sep;
  
     my $committed;
     local $self->{committer} = sub { $committed++ };
  
     my @ret;
  
     while( !$self->at_eos ) {
        $committed = 0;
        my $pos = pos $self->{str};
  
        try {
           push @ret, $self->$code;
           next;
        }
        catch ( $e ) {
           pos($self->{str}) = $pos;
           die $e if $committed or not _isa_failure( $e );
  
           last;
        }
     }
     continue {
        if( defined $sep ) {
           $self->skip_ws;
           $self->{str} =~ m/\G$sep/gc or last;
        }
     }
  
     return \@ret;
  }
  
  =head2 sequence_of
  
     $ret = $parser->sequence_of( $code )
  
  A shortcut for calling C<list_of> with an empty string as separator; expects
  to find at least one instance of something parsed by C<$code>, separated only
  by skipped whitespace.
  
  This may be considered to be similar to the C<+> or C<*> regexp qualifiers.
  
     sub parse_statements
     {
        my $self = shift;
  
        $self->sequence_of( 'parse_statement' );
     }
  
  The interaction of failures in the code and the C<commit> method is identical
  to that of C<list_of>.
  
  =cut
  
  sub sequence_of
  {
     my $self = shift;
     my ( $code ) = @_;
  
     $self->list_of( undef, $code );
  }
  
  =head2 any_of
  
     $ret = $parser->any_of( @codes )
  
  I<Since version 0.06.>
  
  Expects that one of the given code instances can parse something from the
  input, returning what it returned. Each code instance may indicate a failure
  to parse by calling the C<fail> method or otherwise propagating a failure.
  Each code instance may either be a CODE reference or a method name given as a
  string.
  
  This may be considered to be similar to the C<|> regexp operator for forming
  alternations of possible parse trees.
  
     sub parse_statement
     {
        my $self = shift;
  
        $self->any_of(
           sub { $self->parse_declaration; $self->expect(";") },
           sub { $self->parse_expression; $self->expect(";") },
           sub { $self->parse_block },
        );
     }
  
  If the code for a given choice fails (either by invoking C<fail> itself, or by
  propagating a failure from another method it invoked) before it has invoked
  C<commit> itself, then the parsing position restored and the next choice will
  be attempted.
  
  If it calls C<commit> then any subsequent failure for that choice will cause
  the entire C<any_of> to fail, propagating that to the caller and no further
  choices will be attempted.
  
  If none of the choices match then a simple failure message is printed:
  
     Found nothing parseable
  
  As this is unlikely to be helpful to users, a better message can be provided
  by the final choice instead. Don't forget to C<commit> before printing the
  failure message, or it won't count.
  
     $self->any_of(
        'token_int',
        'token_string',
        ...,
  
        sub { $self->commit; $self->fail( "Expected an int or string" ) }
     );
  
  =cut
  
  sub any_of
  {
     my $self = shift;
  
     while( @_ ) {
        my $code = shift;
        my $pos = pos $self->{str};
  
        my $committed = 0;
        local $self->{committer} = sub { $committed++ };
  
        try {
           return $self->$code;
        }
        catch ( $e ) {
           pos( $self->{str} ) = $pos;
  
           die $e if $committed or not _isa_failure( $e );
        }
     }
  
     $self->fail( "Found nothing parseable" );
  }
  
  sub one_of {
     croak "Parser::MGC->one_of is deprecated; use ->any_of instead";
  }
  
  =head2 commit
  
     $parser->commit
  
  Calling this method will cancel the backtracking behaviour of the innermost
  C<maybe>, C<list_of>, C<sequence_of>, or C<any_of> structure forming method.
  That is, if later code then calls C<fail>, the exception will be propagated
  out of C<maybe>, no further list items will be attempted by C<list_of> or
  C<sequence_of>, and no further code blocks will be attempted by C<any_of>.
  
  Typically this will be called once the grammatical structure alter has been
  determined, ensuring that any further failures are raised as real exceptions,
  rather than by attempting other alternatives.
  
   sub parse_statement
   {
      my $self = shift;
  
      $self->any_of(
         ...
         sub {
            $self->scope_of( "{",
               sub { $self->commit; $self->parse_statements; },
            "}" ),
         },
      );
   }
  
  Though in this common pattern, L</committed_scope_of> may be used instead.
  
  =cut
  
  sub commit
  {
     my $self = shift;
     if( $self->{committer} ) {
        $self->{committer}->();
     }
     else {
        croak "Cannot commit except within a backtrack-able structure";
     }
  }
  
  =head1 TOKEN PARSING METHODS
  
  The following methods attempt to consume some part of the input string, to be
  used as part of the parsing process.
  
  =cut
  
  sub skip_ws
  {
     my $self = shift;
  
     my $pattern = $self->{patterns}{_skip};
  
     {
        1 while $self->{str} =~ m/\G$pattern/gc;
  
        return if pos( $self->{str} ) < length $self->{str};
  
        return unless $self->{reader};
  
        my $more = $self->{reader}->( $self );
        if( defined $more ) {
           my $pos = pos( $self->{str} );
           $self->{str} .= $more;
           pos( $self->{str} ) = $pos;
  
           redo;
        }
  
        undef $self->{reader};
        return;
     }
  }
  
  =head2 expect
  
     $str = $parser->expect( $literal )
  
     $str = $parser->expect( qr/pattern/ )
  
     @groups = $parser->expect( qr/pattern/ )
  
  Expects to find a literal string or regexp pattern match, and consumes it.
  In scalar context, this method returns the string that was captured. In list
  context it returns the matching substring and the contents of any subgroups
  contained in the pattern.
  
  This method will raise a parse error (by calling C<fail>) if the regexp fails
  to match. Note that if the pattern could match an empty string (such as for
  example C<qr/\d*/>), the pattern will always match, even if it has to match an
  empty string. This method will not consider a failure if the regexp matches
  with zero-width.
  
  =head2 maybe_expect
  
     $str = $parser->maybe_expect( ... )
  
     @groups = $parser->maybe_expect( ... )
  
  I<Since version 0.10.>
  
  A convenient shortcut equivalent to calling C<expect> within C<maybe>, but
  implemented more efficiently, avoiding the exception-handling set up by
  C<maybe>. Returns C<undef> or an empty list if the match fails.
  
  =cut
  
  sub maybe_expect
  {
     my $self = shift;
     my ( $expect ) = @_;
  
     ref $expect or $expect = qr/\Q$expect/;
  
     $self->skip_ws;
     $self->{str} =~ m/\G$expect/gc or return;
  
     return substr( $self->{str}, $-[0], $+[0]-$-[0] ) if !wantarray;
     return map { defined $-[$_] ? substr( $self->{str}, $-[$_], $+[$_]-$-[$_] ) : undef } 0 .. $#+;
  }
  
  sub expect
  {
     my $self = shift;
     my ( $expect ) = @_;
  
     ref $expect or $expect = qr/\Q$expect/;
  
     if( wantarray ) {
        my @ret = $self->maybe_expect( $expect ) or
           $self->fail( "Expected $expect" );
        return @ret;
     }
     else {
        defined( my $ret = $self->maybe_expect( $expect ) ) or
           $self->fail( "Expected $expect" );
        return $ret;
     }
  }
  
  =head2 substring_before
  
     $str = $parser->substring_before( $literal )
  
     $str = $parser->substring_before( qr/pattern/ )
  
  I<Since version 0.06.>
  
  Expects to possibly find a literal string or regexp pattern match. If it finds
  such, consume all the input text before but excluding this match, and return
  it. If it fails to find a match before the end of the current scope, consumes
  all the input text until the end of scope and return it.
  
  This method does not consume the part of input that matches, only the text
  before it. It is not considered a failure if the substring before this match
  is empty. If a non-empty match is required, use the C<fail> method:
  
     sub token_nonempty_part
     {
        my $self = shift;
  
        my $str = $parser->substring_before( "," );
        length $str or $self->fail( "Expected a string fragment before ," );
  
        return $str;
     }
  
  Note that unlike most of the other token parsing methods, this method does not
  consume either leading or trailing whitespace around the substring. It is
  expected that this method would be used as part a parser to read quoted
  strings, or similar cases where whitespace should be preserved.
  
  =cut
  
  sub substring_before
  {
     my $self = shift;
     my ( $expect ) = @_;
  
     ref $expect or $expect = qr/\Q$expect/;
  
     my $endre = ( defined $self->{endofscope} ) ?
        qr/$expect|$self->{endofscope}/ :
        $expect;
  
     # NO skip_ws
  
     my $start = pos $self->{str};
     my $end;
     if( $self->{str} =~ m/\G(?s:.*?)($endre)/ ) {
        $end = $-[1];
     }
     else {
        $end = length $self->{str};
     }
  
     return $self->take( $end - $start );
  }
  
  =head2 generic_token
  
     $val = $parser->generic_token( $name, $re, $convert )
  
  I<Since version 0.08.>
  
  Expects to find a token matching the precompiled regexp C<$re>. If provided,
  the C<$convert> CODE reference can be used to convert the string into a more
  convenient form. C<$name> is used in the failure message if the pattern fails
  to match.
  
  If provided, the C<$convert> function will be passed the parser and the
  matching substring; the value it returns is returned from C<generic_token>.
  
     $convert->( $parser, $substr )
  
  If not provided, the substring will be returned as it stands.
  
  This method is mostly provided for subclasses to define their own token types.
  For example:
  
     sub token_hex
     {
        my $self = shift;
        $self->generic_token( hex => qr/[0-9A-F]{2}h/, sub { hex $_[1] } );
     }
  
  =cut
  
  sub generic_token
  {
     my $self = shift;
     my ( $name, $re, $convert ) = @_;
  
     $self->fail( "Expected $name" ) if $self->at_eos;
  
     $self->skip_ws;
     $self->{str} =~ m/\G$re/gc or
        $self->fail( "Expected $name" );
  
     my $match = substr( $self->{str}, $-[0], $+[0] - $-[0] );
  
     return $convert ? $convert->( $self, $match ) : $match;
  }
  
  sub _token_generic
  {
     my $self = shift;
     my %args = @_;
  
     my $name    = $args{name};
     my $re      = $args{pattern} ? $self->{patterns}{ $args{pattern} } : $args{re};
     my $convert = $args{convert};
  
     $self->generic_token( $name, $re, $convert );
  }
  
  =head2 token_int
  
     $int = $parser->token_int
  
  Expects to find an integer in decimal, octal or hexadecimal notation, and
  consumes it. Negative integers, preceeded by C<->, are also recognised.
  
  =cut
  
  sub token_int
  {
     my $self = shift;
     $self->_token_generic(
        name => "int",
  
        pattern => "int",
        convert => sub {
           my $int = $_[1];
           my $sign = ( $int =~ s/^-// ) ? -1 : 1;
  
           $int =~ s/^0o/0/;
  
           return $sign * oct $int if $int =~ m/^0/;
           return $sign * $int;
        },
     );
  }
  
  =head2 token_float
  
     $float = $parser->token_float
  
  I<Since version 0.04.>
  
  Expects to find a number expressed in floating-point notation; a sequence of
  digits possibly prefixed by C<->, possibly containing a decimal point,
  possibly followed by an exponent specified by C<e> followed by an integer. The
  numerical value is then returned.
  
  =cut
  
  sub token_float
  {
     my $self = shift;
     $self->_token_generic(
        name => "float",
  
        pattern => "float",
        convert => sub { $_[1] + 0 },
     );
  }
  
  =head2 token_number
  
     $number = $parser->token_number
  
  I<Since version 0.09.>
  
  Expects to find a number expressed in either of the above forms.
  
  =cut
  
  sub token_number
  {
     my $self = shift;
     $self->any_of( \&token_float, \&token_int );
  }
  
  =head2 token_string
  
     $str = $parser->token_string
  
  Expects to find a quoted string, and consumes it. The string should be quoted
  using C<"> or C<'> quote marks.
  
  The content of the quoted string can contain character escapes similar to
  those accepted by C or Perl. Specifically, the following forms are recognised:
  
     \a               Bell ("alert")
     \b               Backspace
     \e               Escape
     \f               Form feed
     \n               Newline
     \r               Return
     \t               Horizontal Tab
     \0, \012         Octal character
     \x34, \x{5678}   Hexadecimal character
  
  C's C<\v> for vertical tab is not supported as it is rarely used in practice
  and it collides with Perl's C<\v> regexp escape. Perl's C<\c> for forming other
  control characters is also not supported.
  
  =cut
  
  my %escapes = (
     a => "\a",
     b => "\b",
     e => "\e",
     f => "\f",
     n => "\n",
     r => "\r",
     t => "\t",
  );
  
  sub token_string
  {
     my $self = shift;
  
     $self->fail( "Expected string" ) if $self->at_eos;
  
     my $pos = pos $self->{str};
  
     $self->skip_ws;
     $self->{str} =~ m/\G($self->{patterns}{string_delim})/gc or
        $self->fail( "Expected string delimiter" );
  
     my $delim = $1;
  
     $self->{str} =~ m/
        \G(
           (?:
              \\[0-7]{1,3}     # octal escape
             |\\x[0-9A-F]{2}   # 2-digit hex escape
             |\\x\{[0-9A-F]+\} # {}-delimited hex escape
             |\\.              # symbolic escape
             |[^\\$delim]+     # plain chunk
           )*?
        )$delim/gcix or
           pos($self->{str}) = $pos, $self->fail( "Expected contents of string" );
  
     my $string = $1;
  
     $string =~ s<\\(?:([0-7]{1,3})|x([0-9A-F]{2})|x\{([0-9A-F]+)\}|(.))>
                 [defined $1 ? chr oct $1 :
                  defined $2 ? chr hex $2 :
                  defined $3 ? chr hex $3 :
                               exists $escapes{$4} ? $escapes{$4} : $4]egi;
  
     return $string;
  }
  
  =head2 token_ident
  
     $ident = $parser->token_ident
  
  Expects to find an identifier, and consumes it.
  
  =cut
  
  sub token_ident
  {
     my $self = shift;
     $self->_token_generic(
        name => "ident",
  
        pattern => "ident",
     );
  }
  
  =head2 token_kw
  
     $keyword = $parser->token_kw( @keywords )
  
  Expects to find a keyword, and consumes it. A keyword is defined as an
  identifier which is exactly one of the literal values passed in.
  
  =cut
  
  sub token_kw
  {
     my $self = shift;
     my @acceptable = @_;
  
     $self->skip_ws;
  
     my $pos = pos $self->{str};
  
     defined( my $kw = $self->token_ident ) or
        return undef;
  
     grep { $_ eq $kw } @acceptable or
        pos($self->{str}) = $pos, $self->fail( "Expected any of ".join( ", ", @acceptable ) );
  
     return $kw;
  }
  
  package # hide from indexer
     Parser::MGC::Failure;
  
  sub new
  {
     my $class = shift;
     my $self = bless {}, $class;
     @{$self}{qw( message parser pos )} = @_;
     return $self;
  }
  
  use overload '""' => "STRING";
  sub STRING
  {
     my $self = shift;
  
     my $parser = $self->{parser};
     my ( $linenum, $col, $text ) = $parser->where( $self->{pos} );
  
     # Column number only counts characters. There may be tabs in there.
     # Rather than trying to calculate the visual column number, just print the
     # indentation as it stands.
  
     my $indent = substr( $text, 0, $col );
     $indent =~ s/[^ \t]/ /g; # blank out all the non-whitespace
  
     my $filename = $parser->{filename};
     my $in_file = ( defined $filename and !ref $filename )
                      ? "in $filename " : "";
  
     return "$self->{message} ${in_file}on line $linenum at:\n" . 
            "$text\n" . 
            "$indent^\n";
  }
  
  # Provide fallback operators for cmp, eq, etc...
  use overload fallback => 1;
  
  =head1 EXAMPLES
  
  =head2 Accumulating Results Using Variables
  
  Although the structure-forming methods all return a value, obtained from their
  nested parsing code, it can sometimes be more convenient to use a variable to
  accumulate a result in instead. For example, consider the following parser
  method, designed to parse a set of C<name: "value"> assignments, such as might
  be found in a configuration file, or YAML/JSON-style mapping value.
  
     sub parse_dict
     {
        my $self = shift;
  
        my %ret;
        $self->list_of( ",", sub {
           my $key = $self->token_ident;
           exists $ret{$key} and $self->fail( "Already have a mapping for '$key'" );
  
           $self->expect( ":" );
  
           $ret{$key} = $self->parse_value;
        } );
  
        return \%ret
     }
  
  Instead of using the return value from C<list_of>, this method accumulates
  values in the C<%ret> hash, eventually returning a reference to it as its
  result. Because of this, it can perform some error checking while it parses;
  namely, rejecting duplicate keys.
  
  =head1 TODO
  
  =over 4
  
  =item *
  
  Make unescaping of string constants more customisable. Possibly consider
  instead a C<parse_string_generic> using a loop over C<substring_before>.
  
  =item *
  
  Easy ability for subclasses to define more token types as methods. Perhaps
  provide a class method such as
  
     __PACKAGE__->has_token( hex => qr/[0-9A-F]+/i, sub { hex $_[1] } );
  
  =item *
  
  Investigate how well C<from_reader> can cope with buffer splitting across
  other tokens than simply skippable whitespace
  
  =back
  
  =head1 AUTHOR
  
  Paul Evans <leonerd@leonerd.org.uk>
  
  =cut
  
  0x55AA;
PARSER_MGC

$fatpacked{"Parser/MGC/Examples/EvaluateExpression.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARSER_MGC_EXAMPLES_EVALUATEEXPRESSION';
  package Parser::MGC::Examples::EvaluateExpression;
  
  =head1 NAME
  
  C<Parser::MGC::Examples::EvaluateExpression> - an example parser to evaluate simple numerical expressions
  
  =head1 DESCRIPTION
  
  This evaluator-parser takes simple mathematical expressions involving the four
  basic arithmetic operators (+, -, *, /) applied to integers, and returns the
  numerical result. It handles operator precedence, with * and / having a higher
  level than + and -, and copes with parentheses.
  
  Operator precedence is implemented by using two different parsing functions to
  handle the two different precedence levels.
  
  =cut
  
  =head2 Boilerplate
  
  We start off by declaring a package and subclassing L<Parser::MGC>.
  
     package ExprParser;
     use base qw( Parser::MGC );
  
     use strict;
     use warnings;
  
  =head2 parse
  
  The topmost parsing function, C<parse>, handles the outermost level of
  operator precedence, the + and - operators. It first parses a single term from
  the input by callling C<parse_term> to obtain its value.
  
  It then uses the C<any_of> structure-forming method to look for either a + or -
  operator which would indicate another term will follow it. If it finds either
  of these, it parses the next term from after the operator by another call to
  C<parse_term> and then adds or subtracts the value of it from the running
  total.
  
  The C<any_of> call itself is used as the conditional expression of a C<while>
  loop, to ensure it gets called multiple times. Whenever another term has been
  parsed, the body function returns a true value, to indicate that the while
  loop should be invoked again. Only when there are no more + or - operators,
  indicating no more terms, does the body return false, causing the while loop
  to stop.
  
  This continues until there are no more + or - operators, when the overall
  total value is returned to the caller.
  
  =cut
  
  =pod
  
     sub parse
     {
        my $self = shift;
  
        my $val = $self->parse_term
  
        1 while $self->any_of(
           sub { $self->expect( "+" ); $val += $self->parse_term; 1 },
           sub { $self->expect( "-" ); $val -= $self->parse_term; 1 },
           sub { 0 },
        );
  
        return $val;
     }
  
  =cut
  
  =pod
  
  This function recognises input matching the following EBNF grammar:
  
     EXPR = TERM { ( '+' | '-' ) TERM };
  
  =cut
  
  =head2 parse_term
  
  Called by C<parse>, the next function is C<parse_term> which has a similar
  structure. This function implements the next level of operator precedence, of
  the * and / operators. In a similar fashion to the previous function, this one
  parses a single factor from the input by calling C<parse_factor>, and then
  looks for * or / operators, multiplying or dividing the value by the next
  factor it expects to find after those. This continues until there are no more
  * or / operators, when the overall product is returned.
  
  =cut
  
  =pod
  
     sub parse_term
     {
        my $self = shift;
  
        my $val = $self->parse_factor;
  
        1 while $self->any_of(
           sub { $self->expect( "*" ); $val *= $self->parse_factor; 1 },
           sub { $self->expect( "/" ); $val /= $self->parse_factor; 1 },
           sub { 0 },
        );
  
        return $val;
     }
  
  =cut
  
  =pod
  
  This function recognises input matching the following EBNF grammar:
  
     TERM = FACTOR { ( '*' | '/' ) FACTOR };
  
  =cut
  
  =head2 parse_factor
  
  Finally, the innermost C<parse_factor> function is called by C<parse_term> to
  parse out the actual numerical values. This is also the point at which the
  grammar can recurse, recognising a parenthesized expression. It uses an
  C<any_of> with two alternative function bodies, to cover these two cases.
  
  The first case, to handle a parenthesized sub-expression, consists of a call
  to C<scope_of>. This call would expect to find a C<(> symbol to indicate the
  parenthesized expression. If it finds one, it will recurse back to the
  toplevel C<parse> method to obtain its value, then expects the final C<)>
  symbol. The value of this factor is then the value of the sub-expression
  contained within the parentheses.
  
  If the first case fails, because it does not find that leading C<(> symbol,
  the second case is attempted instead. This handles an actual integer constant.
  This case is simply a call to the C<token_int> method of the underlying class,
  which recognises various string forms of integer constants, returning their
  numerical value.
  
  =cut
  
  =pod
  
     sub parse_factor
     {
        my $self = shift;
  
        $self->any_of(
           sub { $self->scope_of( "(", sub { $self->parse }, ")" ) },
           sub { $self->token_int },
        );
     }
  
  =cut
  
  =pod
  
  This function recognises input matching the following EBNF grammar:
  
     FACTOR = '(' EXPR ')'
            | integer
  
  =cut
  
  =head1 EXAMPLES OF OPERATION
  
  =head2 A single integer
  
  The simplest form of operation of this parser is when it is given a single
  integer value as its input; for example C<"15">.
  
   INPUT:    15
   POSITION: ^
  
  The outermost call to C<parse> will call C<parse_term>, which in turn calls
  C<parse_factor>.
  
   INPUT:    15
   POSITION  ^
   CALLS:    parse
              => parse_term
               => parse_factor
  
  The C<any_of> inside C<parse_factor> will first attempt to find a
  parenthesized sub-expression by using C<scope_of>, but this will fail because
  it does not start with an open parenthesis symbol. The C<any_of> will then
  attempt the second case, calling C<token_int> which will succeed at obtaining
  an integer value from the input stream, consuming it by advancing the stream
  position. The value of 15 is then returned by C<parse_factor> back to
  C<parse_term> where it is stored in the C<$val> lexical.
  
   INPUT:    15
   POSITION:   ^
   CALLS:    parse
              => parse_term -- $val = 15
  
  At this point, the C<any_of> inside C<parse_term> will attempt to find a * or
  / operator, but both will fail because there is none, causing the final
  alternative function to be invoked, which stops the C<while> loop executing.
  The value of 15 is then returned to the outer caller, C<parse>. A similar
  process happens there, where it fails to find a + or - operator, and thus the
  final value of 15 is returned as the result of the entire parsing operation.
  
   INPUT:    15
   OUTPUT:   15
  
  =head2 A simple sum of two integers
  
  Next lets consider a case that actually requires some real parsing, such as an
  expression requesting the sum of two values; C<"6 + 9">.
  
   INPUT:    6 + 9
   POSITION: ^
  
  This parsing operation starts the same as the previous; with C<parse> calling
  C<parse_term> which in turn calls C<parse_factor>.
  
   INPUT:    6 + 9
   POSITION: ^
   CALLS:    parse
              => parse_term
               => parse_factor
  
  As before, the C<any_of> inside C<parse_factor> first attempts and fails to
  find a parenthesized sub-expression and so tries C<token_int> instead. As
  before this obtains an integer value from the stream and advances the
  position. This value is again returned to C<parse_term>. As before, the
  C<any_of> attempts but fails to find a * or / operator so the value gets
  returned to C<parse> to be stored in C<$val>.
  
   INPUT:    6 + 9
   POSITION:  ^
   CALLS:    parse -- $val = 6
  
  This time, the C<any_of> in the outer C<parse> method attempts to find a +
  operator and succeeds, because there is one at the next position in the
  stream. This causes the first case to continue, making another call to
  C<parse_term>.
  
   INPUT:    6 + 9
   POSITION:    ^
   CALLS:    parse -- $val = 6
              => parse_term
  
  This call to C<parse_term> proceeds much like the first, eventually returning
  the value 9 by consuming it from the input stream. This value is added to
  C<$val> by the code inside the C<any_of> call.
  
   INPUT:    6 + 9
   POSITION:      ^
   CALLS:    parse -- $val = 15
  
  C<parse> then calls C<any_of> a second time, which attempts to find another
  operator. This time there is none, so it returns false, which stops the
  C<while> loop and the value is returned as the final result of the operation.
  
   INPUT:    6 + 9
   OUTPUT:   15
  
  =head2 Operator precedence
  
  The two kinds of operators (+ and - vs * and /) are split across two different
  method calls to allow them to implement precedence; to say that some of the
  operators bind more tightly than others. Those operators that are implemented
  in more inwardly-nested functions bind tighter than the ones implemented
  further out.
  
  To see this in operation consider an expression that mixes the two kinds of
  operators, such as C<"15 - 2 * 3">
  
   INPUT:    15 - 2 * 3
   POSITION: ^
  
  The parsing operation starts by calling down from C<parse> all the way to
  C<token_int> which extracts the first integer, 15, from the stream and returns
  it all the way up to C<parse> as before:
  
   INPUT:    15 - 2 * 3
   POSITION:   ^
   CALLS:    parse -- $val = 15
  
  As before, the C<parse> function looks for a * or - operator by its C<any_of>
  test, and finds this time the - operator, which then causes it to call
  C<parse_term> to parse its value:
  
   INPUT:    15 - 2 * 3
   POSITION:     ^
   CALLS:    parse -- $val = 15
              => parse_term
  
  Again, C<parse_term> starts by calling C<parse_factor> which extracts the next
  integer from the stream and returns it. C<parse_factor> temporarily stores
  that in its own C<$val> lexical (which remember, is a lexical variable local
  to that call, so is distinct from the one in C<parse>).
  
   INPUT:    15 - 2 * 3
   POSITION:       ^
   CALLS:    parse -- $val = 15
              => parse_term -- $val = 2
  
  This time, when C<parse_term> attempts its own C<any_of> test to look for a *
  or / operator, it manages to find one. By a process similar to the way that
  the outer C<parse> method forms a sum of terms, C<parse_term> forms a product
  of factors by calling down to C<parse_factor> and accumulating the result.
  Here it will call C<parse_factor> again, which returns the value 3. This gets
  multiplied into C<$var>.
  
   INPUT:    15 - 2 * 3
   POSITION:           ^
   CALLS:    parse -- $val = 15
              => parse_term -- $val = 6
  
  C<parse_term> will try again to look for a * or / operator, but this time
  fails to find one, and so returns its final result, 6, back to C<parse>, which
  then subtracts it from its own C<$val>.
  
   INPUT:    15 - 2 * 3
   POSITION:           ^
   CALLS:    parse -- $val = 9
  
  The outer C<parse> call similarly fails to find any more + or - operators and
  so returns the final result of the parsing operation.
  
   INPUT:    15 - 2 * 3
   OUTPUT:   9
  
  By implementing the * and / operators separately in a different piece of logic
  inside the one that implements the + and - operators, we have ensured that
  they operate more greedily. That is, that they bind tighter, consuming their
  values first, before the outer + and - operators. This is the way that
  operator precedence is implemented.
  
  =head2 Parentheses
  
  This grammar, like many others, provides a way for expressions to override the
  usual operator precedence by supplying a sub-expression in parentheses. The
  expression inside those parentheses is parsed in the usual way, and then its
  result stands in place of the entire parenthesized part, overriding whatever
  rules might have governed the order between those operators inside it and
  those outside.
  
  In this parser we implement this as a recursive call, where one possibility
  of the innermost part (the C<parse_factor> function or the C<FACTOR> EBNF
  rule) is to recurse back to the outermost thing, inside parentheses. This
  example examines what happens to the input string C<"(15 - 2) * 3">.
  
   INPUT:    (15 - 2) * 3
   POSITION: ^
  
  As with all the other examples the parsing operation starts by C<parse>
  calling C<parse_term> which calls C<parse_factor>. This time, the first case
  within the C<any_of> in C<parse_factor> does successfully manage to find an
  open parenthesis, so consumes it. It then stores the close parenthesis pattern
  as the end-of-scope marker, and makes a recursive call back to the parse
  method again.
  
   INPUT:    (15 - 2) * 3
   POSITION:  ^
   CALLS:    parse
              => parse_term
               => parse_factor
                => parse                 EOS = ")"
  
  The operation of the inner call to C<parse> proceeds much like the first few
  examples, calling down through C<parse_term> to C<parse_factor> to obtain
  the 15.
  
   INPUT:    (15 - 2) * 3
   POSITION:    ^
   CALLS:    parse
              => parse_term
               => parse_factor
                => parse -- $val = 15    EOS = ")"
  
  Similar to previous examples, this then finds the - operator, and parses
  another term to subtract from it.
  
   INPUT:    (15 - 2) * 3
   POSITION:        ^
   CALLS:    parse
              => parse_term
               => parse_factor
                => parse -- $val = 13    EOS = ")"
  
  At this point, the C<any_of> test in the inner call to C<parse> tries again to
  look for a + or - operator, and this time fails because it believes it is at
  the end of the input. It isn't really at the end of the string, of course, but
  it believes it to be at the end because of the "end-of-scope" pattern that the
  call to C<scope_of> established. This pretends that the input has finished
  whenever the next part of the input matches the end-of-scope pattern.
  
  Because this inner call to C<parse> now believes it has got to the end of its
  input, it returns its final answer back to the caller, which in this case was
  the C<scope_of> call that C<parse_factor> made. As the C<scope_of> call
  returns, it consumes the input matching the end-of-scope pattern. This return
  value is then stored by C<parse_term>.
  
   INPUT:    (15 - 2) * 3
   POSITION:         ^
   CALLS:    parse
              => parse_term -- $val = 13
  
  At this point, C<parse_term> proceeds as before, finding and extracting the *
  operator and calling C<parse_factor> a second time, multiplying them together
  and returning that to the outer C<parse> call.
  
   INPUT:    (15 - 2) * 3
   POSITION:             ^
   CALLS:    parse -- $val = 39
  
  At this point C<parse> fails to extract any more operators because it is at
  the (real) end of input, so returns the final answer.
  
   INPUT:    (15 - 2) * 3
   OUTPUT:   39
PARSER_MGC_EXAMPLES_EVALUATEEXPRESSION

$fatpacked{"Yabsm/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YABSM_BASE';
  #  Author:  Nicholas Hubbard
  #  WWW:     https://github.com/NicholasBHubbard/yabsm
  #  License: MIT
  
  #  The core module of Yabsm.
  #
  #  See t/Base.t for this modules tests.
  #
  #  The $config_ref variable that is passed all around this module is
  #  created by read_config() from the Yabsm::Config module. read_config()
  #  ensures that the config it produces is valid, so therefore functions
  #  in this library do not need to worry about edge cases caused by an
  #  erroneus config.
  #
  #  All the subroutines are annoted to communicate if the subroutine
  #  has a unit test in Base.t, and if the function is pure. If the
  #  function is pure it means it has no effects on any external state
  #  whether that be a global variable or the filesystem, and always
  #  produces the same output given the same input.
  #
  #  Just because a function doesn't have a unit test does not mean it
  #  has not been informally tested.
  #
  #  An error message prefixed with 'yabsm: internal error' is an error for a
  #  scenario that will only occur if a bug is present.
  
  package Yabsm::Base;
  
  use strict;
  use warnings;
  use v5.16.3;
  
  use Log::Log4perl qw(get_logger);
  use Net::OpenSSH;
  use Time::Piece;
  use File::Path qw(make_path);
  
  sub initialize_directories {
      # TODO init directories
      my $config_ref = shift // get_logger->logconfess(missing_arg());
  
      get_logger->logdie("yabsm: error: initialize_directories() called while not root user")
        if $<;
  
      # We need the main snapshot dir
      # every backup needs blank
      # every subvol needs blank
  
      my $yabsm_dir = local_yabsm_dir($config_ref);
  
      make_path_safe($yabsm_dir);
  
      foreach my $subvol (all_subvols($config_ref)) {
          foreach my $tf (subvol_timeframes($config_ref, $subvol)) {
              make_path_safe("$yabsm_dir/$subvol/$tf");
          }
      }
  
      foreach my $backup (all_backups($config_ref)) {
          #TODO
          my $boot_snap_dir = bootstrap_snap_dir($config_ref, $backup);
     }
  }
  
  sub do_snapshot { # No test. Is not pure.
  
      # Take a new $timeframe snapshot of $subvol and delete old snapshot(s).
  
      my $config_ref = shift // get_logger->logconfess(missing_arg());
      my $subvol     = shift // get_logger->logconfess(missing_arg());
      my $timeframe  = shift // get_logger->logconfess(missing_arg());
  
      take_new_snapshot($config_ref, $subvol, $timeframe);
      delete_old_snapshots($config_ref, $subvol, $timeframe);
  
      return;
  }
  
  sub take_new_snapshot { # No test. Is not pure.
  
      # take a single $timeframe snapshot of $subvol. Used for yabsm's
      # 'take-snap' command.
  
      my $config_ref = shift // get_logger->logconfess(missing_arg());
      my $subvol     = shift // get_logger->logconfess(missing_arg());
      my $timeframe  = shift // get_logger->logconfess(missing_arg());
  
      my $mountpoint = $config_ref->{subvols}{$subvol}{mountpoint};
  
      my $snap_dir = local_yabsm_dir($config_ref, $subvol, $timeframe);
  
      my $snap_name = current_time_snapstring();
  
      # For the first time we take a $timeframe snapshot of $subvol.
      make_path_safe($snap_dir) if not -d $snap_dir;
  
      safe_system("btrfs subvol snapshot -r $mountpoint $snap_dir/$snap_name");
  
      return;
  }
  
  sub delete_old_snapshots { # No test. Is not pure.
  
      # delete old snapshot(s) based off $subvol's ${timeframe}_keep
      # setting defined in the users config. This function should be
      # called directly after take_new_snapshot().
  
      my $config_ref = shift // get_logger->logconfess(missing_arg());
      my $subvol     = shift // get_logger->logconfess(missing_arg());
      my $timeframe  = shift // get_logger->logconfess(missing_arg());
  
      my $existing_snaps_ref = all_snaps($config_ref, $subvol, $timeframe);
  
      my $num_snaps = scalar @$existing_snaps_ref;
  
      my $num_to_keep = $config_ref->{subvols}{$subvol}{"${timeframe}_keep"};
  
      # There is 1 more snapshot than should be kept because we just
      # took a snapshot.
      if ($num_snaps == $num_to_keep + 1) {
  
          # This is the oldest snap because they are sorted newest
          # to oldest and pop takes from the end of the array.
          my $oldest_snap = pop @$existing_snaps_ref;
  
          safe_system("btrfs subvol delete $oldest_snap");
  
          return;
      }
  
      # We haven't reached the snapshot quota yet so don't delete anything.
      elsif ($num_snaps <= $num_to_keep) { return }
  
      # User changed their settings to keep less snapshots then they
      # were keeping prior.
      else {
  
          while ($num_snaps > $num_to_keep) {
  
              # pop mutates $existing_snaps_ref, and thus is not idempotent.
              my $oldest_snap = pop @$existing_snaps_ref;
  
              safe_system("btrfs subvol delete $oldest_snap");
  
              $num_snaps--;
          }
  
          return;
      }
  }
  
  sub do_backup_bootstrap { # No test. Is not pure.
  
      # Determine if $backup is local or remote and dispatch the
      # corresponding do_backup_bootstrap_* subroutine.
  
      my $config_ref = shift // get_logger->logconfess(missing_arg());
      my $backup     = shift // get_logger->logconfess(missing_arg());
  
      if (is_local_backup($config_ref, $backup)) {
          do_backup_bootstrap_local($config_ref, $backup);
      }
  
      elsif (is_remote_backup($config_ref, $backup)) {
          do_backup_bootstrap_ssh($config_ref, $backup);
      }
  
      else {
          get_logger->logconfess("yabsm: internal error: no such user defined backup '$backup'");
      }
  
      return;
  }
  
  sub do_backup_bootstrap_local { # No test. Is not pure.
  
      # Perform bootstrap phase of a btrfs incremental backup. To
      # bootstrap a backup we create a new snapshot and place it in the
      # backups backup bootstrap dir and then then btrfs send/receive
      # the bootstrap snap.
  
      my $config_ref = shift // get_logger->logconfess(missing_arg());
      my $backup     = shift // get_logger->logconfess(missing_arg());
  
      my $boot_snap_dir = bootstrap_snap_dir($config_ref, $backup);
  
      # delete old bootstrap snap
      if (-d $boot_snap_dir) {
          my @snaps = glob "$boot_snap_dir/*";
          1 == scalar @snaps or get_logger->logdie("yabsm: error: multiple bootstrap snapshots in $boot_snap_dir");
          safe_system("btrfs subvol delete " . shift @snaps);
      }
      else {
          make_path_safe($boot_snap_dir);
      }
  
      my $backup_dir = $config_ref->{backups}{$backup}{backup_dir};
  
      # if $backup_dir exists this cannot be the first time
      # bootstrapping so we need to delete the old bootstrap snap.
      if (-d $backup_dir) {
          my @boot_snap = grep { /BOOTSTRAP-/ } glob "$backup_dir/*";
          1 == scalar @boot_snap or get_logger->logdie("yabsm: error: multiple bootstrap snapshots in $backup_dir");
          safe_system('btrfs subvol delete ' . shift @boot_snap);
      }
      else {
          make_path_safe($backup_dir);
      }
  
      my $boot_snap  = "$boot_snap_dir/BOOTSTRAP-" . current_time_snapstring();
      my $subvol     = $config_ref->{backups}{$backup}{subvol};
      my $mountpoint = $config_ref->{subvols}{$subvol}{mountpoint};
  
      safe_system("btrfs subvol snapshot -r $mountpoint $boot_snap");
      safe_system("btrfs send $boot_snap | btrfs receive $backup_dir");
  
      return;
  }
  
  sub do_backup_bootstrap_ssh { # No test. Is not pure.
  
      # Perform bootstrap phase of a btrfs incremental backup. To
      # bootstrap a backup we create a new snapshot and place it in the
      # subvol being snapped's backup bootstrap dir (for example
      # /.snapshots/yabsm/home/backups/homeBackup/bootstrap-snap/), and
      # then btrfs send/receive the bootstrap snap over ssh.
  
      my $config_ref = shift // get_logger->logconfess(missing_arg());
      my $backup     = shift // get_logger->logconfess(missing_arg());
  
      my $boot_snap_dir = bootstrap_snap_dir($config_ref, $backup);
  
      # if $boot_snap_dir exists this cannot be the first time bootstrapping
      # so we need to delete the old bootstrap snap.
      if (-d $boot_snap_dir) {
          my @boot_snap = glob "$boot_snap_dir/*";
          1 == scalar @boot_snap or get_logger->logdie('multiple bootstrap snapshots in $boot_snap_dir');
          safe_system('btrfs subvol delete ' . shift @boot_snap);
      }
      else {
          make_path_safe($boot_snap_dir);
      }
  
      my $subvol = $config_ref->{backups}{$backup}{subvol};
      my $mountpoint = $config_ref->{subvols}{$subvol}{mountpoint};
      my $backup_dir = $config_ref->{backups}{$backup}{backup_dir};
      my $boot_snap = "$boot_snap_dir/BOOTSTRAP-" . current_time_snapstring();
  
      safe_system("btrfs subvol snapshot -r $mountpoint $boot_snap");
  
      # setup Net::OpenSSH ssh connection
      my $host = $config_ref->{backups}{$backup}{host};
      my $ssh = new_ssh_connection($host);
  
      # delete old remote bootstrap snap(s) if it exists
      safe_system_ssh($ssh, "ls -d $backup_dir/* | grep BOOTSTRAP- | while read -r boot_snap; do sudo -n btrfs subvol delete \"\$boot_snap\"; done");
  
      # send the bootstrap backup to remote host
      safe_system_ssh($ssh, "sudo -n btrfs receive $backup_dir", {stdin_file => ['-|', "btrfs send $boot_snap"]});
  
      return;
  }
  
  sub do_backup { # No test. Is not pure.
  
      # Determine if $backup is local or remote and dispatch the
      # corresponding do_backup_* subroutine. If $backup
      # has not been bootstrapped then instead perform the bootstrap
      # routine.
  
      my $config_ref = shift // get_logger->logconfess(missing_arg());
      my $backup     = shift // get_logger->logconfess(missing_arg());
  
      if (not has_bootstrap($config_ref, $backup)) {
          do_backup_bootstrap($config_ref, $backup)
      }
  
      elsif (is_local_backup($config_ref, $backup)) {
          do_backup_local($config_ref, $backup);
      }
  
      elsif (is_remote_backup($config_ref, $backup)) {
          do_backup_ssh($config_ref, $backup);
      }
  
      else {
          get_logger->logconfess("yabsm: internal error: no such defined backup '$backup'");
      }
  
      return;
  }
  
  sub do_backup_local { # No test. Is not pure.
  
      # Perform a single incremental btrfs backup of $backup. This
      # function will kill the program if the bootstrap phase has not
      # yet been completed.
  
      my $config_ref = shift // get_logger->logconfess(missing_arg());
      my $backup     = shift // get_logger->logconfess(missing_arg());
  
      if (not has_bootstrap($config_ref, $backup)) {
          get_logger->logconfess("yabsm: internal error: backup '$backup' has not been bootstrapped");
      }
  
      # bootstrap dir should have exactly one snap
      my $boot_snap = [ glob bootstrap_snap_dir($config_ref, $backup) . '/*' ]->[0];
      my $backup_dir = $config_ref->{backups}{$backup}{backup_dir};
      my $subvol = $config_ref->{backups}{$backup}{subvol};
      my $mountpoint = $config_ref->{subvols}{$subvol}{mountpoint};
      my $tmp_dir = local_yabsm_dir($config_ref) . "/.tmp/$backup";
      my $tmp_snap = "$tmp_dir/" . current_time_snapstring();
  
      # If this is the first time backing up $backup.
      make_path_safe($tmp_dir) if not -d $tmp_dir;
  
      # main
      safe_system("btrfs subvol snapshot -r $mountpoint $tmp_snap");
      safe_system("btrfs send -p $boot_snap $tmp_snap | btrfs receive $backup_dir");
      safe_system("btrfs subvol delete $tmp_snap");
      delete_old_backups_local($config_ref, $backup);
  
      return;
  }
  
  sub do_backup_ssh { # No test. Is not pure.
  
      # Perform a single incremental btrfs backup of $backup over ssh.
      # This function will kill the program if the bootstrap phase has
      # not yet been completed.
  
      my $config_ref = shift // get_logger->logconfess(missing_arg());
      my $backup     = shift // get_logger->logconfess(missing_arg());
  
      if (not has_bootstrap($config_ref, $backup)) {
          get_logger->logconfess("yabsm: internal error: backup '$backup' has not been bootstrapped");
      }
  
      # bootstrap snapshot dir should have exactly one snapshot.
      my $boot_snap =
        [glob bootstrap_snap_dir($config_ref, $backup) . '/*']->[0];
  
      my $subvol = $config_ref->{backups}{$backup}{subvol};
      my $remote_backup_dir = $config_ref->{backups}{$backup}{backup_dir};
      my $remote_host = $config_ref->{backups}{$backup}{host};
      my $mountpoint = $config_ref->{subvols}{$subvol}{mountpoint};
      my $tmp_dir = local_yabsm_dir($config_ref) . "/.tmp/$backup";
      my $tmp_snap = "$tmp_dir/" . current_time_snapstring();
      my $ssh = new_ssh_connection($remote_host);
  
      # If this is the first time backing up $backup.
      make_path_safe($tmp_dir) if not -d $tmp_dir;
  
      # main
      safe_system("btrfs subvol snapshot -r $mountpoint $tmp_snap");
      safe_system_ssh($ssh, "sudo -n btrfs receive $remote_backup_dir", {stdin_file => ['-|', "btrfs send -p $boot_snap $tmp_snap"]});
      safe_system("btrfs subvol delete $tmp_snap");
      delete_old_backups_ssh($config_ref, $ssh, $backup);
  
      return;
  }
  
  sub delete_old_backups_local { # No test. Is not pure.
  
      # Delete old backup snapshot(s) based off $backup's
      # $keep setting defined in the users config. This
      # function should be called directly after do_backup_local().
  
      my $config_ref = shift // get_logger->logconfess(missing_arg());
      my $backup     = shift // get_logger->logconfess(missing_arg());
  
      my $backup_dir = $config_ref->{backups}{$backup}{backup_dir};
  
      my @existing_backups = all_backup_snaps($config_ref, $backup);
  
      my $num_backups = scalar @existing_backups;
  
      my $num_to_keep = $config_ref->{backups}{$backup}{keep};
  
      # There is 1 more backup than should be kept because we just
      # performed a backup.
      if ($num_backups == $num_to_keep + 1) {
  
          # pop takes from the end of the array. This is the oldest backup
          # because they are sorted newest to oldest.
          my $oldest_backup = pop @existing_backups;
  
          safe_system("btrfs subvol delete $oldest_backup");
  
          return;
      }
  
      # We haven't reached the backup quota yet so we don't delete anything.
      elsif ($num_backups <= $num_to_keep) { return }
  
      # User changed their settings to keep less backups than they
      # were keeping prior.
      else {
  
          while ($num_backups > $num_to_keep) {
  
              # note that pop mutates existing_snaps
              my $oldest_backup = pop @existing_backups;
  
              safe_system("btrfs subvol delete $oldest_backup");
  
              $num_backups--;
          }
  
          return;
      }
  }
  
  sub delete_old_backups_ssh { # No test. Is not pure.
  
      # Delete old backup snapshot(s) at the remote host connected to by
      # $ssh. We know how many backups to keep based off $backup's $keep
      # setting defined in the users config. This function should be
      # called directly after do_backup_ssh().
  
      my $config_ref = shift // get_logger->logconfess(missing_arg());
      my $ssh = shift // get_logger->logconfess(missing_arg());
      my $backup     = shift // get_logger->logconfess(missing_arg());
  
      my $remote_backup_dir = $config_ref->{backups}{$backup}{backup_dir};
  
      my @existing_backups = all_backup_snaps($config_ref, $backup, $ssh);
  
      my $num_backups = scalar @existing_backups;
  
      my $num_to_keep = $config_ref->{backups}{$backup}{keep};
  
      # There is 1 more backup than should be kept because we just
      # performed a backup.
      if ($num_backups == $num_to_keep + 1) {
  
          # pop takes from the end of the array. This is the oldest backup
          # because they are sorted newest to oldest.
          my $oldest_backup = pop @existing_backups;
  
          safe_system_ssh($ssh, "sudo -n btrfs subvol delete $oldest_backup");
  
          return;
      }
  
      # We haven't reached the backup quota yet so we don't delete anything.
      elsif ($num_backups <= $num_to_keep) { return }
  
      # User changed their settings to keep less backups than they
      # were keeping prior.
      else {
  
          while ($num_backups > $num_to_keep) {
  
              # note that pop mutates existing_snaps
              my $oldest_backup = pop @existing_backups;
  
              safe_system_ssh($ssh, "sudo -n btrfs subvol delete $oldest_backup");
  
              $num_backups--;
          }
  
          return;
      }
  }
  
  sub has_bootstrap { # No test. Is not pure.
  
      # True if $backup already has a bootstrap snapshot.
  
      my $config_ref = shift // get_logger->logconfess(missing_arg());
      my $backup     = shift // get_logger->logconfess(missing_arg());
  
      my $bootstrap_snap_dir = bootstrap_snap_dir($config_ref, $backup);
  
      return 0 if not -d $bootstrap_snap_dir;
  
      # Log if the bootstrap dir does not exist
  
      opendir(my $dh, $bootstrap_snap_dir) or
        get_logger->logdie("yabsm: internal error: can not open dir '$bootstrap_snap_dir'");
  
      my @snaps = grep { /^[^.]/ } readdir($dh);
  
      closedir $dh;
  
      if (@snaps) {
          return 1;
      }
      else {
          return 0;
      }
  }
  
  sub all_snaps { # No test. Is not pure.
  
      # Gather all snapshots (full paths) of $subject and return them
      # sorted from newest to oldest. $subject can be any user defined
      # subvol or backup. If $subject is a subvol it may make sense to
      # only want snapshots from certain timeframes which can be passed
      # as the >=3'rd arguments.
  
      my $config_ref = shift // get_logger->logconfess(missing_arg());
      my $subject    = shift // get_logger->logconfess(missing_arg());
      my @timeframes = @_;
  
      my @all_snaps = (); # return this
  
      if (is_subvol($config_ref, $subject)) {
          # default to all timeframes
          if (not @timeframes) {
              @timeframes = all_timeframes();
          }
  
          foreach my $tf (@timeframes) {
  
              my $snap_dir = local_yabsm_dir($config_ref, $subject, $tf);
  
              if (-d $snap_dir) {
                  push @all_snaps, glob "$snap_dir/*";
              }
          }
  
          @all_snaps = sort_snaps(\@all_snaps);
      }
  
      if (is_backup($config_ref, $subject)) {
          # all_backup_snaps returns snaps sorted
          @all_snaps = all_backup_snaps($config_ref, $subject);
      }
  
      return wantarray ? @all_snaps : \@all_snaps;
  }
  
  sub all_backup_snaps { # No test. Is not pure.
  
      # Gather all snapshots (full paths) of $backup and return them
      # sorted from newest to oldest. A Net::OpenSSH connection object
      # can be passed as an arg if $backup is a remote backup, otherwise
      # a new connection will be opened.
  
      my $config_ref = shift // get_logger->logconfess(missing_arg());
      my $backup     = shift // get_logger->logconfess(missing_arg());
  
      my @all_backups = ();
  
      if (is_remote_backup($config_ref, $backup)) {
          my $backup_dir = $config_ref->{backups}{$backup}{backup_dir};
          my $remote_host = $config_ref->{backups}{$backup}{host};
          my $ssh = shift // new_ssh_connection( $remote_host );
          @all_backups = sort_snaps([ map { chomp; $_ = "$backup_dir/$_" } grep { $_ !~ /BOOTSTRAP-day/ } $ssh->capture("ls $backup_dir") ]);
  
      }
  
      if (is_local_backup($config_ref, $backup)) {
          my $backup_dir = $config_ref->{backups}{$backup}{backup_dir};
          @all_backups = sort_snaps([ grep { $_ !~ /BOOTSTRAP-day/ } glob "$backup_dir/*" ]);
      }
  
      return wantarray ? @all_backups : \@all_backups;
  }
  
  sub local_yabsm_dir { # Has test. Is pure.
  
      # Return the local directory path to the/a yabsm directory. The
      # $subvol and $timeframe arguments are optional. Note that we do not
      # check check that $subvol and $timeframe are a valid subvol/timeframe.
  
      my $config_ref = shift // get_logger->logconfess(missing_arg());
      my $subvol     = shift; # optional
      my $timeframe  = shift; # optional
  
      my $yabsm_dir = $config_ref->{misc}{yabsm_dir};
  
      if (defined $subvol) {
          $yabsm_dir .= "/$subvol";
          if (defined $timeframe) {
              $yabsm_dir .= "/$timeframe";
          }
      }
  
      return $yabsm_dir;
  }
  
  sub bootstrap_snap_dir { # Has test. Is pure.
  
      # Return the path of the directory holding the bootstrap snapshot for
      # $backup. The bootstrap snapshot is used for btrfs incremental backups.
  
      my $config_ref = shift // get_logger->logconfess(missing_arg());
      my $backup     = shift // get_logger->logconfess(missing_arg());
  
      my $subvol = $config_ref->{backups}{$backup}{subvol};
  
      my $yabsm_root_dir = local_yabsm_dir($config_ref);
  
      return "$yabsm_root_dir/.cache/$subvol/backups/$backup/bootstrap-snap";
  }
  
  sub is_snapstring { # Has test. Is pure.
  
      # Return 1 iff $snapstring is a valid snapstring. Works on
      # absolute paths as well as plain snapstrings.
  
      my $snapstring = shift // get_logger->logconfess(missing_arg());
  
      return $snapstring =~ /day=\d{4}_\d{2}_\d{2},time=\d{2}:\d{2}$/;
  }
  
  sub current_time_snapstring { # No test. Is not pure.
  
      # Return a snapstring of the current time.
  
      my $t = localtime();
  
      return nums_to_snapstring($t->year, $t->mon, $t->mday, $t->hour, $t->min);
  }
  
  sub n_units_ago_snapstring { # Has test. Is not pure.
  
      # Return a snapstring of the time $n $unit's ago from the current
      # time. The unit can be minutes, hours or days.
  
      my $n    = shift // get_logger->logconfess(missing_arg());
      my $unit = shift // get_logger->logconfess(missing_arg());
  
      # Can add/subtract by seconds with Time::Piece objects.
  
      my $seconds_per_unit;
  
      if    ($unit =~ /^(minutes|mins|m)$/) { $seconds_per_unit = 60    }
      elsif ($unit =~ /^(hours|hrs|h)$/   ) { $seconds_per_unit = 3600  }
      elsif ($unit =~ /^(days|d)$/        ) { $seconds_per_unit = 86400 }
      else  { get_logger->logconfess("yabsm: internal error: '$unit' is not a valid time unit") }
  
      my $current_time = current_time_snapstring();
  
      my $time_piece_obj = snapstring_to_time_piece_obj($current_time);
  
      $time_piece_obj -= ($n * $seconds_per_unit);
  
      return time_piece_obj_to_snapstring($time_piece_obj);
  }
  
  sub is_immediate { # Has test. Is pure.
  
      # An immediate is either a literal time or a relative time.
  
      my $imm = shift // get_logger->logconfess(missing_arg());
  
      return is_literal_time($imm) || is_relative_time($imm);
  }
  
  sub is_literal_time { # Has test. Is pure.
  
      # True if $lit_time is a valid literal time. Literal times can
      # come in one of 5 different forms which can be seen by the 5
      # regexps below.
  
      my $lit_time = shift // get_logger->logconfess(missing_arg());
  
      # yr-mon-day-hr:min
      my $re1 = qr/^\d{4}-\d{1,2}-\d{1,2}-\d{1,2}:\d{1,2}$/;
      # yr-mon-day
      my $re2 = qr/^\d{4}-\d{1,2}-\d{1,2}$/;
      # mon-day
      my $re3 = qr/^\d{1,2}-\d{1,2}$/;
      # mon-day-hr
      my $re4 = qr/^\d{1,2}-\d{1,2}-\d{1,2}$/;
      # mon-day-hr:min
      my $re5 = qr/^\d{1,2}-\d{1,2}-\d{1,2}:\d{1,2}$/;
      # day-hr:min
      my $re6 = qr/^\d{1,2}-\d{1,2}:\d{1,2}$/;
      # hr:min
      my $re7 = qr/^\d{1,2}:\d{1,2}$/;
  
      return $lit_time =~ /$re1|$re2|$re3|$re4|$re5|$re6|$re7/;
  }
  
  sub is_relative_time { # Has test. Is pure.
  
      # Relative times take the form of 'back-amount-unit'.
      # 'back' can be abbreviated to 'b'.
      # The amount field must be a whole number.
      # The unit field must be a time unit like 'minutes', 'hours', or 'days'.
  
      my $rel_time = shift // get_logger->logconfess(missing_arg());
  
      my ($back, $amount, $unit) = split '-', $rel_time, 3;
  
      return 0 if grep { not defined } ($back, $amount, $unit);
  
      my $back_correct = $back =~ /^b(ack)?$/;
  
      my $amount_correct = $amount =~ /^\d+$/;
  
      my $unit_correct = grep { $unit eq $_ } qw(minutes mins m hours hrs h days d);
  
      return $back_correct && $amount_correct && $unit_correct;
  }
  
  
  sub immediate_to_snapstring { # No test. Is pure.
  
      # Resolve an immediate to a snapstring.
  
      my $imm = shift // get_logger->logconfess(missing_arg());
  
      if (is_literal_time($imm)) {
          return literal_time_to_snapstring($imm);
      }
  
      if (is_relative_time($imm)) {
          return relative_time_to_snapstring($imm);
      }
  
      # input should have already been cleansed.
      get_logger->logconfess("yabsm: internal error: '$imm' is not an immediate");
  }
  
  sub literal_time_to_snapstring { # Has test. Is pure.
  
      # Resolve a literal time to a snapstring.
  
      my $lit_time = shift // get_logger->logconfess(missing_arg());
  
      # literal time forms
      my $yr_mon_day_hr_min = qr/^(\d{4})-(\d{1,2})-(\d{1,2})-(\d{1,2}):(\d{1,2})$/;
      my $yr_mon_day        = qr/^(\d{4})-(\d{1,2})-(\d{1,2})$/;
      my $mon_day           = qr/^(\d{1,2})-(\d{1,2})$/;
      my $mon_day_hr        = qr/^(\d{1,2})-(\d{1,2})-(\d{1,2})$/;
      my $mon_day_hr_min    = qr/^(\d{1,2})-(\d{1,2})-(\d{1,2}):(\d{1,2})$/;
      my $day_hr_min        = qr/^(\d{1,2})-(\d{1,2}):(\d{1,2})$/;
      my $hr_min            = qr/^(\d{1,2}):(\d{1,2})$/;
  
      if ($lit_time =~ $yr_mon_day_hr_min) {
          return nums_to_snapstring($1, $2, $3, $4, $5);
      }
  
      if ($lit_time =~ $yr_mon_day) {
          return nums_to_snapstring($1, $2, $3, 0, 0);
      }
  
      if ($lit_time =~ $mon_day) {
          my $t = localtime;
          return nums_to_snapstring($t->year, $1, $2, 0, 0);
      }
  
      if ($lit_time =~ $mon_day_hr) {
          my $t = localtime;
          return nums_to_snapstring($t->year, $1, $2, $3, 0);
      }
  
      if ($lit_time =~ $mon_day_hr_min) {
          my $t = localtime;
          return nums_to_snapstring($t->year, $1, $2, $3, $4);
      }
  
      if ($lit_time =~ $day_hr_min) {
          my $t = localtime;
          return nums_to_snapstring($t->year, $t->mon, $1, $2, $3);
      }
  
      if ($lit_time =~ $hr_min) {
          my $t = localtime;
          return nums_to_snapstring($t->year, $t->mon, $t->mday, $1, $2);
      }
  
      # input should have already been cleansed.
      get_logger->logconfess("yabsm: internal error: '$lit_time' is not a valid literal time");
  }
  
  sub time_hour { # Has test. Is pure.
  
      # Takes a time of the form 'hh:mm' and returns the hour (hh).
  
      my $time = shift // missing_arg();
  
      my ($hr, undef) = split ':', $time, 2;
  
      return $hr;
  }
  
  sub time_minute { # Has test. Is pure.
  
      # Takes a time of the form 'hh:mm' and returns the minute (hh).
  
      my $time = shift // missing_arg();
  
      my (undef, $min) = split ':', $time, 2;
  
      return $min;
  }
  
  sub relative_time_to_snapstring { # Has test. Is not pure.
  
      # Resolve a relative time to a snapstring.
  
      my $rel_time = shift // get_logger->logconfess(missing_arg());
  
      my (undef, $amount, $unit) = split '-', $rel_time, 3;
  
      my $n_units_ago_snapstring = n_units_ago_snapstring($amount, $unit);
  
      return $n_units_ago_snapstring;
  }
  
  sub snapstring_to_nums { # Has test. Is pure.
  
      # Take a snapshot name string and return an array containing in
      # order the year, month, day, hour, and minute. This works with
      # both a full path and just a snapshot name string.
  
      my $snap = shift // get_logger->logconfess(missing_arg());
  
      my @nums = $snap =~ /day=(\d{4})_(\d{2})_(\d{2}),time=(\d{2}):(\d{2})$/;
  
      return wantarray ? @nums : \@nums;
  }
  
  sub nums_to_snapstring { # Has test. Is pure.
  
      # Take 5 integer arguments representing in order the year, month,
      # day, hour, and minute and return the corresponding snapstring.
  
      my ($yr, $mon, $day, $hr, $min) = map { sprintf '%02d', $_ } @_;
  
      return "day=${yr}_${mon}_${day},time=${hr}:${min}";
  }
  
  sub snapstring_to_time_piece_obj { # Has test. Is pure.
  
      # Turn a snapshot name string into a Time::Peice object. This is
      # useful because we can do time arithmetic on these objects.
  
      my $snap = shift // get_logger->logconfess(missing_arg());
  
      my ($yr, $mon, $day, $hr, $min) = snapstring_to_nums($snap);
  
      return Time::Piece->strptime("$yr/$mon/$day/$hr/$min",'%Y/%m/%d/%H/%M');
  }
  
  sub time_piece_obj_to_snapstring { # Has test. Is pure.
  
      # Turn a Time::Piece object into a snapshot name string.
  
      my $time_piece_obj = shift // get_logger->logconfess(missing_arg());
  
      my $yr  = $time_piece_obj->year;
      my $mon = $time_piece_obj->mon;
      my $day = $time_piece_obj->mday;
      my $hr  = $time_piece_obj->hour;
      my $min = $time_piece_obj->min;
  
      return nums_to_snapstring($yr, $mon, $day, $hr, $min);
  }
  
  sub sort_snaps { # Has test. Is pure.
  
      # Return a sorted version of the inputted snapshot array ref.
      # The snapshots will be returned newest to oldest. Works with
      # plain snapstrings and full paths.
  
      my $snaps_ref = shift // get_logger->logconfess(missing_arg());
  
      my @sorted_snaps = sort { cmp_snaps($a, $b) } @$snaps_ref;
  
      return wantarray ? @sorted_snaps : \@sorted_snaps;
  }
  
  sub cmp_snaps { # Has test. Is pure.
  
      # Return -1 if $snap1 is newer than $snap2.
      # Return 1 if $snap1 is older than $snap2
      # Return 0 if $snap1 and $snap2 are the same.
      # Works with both plain snapstrings and full paths.
  
      my $snap1 = shift // get_logger->logconfess(missing_arg());
      my $snap2 = shift // get_logger->logconfess(missing_arg());
  
      my @snap1_nums = snapstring_to_nums($snap1);
      my @snap2_nums = snapstring_to_nums($snap2);
  
      # lexicographic order
      for (my $i = 0; $i <= $#snap1_nums; $i++) {
  
          return -1 if $snap1_nums[$i] > $snap2_nums[$i];
          return 1  if $snap1_nums[$i] < $snap2_nums[$i];
      }
  
      # Must be the same
      return 0;
  }
  
  sub snap_closest_to { # Has test. Is pure.
  
      # Return the snapshot from $all_snaps_ref that is closest to
      # $target_snap. $all_snaps_ref should be sorted from newest to
      # oldest.
  
      my $all_snaps_ref = shift // get_logger->logconfess(missing_arg());
      my $target_snap   = shift // get_logger->logconfess(missing_arg());
  
      my $snap;
  
      for (my $i = 0; $i <= $#{ $all_snaps_ref }; $i++) {
  
          my $this_snap = $all_snaps_ref->[$i];
  
          my $cmp = cmp_snaps($this_snap, $target_snap);
  
          # if $this_snap is the same as $target_snap
          if ($cmp == 0) {
              $snap = $this_snap;
              last;
          }
  
          # if $this_snap is older than $target_snap
          if ($cmp == 1) {
              if ($i == 0) { # No previous snap. This is as close as were getting.
                  $snap = $this_snap;
              }
              else {
                  my $prev_snap = $all_snaps_ref->[$i-1];
                  $snap = snap_closer($target_snap, $prev_snap, $this_snap);
              }
              last;
          }
      }
  
      if (not defined $snap) {
          $snap = oldest_snap($all_snaps_ref);
      }
  
      return $snap;
  }
  
  sub snap_closer { # Has test. Is pure.
  
      # Return either $snap1 or $snap2, depending on which is closer to
      # $target_snap. If they are equidistant return $snap1.
  
      my $target_snap = shift // get_logger->logconfess(missing_arg());
      my $snap1       = shift // get_logger->logconfess(missing_arg());
      my $snap2       = shift // get_logger->logconfess(missing_arg());
  
      my $target_epoch = snapstring_to_time_piece_obj($target_snap)->epoch;
      my $snap1_epoch  = snapstring_to_time_piece_obj($snap1)->epoch;
      my $snap2_epoch  = snapstring_to_time_piece_obj($snap2)->epoch;
  
      my $v1 = abs($target_epoch - $snap1_epoch);
      my $v2 = abs($target_epoch - $snap2_epoch);
  
      if ($v1 <= $v2) { return $snap1 }
      else            { return $snap2 }
  }
  
  sub snaps_newer_than { # Has test. Is pure.
  
      # Return all the snapshots from $all_snaps_ref that are newer than
      # $target_snap. We assume that $all_snaps_ref is sorted from
      # newest to oldest.
  
      my $all_snaps_ref = shift // get_logger->logconfess(missing_arg());
      my $target_snap   = shift // get_logger->logconfess(missing_arg());
  
      my @newer = ();
  
      for (my $i = 0; $i <= $#{ $all_snaps_ref }; $i++) {
  
          my $this_snap = $all_snaps_ref->[$i];
  
          my $cmp = cmp_snaps($this_snap, $target_snap);
  
          # if $this_snap is newer than $target_snap
          if ($cmp == -1) {
              push @newer, $this_snap;
          }
          else { last }
      }
  
      return wantarray ? @newer : \@newer;
  }
  
  sub snaps_older_than { # Has test. Is pure.
  
      # Return all the snapshots that are older than $target_snap.
  
      my $all_snaps_ref = shift // get_logger->logconfess(missing_arg());
      my $target_snap   = shift // get_logger->logconfess(missing_arg());
  
      my @older = ();
  
      my $last_idx = $#{ $all_snaps_ref };
  
      for (my $i = 0; $i <= $last_idx; $i++) {
  
          my $this_snap = $all_snaps_ref->[$i];
  
          my $cmp = cmp_snaps($this_snap, $target_snap);
  
          # if $this_snap is older than $target_snap
          if ($cmp == 1) {
              @older = @$all_snaps_ref[$i .. $last_idx];
              last;
          }
      }
  
      return wantarray ? @older : \@older;
  }
  
  sub snaps_between { # Has test. Is pure.
  
      # Return all of the snapshots between (inclusive) $target_snap1
      # and $target_snap2. Remember that $all_snaps_ref is sorted
      # newest to oldest.
  
      my $all_snaps_ref = shift // get_logger->logconfess(missing_arg());
      my $target_snap1  = shift // get_logger->logconfess(missing_arg());
      my $target_snap2  = shift // get_logger->logconfess(missing_arg());
  
      # figure out which target snap is newer/older.
  
      my $older;
      my $newer;
  
      if (-1 == cmp_snaps($target_snap1, $target_snap2)) {
          $newer = $target_snap1;
          $older = $target_snap2;
      }
      else {
          $newer = $target_snap2;
          $older = $target_snap1;
      }
  
      # Find the snaps between (inclusive) $newer and $older. Remember
      # that $all_snaps_ref is sorted newest to oldest.
  
      my @snaps_between = ();
  
      my $last_idx = $#{ $all_snaps_ref };
  
      for (my $i = 0; $i <= $last_idx; $i++) {
  
          my $this_snap = $all_snaps_ref->[$i];
  
          my $cmp = cmp_snaps($this_snap, $newer);
  
          # if $this_snap is older or equal to the $newer
          if ($cmp == 1 || $cmp == 0) {
  
              # between (inclusive)
              push @snaps_between, $this_snap if $cmp == 0;
  
              for (my $j = $i+1; $j <= $last_idx; $j++) {
  
                  my $this_snap = $all_snaps_ref->[$j];
  
                  my $cmp = cmp_snaps($this_snap, $older);
  
                  # if $this_snap is older than or equal to $older
                  if ($cmp == 1 || $cmp == 0) {
  
                      # between (inclusive)
                      push @snaps_between, $this_snap if $cmp == 0;
  
                      # Were done. Break the inner loop. The outer loop
                      # will be broken as well.
                      last;
                  }
  
                  else {
                      push @snaps_between, $this_snap;
                  }
              }
  
              last;
          }
      }
  
      return wantarray ? @snaps_between : \@snaps_between;
  }
  
  sub newest_snap { # Has test. Is not pure.
  
      # $ref can be either an array ref to an array of sorted snapshots,
      # or a reference to the users config. If $ref is a ref to the
      # config this is because the caller wants to get the newest
      # snapshot of some subvol/backup, and thus will require an extra
      # argument denoting the desired subvol/backup.
  
      my $ref    = shift // get_logger->logconfess(missing_arg());
      my $subvol = shift; # only needed if $ref is $config_ref
  
      my $ref_type = ref($ref);
  
      if ($ref_type eq 'ARRAY') {
          return $ref->[0]
      }
  
      if ($ref_type eq 'HASH') {
          my $all_snaps_ref = all_snaps($ref, $subvol);
          return $all_snaps_ref->[0];
      }
  
      get_logger->logconfess("yabsm: internal error: '$ref' has ref type '$ref_type'");
  }
  
  sub oldest_snap { # Has test. Is not pure.
  
      # $ref can be either an array ref to an array of sorted snapshots,
      # or a reference to the users config. If $ref is a ref to the
      # config this is because the caller wants to get the oldest
      # snapshot of some subvol/backup, and thus will require an extra
      # argument denoting the desired subvol/backup.
  
      my $ref = shift // get_logger->logconfess(missing_arg());
  
      my $ref_type = ref($ref);
  
      if ($ref_type eq 'ARRAY') {
          return $ref->[-1];
      }
  
      if ($ref_type eq 'HASH') {
          my $subject = shift // get_logger->logconfess(missing_arg());
          my $all_snaps_ref = all_snaps($ref, $subject);
          return $all_snaps_ref->[-1];
      }
  
      get_logger("yabsm: internal error: '$ref' has ref type '$ref_type'");
  }
  
  sub answer_query { # No test. Is not pure.
  
      # Answers $query to find the appropiate snapshot(s) of
      # $subject. We expect that $query has already been
      # validated. $subject can either be a defined subvol or a backup.
  
      my $config_ref = shift // get_logger->logconfess(missing_arg());
      my $subject    = shift // get_logger->logconfess(missing_arg());
      my $query      = shift // get_logger->logconfess(missing_arg());
  
      my $all_snaps_ref = all_snaps($config_ref, $subject);
  
      my @snaps_to_return;
  
      if ($query eq 'all') {
  
          # return all the snaps
  
          @snaps_to_return = @$all_snaps_ref;
      }
  
      elsif ($query eq 'newest') {
  
          # return just the newest snap
  
          my $snap = newest_snap($all_snaps_ref);
  
          @snaps_to_return = ($snap);
      }
  
      elsif ($query eq 'oldest') {
  
          # return just the oldest snap
  
          my $snap = oldest_snap($all_snaps_ref);
  
          @snaps_to_return = ($snap);
      }
  
      elsif (is_immediate($query)) {
  
          # return the one snap closest to the time denoted by the immediate.
  
          my $target = immediate_to_snapstring($query);
  
          my $snap = snap_closest_to($all_snaps_ref, $target);
  
          @snaps_to_return = ($snap);
      }
  
      elsif (is_newer_than_query($query)) {
  
          my (undef, $imm) = split /\s/, $query, 2;
  
          my $target = immediate_to_snapstring($imm);
  
          @snaps_to_return = snaps_newer_than($all_snaps_ref, $target);
      }
  
      elsif (is_older_than_query($query)) {
  
          my (undef, $imm) = split /\s/, $query, 2;
  
          my $target = immediate_to_snapstring($imm);
  
          @snaps_to_return = snaps_older_than($all_snaps_ref, $target);
      }
  
      elsif (is_between_query($query)) {
  
          my (undef, $imm1, $imm2) = split /\s/, $query, 3;
  
          my $target1 = immediate_to_snapstring($imm1);
  
          my $target2 = immediate_to_snapstring($imm2);
  
          @snaps_to_return = snaps_between($all_snaps_ref, $target1, $target2);
      }
  
      else { # input should have already been cleansed
          get_logger->logconfess("yabsm: internal error: '$query' is not a valid query");
      }
  
      return wantarray ? @snaps_to_return : \@snaps_to_return;
  }
  
  sub is_valid_query { # Has test. Is pure.
  
      # True iff $query is a valid query. Used to validate
      # user input query for 'yabsm find'.
  
      my $query = shift // get_logger->logconfess(missing_arg());
  
      if ($query eq 'all')             { return 1 }
      if ($query eq 'newest')          { return 1 }
      if ($query eq 'oldest')          { return 1 }
      if (is_immediate($query))        { return 1 }
      if (is_newer_than_query($query)) { return 1 }
      if (is_older_than_query($query)) { return 1 }
      if (is_between_query($query))    { return 1 }
  
      return 0;
  }
  
  sub is_newer_than_query { # Has test. Is pure.
  
      # Return 1 iff $query is a syntactically valid newer_than query.
      # A newer_than query returns all snapshots newer than some
      # immediate.  A newer_than query can be denoted by one of the
      # keywords 'newer', 'after', or 'aft'. A newer_than query takes
      # exactly one immediate as an argument.
  
      my $query = shift // get_logger->logconfess(missing_arg());
  
      my ($keyword, $imm) = split /\s/, $query, 2;
  
      return 0 if grep { not defined } ($keyword, $imm);
  
      my $keyword_correct = $keyword =~ /^(newer|after|aft)$/;
  
      my $imm_correct = is_immediate($imm);
  
      return $keyword_correct && $imm_correct;
  }
  
  sub is_older_than_query { # Has test. Is pure.
  
      # Return 1 iff $query is a syntactically valid older_than query.
      # An older_than query returns all snapshots older than some
      # immediate. A older_than query can be denoted by one of the
      # keywords 'older', 'before', or 'bef'. An older_than query takes
      # exactly one immediate as an argument.
  
      my $query = shift // get_logger->logconfess(missing_arg());
  
      my ($keyword, $imm) = split /\s/, $query, 2;
  
      return 0 if grep { not defined } ($keyword, $imm);
  
      my $keyword_correct = $keyword =~ /^(older|before|bef)$/;
  
      my $imm_correct = is_immediate($imm);
  
      return $keyword_correct && $imm_correct;
  }
  
  sub is_between_query { # Has test. Is pure.
  
      # Return 1 iff $query is a syntactically valid 'between' query.
      # A between query takes two immediate arguments and returns all
      # snapshots between the two immediate times.
  
      my $query = shift // get_logger->logconfess(missing_arg());
  
      my ($keyword, $imm1, $imm2) = split /\s/, $query, 3;
  
      return 0 if grep { not defined } ($keyword, $imm1, $imm2);
  
      my $keyword_correct = $keyword =~ /^bet(ween)?$/;
  
      my $imm1_correct = is_immediate($imm1);
  
      my $imm2_correct = is_immediate($imm2);
  
      return $keyword_correct && $imm1_correct && $imm2_correct;
  }
  
  sub all_timeframes { # Has test. Is pure.
  
      # Return an array of all yabsm timeframes.
  
      return qw(5minute hourly daily weekly monthly);
  }
  
  sub is_timeframe { # Has test. Is pure.
  
      # true if $tf is a yabsm timeframe.
  
      my $tf = shift // get_logger->logconfess(missing_arg());
  
      return grep { $tf eq $_ } all_timeframes();
  }
  
  sub timeframe_want { # Has test. Is pure.
  
      # true iff $subvol wants to take $timeframe snapshots.
  
      my $config_ref = shift // get_logger->logconfess(missing_arg());
      my $subvol     = shift // get_logger->logconfess(missing_arg());
      my $timeframe  = shift // get_logger->logconfess(missing_arg());
  
      return 'yes' eq $config_ref->{subvols}{$subvol}{"${timeframe}_want"};
  }
  
  sub subvol_timeframes { # Has test. Is pure.
  
      # Return an array of all the timeframes that $subvol wants snapshots for.
  
      my $config_ref = shift // get_logger->logconfess(missing_arg());
      my $subvol     = shift // get_logger->logconfess(missing_arg());
  
      my @tfs = ();
  
      foreach my $tf (all_timeframes()) {
          if (timeframe_want($config_ref, $subvol, $tf)) {
              push @tfs, $tf;
          }
      }
  
      return wantarray ? @tfs : \@tfs;
  }
  
  sub all_subvols { # Has test. Is pure.
  
      # Return an array of the names of every user defined subvol.
  
      my $config_ref = shift // get_logger->logconfess(missing_arg());
  
      my @subvols = sort keys %{$config_ref->{subvols}};
  
      return wantarray ? @subvols : \@subvols;
  }
  
  sub all_backups { # Has test. Is pure.
  
      # Return an array of the names of every user defined backup.
  
      my $config_ref = shift // get_logger->logconfess(missing_arg());
  
      my @backups = sort keys %{$config_ref->{backups}};
  
      return wantarray ? @backups : \@backups;
  }
  
  sub all_backups_of_subvol { # Has test. Is pure.
  
      # Return an array of all the backups that are backing up $subvol.
  
      my $config_ref = shift // get_logger->logconfess(missing_arg());
      my $subvol     = shift // get_logger->logconfess(missing_arg());
  
      my @backups = ();
  
      foreach my $backup (all_backups($config_ref)) {
  
          my $this_subvol = $config_ref->{backups}{$backup}{subvol};
  
          if ($this_subvol eq $subvol) {
              push @backups, $backup
          }
      }
  
      return wantarray ? @backups : \@backups;
  }
  
  sub is_subject { # Has test. Is pure.
  
      # True iff $subject is an existing user defined subject. A subject
      # is either a subvol or backup.
  
      my $config_ref = shift // get_logger->logconfess(missing_arg());
      my $subject    = shift // get_logger->logconfess(missing_arg());
  
      my $is_subvol = is_subvol($config_ref, $subject);
      my $is_backup = is_backup($config_ref, $subject);
  
      return $is_subvol || $is_backup;
  }
  
  sub is_subvol { # Has test. Is pure.
  
      # True iff $subvol is the name of a user defined subvol.
  
      my $config_ref = shift // get_logger->logconfess(missing_arg());
      my $subvol     = shift // get_logger->logconfess(missing_arg());
  
      return grep { $subvol eq $_ } all_subvols($config_ref);
  }
  
  sub is_backup { # Has test. Is pure.
  
      # True iff $backup is the name of a user defined backup.
  
      my $config_ref = shift // get_logger->logconfess(missing_arg());
      my $backup     = shift // get_logger->logconfess(missing_arg());
  
      return grep { $backup eq $_ } all_backups($config_ref);
  }
  
  sub is_remote_backup { # Has test. Is pure.
  
      # Return 1 iff $backup is the name of a defined local backup. A
      # local backup is one in which the backups 'remote' field is set
      # to 'yes'.
  
      my $config_ref = shift // get_logger->logconfess(missing_arg());
      my $backup     = shift // get_logger->logconfess(missing_arg());
  
      if (is_backup($config_ref, $backup)) {
          return $config_ref->{backups}{$backup}{remote} eq 'yes';
      }
  
      else { return 0 }
  }
  
  sub schedule_snapshots { # No test. Is not pure.
  
      # Schedule snapshots based off user configuration by adding
      # them to $cron_scheduler object (see Schedule::Cron module).
  
      my $config_ref     = shift // get_logger->logconfess(missing_arg());
      my $cron_scheduler = shift // get_logger->logconfess(missing_arg());
  
      foreach my $subvol (all_subvols($config_ref)) {
  
          my $_5minute_want = $config_ref->{subvols}{$subvol}{'5minute_want'};
          my $hourly_want   = $config_ref->{subvols}{$subvol}{hourly_want};
          my $daily_want    = $config_ref->{subvols}{$subvol}{daily_want};
          my $weekly_want   = $config_ref->{subvols}{$subvol}{weekly_want};
          my $monthly_want  = $config_ref->{subvols}{$subvol}{monthly_want};
  
          if ($_5minute_want eq 'yes') {
              $cron_scheduler->add_entry(
                  "*/5 * * * *",
                  sub { do_snapshot($config_ref, $subvol, '5minute') }
              );
          }
  
          if ($hourly_want eq 'yes') {
              $cron_scheduler->add_entry(
                  "0 */1 * * *",
                  sub { do_snapshot($config_ref, $subvol, 'hourly') }
              );
          }
  
          if ($daily_want eq 'yes') {
              my $time = $config_ref->{subvols}{$subvol}{daily_time};
              my $hr   = time_hour($time);
              my $min  = time_minute($time);
              $cron_scheduler->add_entry(
                  "$min $hr * * *",
                  sub { do_snapshot($config_ref, $subvol, 'daily') }
              );
          }
  
          if ($weekly_want eq 'yes') {
              my $time = $config_ref->{subvols}{$subvol}{weekly_time};
              my $hr   = time_hour($time);
              my $min  = time_minute($time);
              my $dow  = day_of_week_num($config_ref->{subvols}{$subvol}{weekly_day});
              $cron_scheduler->add_entry(
                  "$min $hr * * $dow",
                  sub { do_snapshot($config_ref, $subvol, 'weekly') }
              );
          }
  
          if ($monthly_want eq 'yes') {
              my $time = $config_ref->{subvols}{$subvol}{monthly_time};
              my $hr   = time_hour($time);
              my $min  = time_minute($time);
              my $day  = $config_ref->{subvols}{$subvol}{monthly_day};
              $cron_scheduler->add_entry(
                  "$min $hr $day * *",
                  sub { do_snapshot($config_ref, $subvol, 'monthly') }
              );
          }
      }
  }
  
  sub schedule_backups { # No test. Is not pure.
  
      # Schedule backups based off user configuration by adding
      # them to $cron_scheduler object (see Schedule::Cron module).
  
      my $config_ref     = shift // get_logger->logconfess(missing_arg());
      my $cron_scheduler = shift // get_logger->logconfess(missing_arg());
  
      foreach my $backup (all_backups($config_ref)) {
  
          my $timeframe = $config_ref->{backups}{$backup}{timeframe};
  
          if ($timeframe eq '5minute') {
              $cron_scheduler->add_entry(
                  "*/5 * * * *",
                  sub { do_backup($config_ref, $backup) }
              );
          }
  
          elsif ($timeframe eq 'hourly') {
              $cron_scheduler->add_entry(
                  "0 */1 * * *",
                  sub { do_backup($config_ref, $backup) }
              );
          }
  
          elsif ($timeframe eq 'daily') {
              my $time = $config_ref->{backups}{$backup}{daily_time};
              my $hr   = time_hour($time);
              my $min  = time_minute($time);
              $cron_scheduler->add_entry(
                  "$min $hr * * *",
                  sub { do_backup($config_ref, $backup) }
              );
          }
  
          elsif ($timeframe eq 'weekly') {
              my $time = $config_ref->{backups}{$backup}{weekly_time};
              my $hr   = time_hour($time);
              my $min  = time_minute($time);
              my $dow  = day_of_week_num($config_ref->{backups}{$backup}{weekly_day});
              $cron_scheduler->add_entry(
                  "$min $hr * * $dow",
                  sub { do_backup($config_ref, $backup) }
              );
          }
  
          elsif ($timeframe eq 'monthly') {
              my $time = $config_ref->{backups}{$backup}{monthly_time};
              my $hr   = time_hour($time);
              my $min  = time_minute($time);
              my $day  = $config_ref->{backups}{$backup}{monthly_day};
              $cron_scheduler->add_entry(
                  "$min $hr $day * *",
                  sub { do_backup($config_ref, $backup) }
              );
          }
  
          else {
              get_logger->logdie("yabsm: internal error: invalid timeframe '$timeframe'");
          }
      }
  }
  
  sub is_local_backup { # Has test. Is pure.
  
      # Return 1 iff $backup is the name of a defined local backup. A
      # local backup is a backup whos 'remote' field is set # to 'no'.
  
      my $config_ref = shift // get_logger->logconfess(missing_arg());
      my $backup     = shift // get_logger->logconfess(missing_arg());
  
      if (is_backup($config_ref, $backup)) {
          return $config_ref->{backups}{$backup}{remote} eq 'no';
      }
      else { return 0 }
  }
  
  sub new_ssh_connection { # No test. Is not pure.
  
      # Create and return a Net::OpenSSH connection object. Kill the
      # program if we cannot establish a connection to $remote host.
  
      my $remote_host = shift // get_logger->logconfess(missing_arg());
  
      my $ssh = Net::OpenSSH->new( $remote_host,
                                        , batch_mode => 1 # Don't try asking for password
                                        , timeout => 5    # Minutes
                                        , kill_ssh_on_timeout => 1
                                        );
  
      $ssh->error and
        get_logger->logdie("yabsm: error: could not establish ssh connection to '$remote_host': " . $ssh->error);
  
      return $ssh;
  }
  
  sub day_of_week_num { # Has test. Is pure.
  
      # Take day of week string ($dow) and return the cooresponding
      # number of the week. Cron considers monday the first day of
      # the week, and this function is used to generate cron
      # strings. Exit program if $dow is not a valid day of week.
  
      my $dow = shift // get_logger->logconfess(missing_arg());
  
      $dow = lc $dow;
  
      if    ($dow eq 'monday')    { return 1 }
      elsif ($dow eq 'tuesday')   { return 2 }
      elsif ($dow eq 'wednesday') { return 3 }
      elsif ($dow eq 'thursday')  { return 4 }
      elsif ($dow eq 'friday')    { return 5 }
      elsif ($dow eq 'saturday')  { return 6 }
      elsif ($dow eq 'sunday')    { return 7 }
      else {
          get_logger->logconfess("yabsm: internal error: no such day of week '$dow'");
      }
  }
  
  sub all_days_of_week { # No test. Is pure.
  
      # Return all the valid days of the week.
  
      return qw(monday tuesday wednesday thursday friday saturday sunday);
  }
  
  sub safe_system {
  
      # Like backticks but logconfess if $cmd
      # exits with non-zero status.
  
      my $cmd = shift // get_logger->logconfess(missing_arg());
  
      my $output = `$cmd`;
  
      0 == system($cmd) or get_logger->logconfess("yabsm: error: $!\n");
  
      return $output;
  }
  
  sub safe_system_ssh {
  
      # Like Net::OpenSSH::capture but log and die if $cmd exits with
      # a non-zero status.
  
      my $ssh  = shift // get_logger->logconfess(missing_arg());
      my $cmd  = shift // get_logger->logconfess(missing_arg());
      my %opts = (ref $_[0] eq 'HASH' ? %{shift()} : ());
  
      my $output = $ssh->capture({%opts}, $cmd);
  
      unless (0 == $?) {
          get_logger->logdie( 'yabsm: error: SSH command sent to '
                            . $ssh->get_host
                            . " exited with status $? and outputted - "
                            . $output
                            );
      }
  
      return $output
  }
  
  sub make_path_safe {
  
      # Wrapper around File::Path::make_path() that logdies if the path
      # cannot be created.
  
      my $path = shift // get_logger->logconfess(missing_arg());
  
      -d $path        and return 1;
      make_path $path and return 1;
  
      get_logger->logdie("yabsm: error: $!\n");
  }
  
  sub missing_arg {
      return 'yabsm: internal error: subroutine missing a required arg';
  }
  
  1;
YABSM_BASE

$fatpacked{"Yabsm/Commands/CheckConfig.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YABSM_COMMANDS_CHECKCONFIG';
  #  Author:  Nicholas Hubbard
  #  WWW:     https://github.com/NicholasBHubbard/yabsm
  #  License: MIT
  
  #  Check if a config file is a valid yabsmrc file. If no config file
  #  argument is passed then check /etc/yabsmrc. If the config is
  #  erroneous print all errors to stderr and exit with nonzero status.
  #  Else print 'all good' to stdout.
  
  package Yabsm::Commands::CheckConfig;
  
  use strict;
  use warnings;
  use v5.16.3;
  
  # located using lib::relative in yabsm.pl
  use Yabsm::Config;
  
  sub die_usage {
      die "usage: yabsm check-config <?FILE>\n";
  }
  
  sub main {
  
      my $file = shift // '/etc/yabsmd.conf';
  
      die_usage() if @_;
  
      # read_config() will kill the program with error
      # messages if the config is erroneous.
      Yabsm::Config::read_config( $file );
  
      say 'all good';
  
      return;
  }
  
  1;
YABSM_COMMANDS_CHECKCONFIG

$fatpacked{"Yabsm/Commands/Find.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YABSM_COMMANDS_FIND';
  #  Author:  Nicholas Hubbard
  #  WWW:     https://github.com/NicholasBHubbard/yabsm
  #  License: MIT
  
  #  Find one or more snapshots of a subvol or backup by applying a query.
  #  See the yabsm manual for a detailed explanation on queries.
  
  package Yabsm::Commands::Find;
  
  use strict;
  use warnings;
  use v5.16.3;
  
  # located using lib::relative in yabsm.pl
  use Yabsm::Base;
  use Yabsm::Config;
  
  sub die_usage {
      die "usage: yabsm find <SUBVOL> <QUERY>\n";
  }
  
  sub main {
  
      my $subject = shift // die_usage();
      my $query   = shift // die_usage();
  
      die_usage() if @_;
  
      my $config_ref = Yabsm::Config::read_config();
  
      if (not Yabsm::Base::is_subject($config_ref, $subject)) {
  	die "yabsm: error: '$subject' is not a defined subvol or backup\n";
      }
  
      if (not Yabsm::Base::is_valid_query($query)) {
  	die "yabsm: error: '$query' is not a valid query\n"
      }
  
      my @snapshots = Yabsm::Base::answer_query($config_ref, $subject, $query);
  
      say for @snapshots;
  
      return;
  }
  
  1;
YABSM_COMMANDS_FIND

$fatpacked{"Yabsm/Commands/PrintBackups.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YABSM_COMMANDS_PRINTBACKUPS';
  #  Author:  Nicholas Hubbard
  #  WWW:     https://github.com/NicholasBHubbard/yabsm
  #  License: MIT
  
  #  Print the names of all user defined backups separated by newlines.
  
  package Yabsm::Commands::PrintBackups;
  
  use strict;
  use warnings;
  use v5.16.3;
  
  # located using lib::relative in yabsm.pl
  use Yabsm::Base;
  use Yabsm::Config;
  
  sub die_usage {
      die "usage: yabsm print-backups\n";
  }
  
  sub main {
  
      die_usage() if @_;
  
      my $config_ref = Yabsm::Config::read_config();
  
      my @all_backups = Yabsm::Base::all_backups($config_ref);
  
      say for @all_backups;
  
      return;
  }
  
  1;
YABSM_COMMANDS_PRINTBACKUPS

$fatpacked{"Yabsm/Commands/PrintSubvols.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YABSM_COMMANDS_PRINTSUBVOLS';
  #  Author:  Nicholas Hubbard
  #  WWW:     https://github.com/NicholasBHubbard/yabsm
  #  License: MIT
  
  #  Print the names of all user defined subvols separated by newlines.
  
  package Yabsm::Commands::PrintSubvols;
  
  use strict;
  use warnings;
  use v5.16.3;
  
  # located using lib::relative in yabsm.pl
  use Yabsm::Base;
  use Yabsm::Config;
  
  sub die_usage {
      die "usage: yabsm print-subvols\n";
  }
  
  sub main {
  
      die_usage() if @_;
  
      my $config_ref = Yabsm::Config::read_config();
  
      my @all_subvols = Yabsm::Base::all_subvols($config_ref);
  
      say for @all_subvols;
  
      return;
  }
  
  1;
YABSM_COMMANDS_PRINTSUBVOLS

$fatpacked{"Yabsm/Commands/TestRemoteBackupConfig.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YABSM_COMMANDS_TESTREMOTEBACKUPCONFIG';
  #  Author:  Nicholas Hubbard
  #  WWW:     https://github.com/NicholasBHubbard/yabsm
  #  License: MIT
  #
  #  A valid remote backup config is setup so the root user can connect
  #  to the remote host and run btrfs with sudo without having to enter
  #  any passwords.
  
  package Yabsm::Commands::TestRemoteBackupConfig;
  
  use strict;
  use warnings;
  use v5.16.3;
  
  # located using lib::relative in yabsm.pl
  use Yabsm::Base;
  use Yabsm::Config;
  
  sub die_usage {
      die "usage: yabsm test-remote-backup <BACKUP>\n";
  }
  
  sub main {
  
      die "yabsm: error: permission denied\n" if $<;
  
      my $backup = shift // die_usage();
  
      die_usage() if @_;
  
      my $config_ref = Yabsm::Config::read_config();
  
      if (not Yabsm::Base::is_backup($config_ref, $backup)) {
  	die "yabsm: error: no such defined backup '$backup'\n";
      }
  
      if (Yabsm::Base::is_local_backup($config_ref, $backup)) {
  	die "yabsm: error: backup '$backup' is a local backup\n";
      }
  
      my $host = $config_ref->{backups}{$backup}{host};
  
      # new_ssh_connection() will kill the program if a passwordless
      # connection cannot be established.
      my $ssh = Yabsm::Base::new_ssh_connection( $host );
  
      # make sure user can use btrfs with non-interactive sudo
      if (my $out = $ssh->capture('sudo -n btrfs --help 2>&1 1>/dev/null')) {
          chomp $out;
          die "$out\n";
      }
  
      # make sure user has read/write permissions on the remote backup_dir
      my $backup_dir = $config_ref->{backups}{$backup}{backup_dir};
  
      my $backup_dir_exists =
        "if ! [ -d $backup_dir ]; then "
      . qq(echo -n "yabsm: error: no such directory '$backup_dir' at host '$host'"; fi);
  
      if (my $out = $ssh->capture( $backup_dir_exists )) {
          die "$out\n";
      }
  
      say 'all good';
  
      return;
  }
  
  1;
YABSM_COMMANDS_TESTREMOTEBACKUPCONFIG

$fatpacked{"Yabsm/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YABSM_CONFIG';
  #  Author:  Nicholas Hubbard
  #  WWW:     https://github.com/NicholasBHubbard/yabsm
  #  License: MIT
  
  #  This module exists to provide the read_config() subroutine that is
  #  used to create the $config_ref variable that is passed around the
  #  rest of yabsm constantly. See t/Config.t for this modules testing.
  
  package Yabsm::Config;
  
  use strict;
  use warnings;
  use v5.16.3;
  
  use Exporter 'import';
  our @EXPORT_OK = qw( read_config );
  
  # located using lib::relative in yabsm.pl
  use lib::relative '..';
  use Yabsm::Base;
  
  use Carp;
  use Array::Utils 'array_minus';
  use Log::Log4perl 'get_logger';
  
  use Parser::MGC;
  use base 'Parser::MGC';
  
                   ####################################
                   #         REGEX LOOKUP TABLE       #
                   ####################################
  
  my %regex = ( path         => qr/\/[^#\s]*/
              , subject_name => qr/[a-zA-Z][-\w]*/
              , ssh_host     => qr/[-@.\/\w]+/
              , comment      => qr/#.*/
              , pos_int      => qr/[1-9]\d*/
              , month_day    => qr/3[01]|[12][0-9]|[1-9]/ # 1-31
              , time         => qr/(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]/
              );
  
                   ####################################
                   #          MAIN SUBROUTINE         #
                   ####################################
  
  sub read_config {
  
      my $file = shift // '/etc/yabsmd.conf';
  
      # see documentation of Parser::MGC to see what is going on here
      my $parser = __PACKAGE__->new( toplevel => 'p'
                                   , patterns => { comment => $regex{comment}
                                                 , ident   => qr/[-\w]+/
                                                 }
                                   );
  
      my $config_ref = $parser->from_file($file);
  
      my @errors = ();
  
      push @errors, $_ for missing_subvol_settings($config_ref);
      push @errors, $_ for missing_backup_settings($config_ref);
      push @errors, $_ for missing_misc_settings($config_ref);
  
      if (@errors) {
          die ((join "\n", @errors) . "\n");
      }
  
      return $config_ref;
  }
  
                   ####################################
                   #              PARSER              #
                   ####################################
  
  sub p {
  
      my $self = shift // get_logger->logconfess(Yabsm::Base::missing_arg());
  
      my %config;
  
      $self->sequence_of( sub {
          $self->commit;
          $self->any_of(
              sub {
                  $self->token_kw( 'subvol' );
                  $self->commit;
                  my $name = $self->maybe_expect( $regex{subject_name} );
                  $name // $self->fail('expected alphanumeric sequence starting with letter');
                  my $kvs  = $self->scope_of('{', 'subvol_def_p', '}');
                  $config{subvols}{$name} = $kvs;
              },
              sub {
                  $self->token_kw( 'backup' );
                  $self->commit;
                  my $name = $self->maybe_expect( $regex{subject_name} );
                  $name // $self->fail('expected alphanumeric sequence starting with letter');
                  my $kvs  = $self->scope_of('{', 'backup_def_p', '}');
                  $config{backups}{$name} = $kvs;
              },
              sub {
                  my $k = $self->token_kw( misc_keywords() );
                  $self->commit;
                  $self->maybe_expect( '=' ) // $self->fail("expected '='");
                  my $v;
                  # the only misc setting at this time is 'yabsm_dir'
                  if ($k eq 'yabsm_dir') {
                      $v = $self->maybe_expect( $regex{path} );
                      $v // $self->fail('expected file path');
                  }
                  else {
                      confess "internal error: no such misc setting '$k'";
                  }
                  $config{misc}{$k} = $v;
              },
              sub {
                  $self->commit;
                  $self->fail('could not parse subvol, backup or misc setting');
              }
          );
      });
  
      return \%config;
  }
  
  sub subvol_def_p {
  
      my $self = shift // get_logger->logconfess(Yabsm::Base::missing_arg());
  
      my %kvs; # return this
      my $k;
      my $v;
  
      $self->sequence_of( sub {
          $self->commit;
          $k = $self->token_kw( subvol_keywords() );
          $self->maybe_expect( '=' ) // $self->fail("expected '='");
          if ($k eq 'mountpoint') {
              $v = $self->maybe_expect( $regex{path} );
              $v // $self->fail('expected file path');
          }
          elsif ($k =~ /_want$/) {
              $v = $self->maybe( sub { $self->token_kw( 'yes', 'no' ) } );
              $v // $self->fail( q(expected 'yes' or 'no') );
          }
          elsif ($k =~ /_time$/) {
              $v = $self->maybe_expect( $regex{time} );
              $v // $self->fail(q(expected time in format 'hh:mm'));
          }
          elsif ($k =~ /_keep$/) {
              $v = $self->maybe_expect( $regex{pos_int} );
              $v // $self->fail('expected positive integer');
          }
          elsif ($k eq 'weekly_day') {
              $v = $self->token_kw( Yabsm::Base::all_days_of_week() );
          }
          elsif ($k eq 'monthly_day') {
              $v = $self->maybe_expect( $regex{month_day} );
              $v // $self->fail('expected integer in range 1-31');
          }
          else {
              confess "yabsm: internal error: no such subvol setting '$k'";
          }
  
          $kvs{ $k } = $v;
      });
  
      return \%kvs;
  }
  
  sub backup_def_p {
  
      my $self = shift // get_logger->logconfess(Yabsm::Base::missing_arg());
  
      my %kvs; # return this
      my $k;
      my $v;
  
      $self->sequence_of( sub {
          $self->commit;
          $k = $self->token_kw( backup_keywords() );
          $self->maybe_expect( '=' ) // $self->fail("expected '='");
  
          if ($k eq 'remote') {
              $v = $self->maybe( sub { $self->token_kw( 'yes', 'no' ) } );
              $v // $self->fail( q(expected 'yes' or 'no') );
          }
          elsif ($k eq 'timeframe') {
              $v = $self->token_kw( Yabsm::Base::all_timeframes() );
          }
          elsif ($k =~ /(daily|weekly|monthly)_time$/) {
              $v = $self->maybe_expect( $regex{time} );
              $v // $self->fail(q(expected time in format 'hh:mm'));
          }
          elsif ($k eq 'backup_dir') {
              $v = $self->maybe_expect( $regex{path} );
              $v // $self->fail('expected file path');
          }
          elsif ($k eq 'keep') {
              $v = $self->maybe_expect( $regex{pos_int} );
              $v // $self->fail('expected positive integer');
          }
          elsif ($k eq 'host') {
              $v = $self->maybe_expect( $regex{ssh_host} );
              $v // $self->fail('expected alphanumeric sequence starting with a letter');
          }
          elsif ($k eq 'subvol') {
              # We check that $v is a defined subvol later
              $v = $self->maybe_expect( $regex{subject_name} );
              $v // $self->fail('expected alphanumeric sequence starting with a letter');
          }
          elsif ($k eq 'weekly_day') {
              $v = $self->token_kw( Yabsm::Base::all_days_of_week() );
          }
          elsif ($k eq 'monthly_day') {
              $v = $self->maybe_expect( $regex{month_day} );
              $v // $self->fail('expected integer in range 1-31');
          }
          else {
              confess "yabsm: internal error: no such backup setting '$k'";
          }
  
          $kvs{ $k } = $v;
      });
  
      return \%kvs;
  }
  
                   ####################################
                   #       STATIC CONFIG ANALYSIS     #
                   ####################################
  
  sub missing_subvol_settings {
  
      my $config_ref = shift // get_logger->logconfess(Yabsm::Base::missing_arg());
  
      my @err_msgs = ();
  
      for my $subvol (Yabsm::Base::all_subvols($config_ref)) {
  
          # No matter what these settings are required. More required
          # settings will be added based on the values of these settings.
          my @req = qw(mountpoint 5minute_want hourly_want daily_want weekly_want monthly_want);
  
          my @def = keys %{ $config_ref->{subvols}{$subvol} };
  
          if (my @missing = array_minus(@req, @def)) {
              push @err_msgs, "yabsm: config error: subvol '$subvol' missing required setting '$_'" for @missing;
          }
  
          else { # the minimal required settings are all defined.
  
              for my $tframe (Yabsm::Base::subvol_timeframes($config_ref, $subvol)) {
                  if ($tframe eq '5minute') {
                      push @req, '5minute_keep';
                  }
                  elsif ($tframe eq 'hourly') {
                      push @req, 'hourly_keep';
                  }
                  elsif ($tframe eq 'daily') {
                      push @req, 'daily_time', 'daily_keep';
                  }
                  elsif ($tframe eq 'weekly') {
                      push @req, 'weekly_time', 'weekly_day', 'weekly_keep';
                  }
                  elsif ($tframe eq 'monthly') {
                      push @req, 'monthly_time', 'monthly_day', 'monthly_keep';
                  }
                  else {
                      confess "yabsm: internal error: no such timeframe '$tframe'";
                  }
              }
  
              my @def = keys %{ $config_ref->{subvols}{$subvol} };
  
              if (my @missing = array_minus(@req, @def)) {
                  push @err_msgs, "error: subvol '$subvol' missing required setting '$_'" for @missing;
              }
          }
      }
  
      return wantarray ? @err_msgs : \@err_msgs;
  }
  
  sub missing_backup_settings {
  
      my $config_ref = shift // get_logger->logconfess(Yabsm::Base::missing_arg());
  
      my @err_msgs = ();
  
      for my $backup (Yabsm::Base::all_backups($config_ref)) {
  
          # base required settings
          my @req = qw(remote subvol backup_dir timeframe keep);
  
          my @def = keys %{ $config_ref->{backups}{$backup} };
  
          if (my @missing = array_minus(@req, @def)) {
              push @err_msgs, "yabsm: config error: backup '$backup' missing required setting '$_'" for @missing;
          }
  
          else { # the base required settings are defined
  
              my $subvol = $config_ref->{backups}{$backup}{subvol};
              my $remote = $config_ref->{backups}{$backup}{remote};
              my $tframe = $config_ref->{backups}{$backup}{timeframe};
  
              if (not grep { $subvol eq $_ } Yabsm::Base::all_subvols($config_ref)) {
                  push @err_msgs, "yabsm: config error: backup '$backup' backing up undefined subvol '$subvol'";
              }
  
              if ($remote eq 'yes') {
                  push @req, 'host';
              }
  
              if ($tframe eq 'daily') {
                  push @req, 'daily_time';
              }
              elsif ($tframe eq 'weekly') {
                  push @req, 'weekly_time', 'weekly_day';
              }
              elsif ($tframe eq 'monthly') {
                  push @req, 'monthly_time', 'monthly_day';
              }
  
              if (my @missing = array_minus(@req, @def)) {
                  push @err_msgs, "yabsm: config error: backup '$backup' missing required setting '$_'" for @missing;
              }
          }
      }
  
      return wantarray ? @err_msgs : \@err_msgs;
  }
  
  sub missing_misc_settings {
  
      my $config_ref = shift // get_logger->logconfess(Yabsm::Base::missing_arg());
  
      my @err_msgs = ();
  
      # for now all misc settings are required
      my @req = misc_keywords();
  
      my @def = keys %{ $config_ref->{misc} };
  
      my @missing = array_minus(@req, @def);
  
      push @err_msgs, "yabsm: config error: missing misc setting '$_'" for @missing;
  
      return wantarray ? @err_msgs : \@err_msgs;
  }
  
                   ####################################
                   #              KEYWORDS            #
                   ####################################
  
  sub subvol_keywords {
      return qw(mountpoint 5minute_want 5minute_keep hourly_want hourly_keep daily_want daily_time daily_keep weekly_want weekly_time weekly_day weekly_keep monthly_want monthly_time monthly_day monthly_keep);
  }
  
  sub backup_keywords {
      return qw(subvol remote host keep backup_dir timeframe daily_time weekly_time monthly_time weekly_day monthly_day);
  }
  
  sub misc_keywords {
      # This is set up so in the future it is easy to add
      # new settings as misc settings.
      return qw(yabsm_dir);
  }
  
  1;
YABSM_CONFIG

$fatpacked{"lib/relative.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIB_RELATIVE';
  package lib::relative;
  
  use strict;
  use warnings;
  use Cwd ();
  use File::Basename ();
  use File::Spec ();
  use lib ();
  
  our $VERSION = '1.000';
  
  sub import {
    my ($class, @paths) = @_;
    my $file = (caller)[1];
    my $dir = -e $file ? File::Basename::dirname(Cwd::abs_path $file) : Cwd::getcwd;
    lib->import(map { File::Spec->file_name_is_absolute($_) ? $_ : File::Spec->catdir($dir, $_) } @paths);
  }
  
  1;
  
  =head1 NAME
  
  lib::relative - Add paths relative to the current file to @INC
  
  =head1 SYNOPSIS
  
    # Path is relative to this file, not current working directory
    use lib::relative 'path/to/lib';
    use lib::relative '../../lib';
    
    # Add two lib paths, as in lib.pm
    use lib::relative 'foo', 'bar';
    
    # Absolute paths are passed through unchanged
    use lib::relative 'foo/baz', '/path/to/lib';
    
    # Equivalent code using core modules
    use Cwd ();
    use File::Basename ();
    use File::Spec ();
    use lib File::Spec->catdir(File::Basename::dirname(Cwd::abs_path __FILE__), 'path/to/lib');
  
  =head1 DESCRIPTION
  
  Adding a path to L<@INC|perlvar/"@INC"> to load modules from a local directory
  may seem simple, but has a few common pitfalls to be aware of. Directly adding
  a relative path to C<@INC> means that any later code that changes the current
  working directory will change where modules are loaded from. This applies to
  the C<.> path that used to be in C<@INC> by default until perl 5.26.0, or a
  relative path added in code like C<use lib 'path/to/lib'>, and may be a
  vulnerability if such a location is not supposed to be writable. Additionally,
  the commonly used L<FindBin> module relies on interpreter state and the path to
  the original script invoked by the perl interpreter, sometimes requiring
  workarounds in uncommon cases like generated or embedded code. This module
  proposes a more straightforward method: take a path relative to the
  L<current file|perldata/"Special Literals">, absolutize it, and add it to
  C<@INC>.
  
  If this module is already available to be loaded, it can be used as with
  L<lib>.pm, passing relative paths, which will be absolutized relative to the
  current file then passed on to L<lib>. Multiple arguments will be separately
  absolutized, and absolute paths will be passed on unchanged.
  
  For cases where this module cannot be loaded beforehand, the last section of
  the L</"SYNOPSIS"> can be copy-pasted into a file to perform the same task.
  
  =head1 CAVEATS
  
  Due to C<__FILE__> possibly being a path relative to the current working
  directory, be sure to use C<lib::relative> or the equivalent code from
  L</"SYNOPSIS"> as early as possible in the file. If a C<chdir> occurs before
  this code, it will add the incorrect directory path.
  
  All file paths are expected to be in a format appropriate to the current
  operating system, e.g. C<..\\foo\\bar> on Windows. L<File::Spec/"catdir"> can
  be used to form directory paths portably.
  
  =head1 BUGS
  
  Report any issues on the public bugtracker.
  
  =head1 AUTHOR
  
  Dan Book <dbook@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2017 by Dan Book.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =head1 SEE ALSO
  
  L<lib>, L<FindBin>, L<Dir::Self>
LIB_RELATIVE

$fatpacked{"x86_64-linux/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce reductions sum sum0
    sample shuffle uniq uniqint uniqnum uniqstr zip zip_longest zip_shortest mesh mesh_longest mesh_shortest
    head tail pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst
  );
  our $VERSION    = "1.62";
  our $XS_VERSION = $VERSION;
  $VERSION =~ tr/_//d;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  # Used by shuffle()
  our $RAND;
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  # For objects returned by pairs()
  sub List::Util::_Pair::key   { shift->[0] }
  sub List::Util::_Pair::value { shift->[1] }
  sub List::Util::_Pair::TO_JSON { [ @{+shift} ] }
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(
        reduce any all none notall first reductions
  
        max maxstr min minstr product sum sum0
  
        pairs unpairs pairkeys pairvalues pairfirst pairgrep pairmap
  
        shuffle uniq uniqint uniqnum uniqstr zip mesh
      );
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all apply a given block of code to a list of
  values.
  
  =cut
  
  =head2 reduce
  
      $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The above example code blocks also suggest how to use C<reduce> to build a
  more efficient combined version of one of these basic functions and a C<map>
  block. For example, to find the total length of all the strings in a list,
  we could use
  
      $total = sum map { length } @strings;
  
  However, this produces a list of temporary integer values as long as the
  original list of strings, only to reduce it down to a single value again. We
  can compute the same result more efficiently by using C<reduce> with a code
  block that accumulates lengths by writing this instead as:
  
      $total = reduce { $a + length $b } 0, @strings
  
  The other scalar-returning list reduction functions are all specialisations of
  this generic idea.
  
  =head2 reductions
  
      @results = reductions { BLOCK } @list
  
  I<Since version 1.54.>
  
  Similar to C<reduce> except that it also returns the intermediate values along
  with the final result. As before, C<$a> is set to the first element of the
  given list, and the C<BLOCK> is then called once for remaining item in the
  list set into C<$b>, with the result being captured for return as well as
  becoming the new value for C<$a>.
  
  The returned list will begin with the initial value for C<$a>, followed by
  each return value from the block in order. The final value of the result will
  be identical to what the C<reduce> function would have returned given the same
  block and list.
  
      reduce     { "$a-$b" }  "a".."d"    # "a-b-c-d"
      reductions { "$a-$b" }  "a".."d"    # "a", "a-b", "a-b-c", "a-b-c-d"
  
  =head2 any
  
      my $bool = any { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 all
  
      my $bool = all { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any>, except that it requires all elements of the C<@list> to
  make the C<BLOCK> return true. If any element returns false, then it returns
  false. If the C<BLOCK> never returns false or the C<@list> was empty then it
  returns true.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 none
  
  =head2 notall
  
      my $bool = none { BLOCK } @list;
  
      my $bool = notall { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any> and L</all>, but with the return sense inverted. C<none>
  returns true only if no value in the C<@list> causes the C<BLOCK> to return
  true, and C<notall> returns true only if not all of the values do.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 first
  
      my $val = first { BLOCK } @list;
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 max
  
      my $num = max @list;
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 maxstr
  
      my $str = maxstr @list;
  
  Similar to L</max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 min
  
      my $num = min @list;
  
  Similar to L</max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 minstr
  
      my $str = minstr @list;
  
  Similar to L</min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 product
  
      my $num = product @list;
  
  I<Since version 1.35.>
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 sum
  
      my $num_or_undef = sum @list;
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 sum0
  
      my $num = sum0 @list;
  
  I<Since version 1.26.>
  
  Similar to L</sum>, except this returns 0 when given an empty list, rather
  than C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  B<NOTE>: At the time of writing, the following C<pair*> functions that take a
  block do not modify the value of C<$_> within the block, and instead operate
  using the C<$a> and C<$b> globals instead. This has turned out to be a poor
  design, as it precludes the ability to provide a C<pairsort> function. Better
  would be to pass pair-like objects as 2-element array references in C<$_>, in
  a style similar to the return value of the C<pairs> function. At some future
  version this behaviour may be added.
  
  Until then, users are alerted B<NOT> to rely on the value of C<$_> remaining
  unmodified between the outside and the inside of the control block. In
  particular, the following example is B<UNSAFE>:
  
   my @kvlist = ...
  
   foreach (qw( some keys here )) {
      my @items = pairgrep { $a eq $_ } @kvlist;
      ...
   }
  
  Instead, write this using a lexical variable:
  
   foreach my $key (qw( some keys here )) {
      my @items = pairgrep { $a eq $key } @kvlist;
      ...
   }
  
  =cut
  
  =head2 pairs
  
      my @pairs = pairs @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of C<ARRAY> references, each containing two items from the
  given list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach my $pair ( pairs @kvlist ) {
         my ( $key, $value ) = @$pair;
         ...
      }
  
  Since version C<1.39> these C<ARRAY> references are blessed objects,
  recognising the two methods C<key> and C<value>. The following code is
  equivalent:
  
      foreach my $pair ( pairs @kvlist ) {
         my $key   = $pair->key;
         my $value = $pair->value;
         ...
      }
  
  Since version C<1.51> they also have a C<TO_JSON> method to ease
  serialisation.
  
  =head2 unpairs
  
      my @kvlist = unpairs @pairs
  
  I<Since version 1.42.>
  
  The inverse function to C<pairs>; this function takes a list of C<ARRAY>
  references containing two elements each, and returns a flattened list of the
  two values from each of the pairs, in order. This is notionally equivalent to
  
      my @kvlist = map { @{$_}[0,1] } @pairs
  
  except that it is implemented more efficiently internally. Specifically, for
  any input item it will extract exactly two values for the output list; using
  C<undef> if the input array references are short.
  
  Between C<pairs> and C<unpairs>, a higher-order list function can be used to
  operate on the pairs as single scalars; such as the following near-equivalents
  of the other C<pair*> higher-order functions:
  
      @kvlist = unpairs grep { FUNC } pairs @kvlist
      # Like pairgrep, but takes $_ instead of $a and $b
  
      @kvlist = unpairs map { FUNC } pairs @kvlist
      # Like pairmap, but takes $_ instead of $a and $b
  
  Note however that these versions will not behave as nicely in scalar context.
  
  Finally, this technique can be used to implement a sort on a keyvalue pair
  list; e.g.:
  
      @kvlist = unpairs sort { $a->key cmp $b->key } pairs @kvlist
  
  =head2 pairkeys
  
      my @keys = pairkeys @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 pairvalues
  
      my @values = pairvalues @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =head2 pairgrep
  
      my @kvlist = pairgrep { BLOCK } @kvlist;
  
      my $count = pairgrep { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairfirst
  
      my ( $key, $val ) = pairfirst { BLOCK } @kvlist;
  
      my $found = pairfirst { BLOCK } @kvlist;
  
  I<Since version 1.30.>
  
  Similar to the L</first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairmap
  
      my @list = pairmap { BLOCK } @kvlist;
  
      my $count = pairmap { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  See L</KNOWN BUGS> for a known-bug with C<pairmap>, and a workaround.
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 shuffle
  
      my @values = shuffle @values;
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  This function is affected by the C<$RAND> variable.
  
  =cut
  
  =head2 sample
  
      my @items = sample $count, @values
  
  I<Since version 1.54.>
  
  Randomly select the given number of elements from the input list. Any given
  position in the input list will be selected at most once.
  
  If there are fewer than C<$count> items in the list then the function will
  return once all of them have been randomly selected; effectively the function
  behaves similarly to L</shuffle>.
  
  This function is affected by the C<$RAND> variable.
  
  =head2 uniq
  
      my @subset = uniq @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  DWIM-ish string equality or C<undef> test. Preserves the order of unique
  elements, and retains the first value of any duplicate set.
  
      my $count = uniq @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  The C<undef> value is treated by this function as distinct from the empty
  string, and no warning will be produced. It is left as-is in the returned
  list. Subsequent C<undef> values are still considered identical to the first,
  and will be removed.
  
  =head2 uniqint
  
      my @subset = uniqint @values
  
  I<Since version 1.55.>
  
  Filters a list of values to remove subsequent duplicates, as judged by an
  integer numerical equality test. Preserves the order of unique elements, and
  retains the first value of any duplicate set. Values in the returned list will
  be coerced into integers.
  
      my $count = uniqint @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqint> are well-behaved as integers.
  
  =head2 uniqnum
  
      my @subset = uniqnum @values
  
  I<Since version 1.44.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  numerical equality test. Preserves the order of unique elements, and retains
  the first value of any duplicate set.
  
      my $count = uniqnum @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqnum> are well-behaved as numbers.
  
  Note also that multiple IEEE C<NaN> values are treated as duplicates of
  each other, regardless of any differences in their payloads, and despite
  the fact that C<< 0+'NaN' == 0+'NaN' >> yields false.
  
  =head2 uniqstr
  
      my @subset = uniqstr @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  string equality test. Preserves the order of unique elements, and retains the
  first value of any duplicate set.
  
      my $count = uniqstr @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other string operations treat it; it
  compares equal to the empty string but additionally produces a warning if such
  warnings are enabled (C<use warnings 'uninitialized';>). In addition, an
  C<undef> in the returned list is coerced into an empty string, so that the
  entire list of values returned by C<uniqstr> are well-behaved as strings.
  
  =cut
  
  =head2 head
  
      my @values = head $size, @list;
  
  I<Since version 1.50.>
  
  Returns the first C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the last C<$size> elements from C<@list>.
  
      @result = head 2, qw( foo bar baz );
      # foo, bar
  
      @result = head -2, qw( foo bar baz );
      # foo
  
  =head2 tail
  
      my @values = tail $size, @list;
  
  I<Since version 1.50.>
  
  Returns the last C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the first C<$size> elements from C<@list>.
  
      @result = tail 2, qw( foo bar baz );
      # bar, baz
  
      @result = tail -2, qw( foo bar baz );
      # baz
  
  =head2 zip
  
      my @result = zip [1..3], ['a'..'c'];
      # [1, 'a'], [2, 'b'], [3, 'c']
  
  I<Since version 1.56.>
  
  Returns a list of array references, composed of elements from the given list
  of array references. Each array in the returned list is composed of elements
  at that corresponding position from each of the given input arrays. If any
  input arrays run out of elements before others, then C<undef> will be inserted
  into the result to fill in the gaps.
  
  The C<zip> function is particularly handy for iterating over multiple arrays
  at the same time with a C<foreach> loop, taking one element from each:
  
      foreach ( zip \@xs, \@ys, \@zs ) {
          my ($x, $y, $z) = @$_;
          ...
      }
  
  B<NOTE> to users of L<List::MoreUtils>: This function does not behave the same
  as C<List::MoreUtils::zip>, but is actually a non-prototyped equivalent to
  C<List::MoreUtils::zip_unflatten>. This function does not apply a prototype,
  so make sure to invoke it with references to arrays.
  
  For a function similar to the C<zip> function from C<List::MoreUtils>, see
  L<mesh>.
  
      my @result = zip_shortest ...
  
  A variation of the function that differs in how it behaves when given input
  arrays of differing lengths. C<zip_shortest> will stop as soon as any one of
  the input arrays run out of elements, discarding any remaining unused values
  from the others.
  
      my @result = zip_longest ...
  
  C<zip_longest> is an alias to the C<zip> function, provided simply to be
  explicit about that behaviour as compared to C<zip_shortest>.
  
  =head2 mesh
  
      my @result = mesh [1..3], ['a'..'c'];
      # (1, 'a', 2, 'b', 3, 'c')
  
  I<Since version 1.56.>
  
  Returns a list of items collected from elements of the given list of array
  references. Each section of items in the returned list is composed of elements
  at the corresponding position from each of the given input arrays. If any
  input arrays run out of elements before others, then C<undef> will be inserted
  into the result to fill in the gaps.
  
  This is similar to L<zip>, except that all of the ranges in the result are
  returned in one long flattened list, instead of being bundled into separate
  arrays.
  
  Because it returns a flat list of items, the C<mesh> function is particularly
  useful for building a hash out of two separate arrays of keys and values:
  
      my %hash = mesh \@keys, \@values;
  
      my $href = { mesh \@keys, \@values };
  
  B<NOTE> to users of L<List::MoreUtils>: This function is a non-prototyped
  equivalent to C<List::MoreUtils::mesh> or C<List::MoreUtils::zip> (themselves
  aliases of each other). This function does not apply a prototype, so make sure
  to invoke it with references to arrays.
  
      my @result = mesh_shortest ...
  
      my @result = mesh_longest ...
  
  These variations are similar to those of L<zip>, in that they differ in
  behaviour when one of the input lists runs out of elements before the others.
  
  =head1 CONFIGURATION VARIABLES
  
  =head2 $RAND
  
      local $List::Util::RAND = sub { ... };
  
  I<Since version 1.54.>
  
  This package variable is used by code which needs to generate random numbers
  (such as the L</shuffle> and L</sample> functions). If set to a CODE reference
  it provides an alternative to perl's builtin C<rand()> function. When a new
  random number is needed this function will be invoked with no arguments and is
  expected to return a floating-point value, of which only the fractional part
  will be used.
  
  =head1 KNOWN BUGS
  
  =head2 RT #95409
  
  L<https://rt.cpan.org/Ticket/Display.html?id=95409>
  
  If the block of code given to L</pairmap> contains lexical variables that are
  captured by a returned closure, and the closure is executed after the block
  has been re-used for the next iteration, these lexicals will not see the
  correct values. For example:
  
   my @subs = pairmap {
      my $var = "$a is $b";
      sub { print "$var\n" };
   } one => 1, two => 2, three => 3;
  
   $_->() for @subs;
  
  Will incorrectly print
  
   three is 3
   three is 3
   three is 3
  
  This is due to the performance optimisation of using C<MULTICALL> for the code
  block, which means that fresh SVs do not get allocated for each call to the
  block. Instead, the same SV is re-assigned for each iteration, and all the
  closures will share the value seen on the final iteration.
  
  To work around this bug, surround the code with a second set of braces. This
  creates an inner block that defeats the C<MULTICALL> logic, and does get fresh
  SVs allocated each time:
  
   my @subs = pairmap {
      {
         my $var = "$a is $b";
         sub { print "$var\n"; }
      }
   } one => 1, two => 2, three => 3;
  
  This bug only affects closures that are generated by the block but used
  afterwards. Lexical variables that are only used during the lifetime of the
  block's execution will take their individual values for each invocation, as
  normal.
  
  =head2 uniqnum() on oversized bignums
  
  Due to the way that C<uniqnum()> compares numbers, it cannot distinguish
  differences between bignums (especially bigints) that are too large to fit in
  the native platform types. For example,
  
   my $x = Math::BigInt->new( "1" x 100 );
   my $y = $x + 1;
  
   say for uniqnum( $x, $y );
  
  Will print just the value of C<$x>, believing that C<$y> is a numerically-
  equivalent value. This bug does not affect C<uniqstr()>, which will correctly
  observe that the two values stringify to different strings.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
  
  1;
X86_64-LINUX_LIST_UTIL

$fatpacked{"x86_64-linux/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use warnings;
  use List::Util;
  
  our $VERSION = "1.62";       # FIXUP
  $VERSION =~ tr/_//d;         # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_LIST_UTIL_XS

$fatpacked{"x86_64-linux/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype
    tainted
  );
  our $VERSION    = "1.62";
  $VERSION =~ tr/_//d;
  
  require List::Util; # List::Util loads the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  # populating @EXPORT_FAIL is done in the XS code
  sub export_fail {
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in this version of perl");
    }
  
    @_;
  }
  
  # set_prototype has been moved to Sub::Util with a different interface
  sub set_prototype(&$)
  {
    my ( $code, $proto ) = @_;
    return Sub::Util::set_prototype( $proto, $code );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size would be so small that 
  being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =head2 Core Perl C<builtin> Functions
  
  Many functions in this module have served as the inspiration for a new
  experimental facility in recent versions of Perl. From various development
  versions, starting at 5.35.7, equivalent functions to many of these utilities
  are available in the C<builtin::> package.
  
      use Scalar::Util qw(blessed);
  
      $class = blessed $obj;
  
      $class = builtin::blessed $obj;  # equivalent
  
  For more information, see the documentation on L<builtin>.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 blessed
  
      my $pkg = blessed( $ref );
  
  If C<$ref> is a blessed reference, the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  I<Since Perl version 5.35.7> an equivalent function is available as
  C<builtin::blessed>.
  
  =head2 refaddr
  
      my $addr = refaddr( $ref );
  
  If C<$ref> is reference, the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  I<Since Perl version 5.35.7> an equivalent function is available as
  C<builtin::refaddr>.
  
  =head2 reftype
  
      my $type = reftype( $ref );
  
  If C<$ref> is a reference, the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  Note that for internal reasons, all precompiled regexps (C<qr/.../>) are
  blessed references; thus C<ref()> returns the package name string C<"Regexp">
  on these but C<reftype()> will return the underlying C structure type of
  C<"REGEXP"> in all capitals.
  
  I<Since Perl version 5.35.7> an equivalent function is available as
  C<builtin::refaddr>.
  
  =head2 weaken
  
      weaken( $ref );
  
  The lvalue C<$ref> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also, when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  I<Since Perl version 5.35.7> an equivalent function is available as
  C<builtin::weaken>.
  
  =head2 unweaken
  
      unweaken( $ref );
  
  I<Since version 1.36.>
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  L</weaken>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  I<Since Perl version 5.35.7> an equivalent function is available as
  C<builtin::unweaken>.
  
  =head2 isweak
  
      my $weak = isweak( $ref );
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  I<Since Perl version 5.35.7> an equivalent function is available as
  C<builtin::isweak>.
  
  =head1 OTHER FUNCTIONS
  
  =head2 dualvar
  
      my $var = dualvar( $num, $string );
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 isdual
  
      my $dual = isdual( $var );
  
  I<Since version 1.26.>
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  standard operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  The C<$!> variable is commonly dual-valued, though it is also magical in other
  ways:
  
      $! = 1;
      $dual = isdual($!);                 # true
      print("$!\n");                      # "Operation not permitted"
  
  B<CAUTION>: This function is not as useful as it may seem. Dualvars are not a
  distinct concept in Perl, but a standard internal construct of all scalar
  values. Almost any value could be considered as a dualvar by this function
  through the course of normal operations.
  
  =head2 isvstring
  
      my $vstring = isvstring( $var );
  
  If C<$var> is a scalar which was coded as a vstring, the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 looks_like_number
  
      my $isnum = looks_like_number( $var );
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 openhandle
  
      my $fh = openhandle( $fh );
  
  Returns C<$fh> itself, if C<$fh> may be used as a filehandle and is open, or if
  it is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 readonly
  
      my $ro = readonly( $var );
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 set_prototype
  
      my $code = set_prototype( $code, $prototype );
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 tainted
  
      my $t = tainted( $var );
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Vstrings are not implemented in this version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  L</isvstring> you will need to use a newer release of perl.
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Additionally L</weaken> and L</isweak> which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  Copyright (C) 2014 cPanel Inc.  All rights reserved.
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_SCALAR_UTIL

$fatpacked{"x86_64-linux/Sub/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SUB_UTIL';
  # Copyright (c) 2014 Paul Evans <leonerd@leonerd.org.uk>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Sub::Util;
  
  use strict;
  use warnings;
  
  require Exporter;
  
  our @ISA = qw( Exporter );
  our @EXPORT_OK = qw(
    prototype set_prototype
    subname set_subname
  );
  
  our $VERSION    = "1.62";
  $VERSION =~ tr/_//d;
  
  require List::Util; # as it has the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  =head1 NAME
  
  Sub::Util - A selection of utility subroutines for subs and CODE references
  
  =head1 SYNOPSIS
  
      use Sub::Util qw( prototype set_prototype subname set_subname );
  
  =head1 DESCRIPTION
  
  C<Sub::Util> contains a selection of utility subroutines that are useful for
  operating on subs and CODE references.
  
  The rationale for inclusion in this module is that the function performs some
  work for which an XS implementation is essential because it cannot be
  implemented in Pure Perl, and which is sufficiently-widely used across CPAN
  that its popularity warrants inclusion in a core module, which this is.
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 prototype
  
      my $proto = prototype( $code )
  
  I<Since version 1.40.>
  
  Returns the prototype of the given C<$code> reference, if it has one, as a
  string. This is the same as the C<CORE::prototype> operator; it is included
  here simply for symmetry and completeness with the other functions.
  
  =cut
  
  sub prototype
  {
    my ( $code ) = @_;
    return CORE::prototype( $code );
  }
  
  =head2 set_prototype
  
      my $code = set_prototype $prototype, $code;
  
  I<Since version 1.40.>
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
  I<Caution>: This function takes arguments in a different order to the previous
  copy of the code from C<Scalar::Util>. This is to match the order of
  C<set_subname>, and other potential additions in this file. This order has
  been chosen as it allows a neat and simple chaining of other
  C<Sub::Util::set_*> functions as might become available, such as:
  
   my $code =
      set_subname   name_here =>
      set_prototype '&@'      =>
      set_attribute ':lvalue' =>
         sub { ...... };
  
  =cut
  
  =head2 subname
  
      my $name = subname( $code )
  
  I<Since version 1.40.>
  
  Returns the name of the given C<$code> reference, if it has one. Normal named
  subs will give a fully-qualified name consisting of the package and the
  localname separated by C<::>. Anonymous code references will give C<__ANON__>
  as the localname. If the package the code was compiled in has been deleted
  (e.g. using C<delete_package> from L<Symbol>), C<__ANON__> will be returned as
  the package name. If a name has been set using L</set_subname>, this name will be
  returned instead.
  
  This function was inspired by C<sub_fullname> from L<Sub::Identify>. The
  remaining functions that C<Sub::Identify> implements can easily be emulated
  using regexp operations, such as
  
   sub get_code_info { return (subname $_[0]) =~ m/^(.+)::(.*?)$/ }
   sub sub_name      { return (get_code_info $_[0])[0] }
   sub stash_name    { return (get_code_info $_[0])[1] }
  
  I<Users of Sub::Name beware>: This function is B<not> the same as
  C<Sub::Name::subname>; it returns the existing name of the sub rather than
  changing it. To set or change a name, see instead L</set_subname>.
  
  =cut
  
  =head2 set_subname
  
      my $code = set_subname $name, $code;
  
  I<Since version 1.40.>
  
  Sets the name of the function given by the C<$code> reference. Returns the
  C<$code> reference itself. If the C<$name> is unqualified, the package of the
  caller is used to qualify it.
  
  This is useful for applying names to anonymous CODE references so that stack
  traces and similar situations, to give a useful name rather than having the
  default of C<__ANON__>. Note that this name is only used for this situation;
  the C<set_subname> will not install it into the symbol table; you will have to
  do that yourself if required.
  
  However, since the name is not used by perl except as the return value of
  C<caller>, for stack traces or similar, there is no actual requirement that
  the name be syntactically valid as a perl function name. This could be used to
  attach extra information that could be useful in debugging stack traces.
  
  This function was copied from C<Sub::Name::subname> and renamed to the naming
  convention of this module.
  
  =cut
  
  =head1 AUTHOR
  
  The general structure of this module was written by Paul Evans
  <leonerd@leonerd.org.uk>.
  
  The XS implementation of L</set_subname> was copied from L<Sub::Name> by
  Matthijs van Duin <xmath@cpan.org>
  
  =cut
  
  1;
X86_64-LINUX_SUB_UTIL

$fatpacked{"x86_64-linux/Syntax/Keyword/Try.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SYNTAX_KEYWORD_TRY';
  #  You may distribute under the terms of either the GNU General Public License
  #  or the Artistic License (the same terms as Perl itself)
  #
  #  (C) Paul Evans, 2016-2022 -- leonerd@leonerd.org.uk
  
  package Syntax::Keyword::Try 0.27;
  
  use v5.14;
  use warnings;
  
  use Carp;
  
  require XSLoader;
  XSLoader::load( __PACKAGE__, our $VERSION );
  
  =head1 NAME
  
  C<Syntax::Keyword::Try> - a C<try/catch/finally> syntax for perl
  
  =head1 SYNOPSIS
  
     use Syntax::Keyword::Try;
  
     sub foo {
        try {
           attempt_a_thing();
           return "success";
        }
        catch ($e) {
           warn "It failed - $e";
           return "failure";
        }
     }
  
  =head1 DESCRIPTION
  
  This module provides a syntax plugin that implements exception-handling
  semantics in a form familiar to users of other languages, being built on a
  block labeled with the C<try> keyword, followed by at least one of a C<catch>
  or C<finally> block.
  
  As well as providing a handy syntax for this useful behaviour, this module
  also serves to contain a number of code examples for how to implement parser
  plugins and manipulate optrees to provide new syntax and behaviours for perl
  code.
  
  Syntax similar to this module has now been added to core perl, starting at
  version 5.34.0. If you are writing new code, it is suggested that you instead
  use the L<Feature::Compat::Try> module instead, as that will enable the core
  feature on those supported perl versions, falling back to
  C<Syntax::Keyword::Try> on older perls.
  
  =head1 Experimental Features
  
  Some of the features of this module are currently marked as experimental. They
  will provoke warnings in the C<experimental> category, unless silenced.
  
  You can silence this with C<no warnings 'experimental'> but then that will
  silence every experimental warning, which may hide others unintentionally. For
  a more fine-grained approach you can instead use the import line for this
  module to only silence this module's warnings selectively:
  
     use Syntax::Keyword::Try qw( try :experimental(typed) );
  
     use Syntax::Keyword::Try qw( try :experimental );  # all of the above
  
  Don't forget to import the main C<try> symbol itself, to activate the syntax.
  
  =cut
  
  =head1 KEYWORDS
  
  =head2 try
  
     try {
        STATEMENTS...
     }
     ...
  
  A C<try> statement provides the main body of code that will be invoked, and
  must be followed by either a C<catch> statement, a C<finally> statement, or
  both.
  
  Execution of the C<try> statement itself begins from the block given to the
  statement and continues until either it throws an exception, or completes
  successfully by reaching the end of the block. What will happen next depends
  on the presence of a C<catch> or C<finally> statement immediately following
  it.
  
  The body of a C<try {}> block may contain a C<return> expression. If executed,
  such an expression will cause the entire containing function to return with
  the value provided. This is different from a plain C<eval {}> block, in which
  circumstance only the C<eval> itself would return, not the entire function.
  
  The body of a C<try {}> block may contain loop control expressions (C<redo>,
  C<next>, C<last>) which will have their usual effect on any loops that the
  C<try {}> block is contained by.
  
  The parsing rules for the set of statements (the C<try> block and its
  associated C<catch> and C<finally>) are such that they are parsed as a self-
  contained statement. Because of this, there is no need to end with a
  terminating semicolon.
  
  Even though it parses as a statement and not an expression, a C<try> block can
  still yield a value if it appears as the final statement in its containing
  C<sub> or C<do> block. For example:
  
     my $result = do {
        try { attempt_func() }
        catch ($e) { "Fallback Value" }
     };
  
  Note (especially to users of L<Try::Tiny> and similar) that the C<try {}>
  block itself does not necessarily stop exceptions thrown inside it from
  propagating outside. It is the presence of a later C<catch {}> block which
  causes this to happen. A C<try> with only a C<finally> and no C<catch> will
  still propagate exceptions up to callers as normal.
  
  =head2 catch
  
     ...
     catch ($var) {
        STATEMENTS...
     }
  
  or
  
     ...
     catch {
        STATEMENTS...
     }
  
  A C<catch> statement provides a block of code to the preceding C<try>
  statement that will be invoked in the case that the main block of code throws
  an exception. Optionally a new lexical variable can be provided to store the
  exception in. If not provided, the C<catch> block can inspect the raised
  exception by looking in C<$@> instead.
  
  Presence of this C<catch> statement causes any exception thrown by the
  preceding C<try> block to be non-fatal to the surrounding code. If the
  C<catch> block wishes to optionally handle some exceptions but not others, it
  can re-raise it (or another exception) by calling C<die> in the usual manner.
  
  As with C<try>, the body of a C<catch {}> block may also contain a C<return>
  expression, which as before, has its usual meaning, causing the entire
  containing function to return with the given value. The body may also contain
  loop control expressions (C<redo>, C<next> or C<last>) which also have their
  usual effect.
  
  If a C<catch> statement is not given, then any exceptions raised by the C<try>
  block are raised to the caller in the usual way.
  
  =head2 catch (Typed)
  
     ...
     catch ($var isa Class) { ... }
  
     ...
     catch ($var =~ m/^Regexp match/) { ... }
  
  I<Experimental; since version 0.15.>
  
  Optionally, multiple catch statements can be provided, where each block is
  given a guarding condition, to control whether or not it will catch particular
  exception values. Use of this syntax will provoke an C<experimental> category
  warning on supporting perl versions, unless silenced by importing the
  C<:experimental(typed)> tag (see above).
  
  Two kinds of condition are supported:
  
  =over 4
  
  =item *
  
     catch ($var isa Class)
  
  The block is invoked only if the caught exception is a blessed object, and
  derives from the given package name.
  
  On Perl version 5.32 onwards, this condition test is implemented using the
  same op type that the core C<$var isa Class> syntax is provided by and works
  in exactly the same way.
  
  On older perl versions it is emulated by a compatibility function. Currently
  this function does not respect a C<< ->isa >> method overload on the exception
  instance. Usually this should not be a problem, as exception class types
  rarely provide such a method.
  
  =item *
  
     catch ($var =~ m/regexp/)
  
  The block is invoked only if the caught exception is a string that matches
  the given regexp.
  
  =back
  
  When an exception is caught, each condition is tested in the order they are
  written in, until a matching case is found. If such a case is found the
  corresponding block is invoked, and no further condition is tested. If no
  contional block matched and there is a default (unconditional) block at the
  end then that is invoked instead. If no such block exists, then the exception
  is propagated up to the calling scope.
  
  =head2 finally
  
     ...
     finally {
        STATEMENTS...
     }
  
  A C<finally> statement provides a block of code to the preceding C<try>
  statement (or C<try/catch> pair) which is executed afterwards, both in the
  case of a normal execution or a thrown exception. This code block may be used
  to provide whatever clean-up operations might be required by preceding code.
  
  Because it is executed during a stack cleanup operation, a C<finally {}> block
  may not cause the containing function to return, or to alter the return value
  of it. It also cannot see the containing function's C<@_> arguments array
  (though as it is block scoped within the function, it will continue to share
  any normal lexical variables declared up until that point). It is protected
  from disturbing the value of C<$@>. If the C<finally {}> block code throws an
  exception, this will be printed as a warning and discarded, leaving C<$@>
  containing the original exception, if one existed.
  
  =head1 OTHER MODULES
  
  There are already quite a number of modules on CPAN that provide a
  C<try/catch>-like syntax for Perl.
  
  =over 2
  
  =item *
  
  L<Try>
  
  =item *
  
  L<TryCatch>
  
  =item *
  
  L<Try::Tiny>
  
  =item *
  
  L<Syntax::Feature::Try>
  
  =back
  
  In addition, core perl itself gained a C<try/catch> syntax based on this
  module at version 5.34.0. It is available as C<use feature 'try'>.
  
  They are compared here, by feature:
  
  =head2 True syntax plugin
  
  Like L<Try> and L<Syntax::Feature::Try>, this module is implemented as a true
  syntax plugin, allowing it to provide new parsing rules not available to
  simple functions. Most notably here it means that the resulting combination
  does not need to end in a semicolon.
  
  The core C<feature 'try'> is also implemented as true native syntax in the
  perl parser.
  
  In comparison, L<Try::Tiny> is plain perl and provides its functionality using
  regular perl functions; as such its syntax requires the trailing semicolon.
  
  L<TryCatch> is a hybrid that uses L<Devel::Declare> to parse the syntax tree.
  
  =head2 C<@_> in a try or catch block
  
  Because the C<try> and C<catch> block code is contained in a true block rather
  than an entire anonymous subroutine, invoking it does not interfere with the
  C<@_> arguments array. Code inside these blocks can interact with the
  containing function's array as before.
  
  This feature is unique among these modules; none of the others listed have
  this ability.
  
  The core C<feature 'try'> also behaves in this manner.
  
  =head2 C<return> in a try or catch block
  
  Like L<TryCatch> and L<Syntax::Feature::Try>, the C<return> statement has its
  usual effect within a subroutine containing syntax provided by this module.
  Namely, it causes the containing C<sub> itself to return.
  
  It also behaves this way using the core C<feature 'try'>.
  
  In comparison, using L<Try> or L<Try::Tiny> mean that a C<return> statement
  will only exit from the C<try> block.
  
  =head2 C<next>/C<last>/C<redo> in a try or catch block
  
  The loop control keywords of C<next>, C<last> and C<redo> have their usual
  effect on dynamically contained loops.
  
  These also work fine when using the core C<feature 'try'>.
  
  L<Syntax::Feature::Try> documents that these do not work there. The other
  modules make no statement either way.
  
  =head2 Value Semantics
  
  Like L<Try> and L<Syntax::Feature::Try>, the syntax provided by this module
  only works as a syntax-level statement and not an expression. You cannot
  assign from the result of a C<try> block. A common workaround is to wrap
  the C<try/catch> statement inside a C<do> block, where its final expression
  can be captured and used as a value.
  
  The same C<do> block wrapping also works for the core C<feature 'try'>.
  
  In comparison, the behaviour implemented by L<Try::Tiny> can be used as a
  valued expression, such as assigned to a variable or returned to the caller of
  its containing function.
  
  =head2 C<try> without C<catch>
  
  Like L<Syntax::Feature::Try>, the syntax provided by this module allows a
  C<try> block to be followed by only a C<finally> block, with no C<catch>. In
  this case, exceptions thrown by code contained by the C<try> are not
  suppressed, instead they propagate as normal to callers. This matches the
  behaviour familiar to Java or C++ programmers.
  
  In comparison, the code provided by L<Try> and L<Try::Tiny> always suppress
  exception propagation even without an actual C<catch> block.
  
  The L<TryCatch> module does not allow a C<try> block not followed by C<catch>.
  
  The core C<feature 'try'> does not implement C<finally> at all, and also
  requires that every C<try> block be followed by a C<catch>.
  
  =head2 Typed C<catch>
  
  L<Try> and L<Try::Tiny> make no attempt to perform any kind of typed dispatch
  to distinguish kinds of exception caught by C<catch> blocks.
  
  Likewise the core C<feature 'try'> currently does not provide this ability,
  though it remains an area of ongoing design work.
  
  L<TryCatch> and L<Syntax::Feature::Try> both attempt to provide a kind of
  typed dispatch where different classes of exception are caught by different
  blocks of code, or propagated up entirely to callers.
  
  This module provides such an ability, via the currently-experimental
  C<catch (VAR cond...)> syntax.
  
  The design thoughts continue on the RT ticket
  L<https://rt.cpan.org/Ticket/Display.html?id=123918>.
  
  =cut
  
  sub import
  {
     my $class = shift;
     my $caller = caller;
  
     $class->import_into( $caller, @_ );
  }
  
  my @EXPERIMENTAL = qw( typed );
  
  sub import_into
  {
     my $class = shift;
     my ( $caller, @syms ) = @_;
  
     @syms or @syms = qw( try );
  
     my %syms = map { $_ => 1 } @syms;
     $^H{"Syntax::Keyword::Try/try"}++ if delete $syms{try};
  
     # Largely for Feature::Compat::Try's benefit
     $^H{"Syntax::Keyword::Try/no_finally"}++    if delete $syms{"-no_finally"};
     $^H{"Syntax::Keyword::Try/require_catch"}++ if delete $syms{"-require_catch"};
     $^H{"Syntax::Keyword::Try/require_var"}++   if delete $syms{"-require_var"};
  
     # stablised experiments
     delete $syms{":experimental($_)"} for qw( var );
  
     foreach ( @EXPERIMENTAL ) {
        $^H{"Syntax::Keyword::Try/experimental($_)"}++ if delete $syms{":experimental($_)"};
     }
  
     if( delete $syms{":experimental"} ) {
        $^H{"Syntax::Keyword::Try/experimental($_)"}++ for @EXPERIMENTAL;
     }
  
     # Ignore requests for these, as they come automatically with `try`
     delete @syms{qw( catch finally )};
  
     if( $syms{try_value} or $syms{":experimental(try_value)"} ) {
        croak "The 'try_value' experimental feature is now removed\n" .
              "Instead, you should use  do { try ... }  to yield a value from a try/catch statement";
     }
  
     croak "Unrecognised import symbols @{[ keys %syms ]}" if keys %syms;
  }
  
  =head1 WITH OTHER MODULES
  
  =head2 Future::AsyncAwait
  
  As of C<Future::AsyncAwait> version 0.10 and L<Syntax::Keyword::Try> version
  0.07, cross-module integration tests assert that basic C<try/catch> blocks
  inside an C<async sub> work correctly, including those that attempt to
  C<return> from inside C<try>.
  
     use Future::AsyncAwait;
     use Syntax::Keyword::Try;
  
     async sub attempt
     {
        try {
           await func();
           return "success";
        }
        catch {
           return "failed";
        }
     }
  
  =head1 ISSUES
  
  =head2 Thread-safety at load time cannot be assured before perl 5.16
  
  On F<perl> versions 5.16 and above this module is thread-safe.
  
  On F<perl> version 5.14 this module is thread-safe provided that it is
  C<use>d before any additional threads are created.
  
  However, when using 5.14 there is a race condition if this module is loaded
  late in the program startup, after additional threads have been created. This
  leads to the potential for it to be started up multiple times concurrently,
  which creates data races when modifying internal structures and likely leads
  to a segmentation fault, either during load or soon after when more code is
  compiled.
  
  As a workaround, for any such program that creates multiple threads, loads
  additional code (such as dynamically-discovered plugins), and has to run on
  5.14, it should make sure to
  
     use Syntax::Keyword::Try;
  
  early on in startup, before it spins out any additional threads.
  
  (See also L<https://rt.cpan.org/Public/Bug/Display.html?id=123547>)
  
  =head2 $@ is not local'ised by C<try do> before perl 5.24
  
  On F<perl> versions 5.24 and above, or when using only control-flow statement
  syntax, C<$@> is always correctly C<local>ised.
  
  However, when using the experimental value-yielding expression version
  C<try do {...}> on perl versions 5.22 or older, the C<local>isation of C<$@>
  does not correctly apply around the expression. After such an expression, the
  value of C<$@> will leak out if a failure happened and the C<catch> block was
  invoked, overwriting any previous value that was visible there.
  
  (See also L<https://rt.cpan.org/Public/Bug/Display.html?id=124366>)
  
  =head1 ACKNOWLEDGEMENTS
  
  With thanks to C<Zefram>, C<ilmari> and others from C<irc.perl.org/#p5p> for
  assisting with trickier bits of XS logic.
  
  =head1 AUTHOR
  
  Paul Evans <leonerd@leonerd.org.uk>
  
  =cut
  
  0x55AA;
X86_64-LINUX_SYNTAX_KEYWORD_TRY

$fatpacked{"x86_64-linux/Syntax/Keyword/Try/Deparse.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SYNTAX_KEYWORD_TRY_DEPARSE';
  #  You may distribute under the terms of either the GNU General Public License
  #  or the Artistic License (the same terms as Perl itself)
  #
  #  (C) Paul Evans, 2021 -- leonerd@leonerd.org.uk
  
  package Syntax::Keyword::Try::Deparse 0.27;
  
  use v5.14;
  use warnings;
  
  use B qw( opnumber );
  
  require B::Deparse;
  
  use constant {
     OP_CUSTOM  => opnumber('custom'),
     OP_ENTER   => opnumber('enter'),
     OP_LINESEQ => opnumber('lineseq'),
  };
  
  =head1 NAME
  
  C<Syntax::Keyword::Try::Deparse> - L<B::Deparse> support for L<Syntax::Keyword::Try>
  
  =head1 DESCRIPTION
  
  Loading this module will apply some hacks onto L<B::Deparse> that attempts to
  provide deparse support for code which uses the syntax provided by
  L<Syntax::Keyword::Try>.
  
  =cut
  
  my $orig_pp_leave;
  {
     no warnings 'redefine';
     no strict 'refs';
     $orig_pp_leave = *{"B::Deparse::pp_leave"}{CODE};
     *{"B::Deparse::pp_leave"} = \&pp_leave;
  }
  
  sub pp_leave
  {
     my $self = shift;
     my ( $op ) = @_;
  
     my $enter = $op->first;
     $enter->type == OP_ENTER or
        return $self->$orig_pp_leave( @_ );
  
     my $body = $enter->sibling;
     my $first = $body->first;
  
     my $finally = "";
  
     if( $body->type == OP_LINESEQ and $first->name eq "pushfinally" ) {
        my $finally_cv = $first->sv;
        $finally = "\nfinally " . $self->deparse_sub( $finally_cv ) . "\cK";
  
        $first = $first->sibling;
        $first = $first->sibling while $first and $first->name eq "lineseq";
  
        # Jump over a scope op
        if( $first->type == 0 ) {
           $body  = $first;
           $first = $first->first;
        }
     }
  
     if( $first->type == OP_CUSTOM and $first->name eq "catch" ) {
        # This is a try/catch block
        shift;
        return $self->deparse( $body, @_ ) . $finally;
     }
     elsif( length $finally ) {
        # Body is the remaining siblings. We'll have to do them all together
        my $try = B::Deparse::scopeop( 1, $self, $body, 0 );
  
        return "try {\n\t$try\n\b}" . $finally;
     }
  
     return $orig_pp_leave->($self, @_);
  }
  
  sub B::Deparse::pp_catch
  {
     my $self = shift;
     my ( $op ) = @_;
  
     my $tryop   = $op->first;
     my $catchop = $op->first->sibling;
  
     my $try = $self->pp_leave($tryop, 0);
  
     # skip the OP_SCOPE and dive into the OP_LINESEQ inside
     #
     # TODO: Try to detect the `catch my $e` variable, though that will be hard
     # to dishtinguish from actual code that really does that
     my $catch = $self->deparse($catchop->first, 0);
  
     return "try {\n\t$try\n\b}\ncatch {\n\t$catch\n\b}\cK";
  }
  
  =head1 TODO
  
  Correctly handle typed dispatch cases
  (C<catch($var isa CLASS)>, C<catch($var =~ m/pattern/)>)
  
  =cut
  
  =head1 AUTHOR
  
  Paul Evans <leonerd@leonerd.org.uk>
  
  =cut
  
  0x55AA;
X86_64-LINUX_SYNTAX_KEYWORD_TRY_DEPARSE

$fatpacked{"x86_64-linux/XS/Parse/Infix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_XS_PARSE_INFIX';
  #  You may distribute under the terms of either the GNU General Public License
  #  or the Artistic License (the same terms as Perl itself)
  #
  #  (C) Paul Evans, 2021 -- leonerd@leonerd.org.uk
  
  package XS::Parse::Infix 0.23;
  
  use v5.14;
  use warnings;
  
  # No actual .xs file; the code is implemented in XS::Parse::Keyword
  require XS::Parse::Keyword;
  
  =head1 NAME
  
  C<XS::Parse::Infix> - XS functions to assist in parsing infix operators
  
  =head1 DESCRIPTION
  
  This module provides some XS functions to assist in writing syntax modules
  that provide new infix operators as perl syntax, primarily for authors of
  syntax plugins. It is unlikely to be of much use to anyone else; and highly
  unlikely to be of any use when writing perl code using these. Unless you are
  writing a syntax plugin using XS, this module is not for you.
  
  This module is also currently experimental, and the design is still evolving
  and subject to change. Later versions may break ABI compatibility, requiring
  changes or at least a rebuild of any module that depends on it.
  
  In addition, the places this functionality can be used are relatively small.
  No current release of perl actually supports custom infix operators, though I
  have a branch where I am currently experimenting with such support:
  
  L<https://github.com/leonerd/perl5/tree/infix-plugin>
  
  In addition, the various C<XPK_INFIX_*> token types of L<XS::Parse::Keyword>
  support querying on this module, so some syntax provided by other modules may
  be able to make use of these new infix operators.
  
  =cut
  
  =head1 CONSTANTS
  
  =head2 HAVE_PL_INFIX_PLUGIN
  
     if( XS::Parse::Infix::HAVE_PL_INFIX_PLUGIN ) { ... }
  
  This constant is true if built on a perl that supports the C<PL_infix_plugin>
  extension mechanism, meaning that custom infix operators registered with this
  module will actually be recognised by the perl parser.
  
  No actual production or development releases of perl yet support this feature,
  but see above for details of a branch which does.
  
  =cut
  
  =head1 XS FUNCTIONS
  
  =head2 boot_xs_parse_infix
  
    void boot_xs_parse_infix(double ver);
  
  Call this function from your C<BOOT> section in order to initialise the module
  and parsing hooks.
  
  I<ver> should either be 0 or a decimal number for the module version
  requirement; e.g.
  
     boot_xs_parse_infix(0.14);
  
  =head2 xs_parse_infix_new_op
  
     OP *xs_parse_infix_new_op(const struct XSParseInfixInfo *info, U32 flags,
        OP *lhs, OP *rhs);
  
  This function constructs a new optree fragment to represent invoking the infix
  operator with the given operands. It should be used much the same as core
  perl's C<newBINOP> function.
  
  The C<info> structure pointer would be obtained from the C<infix> field of the
  result of invoking the various C<XPK_INFIX_*> token types from
  C<XS::Parse::Keyword>.
  
  =head2 register_xs_parse_infix
  
     void register_xs_parse_infix(const char *opname,
        const struct XSParseInfixHooks *hooks, void *hookdata);
  
  This function installs a set of parsing hooks to be associated with the given
  operator name. This new operator will then be available via
  L<XS::Parse::Keyword> by the various C<XPK_INFIX_*> token types, or to core
  perl's C<PL_infix_plugin> if availble.
  
  These tokens will all yield an info structure, with the following fields:
  
     struct XSParseInfixInfo {
        const char *opname;
        OPCODE opcode;  /* for built-in operators, or OP_CUSTOM for 
                           custom-registered ones */
  
        struct XSParseInfixHooks *hooks;
        void                     *hookdata;
     };
  
  If the operator name contains any non-ASCII characters they are presumed to be
  in UTF-8 encoding. This will matter for deparse purposes.
  
  =cut
  
  =head1 PARSE HOOKS
  
  The C<XSParseInfixHooks> structure provides the following fields which are
  used at various stages of parsing.
  
     struct XSParseInfixHooks {
        U16 flags; /* currently ignored */
        U8 lhs_flags;
        U8 rhs_flags;
        enum XSParseInfixClassification cls;
  
        const char *wrapper_func_name;
  
        const char *permit_hintkey;
        bool (*permit)(pTHX_ void *hookdata);
  
        OP *(*new_op)(pTHX_ U32 flags, OP *lhs, OP *rhs, void *hookdata);
        OP *(*ppaddr)(pTHX);
     };
  
  =head2 Flags
  
  The C<flags> field is currently ignored. It is defined simply to reserve the
  space in case used in a later version. It should be set to zero.
  
  The C<rhs_flags> field gives details on how to parse and handle the right-hand
  side of the operator syntax. It should be set to one of the following constants:
  
  =over 4
  
  =item XPI_OPERAND_TERM (0)
  
  Default. The operand is a term expression.
  
  =item XPI_OPERAND_TERM_LIST
  
  The operand is a term expression. It will be foced into list context,
  preserving the C<OP_PUSHMARK> at the beginning. This means that the ppfunc for
  this infix operator will have to C<POPMARK> to find that.
  
  =item XPI_OPERAND_LIST
  
  The operand is a list expression. It will be forced into list context, the
  same as above.
  
  =back
  
  In addition the following extra bitflags are defined:
  
  =over 4
  
  =item XPI_OPERAND_ONLY_LOOK
  
  If set, the operator function promises that it will not mutate any of its
  passed values, nor allow leaking of direct alias pointers to them via return
  value or other locations.
  
  This flag is optional; omitting it when applicable will not change any
  observed behaviour. Setting it may enable certain optimisations to be
  performed.
  
  Currently, this flag simply enables an optimisation in the call-checker for
  infix operator wrapper functions that take list-shaped operands. This
  optimisation discards an C<OP_ANONLIST> operation which would create a
  temporary anonymous array reference for its operand values, allowing a slight
  saving of memory use and CPU time. This optimisation is only safe to perform
  if the operator does not mutate or retain aliases of any of the arguments, as
  otherwise the caller might see unexpected modifications or value references to
  the values passed.
  
  =back
  
  The C<lhs_flags> field gives details on how to handle the left-hand side of
  the operator syntax. It takes similar values to C<rhs_flags>, except that it
  does not accept the C<XPI_OPERAND_LIST> value. Parsing always happens on just
  a term expression, though it may be placed into list context (which therefore
  still permits things like parenthesized lists, or array variables).
  
  =head2 The Selection Stage
  
  The C<cls> field gives a "classification" of the operator, suggesting what
  sort of operation it provides. This is used as a filter by the various
  C<XS::Parse::Keyword> selection macros.
  
  The classification should be one of the C<XPI_CLS_*> constants found and
  described further in the main F<XSParseInfix.h> file.
  
  =head2 The C<permit> Stage
  
  As a shortcut for the common case, the C<permit_hintkey> may point to a string
  to look up from the hints hash. If the given key name is not found in the
  hints hash then the keyword is not permitted. If the key is present then the
  C<permit> function is invoked as normal.
  
  If not rejected by a hint key that was not found in the hints hash, the
  function part of the stage is called next and should inspect whether the
  keyword is permitted at this time perhaps by inspecting other lexical clues,
  and return true only if the keyword is permitted.
  
  Both the string and the function are optional. Either or both may be present.
  If neither is present then the keyword is always permitted - which is likely
  not what you wanted to do.
  
  =head2 The Op Generation Stage
  
  If the infix operator is going to be used, then one of the C<new_op> or the
  C<ppaddr> fields explain how to create a new optree fragment.
  
  If C<new_op> is defined then it will be used, and is expected to return an
  optree fragment that consumes the LHS and RHS arguments to implement the
  semantics of the operator. If this is not present, then the C<ppaddr> will be
  used instead to construct a new BINOP of the C<OP_CUSTOM> type.
  
  =head2 The Wrapper Function
  
  Additionally, if the C<wrapper_func_name> field is set to a string, this gives
  the (fully-qualified) name for a function to be generated as part of
  registering the operator. This newly-generated function will act as a wrapper
  for the operator.
  
  For operators whose RHS is a scalar, the wrapper function is assumed to take
  two simple scalar arguments. The result of invoking the function on those
  arguments will be determined by using the operator code.
  
     $result = $lhs OP $rhs;
  
     $result = WRAPPERFUNC( $lhs, $rhs );
  
  For operators whose RHS is a list, the wrapper function takes at least one
  argument, possibly more. The first argument is the scalar on the LHS, and the
  remaining arguments, however many there are, form the RHS:
  
     $result = $lhs OP @rhs;
  
     $result = WRAPPERFUNC( $lhs, @rhs );
  
  For operators whose LHS and RHS is a list, the wrapper function takes two
  arguments which must be array references containing the lists.
  
     $result = @lhs OP @rhs;
  
     $result = WRAPPERFUNC( \@lhs, \@rhs );
  
  This creates a convenience for accessing the operator from perls that do not
  support C<PL_infix_plugin>.
  
  In the case of scalar infix operators, the wrapper function also includes a
  call-checker which attempts to inline the operator directly into the callsite.
  Thus, in simple cases where the function is called directly on exactly two
  scalar arguments (such as in the following), no C<ENTERSUB> overhead will be
  incurred and the generated optree will be identical to that which would have
  been generated by using infix operator syntax directly:
  
     WRAPPERFUNC( $lhs, $rhs );
     WRAPPERFUNC( $lhs, CONSTANT );
     WRAPPERFUNC( $args[0], $args[1] );
     WRAPPERFUNC( $lhs, scalar otherfunc() );
  
  The checker is very pessimistic and will only rewrite callsites where it
  determines this can be done safely. It will not rewrite any of the following
  forms:
  
     WRAPPERFUNC( $onearg );            # not enough args
     WRAPPERFUNC( $x, $y, $z );         # too many args
     WRAPPERFUNC( @args[0,1] );         # not a scalar
     WRAPPERFUNC( $lhs, otherfunc() );  # not a scalar
  
  The wrapper function for infix operators which take lists on both sides also
  has a call-checker which will attempt to inline the operator in similar
  circumstances. In addition to the optimisations described above for scalar
  operators, this checker will also inline an array-reference operator and omit
  the resulting dereference behaviour. Thus, the two following lines emit the
  same optree, without an C<OP_SREFGEN> or C<OP_RV2AV>:
  
     @lhs OP @rhs;
     WRAPPERFUNC( \@lhs, \@rhs );
  
  B<Note> that technically, this optimisation isn't strictly transparent in the
  odd cornercase that one of the referenced arrays is also the backing store for
  a blessed object reference, and that object class has a C<@{}> overload.
  
     my @arr;
     package SomeClass {
        use overload '@{}' => sub { return ["values", "go", "here"]; };
     }
     bless \@arr, "SomeClass";
  
     # this will not actually invoke the overload operator
     WRAPPERFUNC( \@arr, [4, 5, 6] );
  
  As this cornercase relates to taking duplicate references to the same blessed
  object's backing store variable, it should not matter to any real code;
  regular objects that are passed by reference into the wrapper function will
  run their overload methods as normal.
  
  The callchecker for list operands can optionally also discard an op of the
  C<OP_ANONLIST> type, which is used by anonymous array-ref construction:
  
     ($u, $v, $w) OP ($x, $y, $z);
     WRAPPERFUNC( [$u, $v, $w], [$x, $y, $z] );
  
  This optimisation is only performed if the operator declared it safe to do so,
  via the C<XPI_OPERAND_ONLY_LOOK> flag.
  
  =cut
  
  =head1 DEPARSE
  
  This module operates with L<B::Deparse> in order to automatically provide
  deparse support for infix operators. Every infix operator that is implemented
  as a custom op (and thus has the C<ppaddr> hook field set) will have deparse
  logic added. This will allow it to deparse to either the named wrapper
  function, or to the infix operator syntax if on a C<PL_infix_plugin>-enabled
  perl and the appropriate lexical hint is enabled at the callsite.
  
  In order for this to work, it is important that your custom operator is I<not>
  registered as a custom op using the C<Perl_register_custom_op()> function.
  This registration will be performed by C<XS::Parse::Infix> itself at the time
  the infix operator is registered.
  
  =cut
  
  sub B::Deparse::_deparse_infix_wrapperfunc_scalarscalar
  {
     my ( $self, $wrapper_func_name, $op, $ctx ) = @_;
  
     my $lhs = $op->first;
     my $rhs = $op->last;
  
     $_ = $self->deparse( $_, 6 ) for $lhs, $rhs;
  
     return "$wrapper_func_name($lhs, $rhs)";
  }
  
  sub B::Deparse::_deparse_infix_wrapperfunc_listlist
  {
     my ( $self, $wrapper_func_name, $op, $ctx ) = @_;
  
     my $lhs = $op->first;
     my $rhs = $op->last;
  
     foreach my $var ( \$lhs, \$rhs ) {
        my $argop = $$var;
        my $kid;
  
        if( $argop->name eq "null" and
            $argop->first->name eq "pushmark" and
            ($kid = $argop->first->sibling) and
            B::Deparse::null($kid->sibling) ) {
           my $add_refgen;
  
           # A list of a single item
           if( $kid->name eq "rv2av" and $kid->first->name ne "gv" ) {
              $argop = $kid->first;
           }
           elsif( $kid->name eq "padav" or $kid->name eq "rv2av" ) {
              $add_refgen++;
           }
           else {
              print STDERR "Maybe UNWRAP list ${\ $kid->name }\n";
           }
  
           $$var = $self->deparse( $argop, 6 );
  
           $$var = "\\$$var" if $add_refgen;
        }
        else {
           # Pretend the entire list was anonlist
           my @args;
           $argop = $argop->first->sibling; # skip pushmark
           while( not B::Deparse::null($argop) ) {
              push @args, $self->deparse( $argop, 6 );
              $argop = $argop->sibling;
           }
  
           $$var = "[" . join( ", ", @args ) . "]";
        }
     }
  
     return "$wrapper_func_name($lhs, $rhs)";
  }
  
  sub B::Deparse::_deparse_infix_named
  {
     my ( $self, $opname, $op, $ctx ) = @_;
  
     my $lhs = $op->first;
     my $rhs = $op->last;
  
     return join " ",
        $self->deparse_binop_left( $op, $lhs, 14 ),
        $opname,
        $self->deparse_binop_right( $op, $rhs, 14 );
  }
  
  =head1 TODO
  
  =over 4
  
  =item *
  
  Have the entersub checker for list/list operators unwrap arrayref or
  anon-array argument forms (C<WRAPPERFUNC( \@lhs, \@rhs )> or
  C<WRAPPERFUNC( [LHS], [RHS] )>).
  
  =back
  
  =cut
  
  =head1 AUTHOR
  
  Paul Evans <leonerd@leonerd.org.uk>
  
  =cut
  
  0x55AA;
X86_64-LINUX_XS_PARSE_INFIX

$fatpacked{"x86_64-linux/XS/Parse/Infix/Builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_XS_PARSE_INFIX_BUILDER';
  #  You may distribute under the terms of either the GNU General Public License
  #  or the Artistic License (the same terms as Perl itself)
  #
  #  (C) Paul Evans, 2021 -- leonerd@leonerd.org.uk
  
  package XS::Parse::Infix::Builder 0.23;
  
  use v5.14;
  use warnings;
  
  =head1 NAME
  
  C<XS::Parse::Infix::Builder> - build-time support for C<XS::Parse::Infix>
  
  =head1 SYNOPSIS
  
  In F<Build.PL>:
  
     use XS::Parse::Infix::Builder;
  
     my $build = Module::Build->new(
        ...,
        configure_requires => {
           ...
           'XS::Parse::Infix::Builder' => 0,
        }
     );
  
     XS::Parse::Infix::Builder->extend_module_build( $build );
  
     ...
  
  =head1 DESCRIPTION
  
  This module provides a build-time helper to assist authors writing XS modules
  that use L<XS::Parse::Infix>. It prepares a L<Module::Build>-using
  distribution to be able to make use of C<XS::Parse::Infix>.
  
  =cut
  
  require XS::Parse::Infix::Builder_data;
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 write_XSParseInfix_h
  
     XS::Parse::Infix::Builder->write_XSParseInfix_h
  
  Writes the F<XSParseInfix.h> file to the current working directory. To cause
  the compiler to actually find this file, see L</extra_compiler_flags>.
  
  =cut
  
  sub write_XSParseInfix_h
  {
     shift;
  
     open my $out, ">", "XSParseInfix.h" or
        die "Cannot open XSParseInfix.h for writing - $!\n";
  
     $out->print( XS::Parse::Infix::Builder_data->XSPARSEINFIX_H );
  }
  
  =head2 extra_compiler_flags
  
     @flags = XS::Parse::Infix::Builder->extra_compiler_flags
  
  Returns a list of extra flags that the build scripts should add to the
  compiler invocation. This enables the C compiler to find the
  F<XSParseInfix.h> file.
  
  =cut
  
  sub extra_compiler_flags
  {
     shift;
     return "-I.", XS::Parse::Infix::Builder_data->BUILDER_CFLAGS;
  }
  
  =head2 extend_module_build
  
     XS::Parse::Infix::Builder->extend_module_build( $build )
  
  A convenient shortcut for performing all the tasks necessary to make a
  L<Module::Build>-based distribution use the helper.
  
  =cut
  
  sub extend_module_build
  {
     my $self = shift;
     my ( $build ) = @_;
  
     eval { $self->write_XSParseInfix_h } or do {
        warn $@;
        return;
     };
  
     # preserve existing flags
     my @flags = @{ $build->extra_compiler_flags };
     push @flags, $self->extra_compiler_flags;
  
     $build->extra_compiler_flags( @flags );
  }
  
  =head1 AUTHOR
  
  Paul Evans <leonerd@leonerd.org.uk>
  
  =cut
  
  0x55AA;
X86_64-LINUX_XS_PARSE_INFIX_BUILDER

$fatpacked{"x86_64-linux/XS/Parse/Infix/Builder_data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_XS_PARSE_INFIX_BUILDER_DATA';
  package XS::Parse::Infix::Builder_data 0.23;
  
  use v5.14;
  use warnings;
  
  # Additional CFLAGS arguments to pass during compilation
  use constant BUILDER_CFLAGS => ;
  
  # The contents of the "XSParseInfix.h" file
  my $XSParseInfix_h = do {
     local $/;
     readline DATA;
  };
  sub XSPARSEINFIX_H() { $XSParseInfix_h }
  
  0x55AA;
  
  __DATA__
  #ifndef __XS_PARSE_INFIX_H__
  #define __XS_PARSE_INFIX_H__
  
  #define XSPARSEINFIX_ABI_VERSION 1
  
  /* Infix operator classifications */
  /* No built-in operators use the _MISC categories, but they are provided for
   * custom infix operators to use so they are still found by selections */
  enum XSParseInfixClassification {
    XPI_CLS_NONE = 0,
    XPI_CLS_PREDICATE,   /* any boolean-returning operator */
    XPI_CLS_RELATION,    /*  ... any predicate that is typewise symmetric */
    XPI_CLS_EQUALITY,    /*      ... any relation that is true for (x == x) and false otherwise */
    XPI_CLS_SMARTMATCH,  /*  ... the predicate smartmatch (~~) */
    XPI_CLS_MATCHRE,     /*  ... the predicate regexp match (=~) */
    XPI_CLS_ISA,         /*  ... the predicate instance of (isa) */
    XPI_CLS_MATCH_MISC,  /*  ... any other match-like predicate */
    XPI_CLS_ORDERING,    /* cmp or <=> */
  };
  
  enum XSParseInfixSelection {
    XPI_SELECT_ANY,
    XPI_SELECT_PREDICATE, /* any predicate */
    XPI_SELECT_RELATION,  /* any relation */
    XPI_SELECT_EQUALITY,  /* any equality */
    XPI_SELECT_ORDERING,  /* any ordering */
  
    XPI_SELECT_MATCH_NOSMART, /* any equality or other match operator, including smartmatch */
    XPI_SELECT_MATCH_SMART,   /* any equality or other match operator, not including smartmatch */
  };
  
  /* lhs_flags, rhs_flags */
  enum {
    XPI_OPERAND_TERM = 0, /* the "default" termexpr with no context */
    /* other space reserved for other scalar types */
    XPI_OPERAND_TERM_LIST = 6, /* term in list context */
    XPI_OPERAND_LIST      = 7, /* list in list context */
  
    /* Other bitflags */
    XPI_OPERAND_ONLY_LOOK = (1<<3),
  };
  
  struct XSParseInfixHooks {
    U16 flags;
    U8 lhs_flags, rhs_flags;
    enum XSParseInfixClassification cls;
  
    const char *wrapper_func_name;
  
    /* These two hooks are ANDed together; both must pass, if present */
    const char *permit_hintkey;
    bool (*permit) (pTHX_ void *hookdata);
  
    /* These hooks are alternatives; the first one defined is used */
    OP *(*new_op)(pTHX_ U32 flags, OP *lhs, OP *rhs, void *hookdata);
    OP *(*ppaddr)(pTHX); /* A pp func used directly in newBINOP_custom() */
  };
  
  struct XSParseInfixInfo {
    const char *opname;
    OPCODE opcode;
  
    const struct XSParseInfixHooks *hooks;
    void *hookdata;
  };
  
  static OP *(*xs_parse_infix_new_op_func)(pTHX_ const struct XSParseInfixInfo *info, U32 flags, OP *lhs, OP *rhs);
  #define xs_parse_infix_new_op(info, flags, lhs, rhs)  S_xs_parse_infix_new_op(aTHX_ info, flags, lhs, rhs)
  static OP *S_xs_parse_infix_new_op(pTHX_ const struct XSParseInfixInfo *info, U32 flags, OP *lhs, OP *rhs)
  {
    if(!xs_parse_infix_new_op_func)
      croak("Must call boot_xs_parse_infix() first");
  
    return (*xs_parse_infix_new_op_func)(aTHX_ info, flags, lhs, rhs);
  }
  
  static void (*register_xs_parse_infix_func)(pTHX_ const char *kw, const struct XSParseInfixHooks *hooks, void *hookdata);
  #define register_xs_parse_infix(opname, hooks, hookdata)  S_register_xs_parse_infix(aTHX_ opname, hooks, hookdata)
  static void S_register_xs_parse_infix(pTHX_ const char *opname, const struct XSParseInfixHooks *hooks, void *hookdata)
  {
    if(!register_xs_parse_infix_func)
      croak("Must call boot_xs_parse_infix() first");
  
    return (*register_xs_parse_infix_func)(aTHX_ opname, hooks, hookdata);
  }
  
  #define boot_xs_parse_infix(ver) S_boot_xs_parse_infix(aTHX_ ver)
  static void S_boot_xs_parse_infix(pTHX_ double ver) {
    SV **svp;
    SV *versv = ver ? newSVnv(ver) : NULL;
  
    /* XS::Parse::Infix is implemented in XS::Parse::Keyword's .so file */
    load_module(PERL_LOADMOD_NOIMPORT, newSVpvs("XS::Parse::Keyword"), versv, NULL);
  
    svp = hv_fetchs(PL_modglobal, "XS::Parse::Infix/ABIVERSION_MIN", 0);
    if(!svp)
      croak("XS::Parse::Infix ABI minimum version missing");
    int abi_ver = SvIV(*svp);
    if(abi_ver > XSPARSEINFIX_ABI_VERSION)
      croak("XS::Parse::Infix ABI version mismatch - library supports >= %d, compiled for %d",
          abi_ver, XSPARSEINFIX_ABI_VERSION);
  
    svp = hv_fetchs(PL_modglobal, "XS::Parse::Infix/ABIVERSION_MAX", 0);
    abi_ver = SvIV(*svp);
    if(abi_ver < XSPARSEINFIX_ABI_VERSION)
      croak("XS::Parse::Infix ABI version mismatch - library supports <= %d, compiled for %d",
          abi_ver, XSPARSEINFIX_ABI_VERSION);
  
    xs_parse_infix_new_op_func = INT2PTR(OP *(*)(pTHX_ const struct XSParseInfixInfo *, U32, OP *, OP *),
        SvUV(*hv_fetchs(PL_modglobal, "XS::Parse::Infix/new_op()@0", 0)));
    register_xs_parse_infix_func = INT2PTR(void (*)(pTHX_ const char *, const struct XSParseInfixHooks *, void *),
        SvUV(*hv_fetchs(PL_modglobal, "XS::Parse::Infix/register()@1", 0)));
  }
  
  #endif
X86_64-LINUX_XS_PARSE_INFIX_BUILDER_DATA

$fatpacked{"x86_64-linux/XS/Parse/Keyword.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_XS_PARSE_KEYWORD';
  #  You may distribute under the terms of either the GNU General Public License
  #  or the Artistic License (the same terms as Perl itself)
  #
  #  (C) Paul Evans, 2021-2022 -- leonerd@leonerd.org.uk
  
  package XS::Parse::Keyword 0.23;
  
  use v5.14;
  use warnings;
  
  require XSLoader;
  XSLoader::load( __PACKAGE__, our $VERSION );
  
  =head1 NAME
  
  C<XS::Parse::Keyword> - XS functions to assist in parsing keyword syntax
  
  =head1 DESCRIPTION
  
  This module provides some XS functions to assist in writing syntax modules
  that provide new perl-visible syntax, primarily for authors of keyword plugins
  using the C<PL_keyword_plugin> hook mechanism. It is unlikely to be of much
  use to anyone else; and highly unlikely to be any use when writing perl code
  using these. Unless you are writing a keyword plugin using XS, this module is
  not for you.
  
  This module is also currently experimental, and the design is still evolving
  and subject to change. Later versions may break ABI compatibility, requiring
  changes or at least a rebuild of any module that depends on it.
  
  =cut
  
  =head1 XS FUNCTIONS
  
  =head2 boot_xs_parse_keyword
  
     void boot_xs_parse_keyword(double ver);
  
  Call this function from your C<BOOT> section in order to initialise the module
  and parsing hooks.
  
  I<ver> should either be 0 or a decimal number for the module version
  requirement; e.g.
  
     boot_xs_parse_keyword(0.14);
  
  =head2 register_xs_parse_keyword
  
     void register_xs_parse_keyword(const char *keyword,
       const struct XSParseKeywordHooks *hooks, void *hookdata);
  
  This function installs a set of parsing hooks to be associated with the given
  keyword. Such a keyword will then be handled automatically by a keyword parser
  installed by C<XS::Parse::Keyword> itself.
  
  =cut
  
  =head1 PARSE HOOKS
  
  The C<XSParseKeywordHooks> structure provides the following hook stages, which
  are invoked in the given order.
  
  =head2 flags
  
  The following flags are defined:
  
  =over 4
  
  =item C<XPK_FLAG_EXPR>
  
  The parse or build function is expected to return C<KEYWORD_PLUGIN_EXPR>.
  
  =item C<XPK_FLAG_STMT>
  
  The parse or build function is expected to return C<KEYWORD_PLUGIN_STMT>.
  
  These two flags are largely for the benefit of giving static information at
  registration time to assist static parsing or other related tasks to know what
  kind of grammatical element this keyword will produce.
  
  =item C<XPK_FLAG_AUTOSEMI>
  
  The syntax forms a complete statement, which should be followed by a statement
  separator semicolon (C<;>). This semicolon is optional at the end of a block.
  
  The semicolon, if present, will be consumed automatically.
  
  =back
  
  =head2 The C<permit> Stage
  
     const char *permit_hintkey;
     bool (*permit) (pTHX_ void *hookdata);
  
  Called by the installed keyword parser hook which is used to handle keywords
  registered by L</register_xs_parse_keyword>.
  
  As a shortcut for the common case, the C<permit_hintkey> may point to a string
  to look up from the hints hash. If the given key name is not found in the
  hints hash then the keyword is not permitted. If the key is present then the
  C<permit> function is invoked as normal.
  
  If not rejected by a hint key that was not found in the hints hash, the
  function part of the stage is called next and should inspect whether the
  keyword is permitted at this time perhaps by inspecting other lexical clues,
  and return true only if the keyword is permitted.
  
  Both the string and the function are optional. Either or both may be present.
  If neither is present then the keyword is always permitted - which is likely
  not what you wanted to do.
  
  =head2 The C<check> Stage
  
     void (*check)(pTHX_ void *hookdata);
  
  Invoked once the keyword has been permitted. If present, this hook function
  can check the surrounding lexical context, state, or other information and
  throw an exception if it is unhappy that the keyword should apply in this
  position.
  
  =head2 The C<parse> Stage
  
  This stage is invoked once the keyword has been checked, and actually
  parses the incoming text into an optree. It is implemented by calling the
  B<first> of the following function pointers which is not NULL. The invoked
  function may optionally build an optree to represent the parsed syntax, and
  place it into the variable addressed by C<out>. If it does not, then a simple
  C<OP_NULL> will be constructed in its place.
  
  C<lex_read_space()> is called both before and after this stage is invoked, so
  in many simple cases the hook function itself does not need to bother with it.
  
     int (*parse)(pTHX_ OP **out, void *hookdata);
  
  If present, this should consume text from the parser buffer by invoking
  C<lex_*> or C<parse_*> functions and eventually return a C<KEYWORD_PLUGIN_*>
  result value.
  
  This is the most generic and powerful of the options, but requires the most
  amount of implementation work.
  
     int (*build)(pTHX_ OP **out, XSParseKeywordPiece *args[], size_t nargs, void *hookdata);
  
  If C<parse> is not present, this is called instead after parsing a sequence of
  arguments, of types given by the I<pieces> field; which should be a zero-
  terminated array of piece types.
  
  This alternative is somewhat less generic and powerful than providing C<parse>
  yourself, but involves much less parsing work and is shorter and easier to
  implement.
  
     int (*build1)(pTHX_ OP **out, XSParseKeywordPiece *arg0, void *hookdata);
  
  If neither C<parse> nor C<build> are present, this is called as a simpler
  variant of C<build> when only a single argument is required. It takes its type
  from the C<piece1> field instead.
  
  =cut
  
  =head1 PIECES AND PIECE TYPES
  
  When using the C<build> or C<build1> alternatives for the C<parse> phase, the
  actual syntax is parsed automatically by this module, according to the
  specification given by the I<pieces> or I<piece1> field. The result of that
  parsing step is placed into the I<args> or I<arg0> parameter to the invoked
  function, using a C<struct> type consisting of the following fields:
  
     typedef struct
        union {
           OP *op;
           CV *cv;
           SV *sv;
           int i;
           struct {
              SV *name;
              SV *value;
           } attr;
           PADOFFSET padix;
           struct XSParseInfixInfo *infix;
        };
        int line;
     } XSParseKeywordPiece;
  
  Which field of the anonymous union is set depends on the type of the piece.
  The I<line> field contains the line number of the source file where parsing of
  that piece began.
  
  Some piece types are "atomic", whose definition is self-contained. Others are
  structural, defined in terms of inner pieces. Together these form an entire
  tree-shaped definition of the syntax that the keyword expects to find.
  
  Atomic types generally provide exactly one argument into the list of I<args>
  (with the exception of literal matches, which do not provide anything).
  Structural types may provide an initial argument themselves, followed by a
  list of the values of each sub-piece they contained inside them. Thus, while
  the data structure defining the syntax shape is a tree, the argument values it
  parses into is passed as a flat array to the C<build> function.
  
  Some structural types need to be able to determine whether or not syntax
  relating some optional part of them is present in the incoming source text. In
  this case, the pieces relating to those optional parts must support "probing".
  This ability is also noted below.
  
  The type of each piece should be one of the following macro values.
  
  =head2 XPK_BLOCK
  
  I<atomic, can probe, emits op.>
  
     XPK_BLOCK
  
  A brace-delimited block of code is expected, passed as an optree in the I<op>
  field. This will be parsed as a block within the current function scope.
  
  This can be probed by checking for the presence of an open-brace (C<{>)
  character.
  
  Be careful defining grammars with this because an open-brace is also a valid
  character to start a term expression, for example. Given a choice between
  C<XPK_BLOCK> and C<XPK_TERMEXPR>, either of them could try to consume such
  code as
  
     { 123, 456 }
  
  =head2 XPK_BLOCK_VOIDCTX, XPK_BLOCK_SCALARCTX, XPK_BLOCK_LISTCTX
  
  Variants of C<XPK_BLOCK> which wrap a void, scalar or list-context scope
  around the block.
  
  =head2 XPK_PREFIXED_BLOCK
  
  I<structural, emits op.>
  
     XPK_PREFIXED_BLOCK(pieces ...)
  
  Some pieces are expected, followed by a brace-delimited block of code, which
  is passed as an optree in the I<op> field. The prefix pieces are parsed first,
  and their results are passed before the block itself.
  
  The entire sequence, including the prefix items, is contained within a pair of
  C<block_start()> / C<block_end()> calls. This permits the prefix pieces to
  introduce new items into the lexical scope of the block - for example by the
  use of C<XPK_LEXVAR_MY>.
  
  A call to C<intro_my()> is automatically made at the end of the prefix pieces,
  before the block itself is parsed, ensuring any new lexical variables are now
  visible.
  
  In addition, the following extra piece types are recognised here:
  
  =over 4
  
  =item XPK_SETUP
  
     void setup(pTHX_ void *hookdata);
  
     XPK_SETUP(&setup)
  
  I<atomic, emits nothing.>
  
  This piece type runs a function given by pointer. Typically this function may
  be used to introduce new lexical state into the parser, or in some other way
  have some side-effect on the parsing context of the block to be parsed.
  
  =back
  
  =head2 XPK_PREFIXED_BLOCK_ENTERLEAVE
  
  A variant of C<XPK_PREFIXED_BLOCK> which additionally wraps the entire parsing
  operation, including the C<block_start()>, C<block_end()> and any calls to
  C<XPK_SETUP> functions, within a C<ENTER>/C<LEAVE> pair.
  
  This should not make a difference to the standard parser pieces provided here,
  but may be useful behaviour for the code in the setup function, especially if
  it wishes to modify parser state and use the savestack to ensure it is
  restored again when parsing has finished.
  
  =head2 XPK_ANONSUB
  
  I<atomic, emits op.>
  
  A brace-delimited block of code is expected, and assembled into the body of a
  new anonymous subroutine. This will be passed as a protosub CV in the I<cv>
  field.
  
  =head2 XPK_ARITHEXPR
  
  I<atomic, emits op.>
  
     XPK_ARITHEXPR
  
  An arithmetic expression is expected, parsed using C<parse_arithexpr()>, and
  passed as an optree in the I<op> field.
  
  =head2 XPK_ARITHEXPR_VOIDCTX, XPK_ARITHEXPR_SCALARCTX
  
  Variants of C<XPK_ARITHEXPR> which puts the expression in void or scalar context.
  
  =head2 XPK_TERMEXPR
  
  I<atomic, emits op.>
  
     XPK_TERMEXPR
  
  A term expression is expected, parsed using C<parse_termexpr()>, and passed as
  an optree in the I<op> field.
  
  =head2 XPK_TERMEXPR_VOIDCTX, XPK_TERMEXPR_SCALARCTX
  
  Variants of C<XPK_TERMEXPR> which puts the expression in void or scalar context.
  
  =head2 XPK_LISTEXPR
  
  I<atomic, emits op.>
  
     XPK_LISTEXPR
  
  A list expression is expected, parsed using C<parse_listexpr()>, and passed as
  an optree in the I<op> field.
  
  =head2 XPK_LISTEXPR_LISTCTX
  
  Variant of C<XPK_LISTEXPR> which puts the expression in list context.
  
  =head2 XPK_IDENT, XPK_IDENT_OPT
  
  I<atomic, can probe, emits sv.>
  
  A bareword identifier name is expected, and passed as an SV containing a PV
  in the I<sv> field. An identifier is not permitted to contain a double colon
  (C<::>).
  
  The C<_OPT>-suffixed version is optional; if no identifier is found then I<sv>
  is set to C<NULL>.
  
  =head2 XPK_PACKAGENAME, XPK_PACKAGENAME_OPT
  
  I<atomic, can probe, emits sv.>
  
  A bareword package name is expected, and passed as an SV containing a PV in
  the I<sv> field. A package name is similar to an identifier, except it permits
  double colons in the middle.
  
  The C<_OPT>-suffixed version is optional; if no package name is found then
  I<sv> is set to C<NULL>.
  
  =head2 XPK_LEXVARNAME
  
  I<atomic, emits sv.>
  
     XPK_LEXVARNAME(kind)
  
  A lexical variable name is expected, and passed as an SV containing a PV in
  the I<sv> field. The C<kind> argument specifies what kinds of variable are
  permitted, and should be a bitmask of one or more bits from
  C<XPK_LEXVAR_SCALAR>, C<XPK_LEXVAR_ARRAY> and C<XPK_LEXVAR_HASH>. A convenient
  shortcut C<XPK_LEXVAR_ANY> permits all three.
  
  =head2 XPK_ATTRIBUTES
  
  I<atomic, emits i followed by more args.>
  
  A list of C<:>-prefixed attributes is expected, in the same format as sub or
  variable attributes. An optional leading C<:> indicates the presence of
  attributes, then one or more of them are parsed. Attributes may be optionally
  separated by additional C<:>s, but this is not required.
  
  Each attribute is expected to be an identifier name, followed by an optional
  value wrapped in parentheses. Whitespace is B<NOT> permitted between the name
  and value, as per standard Perl parsing rules.
  
     :attrname
     :attrname(value)
  
  The I<i> field indicates how many attributes were found. That number of
  additional arguments are then passed, each containing two SVs in the
  I<attr.name> and I<attr.value> fields. This number may be zero.
  
  It is not an error for there to be no attributes present, or for the optional
  colon to be missing. In this case I<i> will be set to zero.
  
  =head2 XPK_VSTRING, XPK_VSTRING_OPT
  
  I<atomic, can probe, emits sv.>
  
  A version string is expected, of the form C<v1.234> including the leading C<v>
  character. It is passed as a L<version> SV object in the I<sv> field.
  
  The C<_OPT>-suffixed version is optional; if no version string is found then
  I<sv> is set to C<NULL>.
  
  =head2 XPK_LEXVAR_MY
  
  I<atomic, emits padix.>
  
     XPK_LEXVAR_MY(kind)
  
  A lexical variable name is expected, added to the current pad as if specified
  in a C<my> expression, and passed as the pad index in the I<padix> field.
  
  The C<kind> argument specifies what kinds of variable are permitted, as per
  C<XPK_LEXVARNAME>.
  
  =head2 XPK_COMMA, XPK_COLON, XPK_EQUALS
  
  I<atomic, can probe, emits nothing.>
  
  A literal character (C<,>, C<:> or C<=>) is expected. No argument value is passed.
  
  =head2 XPK_AUTOSEMI
  
  I<atomic, emits nothing.>
  
  A literal semicolon (C<;>) as a statement terminator is optionally expected.
  If the next token is a closing brace to indicate the end of a block, then a
  semicolon is not required. If anything else is encountered an error will be
  raised.
  
  This piece type is the same as specifying the C<XPK_FLAG_AUTOSEMI>. It is
  useful to put at the end of a sequence that forms part of a choice of syntax,
  where some forms indicate a statement ending in a semicolon, whereas others
  may end in a full block that does not need one.
  
  =head2 XPK_INFIX_*
  
  I<atomic, can probe, emits infix.>
  
  An infix operator as recognised by L<XS::Parse::Infix>. The returned pointer
  points to a structure allocated by C<XS::Parse::Infix> describing the
  operator.
  
  Various versions of the macro are provided, each using a different selection
  filter to choose certain available infix operators:
  
     XPK_INFIX_RELATION         # any relational operator
     XPK_INFIX_EQUALITY         # an equality operator like `==` or `eq`
     XPK_INFIX_MATCH_NOSMART    # any sort of "match"-like operator, except smartmatch
     XPK_INFIX_MATCH_SMART      # XPK_INFIX_MATCH_NOSMART plus smartmatch
  
  =head2 XPK_LITERAL
  
  I<atomic, can probe, emits nothing.>
  
     XPK_LITERAL("literal")
  
  A literal string match is expected. No argument value is passed.
  
  This form should generally be avoided if at all possible, because it is very
  easy to abuse to make syntaxes which confuse humans and code tools alike.
  Generally it is best reserved just for the first component of a
  C<XPK_OPTIONAL> or C<XPK_REPEATED> sequence, to provide a "secondary keyword"
  that such a repeated item can look out for.
  
  =head2 XPK_KEYWORD
  
  I<atomic, can probe, emits nothing.>
  
     XPK_KEYWORD("keyword")
  
  A literal string match is expected. No argument value is passed.
  
  This is similar to C<XPK_LITERAL> except that it additionally checks that the
  following character is not an identifier character. This ensures that the
  expected keyword-like behaviour is preserved. For example, given the input
  C<"keyword">, the piece C<XPK_LITERAL("key")> would match it, whereas
  C<XPK_KEYWORD("key")> would not because of the subsequent C<"w"> character.
  
  =head2 XPK_SEQUENCE
  
  I<structural, might support probe, emits nothing.>
  
     XPK_SEQUENCE(pieces ...)
  
  A structural type which contains a number of pieces. This is normally
  equivalent to simply placing the pieces in sequence inside their own
  container, but it is useful inside C<XPK_CHOICE> or C<XPK_TAGGEDCHOICE>.
  
  An C<XPK_SEQUENCE> supports probe if its first contained piece does; i.e.
  is transparent to probing.
  
  =head2 XPK_OPTIONAL
  
  I<structural, emits i.>
  
     XPK_OPTIONAL(pieces ...)
  
  A structural type which may expects to find its contained pieces, or is happy
  not to. This will pass an argument whose I<i> field contains either 1 or 0,
  depending whether the contents were found. The first piece type within must
  support probe.
  
  =head2 XPK_REPEATED
  
  I<structural, emits i.>
  
     XPK_REPEATED(pieces ...)
  
  A structural type which expects to find zero or more repeats of its contained
  pieces. This will pass an argument whose I<i> field contains the count of the
  number of repeats it found. The first piece type within must support probe.
  
  =head2 XPK_CHOICE
  
  I<structural, can probe, emits i.>
  
     XPK_CHOICE(options ...)
  
  A structural type which expects to find one of a number of alternative
  options. An ordered list of types is provided, all of which must support
  probe. This will pass an argument whose I<i> field gives the index of the
  first choice that was accepted. The first option takes the value 0.
  
  As each of the options is interpreted as an alternative, not a sequence, you
  should use C<XPK_SEQUENCE> if a sequence of multiple items should be
  considered as a single alternative.
  
  It is not an error if no choice matches. At that point, the I<i> field will be
  set to -1.
  
  If you require a failure message in this case, set the final choice to be of
  type C<XPK_FAILURE>. This will cause an error message to be printed instead.
  
     XPK_FAILURE("message string")
  
  =head2 XPK_TAGGEDCHOICE
  
  I<structural, can probe, emits i.>
  
     XPK_TAGGEDCHOICE(choice, tag, ...)
  
  A structural type similar to C<XPK_CHOICE>, except that each choice type is
  followed by an element of type C<XPK_TAG> which gives an integer. It is that
  integer value, rather than the positional index of the choice within the list,
  which is passed in the I<i> field.
  
     XPK_TAG(value)
  
  As each of the options is interpreted as an alternative, not a sequence, you
  should use C<XPK_SEQUENCE> if a sequence of multiple items should be
  considered as a single alternative.
  
  =head2 XPK_COMMALIST
  
  I<structural, might support probe, emits i.>
  
     XPK_COMMALIST(pieces ...)
  
  A structural type which expects to find one or more repeats of its contained
  pieces, separated by literal comma (C<,>) characters. This is somewhat similar
  to C<XPK_REPEATED>, except that it needs at least one copy, needs commas
  between its items, but does not require that the first contained piece support
  probe (the comma itself is sufficient to indicate a repeat).
  
  An C<XPK_COMMALIST> supports probe if its first contained piece does; i.e.
  is transparent to probing.
  
  =head2 XPK_PARENSCOPE
  
  I<structural, can probe, emits nothing.>
  
     XPK_PARENSCOPE(pieces ...)
  
  A structural type which expects to find a sequence of pieces, all contained in
  parentheses as C<( ... )>. This will pass no extra arguments.
  
  =head2 XPK_ARGSCOPE
  
  I<structural, emits nothing.>
  
     XPK_ARGSCOPE(pieces ...)
  
  A structural type similar to C<XPK_PARENSCOPE>, except that the parentheses
  themselves are optional; much like Perl's parsing of calls to known functions.
  
  If parentheses are encountered in the input, they will be consumed by this
  piece and it will behave identically to C<XPK_PARENSCOPE>. If there is no open
  parenthesis, this piece will behave like C<XPK_SEQUENCE> and consume all the
  pieces inside it, without expecting a closing parenthesis.
  
  =head2 XPK_BRACKETSCOPE
  
  I<structural, can probe, emits nothing.>
  
     XPK_BRACKETSCOPE(pieces ...)
  
  A structural type which expects to find a sequence of pieces, all contained in
  square brackets as C<[ ... ]>. This will pass no extra arguments.
  
  =head2 XPK_BRACESCOPE
  
  I<structural, can probe, emits nothing.>
  
     XPK_BRACESCOPE(pieces ...)
  
  A structural type which expects to find a sequence of pieces, all contained in
  braces as C<{ ... }>. This will pass no extra arguments.
  
  Note that this is not necessary to use with C<XPK_BLOCK> or C<XPK_ANONSUB>;
  those will already consume a set of braces. This is intended for special
  constrained syntax that should not just accept an arbitrary block.
  
  =head2 XPK_CHEVRONSCOPE
  
  I<structural, can probe, emits nothing.>
  
     XPK_CHEVRONSCOPE(pieces ...)
  
  A structural type which expects to find a sequence of pieces, all contained in
  angle brackets as C<< < ... > >>. This will pass no extra arguments.
  
  Remember that expressions like C<< a > b >> are valid term expressions, so the
  contents of this scope shouldn't allow arbitrary expressions or the closing
  bracket will be ambiguous.
  
  =head2 XPK_PARENSCOPE_OPT, XPK_BRACKETSCOPE_OPT, XPK_BRACESCOPE_OPT, XPK_CHEVRONSCOPE_OPT
  
  I<structural, can probe, emits i.>
  
     XPK_PARENSCOPE_OPT(pieces ...)
     XPK_BRACKETSCOPE_OPT(pieces ...)
     XPK_BRACESCOPE_OPT(pieces ...)
     XPK_CHEVERONSCOPE_OPT(pieces ...)
  
  Each of the four C<XPK_...SCOPE> macros above has an optional variant, whose
  name is suffixed by C<_OPT>. These pass an argument whose I<i> field is either
  true or false, indicating whether the scope was found, followed by the values
  from the scope itself.
  
  This is a convenient shortcut to nesting the scope within a C<XPK_OPTIONAL>
  macro.
  
  =cut
  
  =head1 AUTHOR
  
  Paul Evans <leonerd@leonerd.org.uk>
  
  =cut
  
  0x55AA;
X86_64-LINUX_XS_PARSE_KEYWORD

$fatpacked{"x86_64-linux/XS/Parse/Keyword/Builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_XS_PARSE_KEYWORD_BUILDER';
  #  You may distribute under the terms of either the GNU General Public License
  #  or the Artistic License (the same terms as Perl itself)
  #
  #  (C) Paul Evans, 2021 -- leonerd@leonerd.org.uk
  
  package XS::Parse::Keyword::Builder 0.23;
  
  use v5.14;
  use warnings;
  
  =head1 NAME
  
  C<XS::Parse::Keyword::Builder> - build-time support for C<XS::Parse::Keyword>
  
  =head1 SYNOPSIS
  
  In F<Build.PL>:
  
     use XS::Parse::Keyword::Builder;
  
     my $build = Module::Build->new(
        ...,
        configure_requires => {
           ...
           'XS::Parse::Keyword::Builder' => 0,
        }
     );
  
     XS::Parse::Keyword::Builder->extend_module_build( $build );
  
     ...
  
  =head1 DESCRIPTION
  
  This module provides a build-time helper to assist authors writing XS modules
  that use L<XS::Parse::Keyword>. It prepares a L<Module::Build>-using
  distribution to be able to make use of C<XS::Parse::Keyword>.
  
  =cut
  
  require XS::Parse::Keyword::Builder_data;
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 write_XSParseKeyword_h
  
     XS::Parse::Keyword::Builder->write_XSParseKeyword_h
  
  Writes the F<XSParseKeyword.h> file to the current working directory. To cause
  the compiler to actually find this file, see L</extra_compiler_flags>.
  
  =cut
  
  sub write_XSParseKeyword_h
  {
     shift;
  
     open my $out, ">", "XSParseKeyword.h" or
        die "Cannot open XSParseKeyword.h for writing - $!\n";
  
     $out->print( XS::Parse::Keyword::Builder_data->XSPARSEKEYWORD_H );
  }
  
  =head2 extra_compiler_flags
  
     @flags = XS::Parse::Keyword::Builder->extra_compiler_flags
  
  Returns a list of extra flags that the build scripts should add to the
  compiler invocation. This enables the C compiler to find the
  F<XSParseKeyword.h> file.
  
  =cut
  
  sub extra_compiler_flags
  {
     shift;
     return "-I.", XS::Parse::Keyword::Builder_data->BUILDER_CFLAGS;
  }
  
  =head2 extend_module_build
  
     XS::Parse::Keyword::Builder->extend_module_build( $build )
  
  A convenient shortcut for performing all the tasks necessary to make a
  L<Module::Build>-based distribution use the helper.
  
  =cut
  
  sub extend_module_build
  {
     my $self = shift;
     my ( $build ) = @_;
  
     eval { $self->write_XSParseKeyword_h } or do {
        warn $@;
        return;
     };
  
     # preserve existing flags
     my @flags = @{ $build->extra_compiler_flags };
     push @flags, $self->extra_compiler_flags;
  
     $build->extra_compiler_flags( @flags );
  }
  
  =head1 AUTHOR
  
  Paul Evans <leonerd@leonerd.org.uk>
  
  =cut
  
  0x55AA;
X86_64-LINUX_XS_PARSE_KEYWORD_BUILDER

$fatpacked{"x86_64-linux/XS/Parse/Keyword/Builder_data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_XS_PARSE_KEYWORD_BUILDER_DATA';
  package XS::Parse::Keyword::Builder_data 0.23;
  
  use v5.14;
  use warnings;
  
  # Additional CFLAGS arguments to pass during compilation
  use constant BUILDER_CFLAGS => ;
  
  # The contents of the "XSParseKeyword.h" file
  my $XSParseKeyword_h = do {
     local $/;
     readline DATA;
  };
  sub XSPARSEKEYWORD_H() { $XSParseKeyword_h }
  
  0x55AA;
  
  __DATA__
  #ifndef __XS_PARSE_KEYWORD_H__
  #define __XS_PARSE_KEYWORD_H__
  
  #define XSPARSEKEYWORD_ABI_VERSION 2
  
  struct XSParseKeywordPieceType;
  struct XSParseKeywordPieceType {
    int type;
    union {
      char                                  c;      /* LITERALCHAR */
      const char                           *str;    /* LITERALSTR */
      const struct XSParseKeywordPieceType *pieces; /* SCOPEs */
      void                                (*callback)(pTHX_ void *hookdata); /* SETUP */
    } u;
  };
  
  enum {
    XPK_FLAG_EXPR     = (1<<0),
    XPK_FLAG_STMT     = (1<<1),
    XPK_FLAG_AUTOSEMI = (1<<2),
  };
  
  enum {
    /* skip zero */
  
    /*                                    emits */
    XS_PARSE_KEYWORD_LITERALCHAR = 1,   /* nothing */
    XS_PARSE_KEYWORD_LITERALSTR,        /* nothing */
    XS_PARSE_KEYWORD_AUTOSEMI,          /* nothing */
    XS_PARSE_KEYWORD_FAILURE = 0x0f,    /* nothing */
  
    XS_PARSE_KEYWORD_BLOCK = 0x10,      /* op */
    XS_PARSE_KEYWORD_ANONSUB,           /* cv */
    XS_PARSE_KEYWORD_ARITHEXPR,         /* op */
    XS_PARSE_KEYWORD_TERMEXPR,          /* op */
    XS_PARSE_KEYWORD_LISTEXPR,          /* op */
    /* TODO: XS_PARSE_KEYWORD_FULLEXPR = 0x15 */
    XS_PARSE_KEYWORD_IDENT = 0x16,      /* sv */
    XS_PARSE_KEYWORD_PACKAGENAME,       /* sv */
    XS_PARSE_KEYWORD_LEXVARNAME,        /* sv */
    XS_PARSE_KEYWORD_LEXVAR,            /* padix */
    XS_PARSE_KEYWORD_ATTRS,             /* i / {attr.name + attr.val} */
    XS_PARSE_KEYWORD_VSTRING,           /* sv */
  
    XS_PARSE_KEYWORD_INFIX = 0x40,      /* infix */
  
    XS_PARSE_KEYWORD_SETUP = 0x70,      /* invokes callback, emits nothing */
  
    XS_PARSE_KEYWORD_SEQUENCE = 0x80,   /* contained */
    XS_PARSE_KEYWORD_REPEATED,          /* i, contained */
    XS_PARSE_KEYWORD_CHOICE,            /* i, contained */
    XS_PARSE_KEYWORD_TAGGEDCHOICE,      /* i, contained */
    XS_PARSE_KEYWORD_SEPARATEDLIST,     /* i, contained */
    XS_PARSE_KEYWORD_PARENSCOPE = 0xb0, /* contained */
    XS_PARSE_KEYWORD_BRACKETSCOPE,      /* contained */
    XS_PARSE_KEYWORD_BRACESCOPE,        /* contained */
    XS_PARSE_KEYWORD_CHEVRONSCOPE,      /* contained */
  };
  
  enum {
    XPK_LEXVAR_SCALAR = (1<<0),
    XPK_LEXVAR_ARRAY  = (1<<1),
    XPK_LEXVAR_HASH   = (1<<2),
    XPK_LEXVAR_ANY    = XPK_LEXVAR_SCALAR|XPK_LEXVAR_ARRAY|XPK_LEXVAR_HASH,
  };
  
  enum {
    XPK_TYPEFLAG_OPT      = (1<<16),
    XPK_TYPEFLAG_SPECIAL  = (1<<17), /* on XPK_LITERALSTR: keyword
                                        on XPK_BLOCK: scoped
                                        on XPK_LEXVAR: my */
  
    /* These three are shifted versions of perl's G_VOID, G_SCALAR, G_LIST */
    XPK_TYPEFLAG_G_VOID   = (1<<18),
    XPK_TYPEFLAG_G_SCALAR = (2<<18),
    XPK_TYPEFLAG_G_LIST   = (3<<18),
  
    XPK_TYPEFLAG_ENTERLEAVE = (1<<20), /* wrap ENTER/LEAVE pair around the item */
  
    XPK_TYPEFLAG_MAYBEPARENS = (1<<21), /* parens themselves are optional on PARENSCOPE */
  };
  
  #define XPK_BLOCK_flags(flags) {.type = XS_PARSE_KEYWORD_BLOCK|(flags), .u.pieces = NULL}
  #define XPK_BLOCK              XPK_BLOCK_flags(0)
  #define XPK_BLOCK_VOIDCTX      XPK_BLOCK_flags(XPK_TYPEFLAG_SPECIAL|XPK_TYPEFLAG_G_VOID)
  #define XPK_BLOCK_SCALARCTX    XPK_BLOCK_flags(XPK_TYPEFLAG_SPECIAL|XPK_TYPEFLAG_G_SCALAR)
  #define XPK_BLOCK_LISTCTX      XPK_BLOCK_flags(XPK_TYPEFLAG_SPECIAL|XPK_TYPEFLAG_G_LIST)
  
  #define XPK_PREFIXED_BLOCK_flags(flags,...) \
    {.type = XS_PARSE_KEYWORD_BLOCK|flags, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  #define XPK_PREFIXED_BLOCK(...)            XPK_PREFIXED_BLOCK_flags(0, __VA_ARGS__)
  #define XPK_PREFIXED_BLOCK_ENTERLEAVE(...) XPK_PREFIXED_BLOCK_flags(XPK_TYPEFLAG_ENTERLEAVE, __VA_ARGS__)
  
  #define XPK_SETUP(setup)       {.type = XS_PARSE_KEYWORD_SETUP, .u.callback = setup}
  
  #define XPK_ANONSUB {.type = XS_PARSE_KEYWORD_ANONSUB}
  
  #define XPK_ARITHEXPR_flags(flags) {.type = XS_PARSE_KEYWORD_ARITHEXPR|(flags)}
  #define XPK_ARITHEXPR              XPK_ARITHEXPR_flags(0)
  #define XPK_ARITHEXPR_VOIDCTX      XPK_ARITHEXPR_flags(XPK_TYPEFLAG_G_VOID)
  #define XPK_ARITHEXPR_SCALARCTX    XPK_ARITHEXPR_flags(XPK_TYPEFLAG_G_SCALAR)
  #define XPK_TERMEXPR_flags(flags) {.type = XS_PARSE_KEYWORD_TERMEXPR|(flags)}
  #define XPK_TERMEXPR              XPK_TERMEXPR_flags(0)
  #define XPK_TERMEXPR_VOIDCTX      XPK_TERMEXPR_flags(XPK_TYPEFLAG_G_VOID)
  #define XPK_TERMEXPR_SCALARCTX    XPK_TERMEXPR_flags(XPK_TYPEFLAG_G_SCALAR)
  #define XPK_LISTEXPR_flags(flags) {.type = XS_PARSE_KEYWORD_LISTEXPR|(flags)}
  #define XPK_LISTEXPR              XPK_LISTEXPR_flags(0)
  #define XPK_LISTEXPR_LISTCTX      XPK_LISTEXPR_flags(XPK_TYPEFLAG_G_LIST)
  
  #define XPK_IDENT           {.type = XS_PARSE_KEYWORD_IDENT                       }
  #define XPK_IDENT_OPT       {.type = XS_PARSE_KEYWORD_IDENT      |XPK_TYPEFLAG_OPT}
  #define XPK_PACKAGENAME     {.type = XS_PARSE_KEYWORD_PACKAGENAME                 }
  #define XPK_PACKAGENAME_OPT {.type = XS_PARSE_KEYWORD_PACKAGENAME|XPK_TYPEFLAG_OPT}
  
  #define XPK_LEXVARNAME(kind) {.type = XS_PARSE_KEYWORD_LEXVARNAME, .u.c = kind}
  
  #define XPK_LEXVAR_MY(kind) {.type = XS_PARSE_KEYWORD_LEXVAR|XPK_TYPEFLAG_SPECIAL, .u.c = kind}
  
  #define XPK_ATTRIBUTES {.type = XS_PARSE_KEYWORD_ATTRS}
  
  #define XPK_VSTRING     {.type = XS_PARSE_KEYWORD_VSTRING}
  #define XPK_VSTRING_OPT {.type = XS_PARSE_KEYWORD_VSTRING|XPK_TYPEFLAG_OPT}
  
  #define XPK_COMMA  {.type = XS_PARSE_KEYWORD_LITERALCHAR, .u.c = ','}
  #define XPK_COLON  {.type = XS_PARSE_KEYWORD_LITERALCHAR, .u.c = ':'}
  #define XPK_EQUALS {.type = XS_PARSE_KEYWORD_LITERALCHAR, .u.c = '='}
  
  #define XPK_LITERAL(s) {.type = XS_PARSE_KEYWORD_LITERALSTR, .u.str = (const char *)s}
  #define XPK_STRING(s)  XPK_LITERAL(s)
  #define XPK_AUTOSEMI   {.type = XS_PARSE_KEYWORD_AUTOSEMI}
  #define XPK_KEYWORD(s) {.type = XS_PARSE_KEYWORD_LITERALSTR|XPK_TYPEFLAG_SPECIAL, .u.str = (const char *)s}
  
  #define XPK_INFIX(select) {.type = XS_PARSE_KEYWORD_INFIX, .u.c = select}
  #define XPK_INFIX_RELATION       XPK_INFIX(XPI_SELECT_RELATION)
  #define XPK_INFIX_EQUALITY       XPK_INFIX(XPI_SELECT_EQUALITY)
  #define XPK_INFIX_MATCH_NOSMART  XPK_INFIX(XPI_SELECT_MATCH_NOSMART)
  #define XPK_INFIX_MATCH_SMART    XPK_INFIX(XPI_SELECT_MATCH_SMART)
  
  #define XPK_SEQUENCE(...) \
    {.type = XS_PARSE_KEYWORD_SEQUENCE, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  /* First piece of these must be something probe-able */
  #define XPK_OPTIONAL(...) \
    {.type = XS_PARSE_KEYWORD_SEQUENCE|XPK_TYPEFLAG_OPT, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  #define XPK_REPEATED(...) \
    {.type = XS_PARSE_KEYWORD_REPEATED, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  /* Every piece must be probeable */
  #define XPK_CHOICE(...) \
    {.type = XS_PARSE_KEYWORD_CHOICE, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  /* Every piece must be probeable, and followed by XPK_TAG */
  #define XPK_TAGGEDCHOICE(...) \
    {.type = XS_PARSE_KEYWORD_TAGGEDCHOICE, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0}, {0} }}
  #define XPK_TAG(val) \
    {.type = val}
  #define XPK_COMMALIST(...) \
    {.type = XS_PARSE_KEYWORD_SEPARATEDLIST, .u.pieces = (const struct XSParseKeywordPieceType []){ \
        {.type = XS_PARSE_KEYWORD_LITERALCHAR, .u.c = ','}, __VA_ARGS__, {0}}}
  
  #define XPK_FAILURE(s) {.type = XS_PARSE_KEYWORD_FAILURE, .u.str = (const char *)s}
  
  #define XPK_PARENSCOPE(...) \
    {.type = XS_PARSE_KEYWORD_PARENSCOPE, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  #define XPK_PARENSCOPE_OPT(...) \
    {.type = XS_PARSE_KEYWORD_PARENSCOPE|XPK_TYPEFLAG_OPT, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  
  #define XPK_ARGSCOPE(...) \
    {.type = XS_PARSE_KEYWORD_PARENSCOPE|XPK_TYPEFLAG_MAYBEPARENS, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  
  #define XPK_BRACKETSCOPE(...) \
    {.type = XS_PARSE_KEYWORD_BRACKETSCOPE, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  #define XPK_BRACKETSCOPE_OPT(...) \
    {.type = XS_PARSE_KEYWORD_BRACKETSCOPE|XPK_TYPEFLAG_OPT, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  
  #define XPK_BRACESCOPE(...) \
    {.type = XS_PARSE_KEYWORD_BRACESCOPE, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  #define XPK_BRACESCOPE_OPT(...) \
    {.type = XS_PARSE_KEYWORD_BRACESCOPE|XPK_TYPEFLAG_OPT, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  
  #define XPK_CHEVRONSCOPE(...) \
    {.type = XS_PARSE_KEYWORD_CHEVRONSCOPE, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  #define XPK_CHEVRONSCOPE_OPT(...) \
    {.type = XS_PARSE_KEYWORD_CHEVRONSCOPE|XPK_TYPEFLAG_OPT, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  
  /* This type defined in XSParseInfix.h */
  typedef struct XSParseInfixInfo XSParseInfixInfo;
  
  typedef struct {
    union {
      OP *op;
      CV *cv;
      SV *sv;
      int i;
      struct { SV *name; SV *value; } attr;
      PADOFFSET padix;
      XSParseInfixInfo *infix;
    };
    int line;
  } XSParseKeywordPiece;
  
  struct XSParseKeywordHooks {
    U32 flags;
  
    /* used by build1 */
    struct XSParseKeywordPieceType piece1;
    /* alternatively, used by build */
    const struct XSParseKeywordPieceType *pieces;
  
    /* These two hooks are ANDed together; both must pass, if present */
    const char *permit_hintkey;
    bool (*permit) (pTHX_ void *hookdata);
  
    void (*check)(pTHX_ void *hookdata);
  
    /* These are alternatives; the first one defined is used */
    int (*parse)(pTHX_ OP **opp, void *hookdata);
    int (*build)(pTHX_ OP **out, XSParseKeywordPiece *args[], size_t nargs, void *hookdata);
    int (*build1)(pTHX_ OP **out, XSParseKeywordPiece *arg0, void *hookdata);
  };
  
  static void (*register_xs_parse_keyword_func)(pTHX_ const char *kwname, const struct XSParseKeywordHooks *hooks, void *hookdata);
  #define register_xs_parse_keyword(kwname, hooks, hookdata)  S_register_xs_parse_keyword(aTHX_ kwname, hooks, hookdata)
  static void S_register_xs_parse_keyword(pTHX_ const char *kwname, const struct XSParseKeywordHooks *hooks, void *hookdata)
  {
    if(!register_xs_parse_keyword_func)
      croak("Must call boot_xs_parse_keyword() first");
  
    (*register_xs_parse_keyword_func)(aTHX_ kwname, hooks, hookdata);
  }
  
  #define boot_xs_parse_keyword(ver) S_boot_xs_parse_keyword(aTHX_ ver)
  static void S_boot_xs_parse_keyword(pTHX_ double ver) {
    SV **svp;
    SV *versv = ver ? newSVnv(ver) : NULL;
  
    load_module(PERL_LOADMOD_NOIMPORT, newSVpvs("XS::Parse::Keyword"), versv, NULL);
  
    svp = hv_fetchs(PL_modglobal, "XS::Parse::Keyword/ABIVERSION_MIN", 0);
    if(!svp)
      croak("XS::Parse::Keyword ABI minimum version missing");
    int abi_ver = SvIV(*svp);
    if(abi_ver > XSPARSEKEYWORD_ABI_VERSION)
      croak("XS::Parse::Keyword ABI version mismatch - library supports >= %d, compiled for %d",
          abi_ver, XSPARSEKEYWORD_ABI_VERSION);
  
    svp = hv_fetchs(PL_modglobal, "XS::Parse::Keyword/ABIVERSION_MAX", 0);
    abi_ver = SvIV(*svp);
    if(abi_ver < XSPARSEKEYWORD_ABI_VERSION)
      croak("XS::Parse::Keyword ABI version mismatch - library supports <= %d, compiled for %d",
          abi_ver, XSPARSEKEYWORD_ABI_VERSION);
  
    register_xs_parse_keyword_func = INT2PTR(void (*)(pTHX_ const char *, const struct XSParseKeywordHooks *, void *),
        SvUV(*hv_fetchs(PL_modglobal, "XS::Parse::Keyword/register()@2", 0)));
  }
  
  #endif
X86_64-LINUX_XS_PARSE_KEYWORD_BUILDER_DATA

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


#  Author:  Nicholas Hubbard
#  WWW:     https://github.com/NicholasBHubbard/yabsm
#  License: MIT

#  This is the toplevel script of yabsm. The actual program that is
#  installed on the end users system is this script but fatpacked.

our $VERSION = '3.1.0';

use strict;
use warnings;
use v5.16.3;

sub usage {
    print <<END_USAGE;
usage: yabsm [--help] [--version] <command> <arg(s)>

  find, f <SUBJECT> <QUERY>               Find a snapshot of SUBJECT using
                                          QUERY. SUBJECT must be a backup or
                                          subvol defined in /etc/yabsmd.conf.

  check-config, c <?FILE>                 Check that FILE is a valid yabsm
                                          config file. If FILE is not specified
                                          then check /etc/yabsmd.conf. If errors
                                          are present print their messages to
                                          stderr and exit with non zero status,
                                          else print 'all good'.

  test-remote-config, tr <BACKUP>         Test that the remote BACKUP has been
                                          properly configured. For BACKUP to be
                                          properly configured yabsm should be
                                          able to connect to the remote host and
                                          use the btrfs command with sudo
                                          without having to enter any passwords.
                                          This is a root only command.

  bootstrap-backup, bootstrap <BACKUP>    Perform the boostrap phase of the
                                          btrfs incremental backup process for
                                          BACKUP. This is a root only command.

  print-subvols, subvols                  Print the names of all the subvols
                                          defined in /etc/yabsmd.conf.

  print-backups, backups                  Print the names of all the backups
                                          defined in /etc/yabsmd.conf.
END_USAGE
}

use lib::relative 'lib';

# Every command has their own module with a main() function
use Yabsm::Commands::Find;
use Yabsm::Commands::CheckConfig;
use Yabsm::Commands::TestRemoteBackupConfig;
use Yabsm::Commands::PrintSubvols;
use Yabsm::Commands::PrintBackups;

# command dispatch table
my %run_command =
   ( 'find'               => \&Yabsm::Commands::Find::main
   , 'check-config'       => \&Yabsm::Commands::CheckConfig::main
   , 'test-remote-config' => \&Yabsm::Commands::TestRemoteBackupConfig::main
   , 'print-crons'        => \&Yabsm::Commands::PrintCrons::main
   , 'print-subvols'      => \&Yabsm::Commands::PrintSubvols::main
   , 'print-backups'      => \&Yabsm::Commands::PrintBackups::main
   );

sub unabbreviate {

    # provide the user with command abbreviations

    my $cmd = shift // die;

    if    ($cmd eq 'f')         { return 'find'               }
    elsif ($cmd eq 'c')         { return 'check-config'       }
    elsif ($cmd eq 'tr')        { return 'test-remote-config' }
    elsif ($cmd eq 'crons')     { return 'print-crons'        }
    elsif ($cmd eq 'subvols')   { return 'print-subvols'      }
    elsif ($cmd eq 'backups')   { return 'print-backups'      }
    else                        { return $cmd                 }
}

                 ####################################
                 #               MAIN               #
                 ####################################

my $cmd = shift @ARGV || (usage() and exit 1);

if ($cmd eq '--help' || $cmd eq '-h') { usage() and exit 0 }

if ($cmd eq '--version') { say $VERSION and exit 0 }

my $full_cmd = unabbreviate($cmd);

if (not exists $run_command{ $full_cmd} ) {
    die "yabsm: error: no such command '$cmd'\n";
}

$run_command{ $full_cmd }->(@ARGV);

exit 0; # all good
