#!/usr/bin/env perl
# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/FatPacker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_FATPACKER';
  package App::FatPacker;use strict;use warnings FATAL=>'all';use 5.008001;use Getopt::Long;use Cwd qw(cwd);use File::Find qw(find);use File::Spec::Functions qw(catdir splitpath splitdir catpath rel2abs abs2rel);use File::Spec::Unix;use File::Copy qw(copy);use File::Path qw(mkpath rmtree);use B qw(perlstring);our$VERSION='0.010008';$VERSION=eval$VERSION;sub call_parser {my$self=shift;my ($args,$options)=@_;local*ARGV=[@{$args}];$self->{option_parser}->getoptions(@$options);return [@ARGV ]}sub lines_of {map +(chomp,$_)[1],do {local@ARGV=($_[0]);<>}}sub stripspace {my ($text)=@_;$text =~ /^(\s+)/ && $text =~ s/^$1//mg;$text}sub import {$_[1]&& $_[1]eq '-run_script' and return shift->new->run_script}sub new {bless {option_parser=>Getopt::Long::Parser->new(config=>[qw(require_order pass_through bundling no_auto_abbrev) ]),},$_[0]}sub run_script {my ($self,$args)=@_;my@args=$args ? @$args : @ARGV;(my$cmd=shift@args || 'help')=~ s/-/_/g;if (my$meth=$self->can("script_command_${cmd}")){$self->$meth(\@args)}else {die "No such command ${cmd}"}}sub script_command_help {print "Try `perldoc fatpack` for how to use me\n"}sub script_command_pack {my ($self,$args)=@_;my@modules=split /\r?\n/,$self->trace(args=>$args);my@packlists=$self->packlists_containing(\@modules);my$base=catdir(cwd,'fatlib');$self->packlists_to_tree($base,\@packlists);my$file=shift @$args;print$self->fatpack_file($file)}sub script_command_trace {my ($self,$args)=@_;$args=$self->call_parser($args=>['to=s'=>\my$file,'to-stderr'=>\my$to_stderr,'use=s'=>\my@additional_use ]);die "Can't use to and to-stderr on same call" if$file && $to_stderr;$file ||= 'fatpacker.trace';if (!$to_stderr and -e $file){unlink$file or die "Couldn't remove old trace file: $!"}my$arg=do {if ($to_stderr){">&STDERR"}elsif ($file){">>${file}"}};$self->trace(use=>\@additional_use,args=>$args,output=>$arg,)}sub trace {my ($self,%opts)=@_;my$output=$opts{output};my$trace_opts=join ',',$output||'>&STDOUT',@{$opts{use}||[]};local$ENV{PERL5OPT}=join ' ',($ENV{PERL5OPT}||()),'-MApp::FatPacker::Trace='.$trace_opts;my@args=@{$opts{args}||[]};if ($output){system $^X,@args;return}else {open my$out_fh,"$^X @args |";return do {local $/;<$out_fh>}}}sub script_command_packlists_for {my ($self,$args)=@_;for my$pl ($self->packlists_containing($args)){print "${pl}\n"}}sub packlists_containing {my ($self,$targets)=@_;my@targets;{local@INC=('lib',@INC);for my$t (@$targets){unless (eval {require$t;1}){warn "Failed to load ${t}: $@\n" ."Make sure you're not missing a packlist as a result\n";next}push@targets,$t}}my@search=grep -d $_,map catdir($_,'auto'),@INC;my%pack_rev;find({no_chdir=>1,wanted=>sub {return unless /[\\\/]\.packlist$/ && -f $_;$pack_rev{$_}=$File::Find::name for lines_of$File::Find::name},},@search);my%found;@found{map +($pack_rev{Cwd::abs_path($INC{$_})}||()),@targets}=();sort keys%found}sub script_command_tree {my ($self,$args)=@_;my$base=catdir(cwd,'fatlib');$self->packlists_to_tree($base,$args)}sub packlists_to_tree {my ($self,$where,$packlists)=@_;rmtree$where;mkpath$where;for my$pl (@$packlists){my ($vol,$dirs,$file)=splitpath$pl;my@dir_parts=splitdir$dirs;my$pack_base;PART: foreach my$p (0 .. $#dir_parts){if ($dir_parts[$p]eq 'auto'){my$version_lib=0+!!($dir_parts[$p-1]=~ /^[0-9.]+$/);$pack_base=catpath$vol,catdir@dir_parts[0..$p-(2+$version_lib)];last PART}}die "Couldn't figure out base path of packlist ${pl}" unless$pack_base;for my$source (lines_of$pl){next unless substr($source,0,length$pack_base)eq $pack_base;my$target=rel2abs(abs2rel($source,$pack_base),$where);my$target_dir=catpath((splitpath$target)[0,1]);mkpath$target_dir;copy$source=>$target}}}sub script_command_file {my ($self,$args)=@_;my$file=shift @$args;print$self->fatpack_file($file)}sub fatpack_file {my ($self,$file)=@_;my$shebang="";my$script="";if (defined$file and -r $file){($shebang,$script)=$self->load_main_script($file)}my@dirs=$self->collect_dirs();my%files;$self->collect_files($_,\%files)for@dirs;return join "\n",$shebang,$self->fatpack_code(\%files),$script}sub load_file {my ($self,$file)=@_;my$content=do {local (@ARGV,$/)=($file);<>};close ARGV;return$content}sub collect_dirs {my ($self)=@_;my$cwd=cwd;return grep -d,map rel2abs($_,$cwd),('lib','fatlib')}sub collect_files {my ($self,$dir,$files)=@_;find(sub {return unless -f $_;!/\.pm$/ and warn "File ${File::Find::name} isn't a .pm file - can't pack this -- if you hoped we were going to, things may not be what you expected later\n" and return;$files->{File::Spec::Unix->abs2rel($File::Find::name,$dir)}=$self->load_file($File::Find::name)},$dir)}sub load_main_script {my ($self,$file)=@_;open my$fh,"<",$file or die("Can't read $file: $!");my$shebang=<$fh>;my$script=join "",<$fh>;close$fh;unless (index($shebang,'#!')==0){$script=$shebang .$script;$shebang=""}return ($shebang,$script)}sub fatpack_start {return stripspace <<'  END_START'}sub fatpack_end {return stripspace <<'  END_END'}sub fatpack_code {my ($self,$files)=@_;my@segments=map {(my$stub=$_)=~ s/\.pm$//;my$name=uc join '_',split '/',$stub;my$data=$files->{$_};$data =~ s/^/  /mg;$data =~ s/(?<!\n)\z/\n/;'$fatpacked{'.perlstring($_).qq!} = '#line '.(1+__LINE__).' "'.__FILE__."\\"\\n".<<'${name}';\n! .qq!${data}${name}\n!}sort keys %$files;return join "\n",$self->fatpack_start,@segments,$self->fatpack_end}1;
      # This chunk of stuff was generated by App::FatPacker. To find the original
      # file's code, look for the end of this BEGIN block or the string 'FATPACK'
      BEGIN {
      my %fatpacked;
    END_START
      s/^  //mg for values %fatpacked;
  
      my $class = 'FatPacked::'.(0+\%fatpacked);
      no strict 'refs';
      *{"${class}::files"} = sub { keys %{$_[0]} };
  
      if ($] < 5.008) {
        *{"${class}::INC"} = sub {
          if (my $fat = $_[0]{$_[1]}) {
            my $pos = 0;
            my $last = length $fat;
            return (sub {
              return 0 if $pos == $last;
              my $next = (1 + index $fat, "\n", $pos) || $last;
              $_ .= substr $fat, $pos, $next - $pos;
              $pos = $next;
              return 1;
            });
          }
        };
      }
  
      else {
        *{"${class}::INC"} = sub {
          if (my $fat = $_[0]{$_[1]}) {
            open my $fh, '<', \$fat
              or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
            return $fh;
          }
          return;
        };
      }
  
      unshift @INC, bless \%fatpacked, $class;
    } # END OF FATPACK CODE
    END_END
APP_FATPACKER

$fatpacked{"App/FatPacker/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_FATPACKER_SIMPLE';
  package App::FatPacker::Simple;use strict;use warnings;use utf8;use App::FatPacker;use Config;use Cwd 'abs_path';use Distribution::Metadata;use File::Basename 'basename';use File::Find 'find';use File::Spec::Functions 'catdir';use File::Spec::Unix;use Getopt::Long qw(:config no_auto_abbrev no_ignore_case);use Perl::Strip;use Pod::Usage 1.33 ();our$VERSION='0.09';our$IGNORE_FILE=[qr/\.pod$/,qr/\.packlist$/,qr/MYMETA\.json$/,qr/install\.json$/,];sub new {my$class=shift;bless {@_},$class}sub parse_options {my$self=shift;local@ARGV=@_;GetOptions "d|dir=s"=>\(my$dir='lib,fatlib,local,extlib'),"e|exclude=s"=>\(my$exclude),"h|help"=>sub {$self->show_help;exit 1},"o|output=s"=>\(my$output),"q|quiet"=>\(my$quiet),"s|strict"=>\(my$strict),"v|version"=>sub {printf "%s %s\n",__PACKAGE__,__PACKAGE__->VERSION;exit},"color!"=>\(my$color=1),"shebang=s"=>\(my$custom_shebang),"exclude-strip=s@"=>\(my$exclude_strip),"no-strip|no-perl-strip"=>\(my$no_perl_strip),"cache=s"=>\(my$cache),or exit 1;$self->{script}=shift@ARGV or do {warn "Missing scirpt.\n";pod2usage(1)};$self->{dir}=$self->build_dir($dir);$self->{output}=$output;$self->{quiet}=$quiet;$self->{strict}=$strict;$self->{color}=$color;$self->{custom_shebang}=$custom_shebang;$self->{exclude_strip}=[map {qr/$_/}@{$exclude_strip || []}];$self->{exclude}=[];if (!$no_perl_strip){$self->{perl_strip}=Perl::Strip->new($cache ? (cache=>$cache): ())}if ($exclude){for my$e (split /,/,$exclude){my$dist=Distribution::Metadata->new_from_module($e,inc=>$self->{dir},);if (my$files=$dist->files){push @{$self->{exclude}},@$files}else {$self->warning("Missing $e in $dir")}}}$self}sub show_help {open my$fh,'>',\my$out;Pod::Usage::pod2usage exitval=>'noexit',input=>$0,output=>$fh,sections=>'SYNOPSIS|COMMANDS|OPTIONS|EXAMPLES',verbose=>99,;$out =~ s/^[ ]{4,6}/  /mg;$out =~ s/\n$//;print$out}sub warning {my ($self,$msg)=@_;chomp$msg;my$color=$self->{color}? sub {"\e[31m$_[0]\e[m","\n"}: sub {"$_[0]\n"};if ($self->{strict}){die$color->("=> ERROR $msg")}elsif (!$self->{quiet}){warn$color->("=> WARN $msg")}}sub debug {my ($self,$msg)=@_;chomp$msg;if (!$self->{quiet}){warn "-> $msg\n"}}sub output_filename {my$self=shift;return$self->{output}if$self->{output};my$script=basename$self->{script};my ($suffix,@other)=reverse split /\./,$script;if (!@other){"$script.fatpack"}else {unshift@other,"fatpack";join ".",reverse(@other),$suffix}}sub run {my$self=shift;my$fatpacked=$self->fatpack_file($self->{script});my$output_filename=$self->output_filename;open my$fh,">",$output_filename or die "Cannot open '$output_filename': $!\n";print {$fh}$fatpacked;close$fh;my$mode=(stat$self->{script})[2];chmod$mode,$output_filename;$self->debug("Successfully created $output_filename")}sub fatpack_file {my ($self,$file)=@_;my ($shebang,$script)=$self->load_main_script($file);$shebang=$self->{custom_shebang}if$self->{custom_shebang};my%files;$self->collect_files($_,\%files)for @{$self->{dir}};my$fatpacker=App::FatPacker->new;return join "\n",$shebang,$fatpacker->fatpack_code(\%files),$script}sub load_main_script {my ($self,$file)=@_;open my$fh,"<",$file or die "Cannot open '$file': $!\n";my@lines=<$fh>;my@shebang;if (@lines && index($lines[0],'#!')==0){while (1){push@shebang,shift@lines;last if$shebang[-1]=~ m{^\#\!.*perl}}}((join "",@shebang),(join "",@lines))}sub load_file {my ($self,$absolute,$relative,$original)=@_;my$content=do {open my$fh,"<",$absolute or die "Cannot open '$absolute': $!\n";local $/;<$fh>};if ($self->{perl_strip}and!grep {$original =~ $_}@{$self->{exclude_strip}}){$self->debug("fatpack $relative (with perl-strip)");return$self->{perl_strip}->strip($content)}else {$self->debug("fatpack $relative (without perl-strip)");return$content}}sub collect_files {my ($self,$dir,$files)=@_;my$absolute_dir=abs_path($dir);my$skip_dir=catdir($absolute_dir,$Config{archname});$skip_dir=qr/\Q$skip_dir\E/;my$find=sub {return unless -f $_;for my$ignore (@$IGNORE_FILE){$_ =~ $ignore and return}my$original=$_;my$absolute=abs_path($original);return if$absolute =~ $skip_dir;my$relative=File::Spec::Unix->abs2rel($absolute,$absolute_dir);for my$exclude (@{$self->{exclude}}){if ($absolute eq $exclude){$self->debug("exclude $relative");return}}if (!/\.(?:pm|ix|al|pl)$/){$self->warning("skip non perl module file $relative");return}$files->{$relative}=$self->load_file($absolute,$relative,$original)};find({wanted=>$find,no_chdir=>1},$dir)}sub build_dir {my ($self,$dir_string)=@_;my@dir;for my$d (grep -d,split /,/,$dir_string){my$try=catdir($d,"lib/perl5");if (-d $try){push@dir,$try,catdir($try,$Config{archname})}else {push@dir,$d,catdir($d,$Config{archname})}}return [grep -d,@dir ]}1;
APP_FATPACKER_SIMPLE

$fatpacked{"App/FatPacker/Simple/Tutorial.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_FATPACKER_SIMPLE_TUTORIAL';
  package App::FatPacker::Simple::Tutorial;use strict;use warnings;1;
APP_FATPACKER_SIMPLE_TUTORIAL

$fatpacked{"App/FatPacker/Trace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_FATPACKER_TRACE';
  package App::FatPacker::Trace;use strict;use warnings FATAL=>'all';use B ();my$trace_file;my%initial_inc;sub import {my (undef,$file,@extras)=@_;$trace_file=$file || '>>fatpacker.trace';%initial_inc=%INC;eval "use $_" for@extras;B::minus_c}CHECK {return unless$trace_file;open my$trace,$trace_file or die "Couldn't open $trace_file to trace to: $!";for my$inc (keys%INC){next if exists$initial_inc{$inc};next unless defined($INC{$inc})and $INC{$inc}=~ /\Q${inc}\E\Z/;print$trace "$inc\n"}}1;
APP_FATPACKER_TRACE

$fatpacked{"App/Prove.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROVE';
  package App::Prove;use strict;use warnings;use TAP::Harness::Env;use Text::ParseWords qw(shellwords);use File::Spec;use Getopt::Long;use App::Prove::State;use Carp;use base 'TAP::Object';our$VERSION='3.44';use constant IS_WIN32=>($^O =~ /^(MS)?Win32$/);use constant IS_VMS=>$^O eq 'VMS';use constant IS_UNIXY=>!(IS_VMS || IS_WIN32);use constant STATE_FILE=>IS_UNIXY ? '.prove' : '_prove';use constant RC_FILE=>IS_UNIXY ? '.proverc' : '_proverc';use constant PLUGINS=>'App::Prove::Plugin';my@ATTR;BEGIN {@ATTR=qw(archive argv blib show_count color directives exec failures comments formatter harness includes modules plugins jobs lib merge parse quiet really_quiet recurse backwards shuffle taint_fail taint_warn timer verbose warnings_fail warnings_warn show_help show_man show_version state_class test_args state dry extensions ignore_exit rules state_manager normalize sources tapversion trap statefile);__PACKAGE__->mk_methods(@ATTR)}sub _initialize {my$self=shift;my$args=shift || {};my@is_array=qw(argv rc_opts includes modules state plugins rules sources);for my$key (@is_array){$self->{$key}=[]}for my$attr (@ATTR){if (exists$args->{$attr}){$self->{$attr}=$args->{$attr}}}$self->state_class('App::Prove::State');return$self}sub add_rc_file {my ($self,$rc_file)=@_;local*RC;open RC,"<$rc_file" or croak "Can't read $rc_file ($!)";while (defined(my$line=<RC>)){push @{$self->{rc_opts}},grep {defined and not /^#/}$line =~ m{ ' ([^']*) ' | " ([^"]*) " | (\#.*) | (\S+) }xg}close RC}sub process_args {my$self=shift;my@rc=RC_FILE;unshift@rc,glob '~/' .RC_FILE if IS_UNIXY;my@args;while (defined(my$arg=shift)){if ($arg eq '--norc'){@rc=()}elsif ($arg eq '--rc'){defined(my$rc=shift)or croak "Missing argument to --rc";push@rc,$rc}elsif ($arg =~ m{^--rc=(.+)$}){push@rc,$1}else {push@args,$arg}}if (defined(my$stop_at=_first_pos('::',@args))){my@test_args=splice@args,$stop_at;shift@test_args;$self->{test_args}=\@test_args}$self->add_rc_file($_)for grep -f,@rc;unshift@args,@{$self->{rc_opts}};if (my@bad=map {"-$_"}grep {/^-(man|help)$/}@args){die "Long options should be written with two dashes: ",join(', ',@bad),"\n"}{local@ARGV=@args;Getopt::Long::Configure(qw(no_ignore_case bundling pass_through));GetOptions('v|verbose'=>\$self->{verbose},'f|failures'=>\$self->{failures},'o|comments'=>\$self->{comments},'l|lib'=>\$self->{lib},'b|blib'=>\$self->{blib},'s|shuffle'=>\$self->{shuffle},'color!'=>\$self->{color},'colour!'=>\$self->{color},'count!'=>\$self->{show_count},'c'=>\$self->{color},'D|dry'=>\$self->{dry},'ext=s@'=>sub {my ($opt,$val)=@_;push @{$self->{extensions}||= []},$val},'harness=s'=>\$self->{harness},'ignore-exit'=>\$self->{ignore_exit},'source=s@'=>$self->{sources},'formatter=s'=>\$self->{formatter},'r|recurse'=>\$self->{recurse},'reverse'=>\$self->{backwards},'p|parse'=>\$self->{parse},'q|quiet'=>\$self->{quiet},'Q|QUIET'=>\$self->{really_quiet},'e|exec=s'=>\$self->{exec},'m|merge'=>\$self->{merge},'I=s@'=>$self->{includes},'M=s@'=>$self->{modules},'P=s@'=>$self->{plugins},'state=s@'=>$self->{state},'statefile=s'=>\$self->{statefile},'directives'=>\$self->{directives},'h|help|?'=>\$self->{show_help},'H|man'=>\$self->{show_man},'V|version'=>\$self->{show_version},'a|archive=s'=>\$self->{archive},'j|jobs=i'=>\$self->{jobs},'timer'=>\$self->{timer},'T'=>\$self->{taint_fail},'t'=>\$self->{taint_warn},'W'=>\$self->{warnings_fail},'w'=>\$self->{warnings_warn},'normalize'=>\$self->{normalize},'rules=s@'=>$self->{rules},'tapversion=s'=>\$self->{tapversion},'trap'=>\$self->{trap},)or croak('Unable to continue');$self->{argv}=[@ARGV]}return}sub _first_pos {my$want=shift;for (0 .. $#_){return $_ if $_[$_]eq $want}return}sub _help {my ($self,$verbosity)=@_;eval('use Pod::Usage 1.12 ()');if (my$err=$@){die 'Please install Pod::Usage for the --help option ' .'(or try `perldoc prove`.)' ."\n ($@)"}Pod::Usage::pod2usage({-verbose=>$verbosity });return}sub _color_default {my$self=shift;return -t STDOUT &&!$ENV{HARNESS_NOTTY}}sub _get_args {my$self=shift;my%args;$args{trap}=1 if$self->trap;if (defined$self->color ? $self->color : $self->_color_default){$args{color}=1}if (!defined$self->show_count){$args{show_count}=1}else {$args{show_count}=$self->show_count}if ($self->archive){$self->require_harness(archive=>'TAP::Harness::Archive');$args{archive}=$self->archive}if (my$jobs=$self->jobs){$args{jobs}=$jobs}if (my$harness_opt=$self->harness){$self->require_harness(harness=>$harness_opt)}if (my$formatter=$self->formatter){$args{formatter_class}=$formatter}for my$handler (@{$self->sources}){my ($name,$config)=$self->_parse_source($handler);$args{sources}->{$name}=$config}if ($self->ignore_exit){$args{ignore_exit}=1}if ($self->taint_fail && $self->taint_warn){die '-t and -T are mutually exclusive'}if ($self->warnings_fail && $self->warnings_warn){die '-w and -W are mutually exclusive'}for my$a (qw(lib switches)){my$method="_get_$a";my$val=$self->$method();$args{$a}=$val if defined$val}my%verb_map=(verbose=>1,quiet=>-1,really_quiet=>-2,);my@verb_adj=map {$self->$_()? $verb_map{$_}: ()}keys%verb_map;die "Only one of verbose, quiet or really_quiet should be specified\n" if@verb_adj > 1;$args{verbosity}=shift@verb_adj if@verb_adj;for my$a (qw(merge failures comments timer directives normalize)){$args{$a}=1 if$self->$a()}$args{errors}=1 if$self->parse;$args{exec}=[split(/\s+/,$self->exec)]if (defined($self->exec));$args{version}=$self->tapversion if defined($self->tapversion);if (defined(my$test_args=$self->test_args)){$args{test_args}=$test_args}if (@{$self->rules}){my@rules;for (@{$self->rules}){if (/^par=(.*)/){push@rules,$1}elsif (/^seq=(.*)/){push@rules,{seq=>$1 }}}$args{rules}={par=>[@rules]}}$args{harness_class}=$self->{harness_class}if$self->{harness_class};return \%args}sub _find_module {my ($self,$class,@search)=@_;croak "Bad module name $class" unless$class =~ /^ \w+ (?: :: \w+ ) *$/x;for my$pfx (@search){my$name=join('::',$pfx,$class);eval "require $name";return$name unless $@}eval "require $class";return$class unless $@;return}sub _load_extension {my ($self,$name,@search)=@_;my@args=();if ($name =~ /^(.*?)=(.*)/){$name=$1;@args=split(/,/,$2)}if (my$class=$self->_find_module($name,@search)){$class->import(@args);if ($class->can('load')){$class->load({app_prove=>$self,args=>[@args]})}}else {croak "Can't load module $name"}}sub _load_extensions {my ($self,$ext,@search)=@_;$self->_load_extension($_,@search)for @$ext}sub _parse_source {my ($self,$handler)=@_;(my$opt_name=lc$handler)=~ s/::/-/g;local@ARGV=@{$self->{argv}};my%config;Getopt::Long::GetOptions("$opt_name-option=s%"=>sub {my ($name,$k,$v)=@_;if ($v =~ /(?<!\\)=/){croak "Option $name must be consistently used as a hash" if exists$config{$k}&& ref$config{$k}ne 'HASH';$config{$k}||= {};my ($hk,$hv)=split /(?<!\\)=/,$v,2;$config{$k}{$hk}=$hv}else {$v =~ s/\\=/=/g;if (exists$config{$k}){$config{$k}=[$config{$k}]unless ref$config{$k}eq 'ARRAY';push @{$config{$k}}=>$v}else {$config{$k}=$v}}});$self->{argv}=\@ARGV;return ($handler,\%config)}sub run {my$self=shift;unless ($self->state_manager){$self->state_manager($self->state_class->new({store=>$self->statefile || STATE_FILE }))}if ($self->show_help){$self->_help(1)}elsif ($self->show_man){$self->_help(2)}elsif ($self->show_version){$self->print_version}elsif ($self->dry){print "$_\n" for$self->_get_tests}else {$self->_load_extensions($self->modules);$self->_load_extensions($self->plugins,PLUGINS);local$ENV{TEST_VERBOSE}=1 if$self->verbose;return$self->_runtests($self->_get_args,$self->_get_tests)}return 1}sub _get_tests {my$self=shift;my$state=$self->state_manager;my$ext=$self->extensions;$state->extensions($ext)if defined$ext;if (defined(my$state_switch=$self->state)){$state->apply_switch(@$state_switch)}my@tests=$state->get_tests($self->recurse,@{$self->argv});$self->_shuffle(@tests)if$self->shuffle;@tests=reverse@tests if$self->backwards;return@tests}sub _runtests {my ($self,$args,@tests)=@_;my$harness=TAP::Harness::Env->create($args);my$state=$self->state_manager;$harness->callback(after_test=>sub {$state->observe_test(@_)});$harness->callback(after_runtests=>sub {$state->commit(@_)});my$aggregator=$harness->runtests(@tests);return!$aggregator->has_errors}sub _get_switches {my$self=shift;my@switches;if ($self->taint_fail){push@switches,'-T'}elsif ($self->taint_warn){push@switches,'-t'}if ($self->warnings_fail){push@switches,'-W'}elsif ($self->warnings_warn){push@switches,'-w'}return@switches ? \@switches : ()}sub _get_lib {my$self=shift;my@libs;if ($self->lib){push@libs,'lib'}if ($self->blib){push@libs,'blib/lib','blib/arch'}if (@{$self->includes}){push@libs,@{$self->includes}}@libs=map {File::Spec->rel2abs($_)}@libs;return@libs ? \@libs : ()}sub _shuffle {my$self=shift;my$i=@_;while ($i){my$j=rand$i--;@_[$i,$j ]=@_[$j,$i ]}return}sub require_harness {my ($self,$for,$class)=@_;my ($class_name)=$class =~ /^(\w+(?:::\w+)*)/;$class =~ s!^(\w+(?:::\w+)*)=(.*)$!$1 split(/,/,q{$2})!;eval("use $class;");die "$class_name is required to use the --$for feature: $@" if $@;$self->{harness_class}=$class_name;return}sub print_version {my$self=shift;require TAP::Harness;printf("TAP::Harness v%s and Perl v%vd\n",$TAP::Harness::VERSION,$^V);return}1;
APP_PROVE

$fatpacked{"App/Prove/State.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROVE_STATE';
  package App::Prove::State;use strict;use warnings;use File::Find;use File::Spec;use Carp;use App::Prove::State::Result;use TAP::Parser::YAMLish::Reader ();use TAP::Parser::YAMLish::Writer ();use base 'TAP::Base';BEGIN {__PACKAGE__->mk_methods('result_class')}use constant IS_WIN32=>($^O =~ /^(MS)?Win32$/);use constant NEED_GLOB=>IS_WIN32;our$VERSION='3.44';sub new {my$class=shift;my%args=%{shift || {}};my$self=bless {select=>[],seq=>1,store=>delete$args{store},extensions=>(delete$args{extensions}|| ['.t']),result_class=>(delete$args{result_class}|| 'App::Prove::State::Result'),},$class;$self->{_}=$self->result_class->new({tests=>{},generation=>1,});my$store=$self->{store};$self->load($store)if defined$store && -f $store;return$self}sub extensions {my$self=shift;$self->{extensions}=shift if @_;return$self->{extensions}}sub results {my$self=shift;$self->{_}|| $self->result_class->new}sub commit {my$self=shift;if ($self->{should_save}){$self->save}}sub apply_switch {my$self=shift;my@opts=@_;my$last_gen=$self->results->generation - 1;my$last_run_time=$self->results->last_run_time;my$now=$self->get_time;my@switches=map {split /,/}@opts;my%handler=(last=>sub {$self->_select(limit=>shift,where=>sub {$_->generation >= $last_gen},order=>sub {$_->sequence})},failed=>sub {$self->_select(limit=>shift,where=>sub {$_->result!=0},order=>sub {-$_->result})},passed=>sub {$self->_select(limit=>shift,where=>sub {$_->result==0})},all=>sub {$self->_select(limit=>shift)},todo=>sub {$self->_select(limit=>shift,where=>sub {$_->num_todo!=0},order=>sub {-$_->num_todo})},hot=>sub {$self->_select(limit=>shift,where=>sub {defined $_->last_fail_time},order=>sub {$now - $_->last_fail_time})},slow=>sub {$self->_select(limit=>shift,order=>sub {-$_->elapsed})},fast=>sub {$self->_select(limit=>shift,order=>sub {$_->elapsed})},new=>sub {$self->_select(limit=>shift,order=>sub {-$_->mtime})},old=>sub {$self->_select(limit=>shift,order=>sub {$_->mtime})},fresh=>sub {$self->_select(limit=>shift,where=>sub {$_->mtime >= $last_run_time})},save=>sub {$self->{should_save}++},adrian=>sub {unshift@switches,qw(hot all save)},);while (defined(my$ele=shift@switches)){my ($opt,$arg)=($ele =~ /^([^:]+):(.*)/)? ($1,$2): ($ele,undef);my$code=$handler{$opt}|| croak "Illegal state option: $opt";$code->($arg)}return}sub _select {my ($self,%spec)=@_;push @{$self->{select}},\%spec}sub get_tests {my$self=shift;my$recurse=shift;my@argv=@_;my%seen;my@selected=$self->_query;unless (@argv || @{$self->{select}}){@argv=$recurse ? '.' : 't';croak qq{No tests named and '@argv' directory not found} unless -d $argv[0]}push@selected,$self->_get_raw_tests($recurse,@argv)if@argv;return grep {!$seen{$_}++}@selected}sub _query {my$self=shift;if (my@sel=@{$self->{select}}){warn "No saved state, selection will be empty\n" unless$self->results->num_tests;return map {$self->_query_clause($_)}@sel}return}sub _query_clause {my ($self,$clause)=@_;my@got;my$results=$self->results;my$where=$clause->{where}|| sub {1};for my$name ($results->test_names){next unless -f $name;local $_=$results->test($name);push@got,$name if$where->()}if (my$order=$clause->{order}){@got=map {$_->[0]}sort {(defined$b->[1]<=> defined$a->[1])|| (($a->[1]|| 0)<=> ($b->[1]|| 0))}map {[$_,do {local $_=$results->test($_);$order->()}]}@got}if (my$limit=$clause->{limit}){@got=splice@got,0,$limit if@got > $limit}return@got}sub _get_raw_tests {my$self=shift;my$recurse=shift;my@argv=@_;my@tests;if (NEED_GLOB){eval "use File::Glob::Windows";@argv=map {glob "$_"}@argv}my$extensions=$self->{extensions};for my$arg (@argv){if ('-' eq $arg){push@argv=><STDIN>;chomp(@argv);next}push@tests,sort -d $arg ? $recurse ? $self->_expand_dir_recursive($arg,$extensions): map {glob(File::Spec->catfile($arg,"*$_"))}@{$extensions}: $arg}return@tests}sub _expand_dir_recursive {my ($self,$dir,$extensions)=@_;my@tests;my$ext_string=join('|',map {quotemeta}@{$extensions});find({follow=>1,follow_skip=>2,wanted=>sub {-f && /(?:$ext_string)$/ && push@tests=>$File::Find::name}},$dir);return@tests}sub observe_test {my ($self,$test_info,$parser)=@_;my$name=$test_info->[0];my$fail=scalar($parser->failed)+ ($parser->has_problems ? 1 : 0);my$todo=scalar($parser->todo);my$start_time=$parser->start_time;my$end_time=$parser->end_time,my$test=$self->results->test($name);$test->sequence($self->{seq}++);$test->generation($self->results->generation);$test->run_time($end_time);$test->result($fail);$test->num_todo($todo);$test->elapsed($end_time - $start_time);$test->parser($parser);if ($fail){$test->total_failures($test->total_failures + 1);$test->last_fail_time($end_time)}else {$test->total_passes($test->total_passes + 1);$test->last_pass_time($end_time)}}sub save {my ($self)=@_;my$store=$self->{store}or return;$self->results->last_run_time($self->get_time);my$writer=TAP::Parser::YAMLish::Writer->new;local*FH;open FH,">$store" or croak "Can't write $store ($!)";$writer->write($self->results->raw,\*FH);close FH}sub load {my ($self,$name)=@_;my$reader=TAP::Parser::YAMLish::Reader->new;local*FH;open FH,"<$name" or croak "Can't read $name ($!)";$self->{_}=$self->result_class->new($reader->read(sub {my$line=<FH>;defined$line && chomp$line;return$line}));close FH;$self->_regen_seq;$self->_prune_and_stamp;$self->results->generation($self->results->generation + 1)}sub _prune_and_stamp {my$self=shift;my$results=$self->results;my@tests=$self->results->tests;for my$test (@tests){my$name=$test->name;if (my@stat=stat$name){$test->mtime($stat[9])}else {$results->remove($name)}}}sub _regen_seq {my$self=shift;for my$test ($self->results->tests){$self->{seq}=$test->sequence + 1 if defined$test->sequence && $test->sequence >= $self->{seq}}}1;
APP_PROVE_STATE

$fatpacked{"App/Prove/State/Result.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROVE_STATE_RESULT';
  package App::Prove::State::Result;use strict;use warnings;use Carp 'croak';use App::Prove::State::Result::Test;use constant STATE_VERSION=>1;our$VERSION='3.44';sub new {my ($class,$arg_for)=@_;$arg_for ||= {};my%instance_data=%$arg_for;$instance_data{version}=$class->state_version;my$tests=delete$instance_data{tests}|| {};my$self=bless \%instance_data=>$class;$self->_initialize($tests);return$self}sub _initialize {my ($self,$tests)=@_;my%tests;while (my ($name,$test)=each %$tests){$tests{$name}=$self->test_class->new({%$test,name=>$name })}$self->tests(\%tests);return$self}sub state_version {STATE_VERSION}sub test_class {return 'App::Prove::State::Result::Test'}my%methods=(generation=>{method=>'generation',default=>0 },last_run_time=>{method=>'last_run_time',default=>undef },);while (my ($key,$description)=each%methods){my$default=$description->{default};no strict 'refs';*{$description->{method}}=sub {my$self=shift;if (@_){$self->{$key}=shift;return$self}return$self->{$key}|| $default}}sub tests {my$self=shift;if (@_){$self->{tests}=shift;return$self}my%tests=%{$self->{tests}};my@tests=sort {$a->sequence <=> $b->sequence}values%tests;return wantarray ? @tests : \@tests}sub test {my ($self,$name)=@_;croak("test() requires a test name")unless defined$name;my$tests=$self->{tests}||= {};if (my$test=$tests->{$name}){return$test}else {my$test=$self->test_class->new({name=>$name });$self->{tests}->{$name}=$test;return$test}}sub test_names {my$self=shift;return map {$_->name}$self->tests}sub remove {my ($self,$name)=@_;delete$self->{tests}->{$name};return$self}sub num_tests {keys %{shift->{tests}}}sub raw {my$self=shift;my%raw=%$self;my%tests;for my$test ($self->tests){$tests{$test->name }=$test->raw}$raw{tests}=\%tests;return \%raw}1;
APP_PROVE_STATE_RESULT

$fatpacked{"App/Prove/State/Result/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROVE_STATE_RESULT_TEST';
  package App::Prove::State::Result::Test;use strict;use warnings;our$VERSION='3.44';my%methods=(name=>{method=>'name' },elapsed=>{method=>'elapsed',default=>0 },gen=>{method=>'generation',default=>1 },last_pass_time=>{method=>'last_pass_time',default=>undef },last_fail_time=>{method=>'last_fail_time',default=>undef },last_result=>{method=>'result',default=>0 },last_run_time=>{method=>'run_time',default=>undef },last_todo=>{method=>'num_todo',default=>0 },mtime=>{method=>'mtime',default=>undef },seq=>{method=>'sequence',default=>1 },total_passes=>{method=>'total_passes',default=>0 },total_failures=>{method=>'total_failures',default=>0 },parser=>{method=>'parser' },);while (my ($key,$description)=each%methods){my$default=$description->{default};no strict 'refs';*{$description->{method}}=sub {my$self=shift;if (@_){$self->{$key}=shift;return$self}return$self->{$key}|| $default}}sub new {my ($class,$arg_for)=@_;$arg_for ||= {};bless$arg_for=>$class}sub raw {my$self=shift;my%raw=%$self;delete$raw{name};delete$raw{parser};return \%raw}1;
APP_PROVE_STATE_RESULT_TEST

$fatpacked{"Array/Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARRAY_UTILS';
  package Array::Utils;use strict;require Exporter;our@ISA=qw(Exporter);our%EXPORT_TAGS=(all=>[qw(&unique &intersect &array_diff &array_minus) ],);our@EXPORT_OK=(@{$EXPORT_TAGS{'all'}});our$VERSION='0.5';sub unique(@) {return keys %{{map {$_=>undef}@_}}}sub intersect(\@\@) {my%e=map {$_=>undef}@{$_[0]};return grep {exists($e{$_})}@{$_[1]}}sub array_diff(\@\@) {my%e=map {$_=>undef}@{$_[1]};return @{[(grep {(exists$e{$_})? (delete$e{$_}): (1)}@{$_[0]}),keys%e ]}}sub array_minus(\@\@) {my%e=map{$_=>undef}@{$_[1]};return grep(!exists($e{$_}),@{$_[0]})}1;
ARRAY_UTILS

$fatpacked{"CPAN/DistnameInfo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_DISTNAMEINFO';
  package CPAN::DistnameInfo;$VERSION="0.12";use strict;sub distname_info {my$file=shift or return;my ($dist,$version)=$file =~ /^
      ((?:[-+.]*(?:[A-Za-z0-9]+|(?<=\D)_|_(?=\D))*
       (?:
  	[A-Za-z](?=[^A-Za-z]|$)
  	|
  	\d(?=-)
       )(?<![._-][vV])
      )+)(.*)
    $/xs or return ($file,undef,undef);if ($dist =~ /-undef\z/ and!length$version){$dist =~ s/-undef\z//}$version =~ s/-withoutworldwriteables$//;if ($version =~ /^(-[Vv].*)-(\d.*)/){$dist .= $1;$version=$2}if ($version =~ /(.+_.*)-(\d.*)/){$dist .= $1;$version=$2}$dist =~ s{\.pm$}{};$version=$1 if!length$version and $dist =~ s/-(\d+\w)$//;$version=$1 .$version if$version =~ /^\d+$/ and $dist =~ s/-(\w+)$//;if ($version =~ /\d\.\d/){$version =~ s/^[-_.]+//}else {$version =~ s/^[-_]+//}my$dev;if (length$version){if ($file =~ /^perl-?\d+\.(\d+)(?:\D(\d+))?(-(?:TRIAL|RC)\d+)?$/){$dev=1 if (($1 > 6 and $1 & 1)or ($2 and $2 >= 50))or $3}elsif ($version =~ /\d\D\d+_\d/ or $version =~ /-TRIAL/){$dev=1}}else {$version=undef}($dist,$version,$dev)}sub new {my$class=shift;my$distfile=shift;$distfile =~ s,//+,/,g;my%info=(pathname=>$distfile);($info{filename}=$distfile)=~ s,^(((.*?/)?authors/)?id/)?([A-Z])/(\4[A-Z])/(\5[-A-Z0-9]*)/,, and $info{cpanid}=$6;if ($distfile =~ m,([^/]+)\.(tar\.(?:g?z|bz2)|zip|tgz)$,i){$info{distvname}=$1;$info{extension}=$2}@info{qw(dist version beta)}=distname_info($info{distvname});$info{maturity}=delete$info{beta}? 'developer' : 'released';return bless \%info,$class}sub dist {shift->{dist}}sub version {shift->{version}}sub maturity {shift->{maturity}}sub filename {shift->{filename}}sub cpanid {shift->{cpanid}}sub distvname {shift->{distvname}}sub extension {shift->{extension}}sub pathname {shift->{pathname}}sub properties {%{$_[0]}}1;
CPAN_DISTNAMEINFO

$fatpacked{"CPAN/Meta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META';
  use 5.006;use strict;use warnings;package CPAN::Meta;our$VERSION='2.150010';use Carp qw(carp croak);use CPAN::Meta::Feature;use CPAN::Meta::Prereqs;use CPAN::Meta::Converter;use CPAN::Meta::Validator;use Parse::CPAN::Meta 1.4414 ();BEGIN {*_dclone=\&CPAN::Meta::Converter::_dclone}BEGIN {my@STRING_READERS=qw(abstract description dynamic_config generated_by name release_status version);no strict 'refs';for my$attr (@STRING_READERS){*$attr=sub {$_[0]{$attr }}}}BEGIN {my@LIST_READERS=qw(author keywords license);no strict 'refs';for my$attr (@LIST_READERS){*$attr=sub {my$value=$_[0]{$attr };croak "$attr must be called in list context" unless wantarray;return @{_dclone($value)}if ref$value;return$value}}}sub authors {$_[0]->author}sub licenses {$_[0]->license}BEGIN {my@MAP_READERS=qw(meta-spec resources provides no_index prereqs optional_features);no strict 'refs';for my$attr (@MAP_READERS){(my$subname=$attr)=~ s/-/_/;*$subname=sub {my$value=$_[0]{$attr };return _dclone($value)if$value;return {}}}}sub custom_keys {return grep {/^x_/i}keys %{$_[0]}}sub custom {my ($self,$attr)=@_;my$value=$self->{$attr};return _dclone($value)if ref$value;return$value}sub _new {my ($class,$struct,$options)=@_;my$self;if ($options->{lazy_validation}){my$cmc=CPAN::Meta::Converter->new($struct);$self=$cmc->convert(version=>2);return bless$self,$class}else {my$cmv=CPAN::Meta::Validator->new($struct);unless ($cmv->is_valid){die "Invalid metadata structure. Errors: " .join(", ",$cmv->errors)."\n"}}my$version=$struct->{'meta-spec'}{version}|| '1.0';if ($version==2){$self=$struct}else {my$cmc=CPAN::Meta::Converter->new($struct);$self=$cmc->convert(version=>2)}return bless$self,$class}sub new {my ($class,$struct,$options)=@_;my$self=eval {$class->_new($struct,$options)};croak($@)if $@;return$self}sub create {my ($class,$struct,$options)=@_;my$version=__PACKAGE__->VERSION || 2;$struct->{generated_by}||= __PACKAGE__ ." version $version" ;$struct->{'meta-spec'}{version}||= int($version);my$self=eval {$class->_new($struct,$options)};croak ($@)if $@;return$self}sub load_file {my ($class,$file,$options)=@_;$options->{lazy_validation}=1 unless exists$options->{lazy_validation};croak "load_file() requires a valid, readable filename" unless -r $file;my$self;eval {my$struct=Parse::CPAN::Meta->load_file($file);$self=$class->_new($struct,$options)};croak($@)if $@;return$self}sub load_yaml_string {my ($class,$yaml,$options)=@_;$options->{lazy_validation}=1 unless exists$options->{lazy_validation};my$self;eval {my ($struct)=Parse::CPAN::Meta->load_yaml_string($yaml);$self=$class->_new($struct,$options)};croak($@)if $@;return$self}sub load_json_string {my ($class,$json,$options)=@_;$options->{lazy_validation}=1 unless exists$options->{lazy_validation};my$self;eval {my$struct=Parse::CPAN::Meta->load_json_string($json);$self=$class->_new($struct,$options)};croak($@)if $@;return$self}sub load_string {my ($class,$string,$options)=@_;$options->{lazy_validation}=1 unless exists$options->{lazy_validation};my$self;eval {my$struct=Parse::CPAN::Meta->load_string($string);$self=$class->_new($struct,$options)};croak($@)if $@;return$self}sub save {my ($self,$file,$options)=@_;my$version=$options->{version}|| '2';my$layer=$] ge '5.008001' ? ':utf8' : '';if ($version ge '2'){carp "'$file' should end in '.json'" unless$file =~ m{\.json$}}else {carp "'$file' should end in '.yml'" unless$file =~ m{\.yml$}}my$data=$self->as_string($options);open my$fh,">$layer",$file or die "Error opening '$file' for writing: $!\n";print {$fh}$data;close$fh or die "Error closing '$file': $!\n";return 1}sub meta_spec_version {my ($self)=@_;return$self->meta_spec->{version}}sub effective_prereqs {my ($self,$features)=@_;$features ||= [];my$prereq=CPAN::Meta::Prereqs->new($self->prereqs);return$prereq unless @$features;my@other=map {;$self->feature($_)->prereqs}@$features;return$prereq->with_merged_prereqs(\@other)}sub should_index_file {my ($self,$filename)=@_;for my$no_index_file (@{$self->no_index->{file}|| []}){return if$filename eq $no_index_file}for my$no_index_dir (@{$self->no_index->{directory}}){$no_index_dir =~ s{$}{/} unless$no_index_dir =~ m{/\z};return if index($filename,$no_index_dir)==0}return 1}sub should_index_package {my ($self,$package)=@_;for my$no_index_pkg (@{$self->no_index->{package}|| []}){return if$package eq $no_index_pkg}for my$no_index_ns (@{$self->no_index->{namespace}}){return if index($package,"${no_index_ns}::")==0}return 1}sub features {my ($self)=@_;my$opt_f=$self->optional_features;my@features=map {;CPAN::Meta::Feature->new($_=>$opt_f->{$_ })}keys %$opt_f;return@features}sub feature {my ($self,$ident)=@_;croak "no feature named $ident" unless my$f=$self->optional_features->{$ident };return CPAN::Meta::Feature->new($ident,$f)}sub as_struct {my ($self,$options)=@_;my$struct=_dclone($self);if ($options->{version}){my$cmc=CPAN::Meta::Converter->new($struct);$struct=$cmc->convert(version=>$options->{version})}return$struct}sub as_string {my ($self,$options)=@_;my$version=$options->{version}|| '2';my$struct;if ($self->meta_spec_version ne $version){my$cmc=CPAN::Meta::Converter->new($self->as_struct);$struct=$cmc->convert(version=>$version)}else {$struct=$self->as_struct}my ($data,$backend);if ($version ge '2'){$backend=Parse::CPAN::Meta->json_backend();local$struct->{x_serialization_backend}=sprintf '%s version %s',$backend,$backend->VERSION;$data=$backend->new->pretty->canonical->encode($struct)}else {$backend=Parse::CPAN::Meta->yaml_backend();local$struct->{x_serialization_backend}=sprintf '%s version %s',$backend,$backend->VERSION;$data=eval {no strict 'refs';&{"$backend\::Dump"}($struct)};if ($@){croak$backend->can('errstr')? $backend->errstr : $@}}return$data}sub TO_JSON {return {%{$_[0]}}}1;
CPAN_META

$fatpacked{"CPAN/Meta/Converter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_CONVERTER';
  use 5.006;use strict;use warnings;package CPAN::Meta::Converter;our$VERSION='2.150010';use CPAN::Meta::Validator;use CPAN::Meta::Requirements;use Parse::CPAN::Meta 1.4400 ();BEGIN {eval "use version ()";if (my$err=$@){eval "use ExtUtils::MakeMaker::version" or die$err}}*_is_qv=version->can('is_qv')? sub {$_[0]->is_qv}: sub {exists $_[0]->{qv}};our$DCLONE_MAXDEPTH=1024;our$_CLONE_DEPTH;sub _dclone {my ($ref)=@_;return$ref unless my$reftype=ref$ref;local$_CLONE_DEPTH=defined$_CLONE_DEPTH ? $_CLONE_DEPTH - 1 : $DCLONE_MAXDEPTH;die "Depth Limit $DCLONE_MAXDEPTH Exceeded" if$_CLONE_DEPTH==0;return [map {_dclone($_)}@{$ref}]if 'ARRAY' eq $reftype;return {map {$_=>_dclone($ref->{$_})}keys %{$ref}}if 'HASH' eq $reftype;if ('SCALAR' eq $reftype){my$new=_dclone(${$ref});return \$new}if (eval {$ref->can('TO_JSON')}){my$data=$ref->TO_JSON;return ref$data ? _dclone($data): $data}return "$ref"}my%known_specs=('2'=>'http://search.cpan.org/perldoc?CPAN::Meta::Spec','1.4'=>'http://module-build.sourceforge.net/META-spec-v1.4.html','1.3'=>'http://module-build.sourceforge.net/META-spec-v1.3.html','1.2'=>'http://module-build.sourceforge.net/META-spec-v1.2.html','1.1'=>'http://module-build.sourceforge.net/META-spec-v1.1.html','1.0'=>'http://module-build.sourceforge.net/META-spec-v1.0.html');my@spec_list=sort {$a <=> $b}keys%known_specs;my ($LOWEST,$HIGHEST)=@spec_list[0,-1];sub _keep {$_[0]}sub _keep_or_one {defined($_[0])? $_[0]: 1}sub _keep_or_zero {defined($_[0])? $_[0]: 0}sub _keep_or_unknown {defined($_[0])&& length($_[0])? $_[0]: "unknown"}sub _generated_by {my$gen=shift;my$sig=__PACKAGE__ ." version " .(__PACKAGE__->VERSION || "<dev>");return$sig unless defined$gen and length$gen;return$gen if$gen =~ /\Q$sig/;return "$gen, $sig"}sub _listify {!defined $_[0]? undef : ref $_[0]eq 'ARRAY' ? $_[0]: [$_[0]]}sub _prefix_custom {my$key=shift;$key =~ s/^(?!x_)   # Unless it already starts with x_
               (?:x-?)? # Remove leading x- or x (if present)
             /x_/ix;return$key}sub _ucfirst_custom {my$key=shift;$key=ucfirst$key unless$key =~ /[A-Z]/;return$key}sub _no_prefix_ucfirst_custom {my$key=shift;$key =~ s/^x_//;return _ucfirst_custom($key)}sub _change_meta_spec {my ($element,undef,undef,$version)=@_;return {version=>$version,url=>$known_specs{$version},}}my@open_source=('perl','gpl','apache','artistic','artistic_2','lgpl','bsd','gpl','mit','mozilla','open_source',);my%is_open_source=map {;$_=>1}@open_source;my@valid_licenses_1=(@open_source,'unrestricted','restrictive','unknown',);my%license_map_1=((map {$_=>$_}@valid_licenses_1),artistic2=>'artistic_2',);sub _license_1 {my ($element)=@_;return 'unknown' unless defined$element;if ($license_map_1{lc$element}){return$license_map_1{lc$element}}else {return 'unknown'}}my@valid_licenses_2=qw(agpl_3 apache_1_1 apache_2_0 artistic_1 artistic_2 bsd freebsd gfdl_1_2 gfdl_1_3 gpl_1 gpl_2 gpl_3 lgpl_2_1 lgpl_3_0 mit mozilla_1_0 mozilla_1_1 openssl perl_5 qpl_1_0 ssleay sun zlib open_source restricted unrestricted unknown);my%license_map_2=((map {$_=>$_}@valid_licenses_2),apache=>'apache_2_0',artistic=>'artistic_1',artistic2=>'artistic_2',gpl=>'open_source',lgpl=>'open_source',mozilla=>'open_source',perl=>'perl_5',restrictive=>'restricted',);sub _license_2 {my ($element)=@_;return ['unknown' ]unless defined$element;$element=[$element ]unless ref$element eq 'ARRAY';my@new_list;for my$lic (@$element){next unless defined$lic;if (my$new=$license_map_2{lc$lic}){push@new_list,$new}}return@new_list ? \@new_list : ['unknown' ]}my%license_downgrade_map=qw(agpl_3 open_source apache_1_1 apache apache_2_0 apache artistic_1 artistic artistic_2 artistic_2 bsd bsd freebsd open_source gfdl_1_2 open_source gfdl_1_3 open_source gpl_1 gpl gpl_2 gpl gpl_3 gpl lgpl_2_1 lgpl lgpl_3_0 lgpl mit mit mozilla_1_0 mozilla mozilla_1_1 mozilla openssl open_source perl_5 perl qpl_1_0 open_source ssleay open_source sun open_source zlib open_source open_source open_source restricted restrictive unrestricted unrestricted unknown unknown);sub _downgrade_license {my ($element)=@_;if (!defined$element){return "unknown"}elsif(ref$element eq 'ARRAY'){if (@$element > 1){if (grep {!$is_open_source{$license_downgrade_map{lc $_}|| 'unknown' }}@$element){return 'unknown'}else {return 'open_source'}}elsif (@$element==1){return$license_downgrade_map{lc$element->[0]}|| "unknown"}}elsif (!ref$element){return$license_downgrade_map{lc$element}|| "unknown"}return "unknown"}my$no_index_spec_1_2={'file'=>\&_listify,'dir'=>\&_listify,'package'=>\&_listify,'namespace'=>\&_listify,};my$no_index_spec_1_3={'file'=>\&_listify,'directory'=>\&_listify,'package'=>\&_listify,'namespace'=>\&_listify,};my$no_index_spec_2={'file'=>\&_listify,'directory'=>\&_listify,'package'=>\&_listify,'namespace'=>\&_listify,':custom'=>\&_prefix_custom,};sub _no_index_1_2 {my (undef,undef,$meta)=@_;my$no_index=$meta->{no_index}|| $meta->{private};return unless$no_index;if (!ref$no_index){my$item=$no_index;$no_index={dir=>[$item ],file=>[$item ]}}elsif (ref$no_index eq 'ARRAY'){my$list=$no_index;$no_index={dir=>[@$list ],file=>[@$list ]}}if (exists$no_index->{files}){$no_index->{file}=delete$no_index->{files}}if (exists$no_index->{modules}){$no_index->{module}=delete$no_index->{modules}}return _convert($no_index,$no_index_spec_1_2)}sub _no_index_directory {my ($element,$key,$meta,$version)=@_;return unless$element;if (!ref$element){my$item=$element;$element={directory=>[$item ],file=>[$item ]}}elsif (ref$element eq 'ARRAY'){my$list=$element;$element={directory=>[@$list ],file=>[@$list ]}}if (exists$element->{dir}){$element->{directory}=delete$element->{dir}}if (exists$element->{files}){$element->{file}=delete$element->{files}}if (exists$element->{modules}){$element->{module}=delete$element->{modules}}my$spec=$version==2 ? $no_index_spec_2 : $no_index_spec_1_3;return _convert($element,$spec)}sub _is_module_name {my$mod=shift;return unless defined$mod && length$mod;return$mod =~ m{^[A-Za-z][A-Za-z0-9_]*(?:::[A-Za-z0-9_]+)*$}}sub _clean_version {my ($element)=@_;return 0 if!defined$element;$element =~ s{^\s*}{};$element =~ s{\s*$}{};$element =~ s{^\.}{0.};return 0 if!length$element;return 0 if ($element eq 'undef' || $element eq '<undef>');my$v=eval {version->new($element)};if (defined$v){return _is_qv($v)? $v->normal : $element}else {return 0}}sub _bad_version_hook {my ($v)=@_;$v =~ s{^\s*}{};$v =~ s{\s*$}{};$v =~ s{[a-z]+$}{};my$vobj=eval {version->new($v)};return defined($vobj)? $vobj : version->new(0)}sub _version_map {my ($element)=@_;return unless defined$element;if (ref$element eq 'HASH'){my$new_map=CPAN::Meta::Requirements->new({bad_version_hook=>\&_bad_version_hook });while (my ($k,$v)=each %$element){next unless _is_module_name($k);if (!defined($v)||!length($v)|| $v eq 'undef' || $v eq '<undef>'){$v=0}if (_is_module_name($v)&&!version::is_lax($v)){$new_map->add_minimum($k=>0);$new_map->add_minimum($v=>0)}$new_map->add_string_requirement($k=>$v)}return$new_map->as_string_hash}elsif (ref$element eq 'ARRAY'){my$hashref={map {$_=>0}@$element };return _version_map($hashref)}elsif (ref$element eq '' && length$element){return {$element=>0 }}return}sub _prereqs_from_1 {my (undef,undef,$meta)=@_;my$prereqs={};for my$phase (qw/build configure/){my$key="${phase}_requires";$prereqs->{$phase}{requires}=_version_map($meta->{$key})if$meta->{$key}}for my$rel (qw/requires recommends conflicts/){$prereqs->{runtime}{$rel}=_version_map($meta->{$rel})if$meta->{$rel}}return$prereqs}my$prereqs_spec={configure=>\&_prereqs_rel,build=>\&_prereqs_rel,test=>\&_prereqs_rel,runtime=>\&_prereqs_rel,develop=>\&_prereqs_rel,':custom'=>\&_prefix_custom,};my$relation_spec={requires=>\&_version_map,recommends=>\&_version_map,suggests=>\&_version_map,conflicts=>\&_version_map,':custom'=>\&_prefix_custom,};sub _cleanup_prereqs {my ($prereqs,$key,$meta,$to_version)=@_;return unless$prereqs && ref$prereqs eq 'HASH';return _convert($prereqs,$prereqs_spec,$to_version)}sub _prereqs_rel {my ($relation,$key,$meta,$to_version)=@_;return unless$relation && ref$relation eq 'HASH';return _convert($relation,$relation_spec,$to_version)}BEGIN {my@old_prereqs=qw(requires configure_requires recommends conflicts);for (@old_prereqs){my$sub="_get_$_";my ($phase,$type)=split qr/_/,$_;if (!defined$type){$type=$phase;$phase='runtime'}no strict 'refs';*{$sub}=sub {_extract_prereqs($_[2]->{prereqs},$phase,$type)}}}sub _get_build_requires {my ($data,$key,$meta)=@_;my$test_h=_extract_prereqs($_[2]->{prereqs},qw(test requires))|| {};my$build_h=_extract_prereqs($_[2]->{prereqs},qw(build requires))|| {};my$test_req=CPAN::Meta::Requirements->from_string_hash($test_h);my$build_req=CPAN::Meta::Requirements->from_string_hash($build_h);$test_req->add_requirements($build_req)->as_string_hash}sub _extract_prereqs {my ($prereqs,$phase,$type)=@_;return unless ref$prereqs eq 'HASH';return scalar _version_map($prereqs->{$phase}{$type})}sub _downgrade_optional_features {my (undef,undef,$meta)=@_;return unless exists$meta->{optional_features};my$origin=$meta->{optional_features};my$features={};for my$name (keys %$origin){$features->{$name}={description=>$origin->{$name}{description},requires=>_extract_prereqs($origin->{$name}{prereqs},'runtime','requires'),configure_requires=>_extract_prereqs($origin->{$name}{prereqs},'runtime','configure_requires'),build_requires=>_extract_prereqs($origin->{$name}{prereqs},'runtime','build_requires'),recommends=>_extract_prereqs($origin->{$name}{prereqs},'runtime','recommends'),conflicts=>_extract_prereqs($origin->{$name}{prereqs},'runtime','conflicts'),};for my$k (keys %{$features->{$name}}){delete$features->{$name}{$k}unless defined$features->{$name}{$k}}}return$features}sub _upgrade_optional_features {my (undef,undef,$meta)=@_;return unless exists$meta->{optional_features};my$origin=$meta->{optional_features};my$features={};for my$name (keys %$origin){$features->{$name}={description=>$origin->{$name}{description},prereqs=>_prereqs_from_1(undef,undef,$origin->{$name}),};delete$features->{$name}{prereqs}{configure}}return$features}my$optional_features_2_spec={description=>\&_keep,prereqs=>\&_cleanup_prereqs,':custom'=>\&_prefix_custom,};sub _feature_2 {my ($element,$key,$meta,$to_version)=@_;return unless$element && ref$element eq 'HASH';_convert($element,$optional_features_2_spec,$to_version)}sub _cleanup_optional_features_2 {my ($element,$key,$meta,$to_version)=@_;return unless$element && ref$element eq 'HASH';my$new_data={};for my$k (keys %$element){$new_data->{$k}=_feature_2($element->{$k},$k,$meta,$to_version)}return unless keys %$new_data;return$new_data}sub _optional_features_1_4 {my ($element)=@_;return unless$element;$element=_optional_features_as_map($element);for my$name (keys %$element){for my$drop (qw/requires_packages requires_os excluded_os/){delete$element->{$name}{$drop}}}return$element}sub _optional_features_as_map {my ($element)=@_;return unless$element;if (ref$element eq 'ARRAY'){my%map;for my$feature (@$element){my (@parts)=%$feature;$map{$parts[0]}=$parts[1]}$element=\%map}return$element}sub _is_urlish {defined $_[0]&& $_[0]=~ m{\A[-+.a-z0-9]+:.+}i}sub _url_or_drop {my ($element)=@_;return$element if _is_urlish($element);return}sub _url_list {my ($element)=@_;return unless$element;$element=_listify($element);$element=[grep {_is_urlish($_)}@$element ];return unless @$element;return$element}sub _author_list {my ($element)=@_;return ['unknown' ]unless$element;$element=_listify($element);$element=[map {defined $_ && length $_ ? $_ : 'unknown'}@$element ];return ['unknown' ]unless @$element;return$element}my$resource2_upgrade={license=>sub {return _is_urlish($_[0])? _listify($_[0]): undef},homepage=>\&_url_or_drop,bugtracker=>sub {my ($item)=@_;return unless$item;if ($item =~ m{^mailto:(.*)$}){return {mailto=>$1 }}elsif(_is_urlish($item)){return {web=>$item }}else {return}},repository=>sub {return _is_urlish($_[0])? {url=>$_[0]}: undef},':custom'=>\&_prefix_custom,};sub _upgrade_resources_2 {my (undef,undef,$meta,$version)=@_;return unless exists$meta->{resources};return _convert($meta->{resources},$resource2_upgrade)}my$bugtracker2_spec={web=>\&_url_or_drop,mailto=>\&_keep,':custom'=>\&_prefix_custom,};sub _repo_type {my ($element,$key,$meta,$to_version)=@_;return$element if defined$element;return unless exists$meta->{url};my$repo_url=$meta->{url};for my$type (qw/git svn/){return$type if$repo_url =~ m{\A$type}}return}my$repository2_spec={web=>\&_url_or_drop,url=>\&_url_or_drop,type=>\&_repo_type,':custom'=>\&_prefix_custom,};my$resources2_cleanup={license=>\&_url_list,homepage=>\&_url_or_drop,bugtracker=>sub {ref $_[0]? _convert($_[0],$bugtracker2_spec): undef},repository=>sub {my$data=shift;ref$data ? _convert($data,$repository2_spec): undef},':custom'=>\&_prefix_custom,};sub _cleanup_resources_2 {my ($resources,$key,$meta,$to_version)=@_;return unless$resources && ref$resources eq 'HASH';return _convert($resources,$resources2_cleanup,$to_version)}my$resource1_spec={license=>\&_url_or_drop,homepage=>\&_url_or_drop,bugtracker=>\&_url_or_drop,repository=>\&_url_or_drop,':custom'=>\&_keep,};sub _resources_1_3 {my (undef,undef,$meta,$version)=@_;return unless exists$meta->{resources};return _convert($meta->{resources},$resource1_spec)}*_resources_1_4=*_resources_1_3;sub _resources_1_2 {my (undef,undef,$meta)=@_;my$resources=$meta->{resources}|| {};if ($meta->{license_url}&&!$resources->{license}){$resources->{license}=$meta->{license_url}if _is_urlish($meta->{license_url})}return unless keys %$resources;return _convert($resources,$resource1_spec)}my$resource_downgrade_spec={license=>sub {return ref $_[0]? $_[0]->[0]: $_[0]},homepage=>\&_url_or_drop,bugtracker=>sub {return $_[0]->{web}},repository=>sub {return $_[0]->{url}|| $_[0]->{web}},':custom'=>\&_no_prefix_ucfirst_custom,};sub _downgrade_resources {my (undef,undef,$meta,$version)=@_;return unless exists$meta->{resources};return _convert($meta->{resources},$resource_downgrade_spec)}sub _release_status {my ($element,undef,$meta)=@_;return$element if$element && $element =~ m{\A(?:stable|testing|unstable)\z};return _release_status_from_version(undef,undef,$meta)}sub _release_status_from_version {my (undef,undef,$meta)=@_;my$version=$meta->{version}|| '';return ($version =~ /_/)? 'testing' : 'stable'}my$provides_spec={file=>\&_keep,version=>\&_keep,};my$provides_spec_2={file=>\&_keep,version=>\&_keep,':custom'=>\&_prefix_custom,};sub _provides {my ($element,$key,$meta,$to_version)=@_;return unless defined$element && ref$element eq 'HASH';my$spec=$to_version==2 ? $provides_spec_2 : $provides_spec;my$new_data={};for my$k (keys %$element){$new_data->{$k}=_convert($element->{$k},$spec,$to_version);$new_data->{$k}{version}=_clean_version($element->{$k}{version})if exists$element->{$k}{version}}return$new_data}sub _convert {my ($data,$spec,$to_version,$is_fragment)=@_;my$new_data={};for my$key (keys %$spec){next if$key eq ':custom' || $key eq ':drop';next unless my$fcn=$spec->{$key};if ($is_fragment && $key eq 'generated_by'){$fcn=\&_keep}die "spec for '$key' is not a coderef" unless ref$fcn && ref$fcn eq 'CODE';my$new_value=$fcn->($data->{$key},$key,$data,$to_version);$new_data->{$key}=$new_value if defined$new_value}my$drop_list=$spec->{':drop'};my$customizer=$spec->{':custom'}|| \&_keep;for my$key (keys %$data){next if$drop_list && grep {$key eq $_}@$drop_list;next if exists$spec->{$key};$new_data->{$customizer->($key)}=$data->{$key}}return$new_data}my%up_convert=('2-from-1.4'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_2,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'release_status'=>\&_release_status,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_upgrade_optional_features,'provides'=>\&_provides,'resources'=>\&_upgrade_resources_2,'description'=>\&_keep,'prereqs'=>\&_prereqs_from_1,':drop'=>[qw(build_requires configure_requires conflicts distribution_type license_url private recommends requires) ],':custom'=>\&_prefix_custom,},'1.4-from-1.3'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_optional_features_1_4,'provides'=>\&_provides,'recommends'=>\&_version_map,'requires'=>\&_version_map,'resources'=>\&_resources_1_4,'configure_requires'=>\&_keep,':drop'=>[qw(license_url private)],':custom'=>\&_keep },'1.3-from-1.2'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_optional_features_as_map,'provides'=>\&_provides,'recommends'=>\&_version_map,'requires'=>\&_version_map,'resources'=>\&_resources_1_3,':drop'=>[qw(license_url private)],':custom'=>\&_keep },'1.2-from-1.1'=>{'version'=>\&_keep,'license'=>\&_license_1,'name'=>\&_keep,'generated_by'=>\&_generated_by,'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'meta-spec'=>\&_change_meta_spec,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'recommends'=>\&_version_map,'requires'=>\&_version_map,'keywords'=>\&_keep,'no_index'=>\&_no_index_1_2,'optional_features'=>\&_optional_features_as_map,'provides'=>\&_provides,'resources'=>\&_resources_1_2,':drop'=>[qw(license_url private)],':custom'=>\&_keep },'1.1-from-1.0'=>{'version'=>\&_keep,'name'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'recommends'=>\&_version_map,'requires'=>\&_version_map,'license_url'=>\&_url_or_drop,'private'=>\&_keep,':custom'=>\&_keep },);my%down_convert=('1.4-from-2'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_downgrade_license,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'build_requires'=>\&_get_build_requires,'configure_requires'=>\&_get_configure_requires,'conflicts'=>\&_get_conflicts,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_downgrade_optional_features,'provides'=>\&_provides,'recommends'=>\&_get_recommends,'requires'=>\&_get_requires,'resources'=>\&_downgrade_resources,':drop'=>[qw(description prereqs release_status)],':custom'=>\&_keep },'1.3-from-1.4'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_optional_features_as_map,'provides'=>\&_provides,'recommends'=>\&_version_map,'requires'=>\&_version_map,'resources'=>\&_resources_1_3,':drop'=>[qw(configure_requires)],':custom'=>\&_keep,},'1.2-from-1.3'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'keywords'=>\&_keep,'no_index'=>\&_no_index_1_2,'optional_features'=>\&_optional_features_as_map,'provides'=>\&_provides,'recommends'=>\&_version_map,'requires'=>\&_version_map,'resources'=>\&_resources_1_3,':custom'=>\&_keep,},'1.1-from-1.2'=>{'version'=>\&_keep,'name'=>\&_keep,'meta-spec'=>\&_change_meta_spec,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'private'=>\&_keep,'recommends'=>\&_version_map,'requires'=>\&_version_map,':drop'=>[qw(abstract author provides no_index keywords resources)],':custom'=>\&_keep,},'1.0-from-1.1'=>{'name'=>\&_keep,'meta-spec'=>\&_change_meta_spec,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'recommends'=>\&_version_map,'requires'=>\&_version_map,':custom'=>\&_keep,},);my%cleanup=('2'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_2,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'release_status'=>\&_release_status,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_cleanup_optional_features_2,'provides'=>\&_provides,'resources'=>\&_cleanup_resources_2,'description'=>\&_keep,'prereqs'=>\&_cleanup_prereqs,':drop'=>[qw(build_requires configure_requires conflicts distribution_type license_url private recommends requires) ],':custom'=>\&_prefix_custom,},'1.4'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_optional_features_1_4,'provides'=>\&_provides,'recommends'=>\&_version_map,'requires'=>\&_version_map,'resources'=>\&_resources_1_4,'configure_requires'=>\&_keep,':custom'=>\&_keep },'1.3'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_optional_features_as_map,'provides'=>\&_provides,'recommends'=>\&_version_map,'requires'=>\&_version_map,'resources'=>\&_resources_1_3,':custom'=>\&_keep },'1.2'=>{'version'=>\&_keep,'license'=>\&_license_1,'name'=>\&_keep,'generated_by'=>\&_generated_by,'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'meta-spec'=>\&_change_meta_spec,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'recommends'=>\&_version_map,'requires'=>\&_version_map,'keywords'=>\&_keep,'no_index'=>\&_no_index_1_2,'optional_features'=>\&_optional_features_as_map,'provides'=>\&_provides,'resources'=>\&_resources_1_2,':custom'=>\&_keep },'1.1'=>{'version'=>\&_keep,'name'=>\&_keep,'meta-spec'=>\&_change_meta_spec,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'recommends'=>\&_version_map,'requires'=>\&_version_map,'license_url'=>\&_url_or_drop,'private'=>\&_keep,':custom'=>\&_keep },'1.0'=>{'name'=>\&_keep,'meta-spec'=>\&_change_meta_spec,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'recommends'=>\&_version_map,'requires'=>\&_version_map,':custom'=>\&_keep,},);my%fragments_generate=('2'=>{'abstract'=>'abstract','author'=>'author','generated_by'=>'generated_by','license'=>'license','name'=>'name','version'=>'version','dynamic_config'=>'dynamic_config','release_status'=>'release_status','keywords'=>'keywords','no_index'=>'no_index','optional_features'=>'optional_features','provides'=>'provides','resources'=>'resources','description'=>'description','prereqs'=>'prereqs',},'1.4'=>{'abstract'=>'abstract','author'=>'author','generated_by'=>'generated_by','license'=>'license','name'=>'name','version'=>'version','build_requires'=>'prereqs','conflicts'=>'prereqs','distribution_type'=>'distribution_type','dynamic_config'=>'dynamic_config','keywords'=>'keywords','no_index'=>'no_index','optional_features'=>'optional_features','provides'=>'provides','recommends'=>'prereqs','requires'=>'prereqs','resources'=>'resources','configure_requires'=>'prereqs',},);$fragments_generate{$_}=$fragments_generate{'1.4'}for qw/1.3 1.2 1.1 1.0/;sub new {my ($class,$data,%args)=@_;my$self={'data'=>$data,'spec'=>_extract_spec_version($data,$args{default_version}),};return bless$self,$class}sub _extract_spec_version {my ($data,$default)=@_;my$spec=$data->{'meta-spec'};return($default || "1.0")unless defined$spec && ref$spec eq 'HASH';my$v=$spec->{version};if (defined$v && $v =~ /^\d+(?:\.\d+)?$/){return$v if defined$v && grep {$v eq $_}keys%known_specs;return$v+0 if defined$v && grep {$v==$_}keys%known_specs}return "2" if exists$data->{prereqs};return "1.4" if exists$data->{configure_requires};return($default || "1.2")}sub convert {my ($self,%args)=@_;my$args={%args };my$new_version=$args->{version}|| $HIGHEST;my$is_fragment=$args->{is_fragment};my ($old_version)=$self->{spec};my$converted=_dclone($self->{data});if ($old_version==$new_version){$converted=_convert($converted,$cleanup{$old_version},$old_version,$is_fragment);unless ($args->{is_fragment}){my$cmv=CPAN::Meta::Validator->new($converted);unless ($cmv->is_valid){my$errs=join("\n",$cmv->errors);die "Failed to clean-up $old_version metadata. Errors:\n$errs\n"}}return$converted}elsif ($old_version > $new_version){my@vers=sort {$b <=> $a}keys%known_specs;for my$i (0 .. $#vers-1){next if$vers[$i]> $old_version;last if$vers[$i+1]< $new_version;my$spec_string="$vers[$i+1]-from-$vers[$i]";$converted=_convert($converted,$down_convert{$spec_string},$vers[$i+1],$is_fragment);unless ($args->{is_fragment}){my$cmv=CPAN::Meta::Validator->new($converted);unless ($cmv->is_valid){my$errs=join("\n",$cmv->errors);die "Failed to downconvert metadata to $vers[$i+1]. Errors:\n$errs\n"}}}return$converted}else {my@vers=sort {$a <=> $b}keys%known_specs;for my$i (0 .. $#vers-1){next if$vers[$i]< $old_version;last if$vers[$i+1]> $new_version;my$spec_string="$vers[$i+1]-from-$vers[$i]";$converted=_convert($converted,$up_convert{$spec_string},$vers[$i+1],$is_fragment);unless ($args->{is_fragment}){my$cmv=CPAN::Meta::Validator->new($converted);unless ($cmv->is_valid){my$errs=join("\n",$cmv->errors);die "Failed to upconvert metadata to $vers[$i+1]. Errors:\n$errs\n"}}}return$converted}}sub upgrade_fragment {my ($self)=@_;my ($old_version)=$self->{spec};my%expected=map {;$_=>1}grep {defined}map {$fragments_generate{$old_version}{$_}}keys %{$self->{data}};my$converted=$self->convert(version=>$HIGHEST,is_fragment=>1);for my$key (keys %$converted){next if$key =~ /^x_/i || $key eq 'meta-spec';delete$converted->{$key}unless$expected{$key}}return$converted}1;
CPAN_META_CONVERTER

$fatpacked{"CPAN/Meta/Feature.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_FEATURE';
  use 5.006;use strict;use warnings;package CPAN::Meta::Feature;our$VERSION='2.150010';use CPAN::Meta::Prereqs;sub new {my ($class,$identifier,$spec)=@_;my%guts=(identifier=>$identifier,description=>$spec->{description},prereqs=>CPAN::Meta::Prereqs->new($spec->{prereqs}),);bless \%guts=>$class}sub identifier {$_[0]{identifier}}sub description {$_[0]{description}}sub prereqs {$_[0]{prereqs}}1;
CPAN_META_FEATURE

$fatpacked{"CPAN/Meta/History.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_HISTORY';
  use 5.006;use strict;use warnings;package CPAN::Meta::History;our$VERSION='2.150010';1;
CPAN_META_HISTORY

$fatpacked{"CPAN/Meta/Merge.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_MERGE';
  use strict;use warnings;package CPAN::Meta::Merge;our$VERSION='2.150010';use Carp qw/croak/;use Scalar::Util qw/blessed/;use CPAN::Meta::Converter 2.141170;sub _is_identical {my ($left,$right)=@_;return (not defined$left and not defined$right)|| (defined$left and defined$right and $left eq $right)}sub _identical {my ($left,$right,$path)=@_;croak sprintf "Can't merge attribute %s: '%s' does not equal '%s'",join('.',@{$path}),$left,$right unless _is_identical($left,$right);return$left}sub _merge {my ($current,$next,$mergers,$path)=@_;for my$key (keys %{$next}){if (not exists$current->{$key}){$current->{$key}=$next->{$key}}elsif (my$merger=$mergers->{$key}){$current->{$key}=$merger->($current->{$key},$next->{$key},[@{$path},$key ])}elsif ($merger=$mergers->{':default'}){$current->{$key}=$merger->($current->{$key},$next->{$key},[@{$path},$key ])}else {croak sprintf "Can't merge unknown attribute '%s'",join '.',@{$path},$key}}return$current}sub _uniq {my%seen=();return grep {not $seen{$_}++}@_}sub _set_addition {my ($left,$right)=@_;return [+_uniq(@{$left},@{$right})]}sub _uniq_map {my ($left,$right,$path)=@_;for my$key (keys %{$right}){if (not exists$left->{$key}){$left->{$key}=$right->{$key}}elsif (_is_identical($left->{$key},$right->{$key})){1}elsif (ref$left->{$key}eq 'HASH' and ref$right->{$key}eq 'HASH'){$left->{$key}=_uniq_map($left->{$key},$right->{$key},[@{$path},$key ])}else {croak 'Duplication of element ' .join '.',@{$path},$key}}return$left}sub _improvise {my ($left,$right,$path)=@_;my ($name)=reverse @{$path};if ($name =~ /^x_/){if (ref($left)eq 'ARRAY'){return _set_addition($left,$right,$path)}elsif (ref($left)eq 'HASH'){return _uniq_map($left,$right,$path)}else {return _identical($left,$right,$path)}}croak sprintf "Can't merge '%s'",join '.',@{$path}}sub _optional_features {my ($left,$right,$path)=@_;for my$key (keys %{$right}){if (not exists$left->{$key}){$left->{$key}=$right->{$key}}else {for my$subkey (keys %{$right->{$key}}){next if$subkey eq 'prereqs';if (not exists$left->{$key}{$subkey}){$left->{$key}{$subkey}=$right->{$key}{$subkey}}else {Carp::croak "Cannot merge two optional_features named '$key' with different '$subkey' values" if do {no warnings 'uninitialized';$left->{$key}{$subkey}ne $right->{$key}{$subkey}}}}require CPAN::Meta::Prereqs;$left->{$key}{prereqs}=CPAN::Meta::Prereqs->new($left->{$key}{prereqs})->with_merged_prereqs(CPAN::Meta::Prereqs->new($right->{$key}{prereqs}))->as_string_hash}}return$left}my%default=(abstract=>\&_identical,author=>\&_set_addition,dynamic_config=>sub {my ($left,$right)=@_;return$left || $right},generated_by=>sub {my ($left,$right)=@_;return join ', ',_uniq(split(/, /,$left),split(/, /,$right))},license=>\&_set_addition,'meta-spec'=>{version=>\&_identical,url=>\&_identical },name=>\&_identical,release_status=>\&_identical,version=>\&_identical,description=>\&_identical,keywords=>\&_set_addition,no_index=>{map {($_=>\&_set_addition)}qw/file directory package namespace/ },optional_features=>\&_optional_features,prereqs=>sub {require CPAN::Meta::Prereqs;my ($left,$right)=map {CPAN::Meta::Prereqs->new($_)}@_[0,1];return$left->with_merged_prereqs($right)->as_string_hash},provides=>\&_uniq_map,resources=>{license=>\&_set_addition,homepage=>\&_identical,bugtracker=>\&_uniq_map,repository=>\&_uniq_map,':default'=>\&_improvise,},':default'=>\&_improvise,);sub new {my ($class,%arguments)=@_;croak 'default version required' if not exists$arguments{default_version};my%mapping=%default;my%extra=%{$arguments{extra_mappings}|| {}};for my$key (keys%extra){if (ref($mapping{$key})eq 'HASH'){$mapping{$key}={%{$mapping{$key}},%{$extra{$key}}}}else {$mapping{$key}=$extra{$key}}}return bless {default_version=>$arguments{default_version},mapping=>_coerce_mapping(\%mapping,[]),},$class}my%coderef_for=(set_addition=>\&_set_addition,uniq_map=>\&_uniq_map,identical=>\&_identical,improvise=>\&_improvise,improvize=>\&_improvise,);sub _coerce_mapping {my ($orig,$map_path)=@_;my%ret;for my$key (keys %{$orig}){my$value=$orig->{$key};if (ref($orig->{$key})eq 'CODE'){$ret{$key}=$value}elsif (ref($value)eq 'HASH'){my$mapping=_coerce_mapping($value,[@{$map_path},$key ]);$ret{$key}=sub {my ($left,$right,$path)=@_;return _merge($left,$right,$mapping,[@{$path}])}}elsif ($coderef_for{$value}){$ret{$key}=$coderef_for{$value}}else {croak "Don't know what to do with " .join '.',@{$map_path},$key}}return \%ret}sub merge {my ($self,@items)=@_;my$current={};for my$next (@items){if (blessed($next)&& $next->isa('CPAN::Meta')){$next=$next->as_struct}elsif (ref($next)eq 'HASH'){my$cmc=CPAN::Meta::Converter->new($next,default_version=>$self->{default_version});$next=$cmc->upgrade_fragment}else {croak "Don't know how to merge '$next'"}$current=_merge($current,$next,$self->{mapping},[])}return$current}1;
CPAN_META_MERGE

$fatpacked{"CPAN/Meta/Prereqs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_PREREQS';
  use 5.006;use strict;use warnings;package CPAN::Meta::Prereqs;our$VERSION='2.150010';use Carp qw(confess);use Scalar::Util qw(blessed);use CPAN::Meta::Requirements 2.121;sub __legal_phases {qw(configure build test runtime develop)}sub __legal_types {qw(requires recommends suggests conflicts)}sub new {my ($class,$prereq_spec)=@_;$prereq_spec ||= {};my%is_legal_phase=map {;$_=>1}$class->__legal_phases;my%is_legal_type=map {;$_=>1}$class->__legal_types;my%guts;PHASE: for my$phase (keys %$prereq_spec){next PHASE unless$phase =~ /\Ax_/i or $is_legal_phase{$phase};my$phase_spec=$prereq_spec->{$phase };next PHASE unless keys %$phase_spec;TYPE: for my$type (keys %$phase_spec){next TYPE unless$type =~ /\Ax_/i or $is_legal_type{$type};my$spec=$phase_spec->{$type };next TYPE unless keys %$spec;$guts{prereqs}{$phase}{$type}=CPAN::Meta::Requirements->from_string_hash($spec)}}return bless \%guts=>$class}sub requirements_for {my ($self,$phase,$type)=@_;confess "requirements_for called without phase" unless defined$phase;confess "requirements_for called without type" unless defined$type;unless ($phase =~ /\Ax_/i or grep {$phase eq $_}$self->__legal_phases){confess "requested requirements for unknown phase: $phase"}unless ($type =~ /\Ax_/i or grep {$type eq $_}$self->__legal_types){confess "requested requirements for unknown type: $type"}my$req=($self->{prereqs}{$phase}{$type}||= CPAN::Meta::Requirements->new);$req->finalize if$self->is_finalized;return$req}sub phases {my ($self)=@_;my%is_legal_phase=map {;$_=>1}$self->__legal_phases;grep {/\Ax_/i or $is_legal_phase{$_}}keys %{$self->{prereqs}}}sub types_in {my ($self,$phase)=@_;return unless$phase =~ /\Ax_/i or grep {$phase eq $_}$self->__legal_phases;my%is_legal_type=map {;$_=>1}$self->__legal_types;grep {/\Ax_/i or $is_legal_type{$_}}keys %{$self->{prereqs}{$phase}}}sub with_merged_prereqs {my ($self,$other)=@_;my@other=blessed($other)? $other : @$other;my@prereq_objs=($self,@other);my%new_arg;for my$phase (__uniq(map {$_->phases}@prereq_objs)){for my$type (__uniq(map {$_->types_in($phase)}@prereq_objs)){my$req=CPAN::Meta::Requirements->new;for my$prereq (@prereq_objs){my$this_req=$prereq->requirements_for($phase,$type);next unless$this_req->required_modules;$req->add_requirements($this_req)}next unless$req->required_modules;$new_arg{$phase }{$type }=$req->as_string_hash}}return (ref$self)->new(\%new_arg)}sub merged_requirements {my ($self,$phases,$types)=@_;$phases=[qw/runtime build test/]unless defined$phases;$types=[qw/requires recommends/]unless defined$types;confess "merged_requirements phases argument must be an arrayref" unless ref$phases eq 'ARRAY';confess "merged_requirements types argument must be an arrayref" unless ref$types eq 'ARRAY';my$req=CPAN::Meta::Requirements->new;for my$phase (@$phases){unless ($phase =~ /\Ax_/i or grep {$phase eq $_}$self->__legal_phases){confess "requested requirements for unknown phase: $phase"}for my$type (@$types){unless ($type =~ /\Ax_/i or grep {$type eq $_}$self->__legal_types){confess "requested requirements for unknown type: $type"}$req->add_requirements($self->requirements_for($phase,$type))}}$req->finalize if$self->is_finalized;return$req}sub as_string_hash {my ($self)=@_;my%hash;for my$phase ($self->phases){for my$type ($self->types_in($phase)){my$req=$self->requirements_for($phase,$type);next unless$req->required_modules;$hash{$phase }{$type }=$req->as_string_hash}}return \%hash}sub is_finalized {$_[0]{finalized}}sub finalize {my ($self)=@_;$self->{finalized}=1;for my$phase (keys %{$self->{prereqs}}){$_->finalize for values %{$self->{prereqs}{$phase}}}}sub clone {my ($self)=@_;my$clone=(ref$self)->new($self->as_string_hash)}sub __uniq {my (%s,$u);grep {defined($_)?!$s{$_}++ :!$u++}@_}1;
CPAN_META_PREREQS

$fatpacked{"CPAN/Meta/Requirements.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_REQUIREMENTS';
  use 5.006;use strict;use warnings;package CPAN::Meta::Requirements;our$VERSION='2.140';use Carp ();BEGIN {eval "use version ()";if (my$err=$@){eval "use ExtUtils::MakeMaker::version" or die$err}}*_is_qv=version->can('is_qv')? sub {$_[0]->is_qv}: sub {exists $_[0]->{qv}};my$V0=version->new(0);my@valid_options=qw(bad_version_hook);sub new {my ($class,$options)=@_;$options ||= {};Carp::croak "Argument to $class\->new() must be a hash reference" unless ref$options eq 'HASH';my%self=map {;$_=>$options->{$_}}@valid_options;return bless \%self=>$class}sub _find_magic_vstring {my$value=shift;my$tvalue='';require B;my$sv=B::svref_2object(\$value);my$magic=ref($sv)eq 'B::PVMG' ? $sv->MAGIC : undef;while ($magic){if ($magic->TYPE eq 'V'){$tvalue=$magic->PTR;$tvalue =~ s/^v?(.+)$/v$1/;last}else {$magic=$magic->MOREMAGIC}}return$tvalue}sub _isa_version {UNIVERSAL::isa($_[0],'UNIVERSAL')&& $_[0]->isa('version')}sub _version_object {my ($self,$module,$version)=@_;my ($vobj,$err);if (not defined$version or (!ref($version)&& $version eq '0')){return$V0}elsif (ref($version)eq 'version' || (ref($version)&& _isa_version($version))){$vobj=$version}else {if ($INC{'version/vpp.pm'}|| $INC{'ExtUtils/MakeMaker/version/vpp.pm'}){my$magic=_find_magic_vstring($version);$version=$magic if length$magic}if ($] < 5.008001 && $version !~ /\A[0-9]/ && substr($version,0,1)ne 'v' && length($version)< 3){$version .= "\0" x (3 - length($version))}eval {local$SIG{__WARN__}=sub {die "Invalid version: $_[0]"};die "Invalid version: $version" if$version eq 'version';$vobj=version->new($version)};if (my$err=$@){my$hook=$self->{bad_version_hook};$vobj=eval {$hook->($version,$module)}if ref$hook eq 'CODE';unless (eval {$vobj->isa("version")}){$err =~ s{ at .* line \d+.*$}{};die "Can't convert '$version': $err"}}}if ($vobj =~ m{\A\.}){$vobj=version->new("0$vobj")}if (_is_qv($vobj)){$vobj=version->new($vobj->normal)}return$vobj}BEGIN {for my$type (qw(maximum exclusion exact_version)){my$method="with_$type";my$to_add=$type eq 'exact_version' ? $type : "add_$type";my$code=sub {my ($self,$name,$version)=@_;$version=$self->_version_object($name,$version);$self->__modify_entry_for($name,$method,$version);return$self};no strict 'refs';*$to_add=$code}}sub add_minimum {my ($self,$name,$version)=@_;if (not defined$version or "$version" eq '0'){return$self if$self->__entry_for($name);Carp::confess("can't add new requirements to finalized requirements")if$self->is_finalized;$self->{requirements}{$name }=CPAN::Meta::Requirements::_Range::Range->with_minimum($V0,$name)}else {$version=$self->_version_object($name,$version);$self->__modify_entry_for($name,'with_minimum',$version)}return$self}sub add_requirements {my ($self,$req)=@_;for my$module ($req->required_modules){my$modifiers=$req->__entry_for($module)->as_modifiers;for my$modifier (@$modifiers){my ($method,@args)=@$modifier;$self->$method($module=>@args)}}return$self}sub accepts_module {my ($self,$module,$version)=@_;$version=$self->_version_object($module,$version);return 1 unless my$range=$self->__entry_for($module);return$range->_accepts($version)}sub clear_requirement {my ($self,$module)=@_;return$self unless$self->__entry_for($module);Carp::confess("can't clear requirements on finalized requirements")if$self->is_finalized;delete$self->{requirements}{$module };return$self}sub requirements_for_module {my ($self,$module)=@_;my$entry=$self->__entry_for($module);return unless$entry;return$entry->as_string}sub structured_requirements_for_module {my ($self,$module)=@_;my$entry=$self->__entry_for($module);return unless$entry;return$entry->as_struct}sub required_modules {keys %{$_[0]{requirements}}}sub clone {my ($self)=@_;my$new=(ref$self)->new;return$new->add_requirements($self)}sub __entry_for {$_[0]{requirements}{$_[1]}}sub __modify_entry_for {my ($self,$name,$method,$version)=@_;my$fin=$self->is_finalized;my$old=$self->__entry_for($name);Carp::confess("can't add new requirements to finalized requirements")if$fin and not $old;my$new=($old || 'CPAN::Meta::Requirements::_Range::Range')->$method($version,$name);Carp::confess("can't modify finalized requirements")if$fin and $old->as_string ne $new->as_string;$self->{requirements}{$name }=$new}sub is_simple {my ($self)=@_;for my$module ($self->required_modules){return if$self->__entry_for($module)->as_string =~ /\s/}return 1}sub is_finalized {$_[0]{finalized}}sub finalize {$_[0]{finalized}=1}sub as_string_hash {my ($self)=@_;my%hash=map {;$_=>$self->{requirements}{$_}->as_string}$self->required_modules;return \%hash}my%methods_for_op=('=='=>[qw(exact_version) ],'!='=>[qw(add_exclusion) ],'>='=>[qw(add_minimum) ],'<='=>[qw(add_maximum) ],'>'=>[qw(add_minimum add_exclusion) ],'<'=>[qw(add_maximum add_exclusion) ],);sub add_string_requirement {my ($self,$module,$req)=@_;unless (defined$req && length$req){$req=0;$self->_blank_carp($module)}my$magic=_find_magic_vstring($req);if (length$magic){$self->add_minimum($module=>$magic);return}my@parts=split qr{\s*,\s*},$req;for my$part (@parts){my ($op,$ver)=$part =~ m{\A\s*(==|>=|>|<=|<|!=)\s*(.*)\z};if (!defined$op){$self->add_minimum($module=>$part)}else {Carp::confess("illegal requirement string: $req")unless my$methods=$methods_for_op{$op };$self->$_($module=>$ver)for @$methods}}}sub _blank_carp {my ($self,$module)=@_;Carp::carp("Undefined requirement for $module treated as '0'")}sub from_string_hash {my ($class,$hash,$options)=@_;my$self=$class->new($options);for my$module (keys %$hash){my$req=$hash->{$module};unless (defined$req && length$req){$req=0;$class->_blank_carp($module)}$self->add_string_requirement($module,$req)}return$self}{package CPAN::Meta::Requirements::_Range::Exact;sub _new {bless {version=>$_[1]}=>$_[0]}sub _accepts {return $_[0]{version}==$_[1]}sub as_string {return "== $_[0]{version}"}sub as_struct {return [['==',"$_[0]{version}" ]]}sub as_modifiers {return [[exact_version=>$_[0]{version}]]}sub _reject_requirements {my ($self,$module,$error)=@_;Carp::confess("illegal requirements for $module: $error")}sub _clone {(ref $_[0])->_new(version->new($_[0]{version}))}sub with_exact_version {my ($self,$version,$module)=@_;$module='module' unless defined$module;return$self->_clone if$self->_accepts($version);$self->_reject_requirements($module,"can't be exactly $version when exact requirement is already $self->{version}",)}sub with_minimum {my ($self,$minimum,$module)=@_;$module='module' unless defined$module;return$self->_clone if$self->{version}>= $minimum;$self->_reject_requirements($module,"minimum $minimum exceeds exact specification $self->{version}",)}sub with_maximum {my ($self,$maximum,$module)=@_;$module='module' unless defined$module;return$self->_clone if$self->{version}<= $maximum;$self->_reject_requirements($module,"maximum $maximum below exact specification $self->{version}",)}sub with_exclusion {my ($self,$exclusion,$module)=@_;$module='module' unless defined$module;return$self->_clone unless$exclusion==$self->{version};$self->_reject_requirements($module,"tried to exclude $exclusion, which is already exactly specified",)}}{package CPAN::Meta::Requirements::_Range::Range;sub _self {ref($_[0])? $_[0]: (bless {}=>$_[0])}sub _clone {return (bless {}=>$_[0])unless ref $_[0];my ($s)=@_;my%guts=((exists$s->{minimum}? (minimum=>version->new($s->{minimum})): ()),(exists$s->{maximum}? (maximum=>version->new($s->{maximum})): ()),(exists$s->{exclusions}? (exclusions=>[map {version->new($_)}@{$s->{exclusions}}]): ()),);bless \%guts=>ref($s)}sub as_modifiers {my ($self)=@_;my@mods;push@mods,[add_minimum=>$self->{minimum}]if exists$self->{minimum};push@mods,[add_maximum=>$self->{maximum}]if exists$self->{maximum};push@mods,map {;[add_exclusion=>$_ ]}@{$self->{exclusions}|| []};return \@mods}sub as_struct {my ($self)=@_;return 0 if!keys %$self;my@exclusions=@{$self->{exclusions}|| []};my@parts;for my$tuple ([qw(>= > minimum) ],[qw(<= < maximum) ],){my ($op,$e_op,$k)=@$tuple;if (exists$self->{$k}){my@new_exclusions=grep {$_!=$self->{$k }}@exclusions;if (@new_exclusions==@exclusions){push@parts,[$op,"$self->{ $k }" ]}else {push@parts,[$e_op,"$self->{ $k }" ];@exclusions=@new_exclusions}}}push@parts,map {;["!=","$_" ]}@exclusions;return \@parts}sub as_string {my ($self)=@_;my@parts=@{$self->as_struct};return$parts[0][1]if@parts==1 and $parts[0][0]eq '>=';return join q{, },map {;join q{ },@$_}@parts}sub _reject_requirements {my ($self,$module,$error)=@_;Carp::confess("illegal requirements for $module: $error")}sub with_exact_version {my ($self,$version,$module)=@_;$module='module' unless defined$module;$self=$self->_clone;unless ($self->_accepts($version)){$self->_reject_requirements($module,"exact specification $version outside of range " .$self->as_string)}return CPAN::Meta::Requirements::_Range::Exact->_new($version)}sub _simplify {my ($self,$module)=@_;if (defined$self->{minimum}and defined$self->{maximum}){if ($self->{minimum}==$self->{maximum}){if (grep {$_==$self->{minimum}}@{$self->{exclusions}|| []}){$self->_reject_requirements($module,"minimum and maximum are both $self->{minimum}, which is excluded",)}return CPAN::Meta::Requirements::_Range::Exact->_new($self->{minimum})}if ($self->{minimum}> $self->{maximum}){$self->_reject_requirements($module,"minimum $self->{minimum} exceeds maximum $self->{maximum}",)}}if ($self->{exclusions}){my%seen;@{$self->{exclusions}}=grep {(!defined$self->{minimum}or $_ >= $self->{minimum})and (!defined$self->{maximum}or $_ <= $self->{maximum})and !$seen{$_}++}@{$self->{exclusions}}}return$self}sub with_minimum {my ($self,$minimum,$module)=@_;$module='module' unless defined$module;$self=$self->_clone;if (defined (my$old_min=$self->{minimum})){$self->{minimum}=(sort {$b cmp $a}($minimum,$old_min))[0]}else {$self->{minimum}=$minimum}return$self->_simplify($module)}sub with_maximum {my ($self,$maximum,$module)=@_;$module='module' unless defined$module;$self=$self->_clone;if (defined (my$old_max=$self->{maximum})){$self->{maximum}=(sort {$a cmp $b}($maximum,$old_max))[0]}else {$self->{maximum}=$maximum}return$self->_simplify($module)}sub with_exclusion {my ($self,$exclusion,$module)=@_;$module='module' unless defined$module;$self=$self->_clone;push @{$self->{exclusions}||= []},$exclusion;return$self->_simplify($module)}sub _accepts {my ($self,$version)=@_;return if defined$self->{minimum}and $version < $self->{minimum};return if defined$self->{maximum}and $version > $self->{maximum};return if defined$self->{exclusions}and grep {$version==$_}@{$self->{exclusions}};return 1}}1;
CPAN_META_REQUIREMENTS

$fatpacked{"CPAN/Meta/Spec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_SPEC';
  use 5.006;use strict;use warnings;package CPAN::Meta::Spec;our$VERSION='2.150010';1;
CPAN_META_SPEC

$fatpacked{"CPAN/Meta/Validator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_VALIDATOR';
  use 5.006;use strict;use warnings;package CPAN::Meta::Validator;our$VERSION='2.150010';my%known_specs=('1.4'=>'http://module-build.sourceforge.net/META-spec-v1.4.html','1.3'=>'http://module-build.sourceforge.net/META-spec-v1.3.html','1.2'=>'http://module-build.sourceforge.net/META-spec-v1.2.html','1.1'=>'http://module-build.sourceforge.net/META-spec-v1.1.html','1.0'=>'http://module-build.sourceforge.net/META-spec-v1.0.html');my%known_urls=map {$known_specs{$_}=>$_}keys%known_specs;my$module_map1={'map'=>{':key'=>{name=>\&module,value=>\&exversion }}};my$module_map2={'map'=>{':key'=>{name=>\&module,value=>\&version }}};my$no_index_2={'map'=>{file=>{list=>{value=>\&string }},directory=>{list=>{value=>\&string }},'package'=>{list=>{value=>\&string }},namespace=>{list=>{value=>\&string }},':key'=>{name=>\&custom_2,value=>\&anything },}};my$no_index_1_3={'map'=>{file=>{list=>{value=>\&string }},directory=>{list=>{value=>\&string }},'package'=>{list=>{value=>\&string }},namespace=>{list=>{value=>\&string }},':key'=>{name=>\&string,value=>\&anything },}};my$no_index_1_2={'map'=>{file=>{list=>{value=>\&string }},dir=>{list=>{value=>\&string }},'package'=>{list=>{value=>\&string }},namespace=>{list=>{value=>\&string }},':key'=>{name=>\&string,value=>\&anything },}};my$no_index_1_1={'map'=>{':key'=>{name=>\&string,list=>{value=>\&string }},}};my$prereq_map={map=>{':key'=>{name=>\&phase,'map'=>{':key'=>{name=>\&relation,%$module_map1,},},}},};my%definitions=('2'=>{'abstract'=>{mandatory=>1,value=>\&string },'author'=>{mandatory=>1,list=>{value=>\&string }},'dynamic_config'=>{mandatory=>1,value=>\&boolean },'generated_by'=>{mandatory=>1,value=>\&string },'license'=>{mandatory=>1,list=>{value=>\&license }},'meta-spec'=>{mandatory=>1,'map'=>{version=>{mandatory=>1,value=>\&version},url=>{value=>\&url },':key'=>{name=>\&custom_2,value=>\&anything },}},'name'=>{mandatory=>1,value=>\&string },'release_status'=>{mandatory=>1,value=>\&release_status },'version'=>{mandatory=>1,value=>\&version },'description'=>{value=>\&string },'keywords'=>{list=>{value=>\&string }},'no_index'=>$no_index_2,'optional_features'=>{'map'=>{':key'=>{name=>\&string,'map'=>{description=>{value=>\&string },prereqs=>$prereq_map,':key'=>{name=>\&custom_2,value=>\&anything },}}}},'prereqs'=>$prereq_map,'provides'=>{'map'=>{':key'=>{name=>\&module,'map'=>{file=>{mandatory=>1,value=>\&file },version=>{value=>\&version },':key'=>{name=>\&custom_2,value=>\&anything },}}}},'resources'=>{'map'=>{license=>{list=>{value=>\&url }},homepage=>{value=>\&url },bugtracker=>{'map'=>{web=>{value=>\&url },mailto=>{value=>\&string},':key'=>{name=>\&custom_2,value=>\&anything },}},repository=>{'map'=>{web=>{value=>\&url },url=>{value=>\&url },type=>{value=>\&string },':key'=>{name=>\&custom_2,value=>\&anything },}},':key'=>{value=>\&string,name=>\&custom_2 },}},':key'=>{name=>\&custom_2,value=>\&anything },},'1.4'=>{'meta-spec'=>{mandatory=>1,'map'=>{version=>{mandatory=>1,value=>\&version},url=>{mandatory=>1,value=>\&urlspec },':key'=>{name=>\&string,value=>\&anything },},},'name'=>{mandatory=>1,value=>\&string },'version'=>{mandatory=>1,value=>\&version },'abstract'=>{mandatory=>1,value=>\&string },'author'=>{mandatory=>1,list=>{value=>\&string }},'license'=>{mandatory=>1,value=>\&license },'generated_by'=>{mandatory=>1,value=>\&string },'distribution_type'=>{value=>\&string },'dynamic_config'=>{value=>\&boolean },'requires'=>$module_map1,'recommends'=>$module_map1,'build_requires'=>$module_map1,'configure_requires'=>$module_map1,'conflicts'=>$module_map2,'optional_features'=>{'map'=>{':key'=>{name=>\&string,'map'=>{description=>{value=>\&string },requires=>$module_map1,recommends=>$module_map1,build_requires=>$module_map1,conflicts=>$module_map2,':key'=>{name=>\&string,value=>\&anything },}}}},'provides'=>{'map'=>{':key'=>{name=>\&module,'map'=>{file=>{mandatory=>1,value=>\&file },version=>{value=>\&version },':key'=>{name=>\&string,value=>\&anything },}}}},'no_index'=>$no_index_1_3,'private'=>$no_index_1_3,'keywords'=>{list=>{value=>\&string }},'resources'=>{'map'=>{license=>{value=>\&url },homepage=>{value=>\&url },bugtracker=>{value=>\&url },repository=>{value=>\&url },':key'=>{value=>\&string,name=>\&custom_1 },}},':key'=>{name=>\&string,value=>\&anything },},'1.3'=>{'meta-spec'=>{mandatory=>1,'map'=>{version=>{mandatory=>1,value=>\&version},url=>{mandatory=>1,value=>\&urlspec },':key'=>{name=>\&string,value=>\&anything },},},'name'=>{mandatory=>1,value=>\&string },'version'=>{mandatory=>1,value=>\&version },'abstract'=>{mandatory=>1,value=>\&string },'author'=>{mandatory=>1,list=>{value=>\&string }},'license'=>{mandatory=>1,value=>\&license },'generated_by'=>{mandatory=>1,value=>\&string },'distribution_type'=>{value=>\&string },'dynamic_config'=>{value=>\&boolean },'requires'=>$module_map1,'recommends'=>$module_map1,'build_requires'=>$module_map1,'conflicts'=>$module_map2,'optional_features'=>{'map'=>{':key'=>{name=>\&string,'map'=>{description=>{value=>\&string },requires=>$module_map1,recommends=>$module_map1,build_requires=>$module_map1,conflicts=>$module_map2,':key'=>{name=>\&string,value=>\&anything },}}}},'provides'=>{'map'=>{':key'=>{name=>\&module,'map'=>{file=>{mandatory=>1,value=>\&file },version=>{value=>\&version },':key'=>{name=>\&string,value=>\&anything },}}}},'no_index'=>$no_index_1_3,'private'=>$no_index_1_3,'keywords'=>{list=>{value=>\&string }},'resources'=>{'map'=>{license=>{value=>\&url },homepage=>{value=>\&url },bugtracker=>{value=>\&url },repository=>{value=>\&url },':key'=>{value=>\&string,name=>\&custom_1 },}},':key'=>{name=>\&string,value=>\&anything },},'1.2'=>{'meta-spec'=>{mandatory=>1,'map'=>{version=>{mandatory=>1,value=>\&version},url=>{mandatory=>1,value=>\&urlspec },':key'=>{name=>\&string,value=>\&anything },},},'name'=>{mandatory=>1,value=>\&string },'version'=>{mandatory=>1,value=>\&version },'license'=>{mandatory=>1,value=>\&license },'generated_by'=>{mandatory=>1,value=>\&string },'author'=>{mandatory=>1,list=>{value=>\&string }},'abstract'=>{mandatory=>1,value=>\&string },'distribution_type'=>{value=>\&string },'dynamic_config'=>{value=>\&boolean },'keywords'=>{list=>{value=>\&string }},'private'=>$no_index_1_2,'$no_index'=>$no_index_1_2,'requires'=>$module_map1,'recommends'=>$module_map1,'build_requires'=>$module_map1,'conflicts'=>$module_map2,'optional_features'=>{'map'=>{':key'=>{name=>\&string,'map'=>{description=>{value=>\&string },requires=>$module_map1,recommends=>$module_map1,build_requires=>$module_map1,conflicts=>$module_map2,':key'=>{name=>\&string,value=>\&anything },}}}},'provides'=>{'map'=>{':key'=>{name=>\&module,'map'=>{file=>{mandatory=>1,value=>\&file },version=>{value=>\&version },':key'=>{name=>\&string,value=>\&anything },}}}},'resources'=>{'map'=>{license=>{value=>\&url },homepage=>{value=>\&url },bugtracker=>{value=>\&url },repository=>{value=>\&url },':key'=>{value=>\&string,name=>\&custom_1 },}},':key'=>{name=>\&string,value=>\&anything },},'1.1'=>{'name'=>{value=>\&string },'version'=>{mandatory=>1,value=>\&version },'license'=>{value=>\&license },'generated_by'=>{value=>\&string },'license_uri'=>{value=>\&url },'distribution_type'=>{value=>\&string },'dynamic_config'=>{value=>\&boolean },'private'=>$no_index_1_1,'requires'=>$module_map1,'recommends'=>$module_map1,'build_requires'=>$module_map1,'conflicts'=>$module_map2,':key'=>{name=>\&string,value=>\&anything },},'1.0'=>{'name'=>{value=>\&string },'version'=>{mandatory=>1,value=>\&version },'license'=>{value=>\&license },'generated_by'=>{value=>\&string },'license_uri'=>{value=>\&url },'distribution_type'=>{value=>\&string },'dynamic_config'=>{value=>\&boolean },'requires'=>$module_map1,'recommends'=>$module_map1,'build_requires'=>$module_map1,'conflicts'=>$module_map2,':key'=>{name=>\&string,value=>\&anything },},);sub new {my ($class,$data)=@_;my$self={'data'=>$data,'spec'=>eval {$data->{'meta-spec'}{'version'}}|| "1.0",'errors'=>undef,};return bless$self,$class}sub is_valid {my$self=shift;my$data=$self->{data};my$spec_version=$self->{spec};$self->check_map($definitions{$spec_version},$data);return!$self->errors}sub errors {my$self=shift;return ()unless(defined$self->{errors});return @{$self->{errors}}}my$spec_error="Missing validation action in specification. " ."Must be one of 'map', 'list', or 'value'";sub check_map {my ($self,$spec,$data)=@_;if(ref($spec)ne 'HASH'){$self->_error("Unknown META specification, cannot validate.");return}if(ref($data)ne 'HASH'){$self->_error("Expected a map structure from string or file.");return}for my$key (keys %$spec){next unless($spec->{$key}->{mandatory});next if(defined$data->{$key});push @{$self->{stack}},$key;$self->_error("Missing mandatory field, '$key'");pop @{$self->{stack}}}for my$key (keys %$data){push @{$self->{stack}},$key;if($spec->{$key}){if($spec->{$key}{value}){$spec->{$key}{value}->($self,$key,$data->{$key})}elsif($spec->{$key}{'map'}){$self->check_map($spec->{$key}{'map'},$data->{$key})}elsif($spec->{$key}{'list'}){$self->check_list($spec->{$key}{'list'},$data->{$key})}else {$self->_error("$spec_error for '$key'")}}elsif ($spec->{':key'}){$spec->{':key'}{name}->($self,$key,$key);if($spec->{':key'}{value}){$spec->{':key'}{value}->($self,$key,$data->{$key})}elsif($spec->{':key'}{'map'}){$self->check_map($spec->{':key'}{'map'},$data->{$key})}elsif($spec->{':key'}{'list'}){$self->check_list($spec->{':key'}{'list'},$data->{$key})}else {$self->_error("$spec_error for ':key'")}}else {$self->_error("Unknown key, '$key', found in map structure")}pop @{$self->{stack}}}}sub check_list {my ($self,$spec,$data)=@_;if(ref($data)ne 'ARRAY'){$self->_error("Expected a list structure");return}if(defined$spec->{mandatory}){if(!defined$data->[0]){$self->_error("Missing entries from mandatory list")}}for my$value (@$data){push @{$self->{stack}},$value || "<undef>";if(defined$spec->{value}){$spec->{value}->($self,'list',$value)}elsif(defined$spec->{'map'}){$self->check_map($spec->{'map'},$value)}elsif(defined$spec->{'list'}){$self->check_list($spec->{'list'},$value)}elsif ($spec->{':key'}){$self->check_map($spec,$value)}else {$self->_error("$spec_error associated with '$self->{stack}[-2]'")}pop @{$self->{stack}}}}sub header {my ($self,$key,$value)=@_;if(defined$value){return 1 if($value && $value =~ /^--- #YAML:1.0/)}$self->_error("file does not have a valid YAML header.");return 0}sub release_status {my ($self,$key,$value)=@_;if(defined$value){my$version=$self->{data}{version}|| '';if ($version =~ /_/){return 1 if ($value =~ /\A(?:testing|unstable)\z/);$self->_error("'$value' for '$key' is invalid for version '$version'")}else {return 1 if ($value =~ /\A(?:stable|testing|unstable)\z/);$self->_error("'$value' for '$key' is invalid")}}else {$self->_error("'$key' is not defined")}return 0}sub _uri_split {return $_[0]=~ m,(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?,}sub url {my ($self,$key,$value)=@_;if(defined$value){my ($scheme,$auth,$path,$query,$frag)=_uri_split($value);unless (defined$scheme && length$scheme){$self->_error("'$value' for '$key' does not have a URL scheme");return 0}unless (defined$auth && length$auth){$self->_error("'$value' for '$key' does not have a URL authority");return 0}return 1}$value ||= '';$self->_error("'$value' for '$key' is not a valid URL.");return 0}sub urlspec {my ($self,$key,$value)=@_;if(defined$value){return 1 if($value && $known_specs{$self->{spec}}eq $value);if($value && $known_urls{$value}){$self->_error('META specification URL does not match version');return 0}}$self->_error('Unknown META specification');return 0}sub anything {return 1}sub string {my ($self,$key,$value)=@_;if(defined$value){return 1 if($value || $value =~ /^0$/)}$self->_error("value is an undefined string");return 0}sub string_or_undef {my ($self,$key,$value)=@_;return 1 unless(defined$value);return 1 if($value || $value =~ /^0$/);$self->_error("No string defined for '$key'");return 0}sub file {my ($self,$key,$value)=@_;return 1 if(defined$value);$self->_error("No file defined for '$key'");return 0}sub exversion {my ($self,$key,$value)=@_;if(defined$value && ($value || $value =~ /0/)){my$pass=1;for(split(",",$value)){$self->version($key,$_)or ($pass=0)}return$pass}$value='<undef>' unless(defined$value);$self->_error("'$value' for '$key' is not a valid version.");return 0}sub version {my ($self,$key,$value)=@_;if(defined$value){return 0 unless($value || $value =~ /0/);return 1 if($value =~ /^\s*((<|<=|>=|>|!=|==)\s*)?v?\d+((\.\d+((_|\.)\d+)?)?)/)}else {$value='<undef>'}$self->_error("'$value' for '$key' is not a valid version.");return 0}sub boolean {my ($self,$key,$value)=@_;if(defined$value){return 1 if($value =~ /^(0|1)$/)}else {$value='<undef>'}$self->_error("'$value' for '$key' is not a boolean value.");return 0}my%v1_licenses=('perl'=>'http://dev.perl.org/licenses/','gpl'=>'http://www.opensource.org/licenses/gpl-license.php','apache'=>'http://apache.org/licenses/LICENSE-2.0','artistic'=>'http://opensource.org/licenses/artistic-license.php','artistic_2'=>'http://opensource.org/licenses/artistic-license-2.0.php','lgpl'=>'http://www.opensource.org/licenses/lgpl-license.php','bsd'=>'http://www.opensource.org/licenses/bsd-license.php','gpl'=>'http://www.opensource.org/licenses/gpl-license.php','mit'=>'http://opensource.org/licenses/mit-license.php','mozilla'=>'http://opensource.org/licenses/mozilla1.1.php','open_source'=>undef,'unrestricted'=>undef,'restrictive'=>undef,'unknown'=>undef,);my%v2_licenses=map {$_=>1}qw(agpl_3 apache_1_1 apache_2_0 artistic_1 artistic_2 bsd freebsd gfdl_1_2 gfdl_1_3 gpl_1 gpl_2 gpl_3 lgpl_2_1 lgpl_3_0 mit mozilla_1_0 mozilla_1_1 openssl perl_5 qpl_1_0 ssleay sun zlib open_source restricted unrestricted unknown);sub license {my ($self,$key,$value)=@_;my$licenses=$self->{spec}< 2 ? \%v1_licenses : \%v2_licenses;if(defined$value){return 1 if($value && exists$licenses->{$value})}else {$value='<undef>'}$self->_error("License '$value' is invalid");return 0}sub custom_1 {my ($self,$key)=@_;if(defined$key){return 1 if($key && $key =~ /^[_a-z]+$/i && $key =~ /[A-Z]/)}else {$key='<undef>'}$self->_error("Custom resource '$key' must be in CamelCase.");return 0}sub custom_2 {my ($self,$key)=@_;if(defined$key){return 1 if($key && $key =~ /^x_/i)}else {$key='<undef>'}$self->_error("Custom key '$key' must begin with 'x_' or 'X_'.");return 0}sub identifier {my ($self,$key)=@_;if(defined$key){return 1 if($key && $key =~ /^([a-z][_a-z]+)$/i)}else {$key='<undef>'}$self->_error("Key '$key' is not a legal identifier.");return 0}sub module {my ($self,$key)=@_;if(defined$key){return 1 if($key && $key =~ /^[A-Za-z0-9_]+(::[A-Za-z0-9_]+)*$/)}else {$key='<undef>'}$self->_error("Key '$key' is not a legal module name.");return 0}my@valid_phases=qw/configure build test runtime develop/;sub phase {my ($self,$key)=@_;if(defined$key){return 1 if(length$key && grep {$key eq $_}@valid_phases);return 1 if$key =~ /x_/i}else {$key='<undef>'}$self->_error("Key '$key' is not a legal phase.");return 0}my@valid_relations=qw/requires recommends suggests conflicts/;sub relation {my ($self,$key)=@_;if(defined$key){return 1 if(length$key && grep {$key eq $_}@valid_relations);return 1 if$key =~ /x_/i}else {$key='<undef>'}$self->_error("Key '$key' is not a legal prereq relationship.");return 0}sub _error {my$self=shift;my$mess=shift;$mess .= ' ('.join(' -> ',@{$self->{stack}}).')' if($self->{stack});$mess .= " [Validation: $self->{spec}]";push @{$self->{errors}},$mess}1;
CPAN_META_VALIDATOR

$fatpacked{"CPAN/Meta/YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_YAML';
  use 5.008001;use strict;use warnings;package CPAN::Meta::YAML;$CPAN::Meta::YAML::VERSION='0.018';;use Exporter;our@ISA=qw{Exporter};our@EXPORT=qw{Load Dump};our@EXPORT_OK=qw{LoadFile DumpFile freeze thaw};sub Dump {return CPAN::Meta::YAML->new(@_)->_dump_string}sub Load {my$self=CPAN::Meta::YAML->_load_string(@_);if (wantarray){return @$self}else {return$self->[-1]}}BEGIN {*freeze=\&Dump;*thaw=\&Load}sub DumpFile {my$file=shift;return CPAN::Meta::YAML->new(@_)->_dump_file($file)}sub LoadFile {my$file=shift;my$self=CPAN::Meta::YAML->_load_file($file);if (wantarray){return @$self}else {return$self->[-1]}}sub new {my$class=shift;bless [@_ ],$class}sub read_string {my$self=shift;$self->_load_string(@_)}sub write_string {my$self=shift;$self->_dump_string(@_)}sub read {my$self=shift;$self->_load_file(@_)}sub write {my$self=shift;$self->_dump_file(@_)}my@UNPRINTABLE=qw(0 x01 x02 x03 x04 x05 x06 a b t n v f r x0E x0F x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x1A e x1C x1D x1E x1F);my%UNESCAPES=(0=>"\x00",z=>"\x00",N=>"\x85",a=>"\x07",b=>"\x08",t=>"\x09",n=>"\x0a",v=>"\x0b",f=>"\x0c",r=>"\x0d",e=>"\x1b",'\\'=>'\\',);my%QUOTE=map {$_=>1}qw{null true false};my$re_capture_double_quoted=qr/\"([^\\"]*(?:\\.[^\\"]*)*)\"/;my$re_capture_single_quoted=qr/\'([^\']*(?:\'\'[^\']*)*)\'/;my$re_capture_unquoted_key=qr/([^:]+(?::+\S(?:[^:]*|.*?(?=:)))*)(?=\s*\:(?:\s+|$))/;my$re_trailing_comment=qr/(?:\s+\#.*)?/;my$re_key_value_separator=qr/\s*:(?:\s+(?:\#.*)?|$)/;sub _load_file {my$class=ref $_[0]? ref shift : shift;my$file=shift or $class->_error('You did not specify a file name');$class->_error("File '$file' does not exist")unless -e $file;$class->_error("'$file' is a directory, not a file")unless -f _;$class->_error("Insufficient permissions to read '$file'")unless -r _;open(my$fh,"<:unix:encoding(UTF-8)",$file);unless ($fh){$class->_error("Failed to open file '$file': $!")}if (_can_flock()){flock($fh,Fcntl::LOCK_SH())or warn "Couldn't lock '$file' for reading: $!"}my$contents=eval {use warnings FATAL=>'utf8';local $/;<$fh>};if (my$err=$@){$class->_error("Error reading from file '$file': $err")}unless (close$fh){$class->_error("Failed to close file '$file': $!")}$class->_load_string($contents)}sub _load_string {my$class=ref $_[0]? ref shift : shift;my$self=bless [],$class;my$string=$_[0];eval {unless (defined$string){die \"Did not provide a string to load"}if (utf8::is_utf8($string)&&!utf8::valid($string)){die \<<'...'}utf8::upgrade($string);$string =~ s/^\x{FEFF}//;return$self unless length$string;my@lines=grep {!/^\s*(?:\#.*)?\z/}split /(?:\015{1,2}\012|\015|\012)/,$string;@lines and $lines[0]=~ /^\%YAML[: ][\d\.]+.*\z/ and shift@lines;my$in_document=0;while (@lines){if ($lines[0]=~ /^---\s*(?:(.+)\s*)?\z/){shift@lines;if (defined $1 and $1 !~ /^(?:\#.+|\%YAML[: ][\d\.]+)\z/){push @$self,$self->_load_scalar("$1",[undef ],\@lines);next}$in_document=1}if (!@lines or $lines[0]=~ /^(?:---|\.\.\.)/){push @$self,undef;while (@lines and $lines[0]!~ /^---/){shift@lines}$in_document=0}elsif (!$in_document && @$self){die \"CPAN::Meta::YAML failed to classify the line '$lines[0]'"}elsif ($lines[0]=~ /^\s*\-(?:\s|$|-+$)/){my$document=[];push @$self,$document;$self->_load_array($document,[0 ],\@lines)}elsif ($lines[0]=~ /^(\s*)\S/){my$document={};push @$self,$document;$self->_load_hash($document,[length($1)],\@lines)}else {die \"CPAN::Meta::YAML failed to classify the line '$lines[0]'"}}};my$err=$@;if (ref$err eq 'SCALAR'){$self->_error(${$err})}elsif ($err){$self->_error($err)}return$self}sub _unquote_single {my ($self,$string)=@_;return '' unless length$string;$string =~ s/\'\'/\'/g;return$string}sub _unquote_double {my ($self,$string)=@_;return '' unless length$string;$string =~ s/\\"/"/g;$string =~ s{\\([Nnever\\fartz0b]|x([0-9a-fA-F]{2}))}
  Read an invalid UTF-8 string (maybe mixed UTF-8 and 8-bit character set).
  Did you decode with lax ":utf8" instead of strict ":encoding(UTF-8)"?
  ...
           {(length($1)>1)?pack("H2",$2):$UNESCAPES{$1}}gex;return$string}sub _load_scalar {my ($self,$string,$indent,$lines)=@_;$string =~ s/\s*\z//;return undef if$string eq '~';if ($string =~ /^$re_capture_single_quoted$re_trailing_comment\z/){return$self->_unquote_single($1)}if ($string =~ /^$re_capture_double_quoted$re_trailing_comment\z/){return$self->_unquote_double($1)}if ($string =~ /^[\'\"!&]/){die \"CPAN::Meta::YAML does not support a feature in line '$string'"}return {}if$string =~ /^{}(?:\s+\#.*)?\z/;return []if$string =~ /^\[\](?:\s+\#.*)?\z/;if ($string !~ /^[>|]/){die \"CPAN::Meta::YAML found illegal characters in plain scalar: '$string'" if$string =~ /^(?:-(?:\s|$)|[\@\%\`])/ or $string =~ /:(?:\s|$)/;$string =~ s/\s+#.*\z//;return$string}die \"CPAN::Meta::YAML failed to find multi-line scalar content" unless @$lines;$lines->[0]=~ /^(\s*)/;$indent->[-1]=length("$1");if (defined$indent->[-2]and $indent->[-1]<= $indent->[-2]){die \"CPAN::Meta::YAML found bad indenting in line '$lines->[0]'"}my@multiline=();while (@$lines){$lines->[0]=~ /^(\s*)/;last unless length($1)>= $indent->[-1];push@multiline,substr(shift(@$lines),length($1))}my$j=(substr($string,0,1)eq '>')? ' ' : "\n";my$t=(substr($string,1,1)eq '-')? '' : "\n";return join($j,@multiline).$t}sub _load_array {my ($self,$array,$indent,$lines)=@_;while (@$lines){if ($lines->[0]=~ /^(?:---|\.\.\.)/){while (@$lines and $lines->[0]!~ /^---/){shift @$lines}return 1}$lines->[0]=~ /^(\s*)/;if (length($1)< $indent->[-1]){return 1}elsif (length($1)> $indent->[-1]){die \"CPAN::Meta::YAML found bad indenting in line '$lines->[0]'"}if ($lines->[0]=~ /^(\s*\-\s+)[^\'\"]\S*\s*:(?:\s+|$)/){my$indent2=length("$1");$lines->[0]=~ s/-/ /;push @$array,{};$self->_load_hash($array->[-1],[@$indent,$indent2 ],$lines)}elsif ($lines->[0]=~ /^\s*\-\s*\z/){shift @$lines;unless (@$lines){push @$array,undef;return 1}if ($lines->[0]=~ /^(\s*)\-/){my$indent2=length("$1");if ($indent->[-1]==$indent2){push @$array,undef}else {push @$array,[];$self->_load_array($array->[-1],[@$indent,$indent2 ],$lines)}}elsif ($lines->[0]=~ /^(\s*)\S/){push @$array,{};$self->_load_hash($array->[-1],[@$indent,length("$1")],$lines)}else {die \"CPAN::Meta::YAML failed to classify line '$lines->[0]'"}}elsif ($lines->[0]=~ /^\s*\-(\s*)(.+?)\s*\z/){shift @$lines;push @$array,$self->_load_scalar("$2",[@$indent,undef ],$lines)}elsif (defined$indent->[-2]and $indent->[-1]==$indent->[-2]){return 1}else {die \"CPAN::Meta::YAML failed to classify line '$lines->[0]'"}}return 1}sub _load_hash {my ($self,$hash,$indent,$lines)=@_;while (@$lines){if ($lines->[0]=~ /^(?:---|\.\.\.)/){while (@$lines and $lines->[0]!~ /^---/){shift @$lines}return 1}$lines->[0]=~ /^(\s*)/;if (length($1)< $indent->[-1]){return 1}elsif (length($1)> $indent->[-1]){die \"CPAN::Meta::YAML found bad indenting in line '$lines->[0]'"}my$key;if ($lines->[0]=~ s/^\s*$re_capture_single_quoted$re_key_value_separator//){$key=$self->_unquote_single($1)}elsif ($lines->[0]=~ s/^\s*$re_capture_double_quoted$re_key_value_separator//){$key=$self->_unquote_double($1)}elsif ($lines->[0]=~ s/^\s*$re_capture_unquoted_key$re_key_value_separator//){$key=$1;$key =~ s/\s+$//}elsif ($lines->[0]=~ /^\s*\?/){die \"CPAN::Meta::YAML does not support a feature in line '$lines->[0]'"}else {die \"CPAN::Meta::YAML failed to classify line '$lines->[0]'"}if (exists$hash->{$key}){warn "CPAN::Meta::YAML found a duplicate key '$key' in line '$lines->[0]'"}if (length$lines->[0]){$hash->{$key}=$self->_load_scalar(shift(@$lines),[@$indent,undef ],$lines)}else {shift @$lines;unless (@$lines){$hash->{$key}=undef;return 1}if ($lines->[0]=~ /^(\s*)-/){$hash->{$key}=[];$self->_load_array($hash->{$key},[@$indent,length($1)],$lines)}elsif ($lines->[0]=~ /^(\s*)./){my$indent2=length("$1");if ($indent->[-1]>= $indent2){$hash->{$key}=undef}else {$hash->{$key}={};$self->_load_hash($hash->{$key},[@$indent,length($1)],$lines)}}}}return 1}sub _dump_file {my$self=shift;require Fcntl;my$file=shift or $self->_error('You did not specify a file name');my$fh;if (_can_flock()){my$flags=Fcntl::O_WRONLY()|Fcntl::O_CREAT();sysopen($fh,$file,$flags);unless ($fh){$self->_error("Failed to open file '$file' for writing: $!")}binmode($fh,":raw:encoding(UTF-8)");flock($fh,Fcntl::LOCK_EX())or warn "Couldn't lock '$file' for reading: $!";truncate$fh,0;seek$fh,0,0}else {open$fh,">:unix:encoding(UTF-8)",$file}print {$fh}$self->_dump_string;unless (close$fh){$self->_error("Failed to close file '$file': $!")}return 1}sub _dump_string {my$self=shift;return '' unless ref$self && @$self;my$indent=0;my@lines=();eval {for my$cursor (@$self){push@lines,'---';if (!defined$cursor){}elsif (!ref$cursor){$lines[-1].= ' ' .$self->_dump_scalar($cursor)}elsif (ref$cursor eq 'ARRAY'){unless (@$cursor){$lines[-1].= ' []';next}push@lines,$self->_dump_array($cursor,$indent,{})}elsif (ref$cursor eq 'HASH'){unless (%$cursor){$lines[-1].= ' {}';next}push@lines,$self->_dump_hash($cursor,$indent,{})}else {die \("Cannot serialize " .ref($cursor))}}};if (ref $@ eq 'SCALAR'){$self->_error(${$@})}elsif ($@){$self->_error($@)}join '',map {"$_\n"}@lines}sub _has_internal_string_value {my$value=shift;my$b_obj=B::svref_2object(\$value);return$b_obj->FLAGS & B::SVf_POK()}sub _dump_scalar {my$string=$_[1];my$is_key=$_[2];my$has_string_flag=_has_internal_string_value($string);return '~' unless defined$string;return "''" unless length$string;if (Scalar::Util::looks_like_number($string)){if ($is_key || $has_string_flag){return qq['$string']}else {return$string}}if ($string =~ /[\x00-\x09\x0b-\x0d\x0e-\x1f\x7f-\x9f\'\n]/){$string =~ s/\\/\\\\/g;$string =~ s/"/\\"/g;$string =~ s/\n/\\n/g;$string =~ s/[\x85]/\\N/g;$string =~ s/([\x00-\x1f])/\\$UNPRINTABLE[ord($1)]/g;$string =~ s/([\x7f-\x9f])/'\x' . sprintf("%X",ord($1))/ge;return qq|"$string"|}if ($string =~ /(?:^[~!@#%&*|>?:,'"`{}\[\]]|^-+$|\s|:\z)/ or $QUOTE{$string}){return "'$string'"}return$string}sub _dump_array {my ($self,$array,$indent,$seen)=@_;if ($seen->{refaddr($array)}++){die \"CPAN::Meta::YAML does not support circular references"}my@lines=();for my$el (@$array){my$line=('  ' x $indent).'-';my$type=ref$el;if (!$type){$line .= ' ' .$self->_dump_scalar($el);push@lines,$line}elsif ($type eq 'ARRAY'){if (@$el){push@lines,$line;push@lines,$self->_dump_array($el,$indent + 1,$seen)}else {$line .= ' []';push@lines,$line}}elsif ($type eq 'HASH'){if (keys %$el){push@lines,$line;push@lines,$self->_dump_hash($el,$indent + 1,$seen)}else {$line .= ' {}';push@lines,$line}}else {die \"CPAN::Meta::YAML does not support $type references"}}@lines}sub _dump_hash {my ($self,$hash,$indent,$seen)=@_;if ($seen->{refaddr($hash)}++){die \"CPAN::Meta::YAML does not support circular references"}my@lines=();for my$name (sort keys %$hash){my$el=$hash->{$name};my$line=('  ' x $indent).$self->_dump_scalar($name,1).":";my$type=ref$el;if (!$type){$line .= ' ' .$self->_dump_scalar($el);push@lines,$line}elsif ($type eq 'ARRAY'){if (@$el){push@lines,$line;push@lines,$self->_dump_array($el,$indent + 1,$seen)}else {$line .= ' []';push@lines,$line}}elsif ($type eq 'HASH'){if (keys %$el){push@lines,$line;push@lines,$self->_dump_hash($el,$indent + 1,$seen)}else {$line .= ' {}';push@lines,$line}}else {die \"CPAN::Meta::YAML does not support $type references"}}@lines}our$errstr='';sub _error {require Carp;$errstr=$_[1];$errstr =~ s/ at \S+ line \d+.*//;Carp::croak($errstr)}my$errstr_warned;sub errstr {require Carp;Carp::carp("CPAN::Meta::YAML->errstr and \$CPAN::Meta::YAML::errstr is deprecated")unless$errstr_warned++;$errstr}use B;my$HAS_FLOCK;sub _can_flock {if (defined$HAS_FLOCK){return$HAS_FLOCK}else {require Config;my$c=\%Config::Config;$HAS_FLOCK=grep {$c->{$_}}qw/d_flock d_fcntl_can_lock d_lockf/;require Fcntl if$HAS_FLOCK;return$HAS_FLOCK}}use Scalar::Util ();BEGIN {local $@;if (eval {Scalar::Util->VERSION(1.18)}){*refaddr=*Scalar::Util::refaddr}else {eval <<'END_PERL'}}delete$CPAN::Meta::YAML::{refaddr};1;
  # Scalar::Util failed to load or too old
  sub refaddr {
      my $pkg = ref($_[0]) or return undef;
      if ( !! UNIVERSAL::can($_[0], 'can') ) {
          bless $_[0], 'Scalar::Util::Fake';
      } else {
          $pkg = undef;
      }
      "$_[0]" =~ /0x(\w+)/;
      my $i = do { no warnings 'portable'; hex $1 };
      bless $_[0], $pkg if defined $pkg;
      $i;
  }
  END_PERL
CPAN_META_YAML

$fatpacked{"Class/Inspector.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_INSPECTOR';
  package Class::Inspector;use 5.006;use strict qw{vars subs};use warnings;use File::Spec ();our$VERSION='1.36';BEGIN {local $@;eval {require utf8;utf8->import}}our$RE_IDENTIFIER=qr/\A[^\W\d]\w*\z/s;our$RE_CLASS=qr/\A[^\W\d]\w*(?:(?:\'|::)\w+)*\z/s;our$UNIX=!!($File::Spec::ISA[0]eq 'File::Spec::Unix');sub _resolved_inc_handler {my$class=shift;my$filename=$class->_inc_filename(shift)or return undef;for my$inc (@INC){my$ref=ref$inc;if($ref eq 'CODE'){my@ret=$inc->($inc,$filename);if(@ret==1 &&!defined$ret[0]){}elsif(@ret){return 1}}elsif($ref eq 'ARRAY' && ref($inc->[0])eq 'CODE'){my@ret=$inc->[0]->($inc,$filename);if(@ret){return 1}}elsif($ref && eval {$inc->can('INC')}){my@ret=$inc->INC($filename);if(@ret){return 1}}}''}sub installed {my$class=shift;!!($class->loaded_filename($_[0])or $class->resolved_filename($_[0])or $class->_resolved_inc_handler($_[0]))}sub loaded {my$class=shift;my$name=$class->_class(shift)or return undef;$class->_loaded($name)}sub _loaded {my$class=shift;my$name=shift;return 1 if defined ${"${name}::VERSION"};return 1 if @{"${name}::ISA"};for (keys %{"${name}::"}){next if substr($_,-2,2)eq '::';return 1 if defined &{"${name}::$_"}}my$filename=$class->_inc_filename($name);return 1 if defined$INC{$filename};''}sub filename {my$class=shift;my$name=$class->_class(shift)or return undef;File::Spec->catfile(split /(?:\'|::)/,$name).'.pm'}sub resolved_filename {my$class=shift;my$filename=$class->_inc_filename(shift)or return undef;my@try_first=@_;for (@try_first,@INC){my$full="$_/$filename";next unless -e $full;return$UNIX ? $full : $class->_inc_to_local($full)}''}sub loaded_filename {my$class=shift;my$filename=$class->_inc_filename(shift);$UNIX ? $INC{$filename}: $class->_inc_to_local($INC{$filename})}sub functions {my$class=shift;my$name=$class->_class(shift)or return undef;return undef unless$class->loaded($name);my@functions=sort grep {/$RE_IDENTIFIER/o}grep {defined &{"${name}::$_"}}keys %{"${name}::"};\@functions}sub function_refs {my$class=shift;my$name=$class->_class(shift)or return undef;return undef unless$class->loaded($name);my@functions=map {\&{"${name}::$_"}}sort grep {/$RE_IDENTIFIER/o}grep {defined &{"${name}::$_"}}keys %{"${name}::"};\@functions}sub function_exists {my$class=shift;my$name=$class->_class(shift)or return undef;my$function=shift or return undef;return undef unless$class->loaded($name);defined &{"${name}::$function"}}sub methods {my$class=shift;my$name=$class->_class(shift)or return undef;my@arguments=map {lc $_}@_;my%options=();for (@arguments){if ($_ eq 'public'){return undef if$options{private};$options{public}=1}elsif ($_ eq 'private'){return undef if$options{public};$options{private}=1}elsif ($_ eq 'full'){return undef if$options{expanded};$options{full}=1}elsif ($_ eq 'expanded'){return undef if$options{full};$options{expanded}=1}else {return undef}}return undef unless$class->loaded($name);my@path=();my@queue=($name);my%seen=($name=>1);while (my$cl=shift@queue){push@path,$cl;unshift@queue,grep {!$seen{$_}++}map {s/^::/main::/;s/\'/::/g;$_}map {"$_"}(@{"${cl}::ISA"})}my%methods=();for my$namespace (@path){my@functions=grep {!$methods{$_}}grep {/$RE_IDENTIFIER/o}grep {defined &{"${namespace}::$_"}}keys %{"${namespace}::"};for (@functions){$methods{$_}=$namespace}}my@methodlist=sort keys%methods;@methodlist=grep {!/^\_/}@methodlist if$options{public};@methodlist=grep {/^\_/}@methodlist if$options{private};@methodlist=map {"$methods{$_}::$_"}@methodlist if$options{full};@methodlist=map {["$methods{$_}::$_",$methods{$_},$_,\&{"$methods{$_}::$_"}]}@methodlist if$options{expanded};\@methodlist}sub subclasses {my$class=shift;my$name=$class->_class(shift)or return undef;my@found=();my@queue=grep {$_ ne 'main'}$class->_subnames('');while (@queue){my$c=shift(@queue);if ($class->_loaded($c)){local $@;eval {if ($c->isa($name)){push@found,$c unless$c eq $name}}}unshift@queue,map {"${c}::$_"}$class->_subnames($c)}@found ? \@found : ''}sub _subnames {my ($class,$name)=@_;return sort grep {substr($_,-2,2,'')eq '::' and /$RE_IDENTIFIER/o}keys %{"${name}::"}}sub children {my$class=shift;my$name=$class->_class(shift)or return ();no strict 'refs';map {"${name}::$_"}sort grep {s/::$//}keys %{"${name}::"}}sub recursive_children {my$class=shift;my$name=$class->_class(shift)or return ();my@children=($name);my$i=0;no strict 'refs';while (my$namespace=$children[$i++]){push@children,map {"${namespace}::$_"}grep {!/^::/}grep {s/::$//}keys %{"${namespace}::"}}sort@children}sub _class {my$class=shift;my$name=shift or return '';return 'main' if$name eq '::';$name =~ s/\A::/main::/;$name =~ /$RE_CLASS/o ? $name : ''}sub _inc_filename {my$class=shift;my$name=$class->_class(shift)or return undef;join('/',split /(?:\'|::)/,$name).'.pm'}sub _inc_to_local {return $_[1]if$UNIX;my$class=shift;my$inc_name=shift or return undef;my ($vol,$dir,$file)=File::Spec->splitpath($inc_name);$dir=File::Spec->catdir(File::Spec->splitdir($dir || ""));File::Spec->catpath($vol,$dir,$file || "")}1;
CLASS_INSPECTOR

$fatpacked{"Class/Inspector/Functions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_INSPECTOR_FUNCTIONS';
  package Class::Inspector::Functions;use 5.006;use strict;use warnings;use Exporter ();use Class::Inspector ();use base qw(Exporter);our$VERSION='1.36';BEGIN {our@EXPORT=qw(installed loaded filename functions methods subclasses);our@EXPORT_OK=qw(resolved_filename loaded_filename function_refs function_exists);our%EXPORT_TAGS=(ALL=>[@EXPORT_OK,@EXPORT ]);for my$meth (@EXPORT,@EXPORT_OK){my$sub=Class::Inspector->can($meth);no strict 'refs';*{$meth}=sub {&$sub('Class::Inspector',@_)}}}1;
CLASS_INSPECTOR_FUNCTIONS

$fatpacked{"Clone.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLONE';
  package Clone;use strict;use vars qw($VERSION @ISA @EXPORT @EXPORT_OK $AUTOLOAD);require Exporter;require DynaLoader;require AutoLoader;@ISA=qw(Exporter DynaLoader);@EXPORT=qw();@EXPORT_OK=qw(clone);$VERSION='0.45';bootstrap Clone$VERSION;1;
CLONE

$fatpacked{"Distribution/Metadata.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DISTRIBUTION_METADATA';
  package Distribution::Metadata;use 5.008001;use strict;use warnings;use CPAN::DistnameInfo;use CPAN::Meta;use Config;use Cwd ();use ExtUtils::Packlist;use File::Basename qw(basename dirname);use File::Find 'find';use File::Spec::Functions qw(catdir catfile);use JSON ();use Module::Metadata;use constant DEBUG=>$ENV{PERL_DISTRIBUTION_METADATA_DEBUG};my$SEP=qr{/|\\};my$ARCHNAME=$Config{archname};our$VERSION="0.06";our$CACHE;sub new_from_file {my ($class,$file,%option)=@_;$class->_new(%option,_module=>{file=>$file})}sub new_from_module {my ($class,$module,%option)=@_;$class->_new(%option,_module=>{name=>$module})}sub _new {my ($class,%option)=@_;my$module=$option{_module};my$inc=$option{inc}|| \@INC;$inc=$class->_abs_path($inc);$inc=$class->_fill_archlib($inc)if$option{fill_archlib};my$metadata=$module->{file}? Module::Metadata->new_from_file($module->{file},inc=>$inc): Module::Metadata->new_from_module($module->{name},inc=>$inc);my$self=bless {},$class;return$self unless$metadata;$module->{file}=$metadata->filename;$module->{name}=$metadata->name;$module->{version}=$metadata->version;my ($packlist,$files)=$class->_find_packlist($module->{file},$inc);if ($packlist){$self->{packlist}=$packlist;$self->{files}=$files}else {return$self}my ($main_module,$lib)=$self->_guess_main_module($packlist);if ($main_module){$self->{main_module}=$main_module;if ($main_module eq "perl"){$self->{main_module_version}=$^V;$self->{main_module_file}=$^X;$self->{dist}="perl";my$version="" .$^V;$version =~ s/v//;$self->{distvname}="perl-$version";$self->{version}=$version;return$self}}else {return$self}my$archlib=catdir($lib,$ARCHNAME);my$main_metadata=Module::Metadata->new_from_module($main_module,inc=>[$archlib,$lib]);my ($find_module,$find_version);if ($main_metadata){$self->{main_module_version}=$main_metadata->version;$self->{main_module_file}=$main_metadata->filename;$find_module=$main_metadata->name;$find_version=$main_metadata->version}else {$find_module=$module->{name};$find_version=$module->{version}}my ($meta_directory,$install_json,$install_json_hash,$mymeta_json)=$class->_find_meta($main_module,$find_module,$find_version,catdir($archlib,".meta"));$self->{meta_directory}=$meta_directory;$self->{install_json}=$install_json;$self->{install_json_hash}=$install_json_hash;$self->{mymeta_json}=$mymeta_json;$self}sub _guess_main_module {my ($self,$packlist)=@_;my@piece=File::Spec->splitdir(dirname($packlist));if ($piece[-1]eq $ARCHNAME){return ("perl",undef)}my (@module,@lib);for my$i (1 .. ($#piece-2)){if ($piece[$i]eq $ARCHNAME && $piece[$i+1]eq "auto"){@module=@piece[($i+2).. $#piece ];@lib=@piece[0 .. ($i-1)];last}}return unless@module;return (_fix_module_name(join("::",@module)),catdir(@lib))}my@fix_module_name=qw(version Version::Next);sub _fix_module_name {my$module_name=shift;if (my ($fix)=grep {$module_name =~ /^$_$/i}@fix_module_name){$fix}else {$module_name}}sub _fill_archlib {my ($class,$incs)=@_;my%incs=map {$_=>1}@$incs;my@out;for my$inc (@$incs){push@out,$inc;next if$inc =~ /$ARCHNAME$/o;my$archlib=catdir($inc,$ARCHNAME);if (-d $archlib &&!$incs{$archlib}){push@out,$archlib}}\@out}my$decode_install_json=sub {my$file=shift;my$content=do {open my$fh,"<",$file or next;local $/;<$fh>};JSON::decode_json($content)};sub _decode_install_json {my ($class,$file,$dir)=@_;if ($CACHE){$CACHE->{install_json}{$dir}{$file}||= $decode_install_json->($file)}else {$decode_install_json->($file)}}sub _find_meta {my ($class,$main_module,$module,$version,$dir)=@_;return unless -d $dir;my@install_json;if ($CACHE and $CACHE->{install_json_collected}{$dir}){@install_json=keys %{$CACHE->{install_json}{$dir}}}else {@install_json=do {opendir my$dh,$dir or die "opendir $dir: $!";my@meta_dir=grep {!/^[.]{1,2}$/}readdir$dh;grep -f,map {catfile($dir,$_,"install.json")}@meta_dir};if ($CACHE){$CACHE->{install_json}{$dir}{$_}||= undef for@install_json;$CACHE->{install_json_collected}{$dir}++}}my$naive=do {my$dist=$main_module;$dist =~ s/::/-/g;$dist};@install_json=((sort {$b cmp $a}grep {/^$naive/}@install_json),(sort {$b cmp $a}grep {!/^$naive/}@install_json),);my ($meta_directory,$install_json,$install_json_hash,$mymeta_json);INSTALL_JSON_LOOP: for my$file (@install_json){my$hash=$class->_decode_install_json($file,$dir);my$name=$hash->{name}|| "";next if$name ne $main_module;my$provides=$hash->{provides}|| +{};for my$provide (sort keys %$provides){if ($provide eq $module && ($provides->{$provide}{version}|| "")eq $version){$meta_directory=dirname($file);$install_json=$file;$mymeta_json=catfile($meta_directory,"MYMETA.json");$install_json_hash=$hash;last INSTALL_JSON_LOOP}}DEBUG and warn "==> failed to find $module $version in $file\n"}return ($meta_directory,$install_json,$install_json_hash,$mymeta_json)}sub _naive_packlist {my ($class,$module_file,$inc)=@_;for my$i (@$inc){if (my ($path)=$module_file =~ /$i $SEP (.+)\.pm /x){my$archlib=$i =~ /$ARCHNAME$/o ? $i : catdir($i,$ARCHNAME);my$try=catfile($archlib,"auto",$path,".packlist");return$try if -f $try}}return}my$extract_files=sub {my$packlist=shift;[map {Cwd::abs_path($_)}grep {-f}sort keys %{ExtUtils::Packlist->new($packlist)|| +{}}]};sub _extract_files {my ($class,$packlist)=@_;if ($CACHE){$CACHE->{packlist}{$packlist}||= $extract_files->($packlist)}else {$extract_files->($packlist)}}sub _core_packlist {my ($self,$inc)=@_;for my$dir (grep -d,@$inc){opendir my$dh,$dir or die "Cannot open dir $dir: $!\n";my ($packlist)=map {catfile($dir,$_)}grep {$_ eq ".packlist"}readdir$dh;return$packlist if$packlist}return}sub _find_packlist {my ($class,$module_file,$inc)=@_;if ($CACHE and my$core_packlist=$CACHE->{core_packlist}){my$files=$class->_extract_files($core_packlist);if (grep {$module_file eq $_}@$files){return ($core_packlist,$files)}}if (my$naive_packlist=$class->_naive_packlist($module_file,$inc)){my$files=$class->_extract_files($naive_packlist);if (grep {$module_file eq $_}@$files){DEBUG and warn "-> naively found packlist: $module_file\n";return ($naive_packlist,$files)}}my@packlists;if ($CACHE and $CACHE->{packlist_collected}){@packlists=keys %{$CACHE->{packlist}}}else {if (my$core_packlist=$class->_core_packlist($inc)){push@packlists,$core_packlist;$CACHE->{core_packlist}=$core_packlist if$CACHE}find sub {return unless -f;return unless $_ eq ".packlist";push@packlists,$File::Find::name},grep -d,map {catdir($_,"auto")}@{$class->_fill_archlib($inc)};if ($CACHE){$CACHE->{packlist}{$_}||= undef for@packlists;$CACHE->{packlist_collected}++}}for my$try (@packlists){my$files=$class->_extract_files($try);if (grep {$module_file eq $_}@$files){return ($try,$files)}}return}sub _abs_path {my ($class,$dirs)=@_;my@out;for my$dir (grep -d,@$dirs){my$abs=Cwd::abs_path($dir);$abs =~ s/$SEP+$//;push@out,$abs if$abs}\@out}sub packlist {shift->{packlist}}sub meta_directory {shift->{meta_directory}}sub install_json {shift->{install_json}}sub mymeta_json {shift->{mymeta_json}}sub main_module {shift->{main_module}}sub main_module_version {shift->{main_module_version}}sub main_module_file {shift->{main_module_file}}sub files {shift->{files}}sub install_json_hash {shift->{install_json_hash}}sub mymeta_json_hash {my$self=shift;return unless my$mymeta_json=$self->mymeta_json;$self->{mymeta_json_hash}||= CPAN::Meta->load_file($mymeta_json)->as_struct}sub _distnameinfo {my$self=shift;return unless my$hash=$self->install_json_hash;$self->{_distnameinfo}||= CPAN::DistnameInfo->new($hash->{pathname})}for my$attr (qw(dist version cpanid distvname pathname)){no strict 'refs';*$attr=sub {my$self=shift;return$self->{$attr}if exists$self->{$attr};return unless$self->_distnameinfo;$self->_distnameinfo->$attr}}sub name {shift->dist}sub author {shift->cpanid}1;
DISTRIBUTION_METADATA

$fatpacked{"Distribution/Metadata/Factory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DISTRIBUTION_METADATA_FACTORY';
  package Distribution::Metadata::Factory;use strict;use warnings;use Distribution::Metadata;sub new {my ($class,%option)=@_;my$inc=$option{inc}|| \@INC;if ($option{fill_archlib}){$inc=Distribution::Metadata->_fill_archlib($inc)}bless {inc=>$inc,cache=>{}},$class}sub create_from_module {my ($self,$module)=@_;local$Distribution::Metadata::CACHE=$self->{cache};Distribution::Metadata->new_from_module($module,inc=>$self->{inc})}sub create_from_file {my ($self,$file)=@_;local$Distribution::Metadata::CACHE=$self->{cache};Distribution::Metadata->new_from_file($file,inc=>$self->{inc})}1;
DISTRIBUTION_METADATA_FACTORY

$fatpacked{"ExtUtils/CChecker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CCHECKER';
  package ExtUtils::CChecker;use v5;use strict;use warnings;our$VERSION='0.11';use Carp;use ExtUtils::CBuilder;sub new {my$class=shift;my%args=@_;my$quiet=1;$quiet=0 if defined$args{quiet}and!$args{quiet};my$cb=ExtUtils::CBuilder->new(quiet=>$quiet,config=>$args{config},);return bless {cb=>$cb,seq=>0,defines_to=>$args{defines_to},include_dirs=>[],extra_compiler_flags=>[],extra_linker_flags=>[],},$class}sub include_dirs {my$self=shift;return [@{$self->{include_dirs}}]}sub extra_compiler_flags {my$self=shift;return [@{$self->{extra_compiler_flags}}]}sub extra_linker_flags {my$self=shift;return [@{$self->{extra_linker_flags}}]}sub push_include_dirs {my$self=shift;push @{$self->{include_dirs}},@_}sub push_extra_compiler_flags {my$self=shift;push @{$self->{extra_compiler_flags}},@_}sub push_extra_linker_flags {my$self=shift;push @{$self->{extra_linker_flags}},@_}sub cbuilder {my$self=shift;return$self->{cb}}sub compile {my$self=shift;my%args=@_;$args{include_dirs}=[map {defined $_ ? @$_ : ()}$self->{include_dirs},$args{include_dirs}];$args{extra_compiler_flags}=[map {defined $_ ? @$_ : ()}$self->{extra_compiler_flags},$args{extra_compiler_flags}];$self->cbuilder->compile(%args)}sub link_executable {my$self=shift;my%args=@_;$args{extra_linker_flags}=[map {defined $_ ? @$_ : ()}$self->{extra_linker_flags},$args{extra_linker_flags}];$self->cbuilder->link_executable(%args)}sub fail {my$self=shift;my ($diag)=@_;my$message=defined$diag ? "OS unsupported - $diag\n" : "OS unsupported\n";die$message}sub define {my$self=shift;my ($symbol)=@_;if($self->{defines_to}){unless($self->{defines_fh}){open$self->{defines_fh},">",$self->{defines_to}or croak "Cannot open $self->{defines_to} for writing - $!";$self->{defines_fh}->autoflush(1)}$self->{defines_fh}->print("#define $symbol /**/\n")}else {$self->push_extra_compiler_flags("-D$symbol")}}sub try_compile_run {my$self=shift;my%args=(@_==1)? (source=>$_[0]): @_;defined$args{source}or croak "Expected 'source'";my$seq=$self->{seq}++;my$test_source="test-$$-$seq.c";open(my$test_source_fh,"> $test_source")or die "Cannot write $test_source - $!";print$test_source_fh $args{source};close$test_source_fh;my%compile_args=(source=>$test_source,);$compile_args{include_dirs}=$args{include_dirs}if exists$args{include_dirs};$compile_args{extra_compiler_flags}=$args{extra_compiler_flags}if exists$args{extra_compiler_flags};my$test_obj=eval {$self->compile(%compile_args)};unlink$test_source;if(not defined$test_obj){return 0}my%link_args=(objects=>$test_obj,);$link_args{extra_linker_flags}=$args{extra_linker_flags}if exists$args{extra_linker_flags};my$test_exe=eval {$self->link_executable(%link_args)};unlink$test_obj;if(not defined$test_exe){return 0}if(system("./$test_exe")!=0){unlink$test_exe;return 0}unlink$test_exe;$self->define($args{define})if defined$args{define};return 1}sub assert_compile_run {my$self=shift;my%args=@_;my$diag=delete$args{diag};$self->try_compile_run(%args)or $self->fail($diag)}sub try_find_cflags_for {my$self=shift;my%args=@_;ref(my$cflags=$args{cflags})eq "ARRAY" or croak "Expected 'cflags' as ARRAY ref";for my$f (@$cflags){ref$f eq "ARRAY" or croak "Expected 'cflags' element as ARRAY ref";$self->try_compile_run(%args,extra_compiler_flags=>$f)or next;$self->push_extra_compiler_flags(@$f);return 1}return 0}sub try_find_include_dirs_for {my$self=shift;my%args=@_;ref(my$dirs=$args{dirs})eq "ARRAY" or croak "Expected 'dirs' as ARRAY ref";for my$d (@$dirs){ref$d eq "ARRAY" or croak "Expected 'dirs' element as ARRAY ref";$self->try_compile_run(%args,include_dirs=>$d)or next;$self->push_include_dirs(@$d);return 1}return 0}sub try_find_libs_for {my$self=shift;my%args=@_;ref(my$libs=$args{libs})eq "ARRAY" or croak "Expected 'libs' as ARRAY ref";for my$l (@$libs){my@extra_linker_flags=map {"-l$_"}split m/\s+/,$l;$self->try_compile_run(%args,extra_linker_flags=>\@extra_linker_flags)or next;$self->push_extra_linker_flags(@extra_linker_flags);return 1}return 0}for (qw(find_cflags_for find_libs_for find_include_dirs_for)){my$trymethod="try_$_";my$code=sub {my$self=shift;my%args=@_;my$diag=delete$args{diag};$self->$trymethod(%args)or $self->fail($diag)};no strict 'refs';*$_=$code}sub extend_module_build {my$self=shift;my ($build)=@_;for my$key (qw(include_dirs extra_compiler_flags extra_linker_flags)){my@vals=@{$self->$key}or next;push@vals,@{$build->$key};$build->$key($key eq "include_dirs" ? [@vals ]: @vals)}}sub new_module_build {my$self=shift;my%args=@_;require Module::Build;my$build=Module::Build->new(%args);$self->extend_module_build($build);return$build}0x55AA;
EXTUTILS_CCHECKER

$fatpacked{"ExtUtils/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CONFIG';
  package ExtUtils::Config;$ExtUtils::Config::VERSION='0.008';use strict;use warnings;use Config;use Data::Dumper ();sub new {my ($pack,$args)=@_;return bless {values=>($args ? {%$args }: {}),},$pack}sub get {my ($self,$key)=@_;return exists$self->{values}{$key}? $self->{values}{$key}: $Config{$key}}sub exists {my ($self,$key)=@_;return exists$self->{values}{$key}|| exists$Config{$key}}sub values_set {my$self=shift;return {%{$self->{values}}}}sub all_config {my$self=shift;return {%Config,%{$self->{values}}}}sub serialize {my$self=shift;return$self->{serialized}||= Data::Dumper->new([$self->values_set])->Terse(1)->Sortkeys(1)->Dump}1;
EXTUTILS_CONFIG

$fatpacked{"ExtUtils/Helpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS';
  package ExtUtils::Helpers;$ExtUtils::Helpers::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';use Config;use File::Basename qw/basename/;use File::Spec::Functions qw/splitpath canonpath abs2rel splitdir/;use Text::ParseWords 3.24 ();our@EXPORT_OK=qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;BEGIN {my%impl_for=(MSWin32=>'Windows',VMS=>'VMS');my$package='ExtUtils::Helpers::' .($impl_for{$^O}|| 'Unix');my$impl=$impl_for{$^O}|| 'Unix';require "ExtUtils/Helpers/$impl.pm";"ExtUtils::Helpers::$impl"->import()}sub split_like_shell {my ($string)=@_;return if not defined$string;$string =~ s/^\s+|\s+$//g;return if not length$string;return Text::ParseWords::shellwords($string)}sub man1_pagename {my$filename=shift;return basename($filename).".$Config{man1ext}"}my%separator=(MSWin32=>'.',VMS=>'__',os2=>'.',cygwin=>'.',);my$separator=$separator{$^O}|| '::';sub man3_pagename {my ($filename,$base)=@_;$base ||= 'lib';my ($vols,$dirs,$file)=splitpath(canonpath(abs2rel($filename,$base)));$file=basename($file,qw/.pm .pod/);my@dirs=grep {length}splitdir($dirs);return join$separator,@dirs,"$file.$Config{man3ext}"}1;
EXTUTILS_HELPERS

$fatpacked{"ExtUtils/Helpers/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_UNIX';
  package ExtUtils::Helpers::Unix;$ExtUtils::Helpers::Unix::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use Carp qw/croak/;use Config;my$layer=$] >= 5.008001 ? ":raw" : "";sub make_executable {my$filename=shift;my$current_mode=(stat$filename)[2]+ 0;if (-T $filename){open my$fh,"<$layer",$filename;my@lines=<$fh>;if (@lines and $lines[0]=~ s{ \A \#! \s* (?:/\S+/)? perl \b (.*) \z }{$Config{startperl}$1}xms){open my$out,">$layer","$filename.new" or croak "Couldn't open $filename.new: $!";print$out @lines;close$out;rename$filename,"$filename.bak" or croak "Couldn't rename $filename to $filename.bak";rename "$filename.new",$filename or croak "Couldn't rename $filename.new to $filename";unlink "$filename.bak"}}chmod$current_mode | oct(111),$filename;return}sub detildefy {my$value=shift;for ($value){s{ ^ ~ (?= /|$)}          [ $ENV{HOME} || (getpwuid $>)[7] ]ex or s{ ^ ~ ([^/]+) (?= /|$) } { (getpwnam $1)[7] || "~$1" }ex}return$value}1;
EXTUTILS_HELPERS_UNIX

$fatpacked{"ExtUtils/Helpers/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_VMS';
  package ExtUtils::Helpers::VMS;$ExtUtils::Helpers::VMS::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use File::Copy qw/copy/;sub make_executable {my$filename=shift;my$batchname="$filename.com";copy($filename,$batchname);ExtUtils::Helpers::Unix::make_executable($batchname);return}sub detildefy {my$arg=shift;return$arg if ($arg =~ /^~~/);return$arg if ($arg =~ /^~ /);if ($arg =~ /^~/){my$spec=$arg;$spec =~ s/^~//;$spec =~ s#^/##;my$home=VMS::Filespec::unixify($ENV{HOME});$home .= '/' unless$home =~ m#/$#;if ($spec eq ''){$home =~ s#/$##;return$home}my ($hvol,$hdir,$hfile)=File::Spec::Unix->splitpath($home);if ($hdir eq ''){$hdir=$hfile}my ($vol,$dir,$file)=File::Spec::Unix->splitpath($spec);my@hdirs=File::Spec::Unix->splitdir($hdir);my@dirs=File::Spec::Unix->splitdir($dir);unless ($arg =~ m#^~/#){shift@dirs}my$newdirs=File::Spec::Unix->catdir(@hdirs,@dirs);$arg=File::Spec::Unix->catpath($hvol,$newdirs,$file)}return$arg}
EXTUTILS_HELPERS_VMS

$fatpacked{"ExtUtils/Helpers/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_WINDOWS';
  package ExtUtils::Helpers::Windows;$ExtUtils::Helpers::Windows::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use Config;use Carp qw/carp croak/;use ExtUtils::PL2Bat 'pl2bat';sub make_executable {my$script=shift;if (-T $script && $script !~ / \. (?:bat|cmd) $ /x){pl2bat(in=>$script,update=>1)}return}sub detildefy {my$value=shift;$value =~ s{ ^ ~ (?= [/\\] | $ ) }[$ENV{USERPROFILE}]x if$ENV{USERPROFILE};return$value}1;
EXTUTILS_HELPERS_WINDOWS

$fatpacked{"ExtUtils/InstallPaths.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_INSTALLPATHS';
  package ExtUtils::InstallPaths;$ExtUtils::InstallPaths::VERSION='0.012';use 5.006;use strict;use warnings;use File::Spec ();use Carp ();use ExtUtils::Config 0.002;my%complex_accessors=map {$_=>1}qw/prefix_relpaths install_sets/;my%hash_accessors=map {$_=>1}qw/install_path install_base_relpaths original_prefix/;my%defaults=(installdirs=>'site',install_base=>undef,prefix=>undef,verbose=>0,create_packlist=>1,dist_name=>undef,module_name=>undef,destdir=>undef,install_path=>sub {{}},install_sets=>\&_default_install_sets,original_prefix=>\&_default_original_prefix,install_base_relpaths=>\&_default_base_relpaths,prefix_relpaths=>\&_default_prefix_relpaths,);sub _merge_shallow {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);$filter->($_)for grep$filter,values %$override;return {%$defaults,%$override }}}sub _merge_deep {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);my$pair_for=sub {my$key=shift;my%override=%{$override->{$key}|| {}};$filter && $filter->($_)for values%override;return$key=>{%{$defaults->{$key}},%override }};return {map {$pair_for->($_)}keys %$defaults }}}my%allowed_installdir=map {$_=>1}qw/core site vendor/;my$must_be_relative=sub {Carp::croak('Value must be a relative path')if File::Spec->file_name_is_absolute($_[0])};my%deep_filter=map {$_=>$must_be_relative}qw/install_base_relpaths prefix_relpaths/;my%filter=(installdirs=>sub {my$value=shift;$value='core',Carp::carp('Perhaps you meant installdirs to be "core" rather than "perl"?')if$value eq 'perl';Carp::croak('installdirs must be one of "core", "site", or "vendor"')if not $allowed_installdir{$value};return$value},(map {$_=>_merge_shallow($_,$deep_filter{$_})}qw/original_prefix install_base_relpaths/),(map {$_=>_merge_deep($_,$deep_filter{$_})}qw/install_sets prefix_relpaths/),);sub new {my ($class,%args)=@_;my$config=$args{config}|| ExtUtils::Config->new;my%self=(config=>$config,map {$_=>exists$args{$_}? $filter{$_}? $filter{$_}->($args{$_},$config): $args{$_}: ref$defaults{$_}? $defaults{$_}->($config): $defaults{$_}}keys%defaults,);$self{module_name}||= do {my$module_name=$self{dist_name};$module_name =~ s/-/::/g;$module_name}if defined$self{dist_name};return bless \%self,$class}for my$attribute (keys%defaults){no strict qw/refs/;*{$attribute}=$hash_accessors{$attribute}? sub {my ($self,$key)=@_;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$key}}: $complex_accessors{$attribute}? sub {my ($self,$installdirs,$key)=@_;Carp::confess("$attribute needs installdir")if not defined$installdirs;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$installdirs}{$key}}: sub {my$self=shift;return$self->{$attribute}}}my$script=$] > 5.008000 ? 'script' : 'bin';my@install_sets_keys=qw/lib arch bin script bindoc libdoc binhtml libhtml/;my@install_sets_tail=('bin',$script,qw/man1dir man3dir html1dir html3dir/);my%install_sets_values=(core=>[qw/privlib archlib/,@install_sets_tail ],site=>[map {"site$_"}qw/lib arch/,@install_sets_tail ],vendor=>[map {"vendor$_"}qw/lib arch/,@install_sets_tail ],);sub _default_install_sets {my$c=shift;my%ret;for my$installdir (qw/core site vendor/){@{$ret{$installdir}}{@install_sets_keys}=map {$c->get("install$_")}@{$install_sets_values{$installdir}}}return \%ret}sub _default_base_relpaths {my$config=shift;return {lib=>['lib','perl5'],arch=>['lib','perl5',$config->get('archname')],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],}}my%common_prefix_relpaths=(bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],);sub _default_prefix_relpaths {my$c=shift;my@libstyle=$c->get('installstyle')? File::Spec->splitdir($c->get('installstyle')): qw(lib perl5);my$arch=$c->get('archname');my$version=$c->get('version');return {core=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},vendor=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},site=>{lib=>[@libstyle,'site_perl'],arch=>[@libstyle,'site_perl',$version,$arch],%common_prefix_relpaths,},}}sub _default_original_prefix {my$c=shift;my%ret=(core=>$c->get('installprefixexp'),site=>$c->get('siteprefixexp'),vendor=>$c->get('usevendorprefix')? $c->get('vendorprefixexp'): '',);return \%ret}sub _log_verbose {my$self=shift;print @_ if$self->verbose;return}sub is_default_installable {my$self=shift;my$type=shift;my$installable=$self->install_destination($type)&& ($self->install_path($type)|| $self->install_sets($self->installdirs,$type));return$installable ? 1 : 0}sub _prefixify_default {my$self=shift;my$type=shift;my$rprefix=shift;my$default=$self->prefix_relpaths($self->installdirs,$type);if(!$default){$self->_log_verbose("    no default install location for type '$type', using prefix '$rprefix'.\n");return$rprefix}else {return File::Spec->catdir(@{$default})}}sub _prefixify_novms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;$rprefix .= '/' if$sprefix =~ m{/$};$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n")if defined$path && length$path;if (not defined$path or length$path==0){$self->_log_verbose("  no path to prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}elsif(!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("    path is relative, not prefixifying.\n")}elsif($path !~ s{^\Q$sprefix\E\b}{}s){$self->_log_verbose("    cannot prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}$self->_log_verbose("    now $path in $rprefix\n");return$path}sub _catprefix_vms {my ($self,$rprefix,$default)=@_;my ($rvol,$rdirs)=File::Spec->splitpath($rprefix);if ($rvol){return File::Spec->catpath($rvol,File::Spec->catdir($rdirs,$default),'')}else {return File::Spec->catdir($rdirs,$default)}}sub _prefixify_vms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;return '' unless defined$path;$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n");require VMS::Filespec;$rprefix=VMS::Filespec::vmspath($rprefix)if$rprefix;$sprefix=VMS::Filespec::vmspath($sprefix)if$sprefix;$self->_log_verbose("  rprefix translated to $rprefix\n  sprefix translated to $sprefix\n");if (length($path)==0){$self->_log_verbose("  no path to prefixify.\n")}elsif (!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("	path is relative, not prefixifying.\n")}elsif ($sprefix eq $rprefix){$self->_log_verbose("  no new prefix.\n")}else {my ($path_vol,$path_dirs)=File::Spec->splitpath($path);my$vms_prefix=$self->config->get('vms_prefix');if ($path_vol eq $vms_prefix.':'){$self->_log_verbose("  $vms_prefix: seen\n");$path_dirs =~ s{^\[}{\[.} unless$path_dirs =~ m{^\[\.};$path=$self->_catprefix_vms($rprefix,$path_dirs)}else {$self->_log_verbose("	cannot prefixify.\n");return File::Spec->catdir($self->prefix_relpaths($self->installdirs,$type))}}$self->_log_verbose("	now $path\n");return$path}BEGIN {*_prefixify=$^O eq 'VMS' ? \&_prefixify_vms : \&_prefixify_novms}sub prefix_relative {my ($self,$installdirs,$type)=@_;my$relpath=$self->install_sets($installdirs,$type);return$self->_prefixify($relpath,$self->original_prefix($installdirs),$type)}sub install_destination {my ($self,$type)=@_;return$self->install_path($type)if$self->install_path($type);if ($self->install_base){my$relpath=$self->install_base_relpaths($type);return$relpath ? File::Spec->catdir($self->install_base,@{$relpath}): undef}if ($self->prefix){my$relpath=$self->prefix_relative($self->installdirs,$type);return$relpath ? File::Spec->catdir($self->prefix,$relpath): undef}return$self->install_sets($self->installdirs,$type)}sub install_types {my$self=shift;my%types=(%{$self->{install_path}},$self->install_base ? %{$self->{install_base_relpaths}}: $self->prefix ? %{$self->{prefix_relpaths}{$self->installdirs }}: %{$self->{install_sets}{$self->installdirs }});return sort keys%types}sub install_map {my ($self,$dirs)=@_;my%localdir_for;if ($dirs && %$dirs){%localdir_for=%$dirs}else {for my$type ($self->install_types){$localdir_for{$type}=File::Spec->catdir('blib',$type)}}my (%map,@skipping);for my$type (keys%localdir_for){next if not -e $localdir_for{$type};if (my$dest=$self->install_destination($type)){$map{$localdir_for{$type}}=$dest}else {push@skipping,$type}}warn "WARNING: Can't figure out install path for types: @skipping\nFiles will not be installed.\n" if@skipping;if ($self->create_packlist and my$module_name=$self->module_name){my$archdir=$self->install_destination('arch');my@ext=split /::/,$module_name;$map{write}=File::Spec->catfile($archdir,'auto',@ext,'.packlist')}if (length(my$destdir=$self->destdir || '')){for (keys%map){my ($volume,$path,$file)=File::Spec->splitpath($map{$_},0);my@dirs=File::Spec->splitdir($path);$path=File::Spec->catdir($destdir,@dirs);if ($file ne ''){$map{$_}=File::Spec->catfile($path,$file)}else {$map{$_}=$path}}}$map{read}='';return \%map}1;
EXTUTILS_INSTALLPATHS

$fatpacked{"Feature/Compat/Try.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FEATURE_COMPAT_TRY';
  package Feature::Compat::Try 0.04;use v5.14;use warnings;use feature ();use constant HAVE_FEATURE_TRY=>defined$feature::feature{try};sub import {if(HAVE_FEATURE_TRY){feature->import(qw(try));require warnings;warnings->unimport(qw(experimental::try))}else {require Syntax::Keyword::Try;Syntax::Keyword::Try->VERSION('0.22');Syntax::Keyword::Try->import(qw(try -no_finally -require_var))}}0x55AA;
FEATURE_COMPAT_TRY

$fatpacked{"File/Slurp/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SLURP_TINY';
  package File::Slurp::Tiny;$File::Slurp::Tiny::VERSION='0.004';use strict;use warnings;use Carp 'croak';use Exporter 5.57 'import';use File::Spec::Functions 'catfile';use FileHandle;our@EXPORT_OK=qw/read_file read_lines write_file read_dir/;my$default_layer=$^O eq 'MSWin32' ? ':crlf' : ':unix';sub read_file {my ($filename,%options)=@_;my$layer=$options{binmode}|| $default_layer;my$buf_ref=defined$options{buf_ref}? $options{buf_ref}: \my$buf;open my$fh,"<$layer",$filename or croak "Couldn't open $filename: $!";if (my$size=-s $fh){my ($pos,$read)=0;do {defined($read=read$fh,${$buf_ref},$size - $pos,$pos)or croak "Couldn't read $filename: $!";$pos += $read}while ($read && $pos < $size)}else {${$buf_ref}=do {local $/;<$fh>}}close$fh;return if not defined wantarray or $options{buf_ref};return$options{scalar_ref}? $buf_ref : $buf}sub read_lines {my ($filename,%options)=@_;my$layer=delete$options{binmode}|| ':';open my$fh,"<$layer",$filename or croak "Couldn't open $filename: $!";return <$fh> if not %options;my@buf=<$fh>;close$fh;chomp@buf if$options{chomp};return$options{array_ref}? \@buf : @buf}sub write_file {my ($filename,undef,%options)=@_;my$layer=$options{binmode}|| $default_layer;my$mode=$options{append}? '>>' : '>';my$buf_ref=defined$options{buf_ref}? $options{buf_ref}: \$_[1];open my$fh,$mode.$layer,$filename or croak "Couldn't open $filename: $!";$fh->autoflush(1);print$fh ${$buf_ref}or croak "Couldn't write to $filename: $!";close$fh or croak "Couldn't close $filename: $!";return}sub read_dir {my ($dirname,%options)=@_;opendir my ($dir),$dirname or croak "Could not open $dirname: $!";my@ret=grep {not m/ \A \.\.? \z /x}readdir$dir;@ret=map {catfile($dirname,$_)}@ret if$options{prefix};closedir$dir;return@ret}1;
FILE_SLURP_TINY

$fatpacked{"File/pushd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_PUSHD';
  use strict;use warnings;package File::pushd;our$VERSION='1.016';our@EXPORT=qw(pushd tempd);our@ISA=qw(Exporter);use Exporter;use Carp;use Cwd qw(getcwd abs_path);use File::Path qw(rmtree);use File::Temp qw();use File::Spec;use overload q{""}=>sub {File::Spec->canonpath($_[0]->{_pushd})},fallback=>1;sub pushd {unless (defined wantarray){warnings::warnif(void=>'Useless use of File::pushd::pushd in void context');return}my ($target_dir,$options)=@_;$options->{untaint_pattern}||= qr{^([-+@\w./]+)$};$target_dir="." unless defined$target_dir;croak "Can't locate directory $target_dir" unless -d $target_dir;my$tainted_orig=getcwd;my$orig;if ($tainted_orig =~ $options->{untaint_pattern}){$orig=$1}else {$orig=$tainted_orig}my$tainted_dest;eval {$tainted_dest=$target_dir ? abs_path($target_dir): $orig};croak "Can't locate absolute path for $target_dir: $@" if $@;my$dest;if ($tainted_dest =~ $options->{untaint_pattern}){$dest=$1}else {$dest=$tainted_dest}if ($dest ne $orig){chdir$dest or croak "Can't chdir to $dest\: $!"}my$self=bless {_pushd=>$dest,_original=>$orig },__PACKAGE__;return$self}sub tempd {unless (defined wantarray){warnings::warnif(void=>'Useless use of File::pushd::tempd in void context');return}my ($options)=@_;my$dir;eval {$dir=pushd(File::Temp::tempdir(CLEANUP=>0),$options)};croak $@ if $@;$dir->{_tempd}=1;$dir->{_owner}=$$;return$dir}sub preserve {my$self=shift;return 1 if!$self->{"_tempd"};if (@_==0){return$self->{_preserve}=1}else {return$self->{_preserve}=$_[0]? 1 : 0}}sub DESTROY {my ($self)=@_;my$orig=$self->{_original};chdir$orig if$orig;if ($self->{_tempd}&& $self->{_owner}==$$ &&!$self->{_preserve}){my$err=do {local $@;eval {rmtree($self->{_pushd})};$@};carp$err if$err}}1;
FILE_PUSHD

$fatpacked{"Hook/LexWrap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HOOK_LEXWRAP';
  use strict;use warnings;package Hook::LexWrap;our$VERSION='0.26';use Carp ();{no warnings 'redefine';*CORE::GLOBAL::caller=sub (;$) {my ($height)=($_[0]||0);my$i=1;my$name_cache;while (1){my@caller=CORE::caller()eq 'DB' ? do {package DB;CORE::caller($i++)}: CORE::caller($i++);return if not @caller;$caller[3]=$name_cache if$name_cache;$name_cache=$caller[0]eq 'Hook::LexWrap' ? $caller[3]: '';next if$name_cache || $height--!=0;return wantarray ? @_ ? @caller : @caller[0..2]: $caller[0]}}}sub import {no strict 'refs';*{caller()."::wrap"}=\&wrap}sub wrap (*@) {my ($typeglob,%wrapper)=@_;$typeglob=(ref$typeglob || $typeglob =~ /::/)? $typeglob : caller()."::$typeglob";my$original;{no strict 'refs';$original=ref$typeglob eq 'CODE' && $typeglob || *$typeglob{CODE}|| Carp::croak "Can't wrap non-existent subroutine ",$typeglob}Carp::croak "'$_' value is not a subroutine reference" foreach grep {$wrapper{$_}&& ref$wrapper{$_}ne 'CODE'}qw(pre post);no warnings 'redefine';my ($caller,$unwrap)=*CORE::GLOBAL::caller{CODE};my$imposter=sub {if ($unwrap){goto &$original}my ($return,$prereturn);if (wantarray){$prereturn=$return=[];()=$wrapper{pre}->(@_,$return)if$wrapper{pre};if (ref$return eq 'ARRAY' && $return==$prereturn &&!@$return){$return=[&$original ];()=$wrapper{post}->(@_,$return)if$wrapper{post}}return ref$return eq 'ARRAY' ? @$return : ($return)}elsif (defined wantarray){$return=bless sub {$prereturn=1},'Hook::LexWrap::Cleanup';my$dummy=$wrapper{pre}->(@_,$return)if$wrapper{pre};unless ($prereturn){$return=&$original;$dummy=scalar$wrapper{post}->(@_,$return)if$wrapper{post}}return$return}else {$return=bless sub {$prereturn=1},'Hook::LexWrap::Cleanup';$wrapper{pre}->(@_,$return)if$wrapper{pre};unless ($prereturn){&$original;$wrapper{post}->(@_,$return)if$wrapper{post}}return}};ref$typeglob eq 'CODE' and return defined wantarray ? $imposter : Carp::carp "Uselessly wrapped subroutine reference in void context";{no strict 'refs';*{$typeglob}=$imposter}return unless defined wantarray;return bless sub{$unwrap=1},'Hook::LexWrap::Cleanup'}package Hook::LexWrap::Cleanup;sub DESTROY {$_[0]->()}use overload q{""}=>sub {undef},q{0+}=>sub {undef},q{bool}=>sub {undef},q{fallback}=>1;1;
HOOK_LEXWRAP

$fatpacked{"JSON.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON';
  package JSON;use strict;use Carp ();use Exporter;BEGIN {@JSON::ISA='Exporter'}@JSON::EXPORT=qw(from_json to_json jsonToObj objToJson encode_json decode_json);BEGIN {$JSON::VERSION='4.06';$JSON::DEBUG=0 unless (defined$JSON::DEBUG);$JSON::DEBUG=$ENV{PERL_JSON_DEBUG }if exists$ENV{PERL_JSON_DEBUG }}my%RequiredVersion=('JSON::PP'=>'2.27203','JSON::XS'=>'2.34',);my@PublicMethods=qw/ascii latin1 utf8 pretty indent space_before space_after relaxed canonical allow_nonref allow_blessed convert_blessed filter_json_object filter_json_single_key_object shrink max_depth max_size encode decode decode_prefix allow_unknown/;my@Properties=qw/ascii latin1 utf8 indent space_before space_after relaxed canonical allow_nonref allow_blessed convert_blessed shrink max_depth max_size allow_unknown/;my@XSOnlyMethods=qw//;my@PublicMethodsSince4_0=qw/allow_tags/;my@PropertiesSince4_0=qw/allow_tags/;my@PPOnlyMethods=qw/indent_length sort_by allow_singlequote allow_bignum loose allow_barekey escape_slash as_nonblessed/;my$_INSTALL_DONT_DIE=1;my$_ALLOW_UNSUPPORTED=0;my$_UNIV_CONV_BLESSED=0;unless ($JSON::Backend){$JSON::DEBUG and Carp::carp("Check used worker module...");my$backend=exists$ENV{PERL_JSON_BACKEND}? $ENV{PERL_JSON_BACKEND}: 1;if ($backend eq '1'){$backend='JSON::XS,JSON::PP'}elsif ($backend eq '0'){$backend='JSON::PP'}elsif ($backend eq '2'){$backend='JSON::XS'}$backend =~ s/\s+//g;my@backend_modules=split /,/,$backend;while(my$module=shift@backend_modules){if ($module =~ /JSON::XS/){_load_xs($module,@backend_modules ? $_INSTALL_DONT_DIE : 0)}elsif ($module =~ /JSON::PP/){_load_pp($module)}elsif ($module =~ /JSON::backportPP/){_load_pp($module)}else {Carp::croak "The value of environmental variable 'PERL_JSON_BACKEND' is invalid."}last if$JSON::Backend}}sub import {my$pkg=shift;my@what_to_export;my$no_export;for my$tag (@_){if ($tag eq '-support_by_pp'){if (!$_ALLOW_UNSUPPORTED++){JSON::Backend::XS ->support_by_pp(@PPOnlyMethods)if ($JSON::Backend->is_xs)}next}elsif ($tag eq '-no_export'){$no_export++,next}elsif ($tag eq '-convert_blessed_universally'){my$org_encode=$JSON::Backend->can('encode');eval q|
                  require B;
                  local $^W;
                  no strict 'refs';
                  *{"${JSON::Backend}\::encode"} = sub {
                      # only works with Perl 5.18+
                      local *UNIVERSAL::TO_JSON = sub {
                          my $b_obj = B::svref_2object( $_[0] );
                          return    $b_obj->isa('B::HV') ? { %{ $_[0] } }
                                  : $b_obj->isa('B::AV') ? [ @{ $_[0] } ]
                                  : undef
                                  ;
                      };
                      $org_encode->(@_);
                  };
              | if (!$_UNIV_CONV_BLESSED++);next}push@what_to_export,$tag}return if ($no_export);__PACKAGE__->export_to_level(1,$pkg,@what_to_export)}sub jsonToObj {my$alternative='from_json';if (defined $_[0]and UNIVERSAL::isa($_[0],'JSON')){shift @_;$alternative='decode'}Carp::carp "'jsonToObj' will be obsoleted. Please use '$alternative' instead.";return JSON::from_json(@_)};sub objToJson {my$alternative='to_json';if (defined $_[0]and UNIVERSAL::isa($_[0],'JSON')){shift @_;$alternative='encode'}Carp::carp "'objToJson' will be obsoleted. Please use '$alternative' instead.";JSON::to_json(@_)};sub to_json ($@) {if (ref($_[0])eq 'JSON' or (@_ > 2 and $_[0]eq 'JSON')){Carp::croak "to_json should not be called as a method."}my$json=JSON->new;if (@_==2 and ref $_[1]eq 'HASH'){my$opt=$_[1];for my$method (keys %$opt){$json->$method($opt->{$method})}}$json->encode($_[0])}sub from_json ($@) {if (ref($_[0])eq 'JSON' or $_[0]eq 'JSON'){Carp::croak "from_json should not be called as a method."}my$json=JSON->new;if (@_==2 and ref $_[1]eq 'HASH'){my$opt=$_[1];for my$method (keys %$opt){$json->$method($opt->{$method})}}return$json->decode($_[0])}sub true {$JSON::true}sub false {$JSON::false}sub boolean {pop()? $JSON::true : $JSON::false}sub null {undef}sub require_xs_version {$RequiredVersion{'JSON::XS'}}sub backend {my$proto=shift;$JSON::Backend}sub is_xs {return $_[0]->backend->is_xs}sub is_pp {return $_[0]->backend->is_pp}sub pureperl_only_methods {@PPOnlyMethods}sub property {my ($self,$name,$value)=@_;if (@_==1){my%props;for$name (@Properties){my$method='get_' .$name;if ($name eq 'max_size'){my$value=$self->$method();$props{$name}=$value==1 ? 0 : $value;next}$props{$name}=$self->$method()}return \%props}elsif (@_ > 3){Carp::croak('property() can take only the option within 2 arguments.')}elsif (@_==2){if (my$method=$self->can('get_' .$name)){if ($name eq 'max_size'){my$value=$self->$method();return$value==1 ? 0 : $value}$self->$method()}}else {$self->$name($value)}}sub __load_xs {my ($module,$opt)=@_;$JSON::DEBUG and Carp::carp "Load $module.";my$required_version=$RequiredVersion{$module}|| '';eval qq|
          use $module $required_version ();
      |;if ($@){if (defined$opt and $opt & $_INSTALL_DONT_DIE){$JSON::DEBUG and Carp::carp "Can't load $module...($@)";return 0}Carp::croak $@}$JSON::BackendModuleXS=$module;return 1}sub _load_xs {my ($module,$opt)=@_;__load_xs($module,$opt)or return;my$data=join("",<DATA>);close(DATA);eval$data;JSON::Backend::XS->init($module);return 1};sub __load_pp {my ($module,$opt)=@_;$JSON::DEBUG and Carp::carp "Load $module.";my$required_version=$RequiredVersion{$module}|| '';eval qq| use $module $required_version () |;if ($@){if ($module eq 'JSON::PP'){$JSON::DEBUG and Carp::carp "Can't load $module ($@), so try to load JSON::backportPP";$module='JSON::backportPP';local $^W;eval qq| require $module |}Carp::croak $@ if $@}$JSON::BackendModulePP=$module;return 1}sub _load_pp {my ($module,$opt)=@_;__load_pp($module,$opt);JSON::Backend::PP->init($module)};package JSON::Backend::PP;sub init {my ($class,$module)=@_;local $^W;no strict qw(refs);*{"JSON::decode_json"}=\&{"JSON::PP::decode_json"};*{"JSON::encode_json"}=\&{"JSON::PP::encode_json"};*{"JSON::is_bool"}=\&{"JSON::PP::is_bool"};$JSON::true=${"JSON::PP::true"};$JSON::false=${"JSON::PP::false"};push@JSON::Backend::PP::ISA,'JSON::PP';push@JSON::ISA,$class;$JSON::Backend=$class;$JSON::BackendModule=$module;my$version=${"$class\::VERSION"}=$module->VERSION;$version =~ s/_//;if ($version < 3.99){push@XSOnlyMethods,qw/allow_tags get_allow_tags/}else {push@Properties,'allow_tags'}for my$method (@XSOnlyMethods){*{"JSON::$method"}=sub {Carp::carp("$method is not supported by $module $version.");$_[0]}}return 1}sub is_xs {0};sub is_pp {1};package JSON;1;__DATA__ 
  
  #
  # Helper classes for Backend Module (XS)
  #
  
  package JSON::Backend::XS;
  
  sub init {
      my ($class, $module) = @_;
  
      local $^W;
      no strict qw(refs);
      *{"JSON::decode_json"} = \&{"$module\::decode_json"};
      *{"JSON::encode_json"} = \&{"$module\::encode_json"};
      *{"JSON::is_bool"} = \&{"$module\::is_bool"};
  
      $JSON::true  = ${"$module\::true"};
      $JSON::false = ${"$module\::false"};
  
      push @JSON::Backend::XS::ISA, $module;
      push @JSON::ISA, $class;
      $JSON::Backend = $class;
      $JSON::BackendModule = $module;
      ${"$class\::VERSION"} = $module->VERSION;
  
      if ( $module->VERSION < 3 ) {
          eval 'package JSON::PP::Boolean';
          push @{"$module\::Boolean::ISA"}, qw(JSON::PP::Boolean);
      }
  
      for my $method (@PPOnlyMethods) {
          *{"JSON::$method"} = sub {
              Carp::carp("$method is not supported by $module.");
              $_[0];
          };
      }
  
      return 1;
  }
  
  sub is_xs { 1 };
  sub is_pp { 0 };
  
  sub support_by_pp {
      my ($class, @methods) = @_;
  
      JSON::__load_pp('JSON::PP');
  
      local $^W;
      no strict qw(refs);
  
      for my $method (@methods) {
          my $pp_method = JSON::PP->can($method) or next;
          *{"JSON::$method"} = sub {
              if (!$_[0]->isa('JSON::PP')) {
                  my $xs_self = $_[0];
                  my $pp_self = JSON::PP->new;
                  for (@Properties) {
                       my $getter = "get_$_";
                      $pp_self->$_($xs_self->$getter);
                  }
                  $_[0] = $pp_self;
              }
              $pp_method->(@_);
          };
      }
  
      $JSON::DEBUG and Carp::carp("set -support_by_pp mode.");
  }
  
  1;
  __END__
  
  =head1 NAME
  
  JSON - JSON (JavaScript Object Notation) encoder/decoder
  
  =head1 SYNOPSIS
  
   use JSON; # imports encode_json, decode_json, to_json and from_json.
   
   # simple and fast interfaces (expect/generate UTF-8)
   
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
   
   # OO-interface
   
   $json = JSON->new->allow_nonref;
   
   $json_text   = $json->encode( $perl_scalar );
   $perl_scalar = $json->decode( $json_text );
   
   $pretty_printed = $json->pretty->encode( $perl_scalar ); # pretty-printing
  
  =head1 DESCRIPTION
  
  This module is a thin wrapper for L<JSON::XS>-compatible modules with a few
  additional features. All the backend modules convert a Perl data structure
  to a JSON text and vice versa. This module uses L<JSON::XS> by default,
  and when JSON::XS is not available, falls back on L<JSON::PP>, which is
  in the Perl core since 5.14. If JSON::PP is not available either, this
  module then falls back on JSON::backportPP (which is actually JSON::PP
  in a different .pm file) bundled in the same distribution as this module.
  You can also explicitly specify to use L<Cpanel::JSON::XS>, a fork of
  JSON::XS by Reini Urban.
  
  All these backend modules have slight incompatibilities between them,
  including extra features that other modules don't support, but as long as you
  use only common features (most important ones are described below), migration
  from backend to backend should be reasonably easy. For details, see each
  backend module you use.
  
  =head1 CHOOSING BACKEND
  
  This module respects an environmental variable called C<PERL_JSON_BACKEND>
  when it decides a backend module to use. If this environmental variable is
  not set, it tries to load JSON::XS, and if JSON::XS is not available, it
  falls back on JSON::PP, and then JSON::backportPP if JSON::PP is not available
  either.
  
  If you always don't want it to fall back on pure perl modules, set the
  variable like this (C<export> may be C<setenv>, C<set> and the likes,
  depending on your environment):
  
    > export PERL_JSON_BACKEND=JSON::XS
  
  If you prefer Cpanel::JSON::XS to JSON::XS, then:
  
    > export PERL_JSON_BACKEND=Cpanel::JSON::XS,JSON::XS,JSON::PP
  
  You may also want to set this variable at the top of your test files, in order
  not to be bothered with incompatibilities between backends (you need to wrap
  this in C<BEGIN>, and set before actually C<use>-ing JSON module, as it decides
  its backend as soon as it's loaded):
  
    BEGIN { $ENV{PERL_JSON_BACKEND}='JSON::backportPP'; }
    use JSON;
  
  =head1 USING OPTIONAL FEATURES
  
  There are a few options you can set when you C<use> this module.
  These historical options are only kept for backward compatibility,
  and should not be used in a new application.
  
  =over
  
  =item -support_by_pp
  
     BEGIN { $ENV{PERL_JSON_BACKEND} = 'JSON::XS' }
     
     use JSON -support_by_pp;
     
     my $json = JSON->new;
     # escape_slash is for JSON::PP only.
     $json->allow_nonref->escape_slash->encode("/");
  
  With this option, this module loads its pure perl backend along with
  its XS backend (if available), and lets the XS backend to watch if you set
  a flag only JSON::PP supports. When you do, the internal JSON::XS object
  is replaced with a newly created JSON::PP object with the setting copied
  from the XS object, so that you can use JSON::PP flags (and its slower
  C<decode>/C<encode> methods) from then on. In other words, this is not
  something that allows you to hook JSON::XS to change its behavior while
  keeping its speed. JSON::XS and JSON::PP objects are quite different
  (JSON::XS object is a blessed scalar reference, while JSON::PP object is
  a blessed hash reference), and can't share their internals.
  
  To avoid needless overhead (by copying settings), you are advised not
  to use this option and just to use JSON::PP explicitly when you need
  JSON::PP features.
  
  =item -convert_blessed_universally
  
     use JSON -convert_blessed_universally;
  
     my $json = JSON->new->allow_nonref->convert_blessed;
     my $object = bless {foo => 'bar'}, 'Foo';
     $json->encode($object); # => {"foo":"bar"}
  
  JSON::XS-compatible backend modules don't encode blessed objects by
  default (except for their boolean values, which are typically blessed
  JSON::PP::Boolean objects). If you need to encode a data structure
  that may contain objects, you usually need to look into the structure
  and replace objects with alternative non-blessed values, or enable
  C<convert_blessed> and provide a C<TO_JSON> method for each object's
  (base) class that may be found in the structure, in order to let the
  methods replace the objects with whatever scalar values the methods
  return.
  
  If you need to serialise data structures that may contain arbitrary
  objects, it's probably better to use other serialisers (such as
  L<Sereal> or L<Storable> for example), but if you do want to use
  this module for that purpose, C<-convert_blessed_universally> option
  may help, which tweaks C<encode> method of the backend to install
  C<UNIVERSAL::TO_JSON> method (locally) before encoding, so that
  all the objects that don't have their own C<TO_JSON> method can
  fall back on the method in the C<UNIVERSAL> namespace. Note that you
  still need to enable C<convert_blessed> flag to actually encode
  objects in a data structure, and C<UNIVERSAL::TO_JSON> method
  installed by this option only converts blessed hash/array references
  into their unblessed clone (including private keys/values that are
  not supposed to be exposed). Other blessed references will be
  converted into null.
  
  This feature is experimental and may be removed in the future.
  
  =item -no_export
  
  When you don't want to import functional interfaces from a module, you
  usually supply C<()> to its C<use> statement.
  
      use JSON (); # no functional interfaces
  
  If you don't want to import functional interfaces, but you also want to
  use any of the above options, add C<-no_export> to the option list.
  
     # no functional interfaces, while JSON::PP support is enabled.
     use JSON -support_by_pp, -no_export;
  
  =back
  
  =head1 FUNCTIONAL INTERFACE
  
  This section is taken from JSON::XS. C<encode_json> and C<decode_json>
  are exported by default.
  
  This module also exports C<to_json> and C<from_json> for backward
  compatibility. These are slower, and may expect/generate different stuff
  from what C<encode_json> and C<decode_json> do, depending on their
  options. It's better just to use Object-Oriented interfaces than using
  these two functions.
  
  =head2 encode_json
  
      $json_text = encode_json $perl_scalar
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string
  (that is, the string contains octets only). Croaks on error.
  
  This function call is functionally identical to:
  
      $json_text = JSON->new->utf8->encode($perl_scalar)
  
  Except being faster.
  
  =head2 decode_json
  
      $perl_scalar = decode_json $json_text
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
  to parse that as an UTF-8 encoded JSON text, returning the resulting
  reference. Croaks on error.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON->new->utf8->decode($json_text)
  
  Except being faster.
  
  =head2 to_json
  
     $json_text = to_json($perl_scalar[, $optional_hashref])
  
  Converts the given Perl data structure to a Unicode string by default.
  Croaks on error.
  
  Basically, this function call is functionally identical to:
  
     $json_text = JSON->new->encode($perl_scalar)
  
  Except being slower.
  
  You can pass an optional hash reference to modify its behavior, but
  that may change what C<to_json> expects/generates (see
  C<ENCODING/CODESET FLAG NOTES> for details).
  
     $json_text = to_json($perl_scalar, {utf8 => 1, pretty => 1})
     # => JSON->new->utf8(1)->pretty(1)->encode($perl_scalar)
  
  =head2 from_json
  
     $perl_scalar = from_json($json_text[, $optional_hashref])
  
  The opposite of C<to_json>: expects a Unicode string and tries
  to parse it, returning the resulting reference. Croaks on error.
  
  Basically, this function call is functionally identical to:
  
      $perl_scalar = JSON->new->decode($json_text)
  
  You can pass an optional hash reference to modify its behavior, but
  that may change what C<from_json> expects/generates (see
  C<ENCODING/CODESET FLAG NOTES> for details).
  
      $perl_scalar = from_json($json_text, {utf8 => 1})
      # => JSON->new->utf8(1)->decode($json_text)
  
  =head2 JSON::is_bool
  
      $is_boolean = JSON::is_bool($scalar)
  
  Returns true if the passed scalar represents either JSON::true or
  JSON::false, two constants that act like C<1> and C<0> respectively
  and are also used to represent JSON C<true> and C<false> in Perl strings.
  
  See L<MAPPING>, below, for more information on how JSON values are mapped to
  Perl.
  
  =head1 COMMON OBJECT-ORIENTED INTERFACE
  
  This section is also taken from JSON::XS.
  
  The object oriented interface lets you configure your own encoding or
  decoding style, within the limits of supported formats.
  
  =head2 new
  
      $json = JSON->new
  
  Creates a new JSON::XS-compatible backend object that can be used to de/encode JSON
  strings. All boolean flags described below are by default I<disabled>
  (with the exception of C<allow_nonref>, which defaults to I<enabled> since
  version C<4.0>).
  
  The mutators for flags all return the backend object again and thus calls can
  be chained:
  
     my $json = JSON->new->utf8->space_after->encode({a => [1,2]})
     => {"a": [1, 2]}
  
  =head2 ascii
  
      $json = $json->ascii([$enable])
      
      $enabled = $json->get_ascii
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  generate characters outside the code range C<0..127> (which is ASCII). Any
  Unicode characters outside that range will be escaped using either a
  single \uXXXX (BMP characters) or a double \uHHHH\uLLLLL escape sequence,
  as per RFC4627. The resulting encoded JSON text can be treated as a native
  Unicode string, an ascii-encoded, latin1-encoded or UTF-8 encoded string,
  or any other superset of ASCII.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags. This results
  in a faster and more compact format.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  The main use for this flag is to produce JSON texts that can be
  transmitted over a 7-bit channel, as the encoded JSON texts will not
  contain any 8 bit characters.
  
    JSON->new->ascii(1)->encode([chr 0x10401])
    => ["\ud801\udc01"]
  
  =head2 latin1
  
      $json = $json->latin1([$enable])
      
      $enabled = $json->get_latin1
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the resulting JSON text as latin1 (or iso-8859-1), escaping any characters
  outside the code range C<0..255>. The resulting string can be treated as a
  latin1-encoded JSON text or a native Unicode string. The C<decode> method
  will not be affected in any way by this flag, as C<decode> by default
  expects Unicode, which is a strict superset of latin1.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  The main use for this flag is efficiently encoding binary data as JSON
  text, as most octets will not be escaped, resulting in a smaller encoded
  size. The disadvantage is that the resulting JSON text is encoded
  in latin1 (and must correctly be treated as such when storing and
  transferring), a rare encoding for JSON. It is therefore most useful when
  you want to store data structures known to contain binary data efficiently
  in files or databases, not when talking to other JSON encoders/decoders.
  
    JSON->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  =head2 utf8
  
      $json = $json->utf8([$enable])
      
      $enabled = $json->get_utf8
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the JSON result into UTF-8, as required by many protocols, while the
  C<decode> method expects to be handled an UTF-8-encoded string.  Please
  note that UTF-8-encoded strings do not contain any characters outside the
  range C<0..255>, they are thus useful for bytewise/binary I/O. In future
  versions, enabling this option might enable autodetection of the UTF-16
  and UTF-32 encoding families, as described in RFC4627.
  
  If C<$enable> is false, then the C<encode> method will return the JSON
  string as a (non-encoded) Unicode string, while C<decode> expects thus a
  Unicode string.  Any decoding or encoding (e.g. to UTF-8 or UTF-16) needs
  to be done yourself, e.g. using the Encode module.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", JSON->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = JSON->new->decode (decode "UTF-32LE", $jsontext);
  
  =head2 pretty
  
      $json = $json->pretty([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> (and in the future possibly more) flags in one call to
  generate the most readable (or most compact) form possible.
  
  =head2 indent
  
      $json = $json->indent([$enable])
      
      $enabled = $json->get_indent
  
  If C<$enable> is true (or missing), then the C<encode> method will use a multiline
  format as output, putting every array member or object/hash key-value pair
  into its own line, indenting them properly.
  
  If C<$enable> is false, no newlines or indenting will be produced, and the
  resulting JSON text is guaranteed not to contain any C<newlines>.
  
  This setting has no effect when decoding JSON texts.
  
  =head2 space_before
  
      $json = $json->space_before([$enable])
      
      $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts. You will also
  most likely combine this setting with C<space_after>.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  =head2 space_after
  
      $json = $json->space_after([$enable])
      
      $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space after the C<:> separating keys from values in JSON objects
  and extra whitespace after the C<,> separating key-value pairs and array
  members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  =head2 relaxed
  
      $json = $json->relaxed([$enable])
      
      $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in any way. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =back
  
  =head2 canonical
  
      $json = $json->canonical([$enable])
      
      $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
  by sorting their keys. This is adding a comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script, and can change even within the same run from 5.18
  onwards).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  This setting has currently no effect on tied hashes.
  
  =head2 allow_nonref
  
      $json = $json->allow_nonref([$enable])
      
      $enabled = $json->get_allow_nonref
  
  Unlike other boolean options, this option is enabled by default beginning
  with version C<4.0>.
  
  If C<$enable> is true (or missing), then the C<encode> method can convert a
  non-reference into its corresponding string, number or null JSON value,
  which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
  values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
  Example, encode a Perl scalar as JSON value with enabled C<allow_nonref>,
  resulting in an invalid JSON text:
  
     JSON->new->allow_nonref->encode ("Hello, World!")
     => "Hello, World!"
  
  =head2 allow_unknown
  
      $json = $json->allow_unknown ([$enable])
      
      $enabled = $json->get_allow_unknown
  
  If C<$enable> is true (or missing), then C<encode> will I<not> throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON C<null> value. Note
  that blessed objects are not included here and are handled separately by
  c<allow_blessed>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect C<decode> in any way, and it is recommended to
  leave it off unless you know your communications partner.
  
  =head2 allow_blessed
  
      $json = $json->allow_blessed([$enable])
      
      $enabled = $json->get_allow_blessed
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference that it cannot convert
  otherwise. Instead, a JSON C<null> value is encoded instead of the object.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object that it cannot convert
  otherwise.
  
  This setting has no effect on C<decode>.
  
  =head2 convert_blessed
  
      $json = $json->convert_blessed([$enable])
      
      $enabled = $json->get_convert_blessed
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context and
  the resulting scalar will be encoded instead of the object.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with any C<to_json>
  function or method.
  
  If C<$enable> is false (the default), then C<encode> will not consider
  this type of conversion.
  
  This setting has no effect on C<decode>.
  
  =head2 allow_tags (since version 3.0)
  
      $json = $json->allow_tags([$enable])
  
      $enabled = $json->get_allow_tags
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<FREEZE> method on
  the object's class. If found, it will be used to serialise the object into
  a nonstandard tagged JSON value (that JSON decoders cannot decode).
  
  It also causes C<decode> to parse such tagged JSON values and deserialise
  them via a call to the C<THAW> method.
  
  If C<$enable> is false (the default), then C<encode> will not consider
  this type of conversion, and tagged JSON values will cause a parse error
  in C<decode>, as if tags were not part of the grammar.
  
  =head2 boolean_values (since version 4.0)
  
      $json->boolean_values([$false, $true])
  
      ($false,  $true) = $json->get_boolean_values
  
  By default, JSON booleans will be decoded as overloaded
  C<$JSON::false> and C<$JSON::true> objects.
  
  With this method you can specify your own boolean values for decoding -
  on decode, JSON C<false> will be decoded as a copy of C<$false>, and JSON
  C<true> will be decoded as C<$true> ("copy" here is the same thing as
  assigning a value to another variable, i.e. C<$copy = $false>).
  
  This is useful when you want to pass a decoded data structure directly
  to other serialisers like YAML, Data::MessagePack and so on.
  
  Note that this works only when you C<decode>. You can set incompatible
  boolean objects (like L<boolean>), but when you C<encode> a data structure
  with such boolean objects, you still need to enable C<convert_blessed>
  (and add a C<TO_JSON> method if necessary).
  
  Calling this method without any arguments will reset the booleans
  to their default values.
  
  C<get_boolean_values> will return both C<$false> and C<$true> values, or
  the empty list when they are set to the default.
  
  =head2 filter_json_object
  
      $json = $json->filter_json_object([$coderef])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument is a reference to
  the newly-created hash. If the code references returns a single scalar
  (which need not be a reference), this value (or rather a copy of it) is
  inserted into the deserialised data structure. If it returns an empty
  list (NOTE: I<not> C<undef>, which is a valid scalar), the original
  deserialised hash will be inserted. This setting can slow down decoding
  considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialised hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = JSON->new->filter_json_object(sub { 5 });
     # returns [5]
     $js->decode('[{}]');
     # returns 5
     $js->decode('{"a":1, "b":2}');
  
  =head2 filter_json_single_key_object
  
      $json = $json->filter_json_single_key_object($key [=> $coderef])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialise Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialised Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     JSON
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialisation to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  =head2 max_depth
  
      $json = $json->max_depth([$maximum_nesting_depth])
      
      $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  Setting the maximum depth to one disallows any nesting, so that ensures
  that the object is only a single hash/object or array.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  See L<JSON::XS/SECURITY CONSIDERATIONS> for more info on why this is useful.
  
  =head2 max_size
  
      $json = $json->max_size([$maximum_string_size])
      
      $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  See L<JSON::XS/SECURITY CONSIDERATIONS> for more info on why this is useful.
  
  =head2 encode
  
      $json_text = $json->encode($perl_scalar)
  
  Converts the given Perl value or data structure to its JSON
  representation. Croaks on error.
  
  =head2 decode
  
      $perl_scalar = $json->decode($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  =head2 decode_prefix
  
      ($perl_scalar, $characters) = $json->decode_prefix($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
  This is useful if your JSON texts are not delimited by an outer protocol
  and you need to know where the JSON text ends.
  
     JSON->new->decode_prefix ("[1] the tail")
     => ([1], 3)
  
  =head1 ADDITIONAL METHODS
  
  The following methods are for this module only.
  
  =head2 backend
  
      $backend = $json->backend
  
  Since 2.92, C<backend> method returns an abstract backend module used currently,
  which should be JSON::Backend::XS (which inherits JSON::XS or Cpanel::JSON::XS),
  or JSON::Backend::PP (which inherits JSON::PP), not to monkey-patch the actual
  backend module globally.
  
  If you need to know what is used actually, use C<isa>, instead of string comparison.
  
  =head2 is_xs
  
      $boolean = $json->is_xs
  
  Returns true if the backend inherits JSON::XS or Cpanel::JSON::XS.
  
  =head2 is_pp
  
      $boolean = $json->is_pp
  
  Returns true if the backend inherits JSON::PP.
  
  =head2 property
  
      $settings = $json->property()
  
  Returns a reference to a hash that holds all the common flag settings.
  
      $json = $json->property('utf8' => 1)
      $value = $json->property('utf8') # 1
  
  You can use this to get/set a value of a particular flag.
  
  =head2 boolean
  
      $boolean_object = JSON->boolean($scalar)
  
  Returns $JSON::true if $scalar contains a true value, $JSON::false otherwise.
  You can use this as a full-qualified function (C<JSON::boolean($scalar)>).
  
  =head1 INCREMENTAL PARSING
  
  This section is also taken from JSON::XS.
  
  In some cases, there is the need for incremental parsing of JSON
  texts. While this module always has to keep both JSON text and resulting
  Perl data structure in memory at one time, it does allow you to parse a
  JSON stream incrementally. It does so by accumulating text until it has
  a full JSON object, which it then can decode. This process is similar to
  using C<decode_prefix> to see if a full JSON object is available, but
  is much more efficient (and can be implemented with a minimum of method
  calls).
  
  This module will only attempt to parse the JSON text once it is sure it
  has enough text to get a decisive result, using a very simple but
  truly incremental parser. This means that it sometimes won't stop as
  early as the full parser, for example, it doesn't detect mismatched
  parentheses. The only thing it guarantees is that it starts decoding as
  soon as a syntactically valid JSON text has been seen. This means you need
  to set resource limits (e.g. C<max_size>) to ensure the parser will stop
  parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =head2 incr_parse
  
      $json->incr_parse( [$string] ) # void context
      
      $obj_or_undef = $json->incr_parse( [$string] ) # scalar context
      
      @obj_or_empty = $json->incr_parse( [$string] ) # list context
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the erroneous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators (other than
  whitespace) between the JSON objects or arrays, instead they must be
  concatenated back-to-back. If an error occurs, an exception will be
  raised as in the scalar context case. Note that in this case, any
  previously-parsed JSON texts will be lost.
  
  Example: Parse some JSON arrays/objects in a given string and return
  them.
  
      my @objs = JSON->new->incr_parse ("[5][7][1,2]");
  
  =head2 incr_text
  
      $lvalue_string = $json->incr_text
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object. Under
  all other circumstances you must not call this function (I mean it.
  although in simple tests it might actually work, it I<will> fail under
  real world conditions). As a special exception, you can also call this
  method before having parsed anything.
  
  That means you can only use this function to look at or manipulate text
  before or after complete JSON objects, not while the parser is in the
  middle of parsing a JSON object.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
  =head2 incr_skip
  
      $json->incr_skip
  
  This will reset the state of the incremental parser and will remove
  the parsed text from the input buffer so far. This is useful after
  C<incr_parse> died, in which case the input buffer and incremental parser
  state is left unchanged, to skip the text parsed so far and to reset the
  parse state.
  
  The difference to C<incr_reset> is that only text until the parse error
  occurred is removed.
  
  =head2 incr_reset
  
      $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want to repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  =head1 MAPPING
  
  Most of this section is also taken from JSON::XS.
  
  This section describes how the backend modules map Perl values to JSON values and
  vice versa. These mappings are designed to "do the right thing" in most
  circumstances automatically, preserving round-tripping characteristics
  (what you put in comes out as something equivalent).
  
  For the more enlightened: note that in the following descriptions,
  lowercase I<perl> refers to the Perl interpreter, while uppercase I<Perl>
  refers to the abstract Perl language itself.
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserver object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, this module will try to represent
  it as an integer value. If that fails, it will try to represent it as
  a numeric (floating point) value if that is possible without loss of
  precision. Otherwise it will preserve the number as a string value (in
  which case you lose roundtripping ability, as the JSON number will be
  re-encoded to a JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values cannot
  represent most decimal fractions exactly, and when converting from and to
  floating point, this module only guarantees precision up to but not including
  the least significant bit.
  
  =item true, false
  
  These JSON atoms become C<JSON::true> and C<JSON::false>,
  respectively. They are overloaded to act almost exactly like the numbers
  C<1> and C<0>. You can check whether a scalar is a JSON boolean by using
  the C<JSON::is_bool> function.
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  =item shell-style comments (C<< # I<text> >>)
  
  As a nonstandard extension to the JSON syntax that is enabled by the
  C<relaxed> setting, shell-style comments are allowed. They can start
  anywhere outside strings and go till the end of the line.
  
  =item tagged values (C<< (I<tag>)I<value> >>).
  
  Another nonstandard extension to the JSON syntax, enabled with the
  C<allow_tags> setting, are tagged values. In this implementation, the
  I<tag> must be a perl package/class name encoded as a JSON string, and the
  I<value> must be a JSON array encoding optional constructor arguments.
  
  See L<OBJECT SERIALISATION>, below, for details.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent
  ordering in hash keys (or JSON objects), they will usually be encoded
  in a pseudo-random order. This module can optionally sort the hash keys
  (determined by the I<canonical> flag), so the same data structure will
  serialise to the same JSON text (given same settings and version of
  the same backend), but this incurs a runtime overhead and is only rarely useful,
  e.g. when you want to compare some JSON text against another for equality.
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON. You can
  also use C<JSON::false> and C<JSON::true> to improve readability.
  
     encode_json [\0,JSON::true]      # yields [false,true]
  
  =item JSON::true, JSON::false, JSON::null
  
  These special values become JSON true and JSON false values,
  respectively. You can also use C<\1> and C<\0> directly if you want.
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON, but C<JSON::XS>
  allows various ways of handling objects. See L<OBJECT SERIALISATION>,
  below, for details.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: this module will encode undefined scalars as
  JSON C<null> values, scalars that have last been used in a string context
  before encoding as JSON strings, and anything else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, so dump as string
     print $value;
     encode_json [$value]                 # yields ["5"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
  You can force the type to be a string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
  
  You can force the type to be a number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choice is yours.
  
  You can not currently force the type in other, less obscure, ways. Tell me
  if you need this capability (but don't forget to explain why it's needed
  :).
  
  Since version 2.91_01, JSON::PP uses a different number detection logic
  that converts a scalar that is possible to turn into a number safely.
  The new logic is slightly faster, and tends to help people who use older
  perl or who want to encode complicated data structure. However, this may
  results in a different JSON text from the one JSON::XS encodes (and
  thus may break tests that compare entire JSON texts). If you do
  need the previous behavior for better compatibility or for finer control,
  set PERL_JSON_PP_USE_B environmental variable to true before you
  C<use> JSON.
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and it is an
  error to pass those in.
  
  JSON.pm backend modules trust what you pass to C<encode> method
  (or C<encode_json> function) is a clean, validated data structure with
  values that can be represented as valid JSON values only, because it's
  not from an external data source (as opposed to JSON texts you pass to
  C<decode> or C<decode_json>, which JSON backends consider tainted and
  don't trust). As JSON backends don't know exactly what you and consumers
  of your JSON texts want the unexpected values to be (you may want to
  convert them into null, or to stringify them with or without
  normalisation (string representation of infinities/NaN may vary
  depending on platforms), or to croak without conversion), you're advised
  to do what you and your consumers need before you encode, and also not
  to numify values that may start with values that look like a number
  (including infinities/NaN), without validating.
  
  =back
  
  =head2 OBJECT SERIALISATION
  
  As JSON cannot directly represent Perl objects, you have to choose between
  a pure JSON representation (without the ability to deserialise the object
  automatically again), and a nonstandard extension to the JSON syntax,
  tagged values.
  
  =head3 SERIALISATION
  
  What happens when this module encounters a Perl object depends on the
  C<allow_blessed>, C<convert_blessed> and C<allow_tags> settings, which
  are used in this order:
  
  =over 4
  
  =item 1. C<allow_tags> is enabled and the object has a C<FREEZE> method.
  
  In this case, C<JSON> creates a tagged JSON value, using a nonstandard
  extension to the JSON syntax.
  
  This works by invoking the C<FREEZE> method on the object, with the first
  argument being the object to serialise, and the second argument being the
  constant string C<JSON> to distinguish it from other serialisers.
  
  The C<FREEZE> method can return any number of values (i.e. zero or
  more). These values and the package/classname of the object will then be
  encoded as a tagged JSON value in the following format:
  
     ("classname")[FREEZE return values...]
  
  e.g.:
  
     ("URI")["http://www.google.com/"]
     ("MyDate")[2013,10,29]
     ("ImageData::JPEG")["Z3...VlCg=="]
  
  For example, the hypothetical C<My::Object> C<FREEZE> method might use the
  objects C<type> and C<id> members to encode the object:
  
     sub My::Object::FREEZE {
        my ($self, $serialiser) = @_;
  
        ($self->{type}, $self->{id})
     }
  
  =item 2. C<convert_blessed> is enabled and the object has a C<TO_JSON> method.
  
  In this case, the C<TO_JSON> method of the object is invoked in scalar
  context. It must return a single scalar that can be directly encoded into
  JSON. This scalar replaces the object in the JSON text.
  
  For example, the following C<TO_JSON> method will convert all L<URI>
  objects to JSON strings when serialised. The fact that these values
  originally were L<URI> objects is lost.
  
     sub URI::TO_JSON {
        my ($uri) = @_;
        $uri->as_string
     }
  
  =item 3. C<allow_blessed> is enabled.
  
  The object will be serialised as a JSON null value.
  
  =item 4. none of the above
  
  If none of the settings are enabled or the respective methods are missing,
  this module throws an exception.
  
  =back
  
  =head3 DESERIALISATION
  
  For deserialisation there are only two cases to consider: either
  nonstandard tagging was used, in which case C<allow_tags> decides,
  or objects cannot be automatically be deserialised, in which
  case you can use postprocessing or the C<filter_json_object> or
  C<filter_json_single_key_object> callbacks to get some real objects our of
  your JSON.
  
  This section only considers the tagged value case: a tagged JSON object
  is encountered during decoding and C<allow_tags> is disabled, a parse
  error will result (as if tagged values were not part of the grammar).
  
  If C<allow_tags> is enabled, this module will look up the C<THAW> method
  of the package/classname used during serialisation (it will not attempt
  to load the package as a Perl module). If there is no such method, the
  decoding will fail with an error.
  
  Otherwise, the C<THAW> method is invoked with the classname as first
  argument, the constant string C<JSON> as second argument, and all the
  values from the JSON array (the values originally returned by the
  C<FREEZE> method) as remaining arguments.
  
  The method must then return the object. While technically you can return
  any Perl scalar, you might have to enable the C<allow_nonref> setting to
  make that work in all cases, so better return an actual blessed reference.
  
  As an example, let's implement a C<THAW> function that regenerates the
  C<My::Object> from the C<FREEZE> example earlier:
  
     sub My::Object::THAW {
        my ($class, $serialiser, $type, $id) = @_;
  
        $class->new (type => $type, id => $id)
     }
  
  
  =head1 ENCODING/CODESET FLAG NOTES
  
  This section is taken from JSON::XS.
  
  The interested reader might have seen a number of flags that signify
  encodings or codesets - C<utf8>, C<latin1> and C<ascii>. There seems to be
  some confusion on what these do, so here is a short comparison:
  
  C<utf8> controls whether the JSON text created by C<encode> (and expected
  by C<decode>) is UTF-8 encoded or not, while C<latin1> and C<ascii> only
  control whether C<encode> escapes character values outside their respective
  codeset range. Neither of these flags conflict with each other, although
  some combinations make less sense than others.
  
  Care has been taken to make all flags symmetrical with respect to
  C<encode> and C<decode>, that is, texts encoded with any combination of
  these flag values will be correctly decoded when the same flags are used
  - in general, if you use different flag settings while encoding vs. when
  decoding you likely have a bug somewhere.
  
  Below comes a verbose discussion of these flags. Note that a "codeset" is
  simply an abstract set of character-codepoint pairs, while an encoding
  takes those codepoint numbers and I<encodes> them, in our case into
  octets. Unicode is (among other things) a codeset, UTF-8 is an encoding,
  and ISO-8859-1 (= latin 1) and ASCII are both codesets I<and> encodings at
  the same time, which can be confusing.
  
  =over 4
  
  =item C<utf8> flag disabled
  
  When C<utf8> is disabled (the default), then C<encode>/C<decode> generate
  and expect Unicode strings, that is, characters with high ordinal Unicode
  values (> 255) will be encoded as such characters, and likewise such
  characters are decoded as-is, no changes to them will be done, except
  "(re-)interpreting" them as Unicode codepoints or Unicode characters,
  respectively (to Perl, these are the same thing in strings unless you do
  funny/weird/dumb stuff).
  
  This is useful when you want to do the encoding yourself (e.g. when you
  want to have UTF-16 encoded JSON texts) or when some other layer does
  the encoding for you (for example, when printing to a terminal using a
  filehandle that transparently encodes to UTF-8 you certainly do NOT want
  to UTF-8 encode your data first and have Perl encode it another time).
  
  =item C<utf8> flag enabled
  
  If the C<utf8>-flag is enabled, C<encode>/C<decode> will encode all
  characters using the corresponding UTF-8 multi-byte sequence, and will
  expect your input strings to be encoded as UTF-8, that is, no "character"
  of the input string must have any value > 255, as UTF-8 does not allow
  that.
  
  The C<utf8> flag therefore switches between two modes: disabled means you
  will get a Unicode string in Perl, enabled means you get an UTF-8 encoded
  octet/binary string in Perl.
  
  =item C<latin1> or C<ascii> flags enabled
  
  With C<latin1> (or C<ascii>) enabled, C<encode> will escape characters
  with ordinal values > 255 (> 127 with C<ascii>) and encode the remaining
  characters as specified by the C<utf8> flag.
  
  If C<utf8> is disabled, then the result is also correctly encoded in those
  character sets (as both are proper subsets of Unicode, meaning that a
  Unicode string with all character values < 256 is the same thing as a
  ISO-8859-1 string, and a Unicode string with all character values < 128 is
  the same thing as an ASCII string in Perl).
  
  If C<utf8> is enabled, you still get a correct UTF-8-encoded string,
  regardless of these flags, just some more characters will be escaped using
  C<\uXXXX> then before.
  
  Note that ISO-8859-1-I<encoded> strings are not compatible with UTF-8
  encoding, while ASCII-encoded strings are. That is because the ISO-8859-1
  encoding is NOT a subset of UTF-8 (despite the ISO-8859-1 I<codeset> being
  a subset of Unicode), while ASCII is.
  
  Surprisingly, C<decode> will ignore these flags and so treat all input
  values as governed by the C<utf8> flag. If it is disabled, this allows you
  to decode ISO-8859-1- and ASCII-encoded strings, as both strict subsets of
  Unicode. If it is enabled, you can correctly decode UTF-8 encoded strings.
  
  So neither C<latin1> nor C<ascii> are incompatible with the C<utf8> flag -
  they only govern when the JSON output engine escapes a character or not.
  
  The main use for C<latin1> is to relatively efficiently store binary data
  as JSON, at the expense of breaking compatibility with most JSON decoders.
  
  The main use for C<ascii> is to force the output to not contain characters
  with values > 127, which means you can interpret the resulting string
  as UTF-8, ISO-8859-1, ASCII, KOI8-R or most about any character set and
  8-bit-encoding, and still get the same data structure back. This is useful
  when your channel for JSON transfer is not 8-bit clean or the encoding
  might be mangled in between (e.g. in mail), and works because ASCII is a
  proper subset of most 8-bit and multibyte encodings in use in the world.
  
  =back
  
  =head1 BACKWARD INCOMPATIBILITY
  
  Since version 2.90, stringification (and string comparison) for
  C<JSON::true> and C<JSON::false> has not been overloaded. It shouldn't
  matter as long as you treat them as boolean values, but a code that
  expects they are stringified as "true" or "false" doesn't work as
  you have expected any more.
  
      if (JSON::true eq 'true') {  # now fails
  
      print "The result is $JSON::true now."; # => The result is 1 now.
  
  And now these boolean values don't inherit JSON::Boolean, either.
  When you need to test a value is a JSON boolean value or not, use
  C<JSON::is_bool> function, instead of testing the value inherits
  a particular boolean class or not.
  
  =head1 BUGS
  
  Please report bugs on backend selection and additional features
  this module provides to RT or GitHub issues for this module:
  
  L<https://rt.cpan.org/Public/Dist/Display.html?Queue=JSON>
  
  L<https://github.com/makamaka/JSON/issues>
  
  As for bugs on a specific behavior, please report to the author
  of the backend module you are using.
  
  As for new features and requests to change common behaviors, please
  ask the author of JSON::XS (Marc Lehmann, E<lt>schmorp[at]schmorp.deE<gt>)
  first, by email (important!), to keep compatibility among JSON.pm
  backends.
  
  =head1 SEE ALSO
  
  L<JSON::XS>, L<Cpanel::JSON::XS>, L<JSON::PP> for backends.
  
  L<JSON::MaybeXS>, an alternative that prefers Cpanel::JSON::XS.
  
  C<RFC4627>(L<http://www.ietf.org/rfc/rfc4627.txt>)
  
  RFC7159 (L<http://www.ietf.org/rfc/rfc7159.txt>)
  
  RFC8259 (L<http://www.ietf.org/rfc/rfc8259.txt>)
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  JSON::XS was written by  Marc Lehmann E<lt>schmorp[at]schmorp.deE<gt>
  
  The release of this new version owes to the courtesy of Marc Lehmann.
  
  =head1 CURRENT MAINTAINER
  
  Kenichi Ishigaki, E<lt>ishigaki[at]cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2005-2013 by Makamaka Hannyaharamitu
  
  Most of the documentation is taken from JSON::XS by Marc Lehmann
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
JSON

$fatpacked{"JSON/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_PP';
  package JSON::PP;use 5.005;use strict;use Exporter ();BEGIN {@JSON::PP::ISA=('Exporter')}use overload ();use JSON::PP::Boolean;use Carp ();$JSON::PP::VERSION='4.09';@JSON::PP::EXPORT=qw(encode_json decode_json from_json to_json);use constant P_ASCII=>0;use constant P_LATIN1=>1;use constant P_UTF8=>2;use constant P_INDENT=>3;use constant P_CANONICAL=>4;use constant P_SPACE_BEFORE=>5;use constant P_SPACE_AFTER=>6;use constant P_ALLOW_NONREF=>7;use constant P_SHRINK=>8;use constant P_ALLOW_BLESSED=>9;use constant P_CONVERT_BLESSED=>10;use constant P_RELAXED=>11;use constant P_LOOSE=>12;use constant P_ALLOW_BIGNUM=>13;use constant P_ALLOW_BAREKEY=>14;use constant P_ALLOW_SINGLEQUOTE=>15;use constant P_ESCAPE_SLASH=>16;use constant P_AS_NONBLESSED=>17;use constant P_ALLOW_UNKNOWN=>18;use constant P_ALLOW_TAGS=>19;use constant OLD_PERL=>$] < 5.008 ? 1 : 0;use constant USE_B=>$ENV{PERL_JSON_PP_USE_B}|| 0;my$invalid_char_re;BEGIN {$invalid_char_re="[";for my$i (0 .. 0x01F,0x22,0x5c){$invalid_char_re .= quotemeta chr utf8::unicode_to_native($i)}$invalid_char_re=qr/$invalid_char_re]/}BEGIN {if (USE_B){require B}}BEGIN {my@xs_compati_bit_properties=qw(latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink allow_blessed convert_blessed relaxed allow_unknown allow_tags);my@pp_bit_properties=qw(allow_singlequote allow_bignum loose allow_barekey escape_slash as_nonblessed);if (OLD_PERL){my$helper=$] >= 5.006 ? 'JSON::PP::Compat5006' : 'JSON::PP::Compat5005';eval qq| require $helper |;if ($@){Carp::croak $@}}for my$name (@xs_compati_bit_properties,@pp_bit_properties){my$property_id='P_' .uc($name);eval qq/
              sub $name {
                  my \$enable = defined \$_[1] ? \$_[1] : 1;
  
                  if (\$enable) {
                      \$_[0]->{PROPS}->[$property_id] = 1;
                  }
                  else {
                      \$_[0]->{PROPS}->[$property_id] = 0;
                  }
  
                  \$_[0];
              }
  
              sub get_$name {
                  \$_[0]->{PROPS}->[$property_id] ? 1 : '';
              }
          /}}my$JSON;sub encode_json ($) {($JSON ||= __PACKAGE__->new->utf8)->encode(@_)}sub decode_json {($JSON ||= __PACKAGE__->new->utf8)->decode(@_)}sub to_json($) {Carp::croak ("JSON::PP::to_json has been renamed to encode_json.")}sub from_json($) {Carp::croak ("JSON::PP::from_json has been renamed to decode_json.")}sub new {my$class=shift;my$self={max_depth=>512,max_size=>0,indent_length=>3,};$self->{PROPS}[P_ALLOW_NONREF]=1;bless$self,$class}sub encode {return $_[0]->PP_encode_json($_[1])}sub decode {return $_[0]->PP_decode_json($_[1],0x00000000)}sub decode_prefix {return $_[0]->PP_decode_json($_[1],0x00000001)}sub pretty {my ($self,$v)=@_;my$enable=defined$v ? $v : 1;if ($enable){$self->indent(1)->space_before(1)->space_after(1)}else {$self->indent(0)->space_before(0)->space_after(0)}$self}sub max_depth {my$max=defined $_[1]? $_[1]: 0x80000000;$_[0]->{max_depth}=$max;$_[0]}sub get_max_depth {$_[0]->{max_depth}}sub max_size {my$max=defined $_[1]? $_[1]: 0;$_[0]->{max_size}=$max;$_[0]}sub get_max_size {$_[0]->{max_size}}sub boolean_values {my$self=shift;if (@_){my ($false,$true)=@_;$self->{false}=$false;$self->{true}=$true}else {delete$self->{false};delete$self->{true}}return$self}sub get_boolean_values {my$self=shift;if (exists$self->{true}and exists$self->{false}){return @$self{qw/false true/}}return}sub filter_json_object {if (defined $_[1]and ref $_[1]eq 'CODE'){$_[0]->{cb_object}=$_[1]}else {delete $_[0]->{cb_object}}$_[0]->{F_HOOK}=($_[0]->{cb_object}or $_[0]->{cb_sk_object})? 1 : 0;$_[0]}sub filter_json_single_key_object {if (@_==1 or @_ > 3){Carp::croak("Usage: JSON::PP::filter_json_single_key_object(self, key, callback = undef)")}if (defined $_[2]and ref $_[2]eq 'CODE'){$_[0]->{cb_sk_object}->{$_[1]}=$_[2]}else {delete $_[0]->{cb_sk_object}->{$_[1]};delete $_[0]->{cb_sk_object}unless %{$_[0]->{cb_sk_object}|| {}}}$_[0]->{F_HOOK}=($_[0]->{cb_object}or $_[0]->{cb_sk_object})? 1 : 0;$_[0]}sub indent_length {if (!defined $_[1]or $_[1]> 15 or $_[1]< 0){Carp::carp "The acceptable range of indent_length() is 0 to 15."}else {$_[0]->{indent_length}=$_[1]}$_[0]}sub get_indent_length {$_[0]->{indent_length}}sub sort_by {$_[0]->{sort_by}=defined $_[1]? $_[1]: 1;$_[0]}sub allow_bigint {Carp::carp("allow_bigint() is obsoleted. use allow_bignum() instead.");$_[0]->allow_bignum}{my$max_depth;my$indent;my$ascii;my$latin1;my$utf8;my$space_before;my$space_after;my$canonical;my$allow_blessed;my$convert_blessed;my$indent_length;my$escape_slash;my$bignum;my$as_nonblessed;my$allow_tags;my$depth;my$indent_count;my$keysort;sub PP_encode_json {my$self=shift;my$obj=shift;$indent_count=0;$depth=0;my$props=$self->{PROPS};($ascii,$latin1,$utf8,$indent,$canonical,$space_before,$space_after,$allow_blessed,$convert_blessed,$escape_slash,$bignum,$as_nonblessed,$allow_tags)=@{$props}[P_ASCII .. P_SPACE_AFTER,P_ALLOW_BLESSED,P_CONVERT_BLESSED,P_ESCAPE_SLASH,P_ALLOW_BIGNUM,P_AS_NONBLESSED,P_ALLOW_TAGS];($max_depth,$indent_length)=@{$self}{qw/max_depth indent_length/};$keysort=$canonical ? sub {$a cmp $b}: undef;if ($self->{sort_by}){$keysort=ref($self->{sort_by})eq 'CODE' ? $self->{sort_by}: $self->{sort_by}=~ /\D+/ ? $self->{sort_by}: sub {$a cmp $b}}encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")if(!ref$obj and!$props->[P_ALLOW_NONREF ]);my$str=$self->object_to_json($obj);$str .= "\n" if ($indent);return$str}sub object_to_json {my ($self,$obj)=@_;my$type=ref($obj);if($type eq 'HASH'){return$self->hash_to_json($obj)}elsif($type eq 'ARRAY'){return$self->array_to_json($obj)}elsif ($type){if (blessed($obj)){return$self->value_to_json($obj)if ($obj->isa('JSON::PP::Boolean'));if ($allow_tags and $obj->can('FREEZE')){my$obj_class=ref$obj || $obj;$obj=bless$obj,$obj_class;my@results=$obj->FREEZE('JSON');if (@results and ref$results[0]){if (refaddr($obj)eq refaddr($results[0])){encode_error(sprintf("%s::FREEZE method returned same object as was passed instead of a new one",ref$obj))}}return '("'.$obj_class.'")['.join(',',@results).']'}if ($convert_blessed and $obj->can('TO_JSON')){my$result=$obj->TO_JSON();if (defined$result and ref($result)){if (refaddr($obj)eq refaddr($result)){encode_error(sprintf("%s::TO_JSON method returned same object as was passed instead of a new one",ref$obj))}}return$self->object_to_json($result)}return "$obj" if ($bignum and _is_bignum($obj));if ($allow_blessed){return$self->blessed_to_json($obj)if ($as_nonblessed);return 'null'}encode_error(sprintf("encountered object '%s', but neither allow_blessed, convert_blessed nor allow_tags settings are enabled (or TO_JSON/FREEZE method missing)",$obj))}else {return$self->value_to_json($obj)}}else{return$self->value_to_json($obj)}}sub hash_to_json {my ($self,$obj)=@_;my@res;encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")if (++$depth > $max_depth);my ($pre,$post)=$indent ? $self->_up_indent(): ('','');my$del=($space_before ? ' ' : '').':' .($space_after ? ' ' : '');for my$k (_sort($obj)){if (OLD_PERL){utf8::decode($k)}push@res,$self->string_to_json($k).$del .(ref$obj->{$k}? $self->object_to_json($obj->{$k}): $self->value_to_json($obj->{$k}))}--$depth;$self->_down_indent()if ($indent);return '{}' unless@res;return '{' .$pre .join(",$pre",@res).$post .'}'}sub array_to_json {my ($self,$obj)=@_;my@res;encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")if (++$depth > $max_depth);my ($pre,$post)=$indent ? $self->_up_indent(): ('','');for my$v (@$obj){push@res,ref($v)? $self->object_to_json($v): $self->value_to_json($v)}--$depth;$self->_down_indent()if ($indent);return '[]' unless@res;return '[' .$pre .join(",$pre",@res).$post .']'}sub _looks_like_number {my$value=shift;if (USE_B){my$b_obj=B::svref_2object(\$value);my$flags=$b_obj->FLAGS;return 1 if$flags & (B::SVp_IOK()| B::SVp_NOK())and!($flags & B::SVp_POK());return}else {no warnings 'numeric';return if utf8::is_utf8($value);return unless length((my$dummy="")& $value);return unless 0 + $value eq $value;return 1 if$value * 0==0;return -1}}sub value_to_json {my ($self,$value)=@_;return 'null' if(!defined$value);my$type=ref($value);if (!$type){if (_looks_like_number($value)){return$value}return$self->string_to_json($value)}elsif(blessed($value)and $value->isa('JSON::PP::Boolean')){return $$value==1 ? 'true' : 'false'}else {if ((overload::StrVal($value)=~ /=(\w+)/)[0]){return$self->value_to_json("$value")}if ($type eq 'SCALAR' and defined $$value){return $$value eq '1' ? 'true' : $$value eq '0' ? 'false' : $self->{PROPS}->[P_ALLOW_UNKNOWN ]? 'null' : encode_error("cannot encode reference to scalar")}if ($self->{PROPS}->[P_ALLOW_UNKNOWN ]){return 'null'}else {if ($type eq 'SCALAR' or $type eq 'REF'){encode_error("cannot encode reference to scalar")}else {encode_error("encountered $value, but JSON can only represent references to arrays or hashes")}}}}my%esc=("\n"=>'\n',"\r"=>'\r',"\t"=>'\t',"\f"=>'\f',"\b"=>'\b',"\""=>'\"',"\\"=>'\\\\',"\'"=>'\\\'',);sub string_to_json {my ($self,$arg)=@_;$arg =~ s/(["\\\n\r\t\f\b])/$esc{$1}/g;$arg =~ s/\//\\\//g if ($escape_slash);$arg =~ s/([^\n\t\c?[:^cntrl:][:^ascii:]])/'\\u00' . unpack('H2', $1)/eg;if ($ascii){$arg=JSON_PP_encode_ascii($arg)}if ($latin1){$arg=JSON_PP_encode_latin1($arg)}if ($utf8){utf8::encode($arg)}return '"' .$arg .'"'}sub blessed_to_json {my$reftype=reftype($_[1])|| '';if ($reftype eq 'HASH'){return $_[0]->hash_to_json($_[1])}elsif ($reftype eq 'ARRAY'){return $_[0]->array_to_json($_[1])}else {return 'null'}}sub encode_error {my$error=shift;Carp::croak "$error"}sub _sort {defined$keysort ? (sort$keysort (keys %{$_[0]})): keys %{$_[0]}}sub _up_indent {my$self=shift;my$space=' ' x $indent_length;my ($pre,$post)=('','');$post="\n" .$space x $indent_count;$indent_count++;$pre="\n" .$space x $indent_count;return ($pre,$post)}sub _down_indent {$indent_count--}sub PP_encode_box {{depth=>$depth,indent_count=>$indent_count,}}}sub _encode_ascii {join('',map {chr($_)=~ /[[:ascii:]]/ ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',_encode_surrogates($_))}unpack('U*',$_[0]))}sub _encode_latin1 {join('',map {$_ <= 255 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',_encode_surrogates($_))}unpack('U*',$_[0]))}sub _encode_surrogates {my$uni=$_[0]- 0x10000;return ($uni / 0x400 + 0xD800,$uni % 0x400 + 0xDC00)}sub _is_bignum {$_[0]->isa('Math::BigInt')or $_[0]->isa('Math::BigFloat')}my$max_intsize;BEGIN {my$checkint=1111;for my$d (5..64){$checkint .= 1;my$int=eval qq| $checkint |;if ($int =~ /[eE]/){$max_intsize=$d - 1;last}}}{my%escapes=(b=>"\b",t=>"\t",n=>"\n",f=>"\f",r=>"\r",'\\'=>'\\','"'=>'"','/'=>'/',);my$text;my$at;my$ch;my$len;my$depth;my$encoding;my$is_valid_utf8;my$utf8_len;my$utf8;my$max_depth;my$max_size;my$relaxed;my$cb_object;my$cb_sk_object;my$F_HOOK;my$allow_bignum;my$singlequote;my$loose;my$allow_barekey;my$allow_tags;my$alt_true;my$alt_false;sub _detect_utf_encoding {my$text=shift;my@octets=unpack('C4',$text);return 'unknown' unless defined$octets[3];return ($octets[0]and $octets[1])? 'UTF-8' : (!$octets[0]and $octets[1])? 'UTF-16BE' : (!$octets[0]and!$octets[1])? 'UTF-32BE' : ($octets[2])? 'UTF-16LE' : (!$octets[2])? 'UTF-32LE' : 'unknown'}sub PP_decode_json {my ($self,$want_offset);($self,$text,$want_offset)=@_;($at,$ch,$depth)=(0,'',0);if (!defined$text or ref$text){decode_error("malformed JSON string, neither array, object, number, string or atom")}my$props=$self->{PROPS};($utf8,$relaxed,$loose,$allow_bignum,$allow_barekey,$singlequote,$allow_tags)=@{$props}[P_UTF8,P_RELAXED,P_LOOSE .. P_ALLOW_SINGLEQUOTE,P_ALLOW_TAGS];($alt_true,$alt_false)=@$self{qw/true false/};if ($utf8){$encoding=_detect_utf_encoding($text);if ($encoding ne 'UTF-8' and $encoding ne 'unknown'){require Encode;Encode::from_to($text,$encoding,'utf-8')}else {utf8::downgrade($text,1)or Carp::croak("Wide character in subroutine entry")}}else {utf8::encode($text)}$len=length$text;($max_depth,$max_size,$cb_object,$cb_sk_object,$F_HOOK)=@{$self}{qw/max_depth max_size cb_object cb_sk_object F_HOOK/};if ($max_size > 1){use bytes;my$bytes=length$text;decode_error(sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s" ,$bytes,$max_size),1)if ($bytes > $max_size)}white();decode_error("malformed JSON string, neither array, object, number, string or atom")unless defined$ch;my$result=value();if (!$props->[P_ALLOW_NONREF ]and!ref$result){decode_error('JSON text must be an object or array (but found number, string, true, false or null,' .' use allow_nonref to allow this)',1)}Carp::croak('something wrong.')if$len < $at;my$consumed=defined$ch ? $at - 1 : $at;white();return ($result,$consumed)if$want_offset;decode_error("garbage after JSON object")if defined$ch;$result}sub next_chr {return$ch=undef if($at >= $len);$ch=substr($text,$at++,1)}sub value {white();return if(!defined$ch);return object()if($ch eq '{');return array()if($ch eq '[');return tag()if($ch eq '(');return string()if($ch eq '"' or ($singlequote and $ch eq "'"));return number()if($ch =~ /[0-9]/ or $ch eq '-');return word()}sub string {my$utf16;my$is_utf8;($is_valid_utf8,$utf8_len)=('',0);my$s='';if($ch eq '"' or ($singlequote and $ch eq "'")){my$boundChar=$ch;OUTER: while(defined(next_chr())){if($ch eq $boundChar){next_chr();if ($utf16){decode_error("missing low surrogate character in surrogate pair")}utf8::decode($s)if($is_utf8);return$s}elsif($ch eq '\\'){next_chr();if(exists$escapes{$ch}){$s .= $escapes{$ch}}elsif($ch eq 'u'){my$u='';for(1..4){$ch=next_chr();last OUTER if($ch !~ /[0-9a-fA-F]/);$u .= $ch}if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/){$utf16=$u}elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/){unless (defined$utf16){decode_error("missing high surrogate character in surrogate pair")}$is_utf8=1;$s .= JSON_PP_decode_surrogates($utf16,$u)|| next;$utf16=undef}else {if (defined$utf16){decode_error("surrogate pair expected")}my$hex=hex($u);if (chr$u =~ /[[:^ascii:]]/){$is_utf8=1;$s .= JSON_PP_decode_unicode($u)|| next}else {$s .= chr$hex}}}else{unless ($loose){$at -= 2;decode_error('illegal backslash escape sequence in string')}$s .= $ch}}else{if ($ch =~ /[[:^ascii:]]/){unless($ch=is_valid_utf8($ch)){$at -= 1;decode_error("malformed UTF-8 character in JSON string")}else {$at += $utf8_len - 1}$is_utf8=1}if (!$loose){if ($ch =~ $invalid_char_re){if (!$relaxed or $ch ne "\t"){$at--;decode_error(sprintf "invalid character 0x%X" ." encountered while parsing JSON string",ord$ch)}}}$s .= $ch}}}decode_error("unexpected end of string while parsing JSON string")}sub white {while(defined$ch){if($ch eq '' or $ch =~ /\A[ \t\r\n]\z/){next_chr()}elsif($relaxed and $ch eq '/'){next_chr();if(defined$ch and $ch eq '/'){1 while(defined(next_chr())and $ch ne "\n" and $ch ne "\r")}elsif(defined$ch and $ch eq '*'){next_chr();while(1){if(defined$ch){if($ch eq '*'){if(defined(next_chr())and $ch eq '/'){next_chr();last}}else{next_chr()}}else{decode_error("Unterminated comment")}}next}else{$at--;decode_error("malformed JSON string, neither array, object, number, string or atom")}}else{if ($relaxed and $ch eq '#'){pos($text)=$at;$text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;$at=pos($text);next_chr;next}last}}}sub array {my$a=$_[0]|| [];decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')if (++$depth > $max_depth);next_chr();white();if(defined$ch and $ch eq ']'){--$depth;next_chr();return$a}else {while(defined($ch)){push @$a,value();white();if (!defined$ch){last}if($ch eq ']'){--$depth;next_chr();return$a}if($ch ne ','){last}next_chr();white();if ($relaxed and $ch eq ']'){--$depth;next_chr();return$a}}}$at-- if defined$ch and $ch ne '';decode_error(", or ] expected while parsing array")}sub tag {decode_error('malformed JSON string, neither array, object, number, string or atom')unless$allow_tags;next_chr();white();my$tag=value();return unless defined$tag;decode_error('malformed JSON string, (tag) must be a string')if ref$tag;white();if (!defined$ch or $ch ne ')'){decode_error(') expected after tag')}next_chr();white();my$val=value();return unless defined$val;decode_error('malformed JSON string, tag value must be an array')unless ref$val eq 'ARRAY';if (!eval {$tag->can('THAW')}){decode_error('cannot decode perl-object (package does not exist)')if $@;decode_error('cannot decode perl-object (package does not have a THAW method)')}$tag->THAW('JSON',@$val)}sub object {my$o=$_[0]|| {};my$k;decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')if (++$depth > $max_depth);next_chr();white();if(defined$ch and $ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}else {while (defined$ch){$k=($allow_barekey and $ch ne '"' and $ch ne "'")? bareKey(): string();white();if(!defined$ch or $ch ne ':'){$at--;decode_error("':' expected")}next_chr();$o->{$k}=value();white();last if (!defined$ch);if($ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}if($ch ne ','){last}next_chr();white();if ($relaxed and $ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}}}$at-- if defined$ch and $ch ne '';decode_error(", or } expected while parsing object/hash")}sub bareKey {my$key;while($ch =~ /[\$\w[:^ascii:]]/){$key .= $ch;next_chr()}return$key}sub word {my$word=substr($text,$at-1,4);if($word eq 'true'){$at += 3;next_chr;return defined$alt_true ? $alt_true : $JSON::PP::true}elsif($word eq 'null'){$at += 3;next_chr;return undef}elsif($word eq 'fals'){$at += 3;if(substr($text,$at,1)eq 'e'){$at++;next_chr;return defined$alt_false ? $alt_false : $JSON::PP::false}}$at--;decode_error("'null' expected")if ($word =~ /^n/);decode_error("'true' expected")if ($word =~ /^t/);decode_error("'false' expected")if ($word =~ /^f/);decode_error("malformed JSON string, neither array, object, number, string or atom")}sub number {my$n='';my$v;my$is_dec;my$is_exp;if($ch eq '-'){$n='-';next_chr;if (!defined$ch or $ch !~ /\d/){decode_error("malformed number (no digits after initial minus)")}}if($ch eq '0'){my$peek=substr($text,$at,1);if($peek =~ /^[0-9a-dfA-DF]/){decode_error("malformed number (leading zero must not be followed by another digit)")}$n .= $ch;next_chr}while(defined$ch and $ch =~ /\d/){$n .= $ch;next_chr}if(defined$ch and $ch eq '.'){$n .= '.';$is_dec=1;next_chr;if (!defined$ch or $ch !~ /\d/){decode_error("malformed number (no digits after decimal point)")}else {$n .= $ch}while(defined(next_chr)and $ch =~ /\d/){$n .= $ch}}if(defined$ch and ($ch eq 'e' or $ch eq 'E')){$n .= $ch;$is_exp=1;next_chr;if(defined($ch)and ($ch eq '+' or $ch eq '-')){$n .= $ch;next_chr;if (!defined$ch or $ch =~ /\D/){decode_error("malformed number (no digits after exp sign)")}$n .= $ch}elsif(defined($ch)and $ch =~ /\d/){$n .= $ch}else {decode_error("malformed number (no digits after exp sign)")}while(defined(next_chr)and $ch =~ /\d/){$n .= $ch}}$v .= $n;if ($is_dec or $is_exp){if ($allow_bignum){require Math::BigFloat;return Math::BigFloat->new($v)}}else {if (length$v > $max_intsize){if ($allow_bignum){require Math::BigInt;return Math::BigInt->new($v)}else {return "$v"}}}return$is_dec ? $v/1.0 : 0+$v}my$max_unicode_length=do {BEGIN {$] >= 5.006 and require warnings and warnings->unimport('utf8')}chr 0x10FFFF};utf8::encode($max_unicode_length);$max_unicode_length=length$max_unicode_length;sub is_valid_utf8 {my$start_point=substr($text,$at - 1);my$limit=$max_unicode_length;$limit=length($start_point)if$limit > length($start_point);while ($limit > 0){my$copy=substr($start_point,0,$limit);if (utf8::decode($copy)){$copy=substr($copy,0,1);utf8::encode($copy);$utf8_len=length$copy;return substr($start_point,0,$utf8_len)}$limit--}$utf8_len=0;return}sub decode_error {my$error=shift;my$no_rep=shift;my$str=defined$text ? substr($text,$at): '';my$mess='';my$type='U*';if (OLD_PERL){my$type=$] < 5.006 ? 'C*' : utf8::is_utf8($str)? 'U*' : 'C*' }for my$c (unpack($type,$str)){my$chr_c=$c;$mess .= $chr_c eq '\\' ? '\\\\' : $chr_c =~ /[[:print:]]/ ? $chr_c : $chr_c eq '\a' ? '\a' : $chr_c eq '\t' ? '\t' : $chr_c eq '\n' ? '\n' : $chr_c eq '\r' ? '\r' : $chr_c eq '\f' ? '\f' : sprintf('\x{%x}',$c);if (length$mess >= 20){$mess .= '...';last}}unless (length$mess){$mess='(end of string)'}Carp::croak ($no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")")}sub _json_object_hook {my$o=$_[0];my@ks=keys %{$o};if ($cb_sk_object and @ks==1 and exists$cb_sk_object->{$ks[0]}and ref$cb_sk_object->{$ks[0]}){my@val=$cb_sk_object->{$ks[0]}->($o->{$ks[0]});if (@val==0){return$o}elsif (@val==1){return$val[0]}else {Carp::croak("filter_json_single_key_object callbacks must not return more than one scalar")}}my@val=$cb_object->($o)if ($cb_object);if (@val==0){return$o}elsif (@val==1){return$val[0]}else {Carp::croak("filter_json_object callbacks must not return more than one scalar")}}sub PP_decode_box {{text=>$text,at=>$at,ch=>$ch,len=>$len,depth=>$depth,encoding=>$encoding,is_valid_utf8=>$is_valid_utf8,}}}sub _decode_surrogates {my$uni=0x10000 + (hex($_[0])- 0xD800)* 0x400 + (hex($_[1])- 0xDC00);my$un=pack('U*',$uni);utf8::encode($un);return$un}sub _decode_unicode {my$un=pack('U',hex shift);utf8::encode($un);return$un}BEGIN {unless (defined&utf8::is_utf8){require Encode;*utf8::is_utf8=*Encode::is_utf8}if (!OLD_PERL){*JSON::PP::JSON_PP_encode_ascii=\&_encode_ascii;*JSON::PP::JSON_PP_encode_latin1=\&_encode_latin1;*JSON::PP::JSON_PP_decode_surrogates=\&_decode_surrogates;*JSON::PP::JSON_PP_decode_unicode=\&_decode_unicode;if ($] < 5.008003){package JSON::PP;require subs;subs->import('join');eval q|
                  sub join {
                      return '' if (@_ < 2);
                      my $j   = shift;
                      my $str = shift;
                      for (@_) { $str .= $j . $_; }
                      return $str;
                  }
              |}}sub JSON::PP::incr_parse {local$Carp::CarpLevel=1;($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_parse(@_)}sub JSON::PP::incr_skip {($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_skip}sub JSON::PP::incr_reset {($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_reset}eval q{
          sub JSON::PP::incr_text : lvalue {
              $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
              if ( $_[0]->{_incr_parser}->{incr_pos} ) {
                  Carp::croak("incr_text cannot be called when the incremental parser already started parsing");
              }
              $_[0]->{_incr_parser}->{incr_text};
          }
      } if ($] >= 5.006)}BEGIN {eval 'require Scalar::Util';unless($@){*JSON::PP::blessed=\&Scalar::Util::blessed;*JSON::PP::reftype=\&Scalar::Util::reftype;*JSON::PP::refaddr=\&Scalar::Util::refaddr}else{eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';*JSON::PP::blessed=sub {local($@,$SIG{__DIE__},$SIG{__WARN__});ref($_[0])? eval {$_[0]->a_sub_not_likely_to_be_here}: undef};require B;my%tmap=qw(B::NULL SCALAR B::HV HASH B::AV ARRAY B::CV CODE B::IO IO B::GV GLOB B::REGEXP REGEXP);*JSON::PP::reftype=sub {my$r=shift;return undef unless length(ref($r));my$t=ref(B::svref_2object($r));return exists$tmap{$t}? $tmap{$t}: length(ref($$r))? 'REF' : 'SCALAR'};*JSON::PP::refaddr=sub {return undef unless length(ref($_[0]));my$addr;if(defined(my$pkg=blessed($_[0]))){$addr .= bless $_[0],'Scalar::Util::Fake';bless $_[0],$pkg}else {$addr .= $_[0]}$addr =~ /0x(\w+)/;local $^W;hex($1)}}}$JSON::PP::true=do {bless \(my$dummy=1),"JSON::PP::Boolean"};$JSON::PP::false=do {bless \(my$dummy=0),"JSON::PP::Boolean"};sub is_bool {blessed $_[0]and ($_[0]->isa("JSON::PP::Boolean")or $_[0]->isa("Types::Serialiser::BooleanBase")or $_[0]->isa("JSON::XS::Boolean"))}sub true {$JSON::PP::true}sub false {$JSON::PP::false}sub null {undef}package JSON::PP::IncrParser;use strict;use constant INCR_M_WS=>0;use constant INCR_M_STR=>1;use constant INCR_M_BS=>2;use constant INCR_M_JSON=>3;use constant INCR_M_C0=>4;use constant INCR_M_C1=>5;use constant INCR_M_TFN=>6;use constant INCR_M_NUM=>7;$JSON::PP::IncrParser::VERSION='1.01';sub new {my ($class)=@_;bless {incr_nest=>0,incr_text=>undef,incr_pos=>0,incr_mode=>0,},$class}sub incr_parse {my ($self,$coder,$text)=@_;$self->{incr_text}='' unless (defined$self->{incr_text});if (defined$text){$self->{incr_text}.= $text}if (defined wantarray){my$max_size=$coder->get_max_size;my$p=$self->{incr_pos};my@ret;{do {unless ($self->{incr_nest}<= 0 and $self->{incr_mode}==INCR_M_JSON){$self->_incr_parse($coder);if ($max_size and $self->{incr_pos}> $max_size){Carp::croak("attempted decode of JSON text of $self->{incr_pos} bytes size, but max_size is set to $max_size")}unless ($self->{incr_nest}<= 0 and $self->{incr_mode}==INCR_M_JSON){if ($self->{incr_mode}==INCR_M_WS and $self->{incr_pos}){$self->{incr_pos}=0;$self->{incr_text}=''}last}}unless ($coder->get_utf8){utf8::decode($self->{incr_text})}my ($obj,$offset)=$coder->PP_decode_json($self->{incr_text},0x00000001);push@ret,$obj;use bytes;$self->{incr_text}=substr($self->{incr_text},$offset || 0);$self->{incr_pos}=0;$self->{incr_nest}=0;$self->{incr_mode}=0;last unless wantarray}while (wantarray)}if (wantarray){return@ret}else {return defined$ret[0]? $ret[0]: undef}}}sub _incr_parse {my ($self,$coder)=@_;my$text=$self->{incr_text};my$len=length$text;my$p=$self->{incr_pos};INCR_PARSE: while ($len > $p){my$s=substr($text,$p,1);last INCR_PARSE unless defined$s;my$mode=$self->{incr_mode};if ($mode==INCR_M_WS){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if (ord($s)> ord " "){if ($s eq '#'){$self->{incr_mode}=INCR_M_C0;redo INCR_PARSE}else {$self->{incr_mode}=INCR_M_JSON;redo INCR_PARSE}}$p++}}elsif ($mode==INCR_M_BS){$p++;$self->{incr_mode}=INCR_M_STR;redo INCR_PARSE}elsif ($mode==INCR_M_C0 or $mode==INCR_M_C1){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if ($s eq "\n"){$self->{incr_mode}=$self->{incr_mode}==INCR_M_C0 ? INCR_M_WS : INCR_M_JSON;last}$p++}next}elsif ($mode==INCR_M_TFN){last INCR_PARSE if$p >= $len && $self->{incr_nest};while ($len > $p){$s=substr($text,$p++,1);next if defined$s and $s =~ /[rueals]/;last}$p--;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($mode==INCR_M_NUM){last INCR_PARSE if$p >= $len && $self->{incr_nest};while ($len > $p){$s=substr($text,$p++,1);next if defined$s and $s =~ /[0-9eE.+\-]/;last}$p--;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($mode==INCR_M_STR){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if ($s eq '"'){$p++;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($s eq '\\'){$p++;if (!defined substr($text,$p,1)){$self->{incr_mode}=INCR_M_BS;last INCR_PARSE}}$p++}}elsif ($mode==INCR_M_JSON){while ($len > $p){$s=substr($text,$p++,1);if ($s eq "\x00"){$p--;last INCR_PARSE}elsif ($s =~ /^[\t\n\r ]$/){if (!$self->{incr_nest}){$p--;last INCR_PARSE}next}elsif ($s eq 't' or $s eq 'f' or $s eq 'n'){$self->{incr_mode}=INCR_M_TFN;redo INCR_PARSE}elsif ($s =~ /^[0-9\-]$/){$self->{incr_mode}=INCR_M_NUM;redo INCR_PARSE}elsif ($s eq '"'){$self->{incr_mode}=INCR_M_STR;redo INCR_PARSE}elsif ($s eq '[' or $s eq '{'){if (++$self->{incr_nest}> $coder->get_max_depth){Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')}next}elsif ($s eq ']' or $s eq '}'){if (--$self->{incr_nest}<= 0){last INCR_PARSE}}elsif ($s eq '#'){$self->{incr_mode}=INCR_M_C1;redo INCR_PARSE}}}}$self->{incr_pos}=$p;$self->{incr_parsing}=$p ? 1 : 0}sub incr_text {if ($_[0]->{incr_pos}){Carp::croak("incr_text cannot be called when the incremental parser already started parsing")}$_[0]->{incr_text}}sub incr_skip {my$self=shift;$self->{incr_text}=substr($self->{incr_text},$self->{incr_pos});$self->{incr_pos}=0;$self->{incr_mode}=0;$self->{incr_nest}=0}sub incr_reset {my$self=shift;$self->{incr_text}=undef;$self->{incr_pos}=0;$self->{incr_mode}=0;$self->{incr_nest}=0}1;
JSON_PP

$fatpacked{"JSON/PP/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_PP_BOOLEAN';
  package JSON::PP::Boolean;use strict;require overload;local $^W;overload::import('overload',"0+"=>sub {${$_[0]}},"++"=>sub {$_[0]=${$_[0]}+ 1},"--"=>sub {$_[0]=${$_[0]}- 1},fallback=>1,);$JSON::PP::Boolean::VERSION='4.09';1;
JSON_PP_BOOLEAN

$fatpacked{"JSON/backportPP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP';
  package JSON::PP;use 5.005;use strict;use Exporter ();BEGIN {@JSON::backportPP::ISA=('Exporter')}use overload ();use JSON::backportPP::Boolean;use Carp ();$JSON::backportPP::VERSION='4.09';@JSON::PP::EXPORT=qw(encode_json decode_json from_json to_json);use constant P_ASCII=>0;use constant P_LATIN1=>1;use constant P_UTF8=>2;use constant P_INDENT=>3;use constant P_CANONICAL=>4;use constant P_SPACE_BEFORE=>5;use constant P_SPACE_AFTER=>6;use constant P_ALLOW_NONREF=>7;use constant P_SHRINK=>8;use constant P_ALLOW_BLESSED=>9;use constant P_CONVERT_BLESSED=>10;use constant P_RELAXED=>11;use constant P_LOOSE=>12;use constant P_ALLOW_BIGNUM=>13;use constant P_ALLOW_BAREKEY=>14;use constant P_ALLOW_SINGLEQUOTE=>15;use constant P_ESCAPE_SLASH=>16;use constant P_AS_NONBLESSED=>17;use constant P_ALLOW_UNKNOWN=>18;use constant P_ALLOW_TAGS=>19;use constant OLD_PERL=>$] < 5.008 ? 1 : 0;use constant USE_B=>$ENV{PERL_JSON_PP_USE_B}|| 0;my$invalid_char_re;BEGIN {$invalid_char_re="[";for my$i (0 .. 0x01F,0x22,0x5c){$invalid_char_re .= quotemeta chr utf8::unicode_to_native($i)}$invalid_char_re=qr/$invalid_char_re]/}BEGIN {if (USE_B){require B}}BEGIN {my@xs_compati_bit_properties=qw(latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink allow_blessed convert_blessed relaxed allow_unknown allow_tags);my@pp_bit_properties=qw(allow_singlequote allow_bignum loose allow_barekey escape_slash as_nonblessed);if (OLD_PERL){my$helper=$] >= 5.006 ? 'JSON::backportPP::Compat5006' : 'JSON::backportPP::Compat5005';eval qq| require $helper |;if ($@){Carp::croak $@}}for my$name (@xs_compati_bit_properties,@pp_bit_properties){my$property_id='P_' .uc($name);eval qq/
              sub $name {
                  my \$enable = defined \$_[1] ? \$_[1] : 1;
  
                  if (\$enable) {
                      \$_[0]->{PROPS}->[$property_id] = 1;
                  }
                  else {
                      \$_[0]->{PROPS}->[$property_id] = 0;
                  }
  
                  \$_[0];
              }
  
              sub get_$name {
                  \$_[0]->{PROPS}->[$property_id] ? 1 : '';
              }
          /}}my$JSON;sub encode_json ($) {($JSON ||= __PACKAGE__->new->utf8)->encode(@_)}sub decode_json {($JSON ||= __PACKAGE__->new->utf8)->decode(@_)}sub to_json($) {Carp::croak ("JSON::PP::to_json has been renamed to encode_json.")}sub from_json($) {Carp::croak ("JSON::PP::from_json has been renamed to decode_json.")}sub new {my$class=shift;my$self={max_depth=>512,max_size=>0,indent_length=>3,};$self->{PROPS}[P_ALLOW_NONREF]=1;bless$self,$class}sub encode {return $_[0]->PP_encode_json($_[1])}sub decode {return $_[0]->PP_decode_json($_[1],0x00000000)}sub decode_prefix {return $_[0]->PP_decode_json($_[1],0x00000001)}sub pretty {my ($self,$v)=@_;my$enable=defined$v ? $v : 1;if ($enable){$self->indent(1)->space_before(1)->space_after(1)}else {$self->indent(0)->space_before(0)->space_after(0)}$self}sub max_depth {my$max=defined $_[1]? $_[1]: 0x80000000;$_[0]->{max_depth}=$max;$_[0]}sub get_max_depth {$_[0]->{max_depth}}sub max_size {my$max=defined $_[1]? $_[1]: 0;$_[0]->{max_size}=$max;$_[0]}sub get_max_size {$_[0]->{max_size}}sub boolean_values {my$self=shift;if (@_){my ($false,$true)=@_;$self->{false}=$false;$self->{true}=$true}else {delete$self->{false};delete$self->{true}}return$self}sub get_boolean_values {my$self=shift;if (exists$self->{true}and exists$self->{false}){return @$self{qw/false true/}}return}sub filter_json_object {if (defined $_[1]and ref $_[1]eq 'CODE'){$_[0]->{cb_object}=$_[1]}else {delete $_[0]->{cb_object}}$_[0]->{F_HOOK}=($_[0]->{cb_object}or $_[0]->{cb_sk_object})? 1 : 0;$_[0]}sub filter_json_single_key_object {if (@_==1 or @_ > 3){Carp::croak("Usage: JSON::PP::filter_json_single_key_object(self, key, callback = undef)")}if (defined $_[2]and ref $_[2]eq 'CODE'){$_[0]->{cb_sk_object}->{$_[1]}=$_[2]}else {delete $_[0]->{cb_sk_object}->{$_[1]};delete $_[0]->{cb_sk_object}unless %{$_[0]->{cb_sk_object}|| {}}}$_[0]->{F_HOOK}=($_[0]->{cb_object}or $_[0]->{cb_sk_object})? 1 : 0;$_[0]}sub indent_length {if (!defined $_[1]or $_[1]> 15 or $_[1]< 0){Carp::carp "The acceptable range of indent_length() is 0 to 15."}else {$_[0]->{indent_length}=$_[1]}$_[0]}sub get_indent_length {$_[0]->{indent_length}}sub sort_by {$_[0]->{sort_by}=defined $_[1]? $_[1]: 1;$_[0]}sub allow_bigint {Carp::carp("allow_bigint() is obsoleted. use allow_bignum() instead.");$_[0]->allow_bignum}{my$max_depth;my$indent;my$ascii;my$latin1;my$utf8;my$space_before;my$space_after;my$canonical;my$allow_blessed;my$convert_blessed;my$indent_length;my$escape_slash;my$bignum;my$as_nonblessed;my$allow_tags;my$depth;my$indent_count;my$keysort;sub PP_encode_json {my$self=shift;my$obj=shift;$indent_count=0;$depth=0;my$props=$self->{PROPS};($ascii,$latin1,$utf8,$indent,$canonical,$space_before,$space_after,$allow_blessed,$convert_blessed,$escape_slash,$bignum,$as_nonblessed,$allow_tags)=@{$props}[P_ASCII .. P_SPACE_AFTER,P_ALLOW_BLESSED,P_CONVERT_BLESSED,P_ESCAPE_SLASH,P_ALLOW_BIGNUM,P_AS_NONBLESSED,P_ALLOW_TAGS];($max_depth,$indent_length)=@{$self}{qw/max_depth indent_length/};$keysort=$canonical ? sub {$a cmp $b}: undef;if ($self->{sort_by}){$keysort=ref($self->{sort_by})eq 'CODE' ? $self->{sort_by}: $self->{sort_by}=~ /\D+/ ? $self->{sort_by}: sub {$a cmp $b}}encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")if(!ref$obj and!$props->[P_ALLOW_NONREF ]);my$str=$self->object_to_json($obj);$str .= "\n" if ($indent);return$str}sub object_to_json {my ($self,$obj)=@_;my$type=ref($obj);if($type eq 'HASH'){return$self->hash_to_json($obj)}elsif($type eq 'ARRAY'){return$self->array_to_json($obj)}elsif ($type){if (blessed($obj)){return$self->value_to_json($obj)if ($obj->isa('JSON::PP::Boolean'));if ($allow_tags and $obj->can('FREEZE')){my$obj_class=ref$obj || $obj;$obj=bless$obj,$obj_class;my@results=$obj->FREEZE('JSON');if (@results and ref$results[0]){if (refaddr($obj)eq refaddr($results[0])){encode_error(sprintf("%s::FREEZE method returned same object as was passed instead of a new one",ref$obj))}}return '("'.$obj_class.'")['.join(',',@results).']'}if ($convert_blessed and $obj->can('TO_JSON')){my$result=$obj->TO_JSON();if (defined$result and ref($result)){if (refaddr($obj)eq refaddr($result)){encode_error(sprintf("%s::TO_JSON method returned same object as was passed instead of a new one",ref$obj))}}return$self->object_to_json($result)}return "$obj" if ($bignum and _is_bignum($obj));if ($allow_blessed){return$self->blessed_to_json($obj)if ($as_nonblessed);return 'null'}encode_error(sprintf("encountered object '%s', but neither allow_blessed, convert_blessed nor allow_tags settings are enabled (or TO_JSON/FREEZE method missing)",$obj))}else {return$self->value_to_json($obj)}}else{return$self->value_to_json($obj)}}sub hash_to_json {my ($self,$obj)=@_;my@res;encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")if (++$depth > $max_depth);my ($pre,$post)=$indent ? $self->_up_indent(): ('','');my$del=($space_before ? ' ' : '').':' .($space_after ? ' ' : '');for my$k (_sort($obj)){if (OLD_PERL){utf8::decode($k)}push@res,$self->string_to_json($k).$del .(ref$obj->{$k}? $self->object_to_json($obj->{$k}): $self->value_to_json($obj->{$k}))}--$depth;$self->_down_indent()if ($indent);return '{}' unless@res;return '{' .$pre .join(",$pre",@res).$post .'}'}sub array_to_json {my ($self,$obj)=@_;my@res;encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")if (++$depth > $max_depth);my ($pre,$post)=$indent ? $self->_up_indent(): ('','');for my$v (@$obj){push@res,ref($v)? $self->object_to_json($v): $self->value_to_json($v)}--$depth;$self->_down_indent()if ($indent);return '[]' unless@res;return '[' .$pre .join(",$pre",@res).$post .']'}sub _looks_like_number {my$value=shift;if (USE_B){my$b_obj=B::svref_2object(\$value);my$flags=$b_obj->FLAGS;return 1 if$flags & (B::SVp_IOK()| B::SVp_NOK())and!($flags & B::SVp_POK());return}else {no warnings 'numeric';return if utf8::is_utf8($value);return unless length((my$dummy="")& $value);return unless 0 + $value eq $value;return 1 if$value * 0==0;return -1}}sub value_to_json {my ($self,$value)=@_;return 'null' if(!defined$value);my$type=ref($value);if (!$type){if (_looks_like_number($value)){return$value}return$self->string_to_json($value)}elsif(blessed($value)and $value->isa('JSON::PP::Boolean')){return $$value==1 ? 'true' : 'false'}else {if ((overload::StrVal($value)=~ /=(\w+)/)[0]){return$self->value_to_json("$value")}if ($type eq 'SCALAR' and defined $$value){return $$value eq '1' ? 'true' : $$value eq '0' ? 'false' : $self->{PROPS}->[P_ALLOW_UNKNOWN ]? 'null' : encode_error("cannot encode reference to scalar")}if ($self->{PROPS}->[P_ALLOW_UNKNOWN ]){return 'null'}else {if ($type eq 'SCALAR' or $type eq 'REF'){encode_error("cannot encode reference to scalar")}else {encode_error("encountered $value, but JSON can only represent references to arrays or hashes")}}}}my%esc=("\n"=>'\n',"\r"=>'\r',"\t"=>'\t',"\f"=>'\f',"\b"=>'\b',"\""=>'\"',"\\"=>'\\\\',"\'"=>'\\\'',);sub string_to_json {my ($self,$arg)=@_;$arg =~ s/(["\\\n\r\t\f\b])/$esc{$1}/g;$arg =~ s/\//\\\//g if ($escape_slash);$arg =~ s/([^\n\t\c?[:^cntrl:][:^ascii:]])/'\\u00' . unpack('H2', $1)/eg;if ($ascii){$arg=JSON_PP_encode_ascii($arg)}if ($latin1){$arg=JSON_PP_encode_latin1($arg)}if ($utf8){utf8::encode($arg)}return '"' .$arg .'"'}sub blessed_to_json {my$reftype=reftype($_[1])|| '';if ($reftype eq 'HASH'){return $_[0]->hash_to_json($_[1])}elsif ($reftype eq 'ARRAY'){return $_[0]->array_to_json($_[1])}else {return 'null'}}sub encode_error {my$error=shift;Carp::croak "$error"}sub _sort {defined$keysort ? (sort$keysort (keys %{$_[0]})): keys %{$_[0]}}sub _up_indent {my$self=shift;my$space=' ' x $indent_length;my ($pre,$post)=('','');$post="\n" .$space x $indent_count;$indent_count++;$pre="\n" .$space x $indent_count;return ($pre,$post)}sub _down_indent {$indent_count--}sub PP_encode_box {{depth=>$depth,indent_count=>$indent_count,}}}sub _encode_ascii {join('',map {chr($_)=~ /[[:ascii:]]/ ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',_encode_surrogates($_))}unpack('U*',$_[0]))}sub _encode_latin1 {join('',map {$_ <= 255 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',_encode_surrogates($_))}unpack('U*',$_[0]))}sub _encode_surrogates {my$uni=$_[0]- 0x10000;return ($uni / 0x400 + 0xD800,$uni % 0x400 + 0xDC00)}sub _is_bignum {$_[0]->isa('Math::BigInt')or $_[0]->isa('Math::BigFloat')}my$max_intsize;BEGIN {my$checkint=1111;for my$d (5..64){$checkint .= 1;my$int=eval qq| $checkint |;if ($int =~ /[eE]/){$max_intsize=$d - 1;last}}}{my%escapes=(b=>"\b",t=>"\t",n=>"\n",f=>"\f",r=>"\r",'\\'=>'\\','"'=>'"','/'=>'/',);my$text;my$at;my$ch;my$len;my$depth;my$encoding;my$is_valid_utf8;my$utf8_len;my$utf8;my$max_depth;my$max_size;my$relaxed;my$cb_object;my$cb_sk_object;my$F_HOOK;my$allow_bignum;my$singlequote;my$loose;my$allow_barekey;my$allow_tags;my$alt_true;my$alt_false;sub _detect_utf_encoding {my$text=shift;my@octets=unpack('C4',$text);return 'unknown' unless defined$octets[3];return ($octets[0]and $octets[1])? 'UTF-8' : (!$octets[0]and $octets[1])? 'UTF-16BE' : (!$octets[0]and!$octets[1])? 'UTF-32BE' : ($octets[2])? 'UTF-16LE' : (!$octets[2])? 'UTF-32LE' : 'unknown'}sub PP_decode_json {my ($self,$want_offset);($self,$text,$want_offset)=@_;($at,$ch,$depth)=(0,'',0);if (!defined$text or ref$text){decode_error("malformed JSON string, neither array, object, number, string or atom")}my$props=$self->{PROPS};($utf8,$relaxed,$loose,$allow_bignum,$allow_barekey,$singlequote,$allow_tags)=@{$props}[P_UTF8,P_RELAXED,P_LOOSE .. P_ALLOW_SINGLEQUOTE,P_ALLOW_TAGS];($alt_true,$alt_false)=@$self{qw/true false/};if ($utf8){$encoding=_detect_utf_encoding($text);if ($encoding ne 'UTF-8' and $encoding ne 'unknown'){require Encode;Encode::from_to($text,$encoding,'utf-8')}else {utf8::downgrade($text,1)or Carp::croak("Wide character in subroutine entry")}}else {utf8::encode($text)}$len=length$text;($max_depth,$max_size,$cb_object,$cb_sk_object,$F_HOOK)=@{$self}{qw/max_depth max_size cb_object cb_sk_object F_HOOK/};if ($max_size > 1){use bytes;my$bytes=length$text;decode_error(sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s" ,$bytes,$max_size),1)if ($bytes > $max_size)}white();decode_error("malformed JSON string, neither array, object, number, string or atom")unless defined$ch;my$result=value();if (!$props->[P_ALLOW_NONREF ]and!ref$result){decode_error('JSON text must be an object or array (but found number, string, true, false or null,' .' use allow_nonref to allow this)',1)}Carp::croak('something wrong.')if$len < $at;my$consumed=defined$ch ? $at - 1 : $at;white();return ($result,$consumed)if$want_offset;decode_error("garbage after JSON object")if defined$ch;$result}sub next_chr {return$ch=undef if($at >= $len);$ch=substr($text,$at++,1)}sub value {white();return if(!defined$ch);return object()if($ch eq '{');return array()if($ch eq '[');return tag()if($ch eq '(');return string()if($ch eq '"' or ($singlequote and $ch eq "'"));return number()if($ch =~ /[0-9]/ or $ch eq '-');return word()}sub string {my$utf16;my$is_utf8;($is_valid_utf8,$utf8_len)=('',0);my$s='';if($ch eq '"' or ($singlequote and $ch eq "'")){my$boundChar=$ch;OUTER: while(defined(next_chr())){if($ch eq $boundChar){next_chr();if ($utf16){decode_error("missing low surrogate character in surrogate pair")}utf8::decode($s)if($is_utf8);return$s}elsif($ch eq '\\'){next_chr();if(exists$escapes{$ch}){$s .= $escapes{$ch}}elsif($ch eq 'u'){my$u='';for(1..4){$ch=next_chr();last OUTER if($ch !~ /[0-9a-fA-F]/);$u .= $ch}if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/){$utf16=$u}elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/){unless (defined$utf16){decode_error("missing high surrogate character in surrogate pair")}$is_utf8=1;$s .= JSON_PP_decode_surrogates($utf16,$u)|| next;$utf16=undef}else {if (defined$utf16){decode_error("surrogate pair expected")}my$hex=hex($u);if (chr$u =~ /[[:^ascii:]]/){$is_utf8=1;$s .= JSON_PP_decode_unicode($u)|| next}else {$s .= chr$hex}}}else{unless ($loose){$at -= 2;decode_error('illegal backslash escape sequence in string')}$s .= $ch}}else{if ($ch =~ /[[:^ascii:]]/){unless($ch=is_valid_utf8($ch)){$at -= 1;decode_error("malformed UTF-8 character in JSON string")}else {$at += $utf8_len - 1}$is_utf8=1}if (!$loose){if ($ch =~ $invalid_char_re){if (!$relaxed or $ch ne "\t"){$at--;decode_error(sprintf "invalid character 0x%X" ." encountered while parsing JSON string",ord$ch)}}}$s .= $ch}}}decode_error("unexpected end of string while parsing JSON string")}sub white {while(defined$ch){if($ch eq '' or $ch =~ /\A[ \t\r\n]\z/){next_chr()}elsif($relaxed and $ch eq '/'){next_chr();if(defined$ch and $ch eq '/'){1 while(defined(next_chr())and $ch ne "\n" and $ch ne "\r")}elsif(defined$ch and $ch eq '*'){next_chr();while(1){if(defined$ch){if($ch eq '*'){if(defined(next_chr())and $ch eq '/'){next_chr();last}}else{next_chr()}}else{decode_error("Unterminated comment")}}next}else{$at--;decode_error("malformed JSON string, neither array, object, number, string or atom")}}else{if ($relaxed and $ch eq '#'){pos($text)=$at;$text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;$at=pos($text);next_chr;next}last}}}sub array {my$a=$_[0]|| [];decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')if (++$depth > $max_depth);next_chr();white();if(defined$ch and $ch eq ']'){--$depth;next_chr();return$a}else {while(defined($ch)){push @$a,value();white();if (!defined$ch){last}if($ch eq ']'){--$depth;next_chr();return$a}if($ch ne ','){last}next_chr();white();if ($relaxed and $ch eq ']'){--$depth;next_chr();return$a}}}$at-- if defined$ch and $ch ne '';decode_error(", or ] expected while parsing array")}sub tag {decode_error('malformed JSON string, neither array, object, number, string or atom')unless$allow_tags;next_chr();white();my$tag=value();return unless defined$tag;decode_error('malformed JSON string, (tag) must be a string')if ref$tag;white();if (!defined$ch or $ch ne ')'){decode_error(') expected after tag')}next_chr();white();my$val=value();return unless defined$val;decode_error('malformed JSON string, tag value must be an array')unless ref$val eq 'ARRAY';if (!eval {$tag->can('THAW')}){decode_error('cannot decode perl-object (package does not exist)')if $@;decode_error('cannot decode perl-object (package does not have a THAW method)')}$tag->THAW('JSON',@$val)}sub object {my$o=$_[0]|| {};my$k;decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')if (++$depth > $max_depth);next_chr();white();if(defined$ch and $ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}else {while (defined$ch){$k=($allow_barekey and $ch ne '"' and $ch ne "'")? bareKey(): string();white();if(!defined$ch or $ch ne ':'){$at--;decode_error("':' expected")}next_chr();$o->{$k}=value();white();last if (!defined$ch);if($ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}if($ch ne ','){last}next_chr();white();if ($relaxed and $ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}}}$at-- if defined$ch and $ch ne '';decode_error(", or } expected while parsing object/hash")}sub bareKey {my$key;while($ch =~ /[\$\w[:^ascii:]]/){$key .= $ch;next_chr()}return$key}sub word {my$word=substr($text,$at-1,4);if($word eq 'true'){$at += 3;next_chr;return defined$alt_true ? $alt_true : $JSON::PP::true}elsif($word eq 'null'){$at += 3;next_chr;return undef}elsif($word eq 'fals'){$at += 3;if(substr($text,$at,1)eq 'e'){$at++;next_chr;return defined$alt_false ? $alt_false : $JSON::PP::false}}$at--;decode_error("'null' expected")if ($word =~ /^n/);decode_error("'true' expected")if ($word =~ /^t/);decode_error("'false' expected")if ($word =~ /^f/);decode_error("malformed JSON string, neither array, object, number, string or atom")}sub number {my$n='';my$v;my$is_dec;my$is_exp;if($ch eq '-'){$n='-';next_chr;if (!defined$ch or $ch !~ /\d/){decode_error("malformed number (no digits after initial minus)")}}if($ch eq '0'){my$peek=substr($text,$at,1);if($peek =~ /^[0-9a-dfA-DF]/){decode_error("malformed number (leading zero must not be followed by another digit)")}$n .= $ch;next_chr}while(defined$ch and $ch =~ /\d/){$n .= $ch;next_chr}if(defined$ch and $ch eq '.'){$n .= '.';$is_dec=1;next_chr;if (!defined$ch or $ch !~ /\d/){decode_error("malformed number (no digits after decimal point)")}else {$n .= $ch}while(defined(next_chr)and $ch =~ /\d/){$n .= $ch}}if(defined$ch and ($ch eq 'e' or $ch eq 'E')){$n .= $ch;$is_exp=1;next_chr;if(defined($ch)and ($ch eq '+' or $ch eq '-')){$n .= $ch;next_chr;if (!defined$ch or $ch =~ /\D/){decode_error("malformed number (no digits after exp sign)")}$n .= $ch}elsif(defined($ch)and $ch =~ /\d/){$n .= $ch}else {decode_error("malformed number (no digits after exp sign)")}while(defined(next_chr)and $ch =~ /\d/){$n .= $ch}}$v .= $n;if ($is_dec or $is_exp){if ($allow_bignum){require Math::BigFloat;return Math::BigFloat->new($v)}}else {if (length$v > $max_intsize){if ($allow_bignum){require Math::BigInt;return Math::BigInt->new($v)}else {return "$v"}}}return$is_dec ? $v/1.0 : 0+$v}my$max_unicode_length=do {BEGIN {$] >= 5.006 and require warnings and warnings->unimport('utf8')}chr 0x10FFFF};utf8::encode($max_unicode_length);$max_unicode_length=length$max_unicode_length;sub is_valid_utf8 {my$start_point=substr($text,$at - 1);my$limit=$max_unicode_length;$limit=length($start_point)if$limit > length($start_point);while ($limit > 0){my$copy=substr($start_point,0,$limit);if (utf8::decode($copy)){$copy=substr($copy,0,1);utf8::encode($copy);$utf8_len=length$copy;return substr($start_point,0,$utf8_len)}$limit--}$utf8_len=0;return}sub decode_error {my$error=shift;my$no_rep=shift;my$str=defined$text ? substr($text,$at): '';my$mess='';my$type='U*';if (OLD_PERL){my$type=$] < 5.006 ? 'C*' : utf8::is_utf8($str)? 'U*' : 'C*' }for my$c (unpack($type,$str)){my$chr_c=$c;$mess .= $chr_c eq '\\' ? '\\\\' : $chr_c =~ /[[:print:]]/ ? $chr_c : $chr_c eq '\a' ? '\a' : $chr_c eq '\t' ? '\t' : $chr_c eq '\n' ? '\n' : $chr_c eq '\r' ? '\r' : $chr_c eq '\f' ? '\f' : sprintf('\x{%x}',$c);if (length$mess >= 20){$mess .= '...';last}}unless (length$mess){$mess='(end of string)'}Carp::croak ($no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")")}sub _json_object_hook {my$o=$_[0];my@ks=keys %{$o};if ($cb_sk_object and @ks==1 and exists$cb_sk_object->{$ks[0]}and ref$cb_sk_object->{$ks[0]}){my@val=$cb_sk_object->{$ks[0]}->($o->{$ks[0]});if (@val==0){return$o}elsif (@val==1){return$val[0]}else {Carp::croak("filter_json_single_key_object callbacks must not return more than one scalar")}}my@val=$cb_object->($o)if ($cb_object);if (@val==0){return$o}elsif (@val==1){return$val[0]}else {Carp::croak("filter_json_object callbacks must not return more than one scalar")}}sub PP_decode_box {{text=>$text,at=>$at,ch=>$ch,len=>$len,depth=>$depth,encoding=>$encoding,is_valid_utf8=>$is_valid_utf8,}}}sub _decode_surrogates {my$uni=0x10000 + (hex($_[0])- 0xD800)* 0x400 + (hex($_[1])- 0xDC00);my$un=pack('U*',$uni);utf8::encode($un);return$un}sub _decode_unicode {my$un=pack('U',hex shift);utf8::encode($un);return$un}BEGIN {unless (defined&utf8::is_utf8){require Encode;*utf8::is_utf8=*Encode::is_utf8}if (!OLD_PERL){*JSON::PP::JSON_PP_encode_ascii=\&_encode_ascii;*JSON::PP::JSON_PP_encode_latin1=\&_encode_latin1;*JSON::PP::JSON_PP_decode_surrogates=\&_decode_surrogates;*JSON::PP::JSON_PP_decode_unicode=\&_decode_unicode;if ($] < 5.008003){package JSON::PP;require subs;subs->import('join');eval q|
                  sub join {
                      return '' if (@_ < 2);
                      my $j   = shift;
                      my $str = shift;
                      for (@_) { $str .= $j . $_; }
                      return $str;
                  }
              |}}sub JSON::PP::incr_parse {local$Carp::CarpLevel=1;($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_parse(@_)}sub JSON::PP::incr_skip {($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_skip}sub JSON::PP::incr_reset {($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_reset}eval q{
          sub JSON::PP::incr_text : lvalue {
              $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
              if ( $_[0]->{_incr_parser}->{incr_pos} ) {
                  Carp::croak("incr_text cannot be called when the incremental parser already started parsing");
              }
              $_[0]->{_incr_parser}->{incr_text};
          }
      } if ($] >= 5.006)}BEGIN {eval 'require Scalar::Util';unless($@){*JSON::PP::blessed=\&Scalar::Util::blessed;*JSON::PP::reftype=\&Scalar::Util::reftype;*JSON::PP::refaddr=\&Scalar::Util::refaddr}else{eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';*JSON::PP::blessed=sub {local($@,$SIG{__DIE__},$SIG{__WARN__});ref($_[0])? eval {$_[0]->a_sub_not_likely_to_be_here}: undef};require B;my%tmap=qw(B::NULL SCALAR B::HV HASH B::AV ARRAY B::CV CODE B::IO IO B::GV GLOB B::REGEXP REGEXP);*JSON::PP::reftype=sub {my$r=shift;return undef unless length(ref($r));my$t=ref(B::svref_2object($r));return exists$tmap{$t}? $tmap{$t}: length(ref($$r))? 'REF' : 'SCALAR'};*JSON::PP::refaddr=sub {return undef unless length(ref($_[0]));my$addr;if(defined(my$pkg=blessed($_[0]))){$addr .= bless $_[0],'Scalar::Util::Fake';bless $_[0],$pkg}else {$addr .= $_[0]}$addr =~ /0x(\w+)/;local $^W;hex($1)}}}$JSON::PP::true=do {bless \(my$dummy=1),"JSON::PP::Boolean"};$JSON::PP::false=do {bless \(my$dummy=0),"JSON::PP::Boolean"};sub is_bool {blessed $_[0]and ($_[0]->isa("JSON::PP::Boolean")or $_[0]->isa("Types::Serialiser::BooleanBase")or $_[0]->isa("JSON::XS::Boolean"))}sub true {$JSON::PP::true}sub false {$JSON::PP::false}sub null {undef}package JSON::PP::IncrParser;use strict;use constant INCR_M_WS=>0;use constant INCR_M_STR=>1;use constant INCR_M_BS=>2;use constant INCR_M_JSON=>3;use constant INCR_M_C0=>4;use constant INCR_M_C1=>5;use constant INCR_M_TFN=>6;use constant INCR_M_NUM=>7;$JSON::backportPP::IncrParser::VERSION='1.01';sub new {my ($class)=@_;bless {incr_nest=>0,incr_text=>undef,incr_pos=>0,incr_mode=>0,},$class}sub incr_parse {my ($self,$coder,$text)=@_;$self->{incr_text}='' unless (defined$self->{incr_text});if (defined$text){$self->{incr_text}.= $text}if (defined wantarray){my$max_size=$coder->get_max_size;my$p=$self->{incr_pos};my@ret;{do {unless ($self->{incr_nest}<= 0 and $self->{incr_mode}==INCR_M_JSON){$self->_incr_parse($coder);if ($max_size and $self->{incr_pos}> $max_size){Carp::croak("attempted decode of JSON text of $self->{incr_pos} bytes size, but max_size is set to $max_size")}unless ($self->{incr_nest}<= 0 and $self->{incr_mode}==INCR_M_JSON){if ($self->{incr_mode}==INCR_M_WS and $self->{incr_pos}){$self->{incr_pos}=0;$self->{incr_text}=''}last}}unless ($coder->get_utf8){utf8::decode($self->{incr_text})}my ($obj,$offset)=$coder->PP_decode_json($self->{incr_text},0x00000001);push@ret,$obj;use bytes;$self->{incr_text}=substr($self->{incr_text},$offset || 0);$self->{incr_pos}=0;$self->{incr_nest}=0;$self->{incr_mode}=0;last unless wantarray}while (wantarray)}if (wantarray){return@ret}else {return defined$ret[0]? $ret[0]: undef}}}sub _incr_parse {my ($self,$coder)=@_;my$text=$self->{incr_text};my$len=length$text;my$p=$self->{incr_pos};INCR_PARSE: while ($len > $p){my$s=substr($text,$p,1);last INCR_PARSE unless defined$s;my$mode=$self->{incr_mode};if ($mode==INCR_M_WS){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if (ord($s)> ord " "){if ($s eq '#'){$self->{incr_mode}=INCR_M_C0;redo INCR_PARSE}else {$self->{incr_mode}=INCR_M_JSON;redo INCR_PARSE}}$p++}}elsif ($mode==INCR_M_BS){$p++;$self->{incr_mode}=INCR_M_STR;redo INCR_PARSE}elsif ($mode==INCR_M_C0 or $mode==INCR_M_C1){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if ($s eq "\n"){$self->{incr_mode}=$self->{incr_mode}==INCR_M_C0 ? INCR_M_WS : INCR_M_JSON;last}$p++}next}elsif ($mode==INCR_M_TFN){last INCR_PARSE if$p >= $len && $self->{incr_nest};while ($len > $p){$s=substr($text,$p++,1);next if defined$s and $s =~ /[rueals]/;last}$p--;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($mode==INCR_M_NUM){last INCR_PARSE if$p >= $len && $self->{incr_nest};while ($len > $p){$s=substr($text,$p++,1);next if defined$s and $s =~ /[0-9eE.+\-]/;last}$p--;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($mode==INCR_M_STR){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if ($s eq '"'){$p++;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($s eq '\\'){$p++;if (!defined substr($text,$p,1)){$self->{incr_mode}=INCR_M_BS;last INCR_PARSE}}$p++}}elsif ($mode==INCR_M_JSON){while ($len > $p){$s=substr($text,$p++,1);if ($s eq "\x00"){$p--;last INCR_PARSE}elsif ($s =~ /^[\t\n\r ]$/){if (!$self->{incr_nest}){$p--;last INCR_PARSE}next}elsif ($s eq 't' or $s eq 'f' or $s eq 'n'){$self->{incr_mode}=INCR_M_TFN;redo INCR_PARSE}elsif ($s =~ /^[0-9\-]$/){$self->{incr_mode}=INCR_M_NUM;redo INCR_PARSE}elsif ($s eq '"'){$self->{incr_mode}=INCR_M_STR;redo INCR_PARSE}elsif ($s eq '[' or $s eq '{'){if (++$self->{incr_nest}> $coder->get_max_depth){Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')}next}elsif ($s eq ']' or $s eq '}'){if (--$self->{incr_nest}<= 0){last INCR_PARSE}}elsif ($s eq '#'){$self->{incr_mode}=INCR_M_C1;redo INCR_PARSE}}}}$self->{incr_pos}=$p;$self->{incr_parsing}=$p ? 1 : 0}sub incr_text {if ($_[0]->{incr_pos}){Carp::croak("incr_text cannot be called when the incremental parser already started parsing")}$_[0]->{incr_text}}sub incr_skip {my$self=shift;$self->{incr_text}=substr($self->{incr_text},$self->{incr_pos});$self->{incr_pos}=0;$self->{incr_mode}=0;$self->{incr_nest}=0}sub incr_reset {my$self=shift;$self->{incr_text}=undef;$self->{incr_pos}=0;$self->{incr_mode}=0;$self->{incr_nest}=0}1;
JSON_BACKPORTPP

$fatpacked{"JSON/backportPP/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_BOOLEAN';
  package JSON::PP::Boolean;use strict;require overload;local $^W;overload::import('overload',"0+"=>sub {${$_[0]}},"++"=>sub {$_[0]=${$_[0]}+ 1},"--"=>sub {$_[0]=${$_[0]}- 1},fallback=>1,);$JSON::backportPP::Boolean::VERSION='4.09';1;
JSON_BACKPORTPP_BOOLEAN

$fatpacked{"JSON/backportPP/Compat5005.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_COMPAT5005';
  package JSON::backportPP5005;use 5.005;use strict;my@properties;$JSON::PP5005::VERSION='1.10';BEGIN {sub utf8::is_utf8 {0}sub utf8::upgrade {}sub utf8::downgrade {1}sub utf8::encode {}sub utf8::decode {}*JSON::PP::JSON_PP_encode_ascii=\&_encode_ascii;*JSON::PP::JSON_PP_encode_latin1=\&_encode_latin1;*JSON::PP::JSON_PP_decode_surrogates=\&_decode_surrogates;*JSON::PP::JSON_PP_decode_unicode=\&_decode_unicode;sub B::SVp_IOK () {0x01000000}sub B::SVp_NOK () {0x02000000}sub B::SVp_POK () {0x04000000}$INC{'bytes.pm'}=1}sub _encode_ascii {join('',map {$_ <= 127 ? chr($_): sprintf('\u%04x',$_)}unpack('C*',$_[0]))}sub _encode_latin1 {join('',map {chr($_)}unpack('C*',$_[0]))}sub _decode_surrogates {my$uni=0x10000 + (hex($_[0])- 0xD800)* 0x400 + (hex($_[1])- 0xDC00);my$bit=unpack('B32',pack('N',$uni));if ($bit =~ /^00000000000(...)(......)(......)(......)$/){my ($w,$x,$y,$z)=($1,$2,$3,$4);return pack('B*',sprintf('11110%s10%s10%s10%s',$w,$x,$y,$z))}else {Carp::croak("Invalid surrogate pair")}}sub _decode_unicode {my ($u)=@_;my ($utf8bit);if ($u =~ /^00([89a-f][0-9a-f])$/i){return pack('H2',$1)}my$bit=unpack("B*",pack("H*",$u));if ($bit =~ /^00000(.....)(......)$/){$utf8bit=sprintf('110%s10%s',$1,$2)}elsif ($bit =~ /^(....)(......)(......)$/){$utf8bit=sprintf('1110%s10%s10%s',$1,$2,$3)}else {Carp::croak("Invalid escaped unicode")}return pack('B*',$utf8bit)}sub JSON::PP::incr_text {$_[0]->{_incr_parser}||= JSON::PP::IncrParser->new;if ($_[0]->{_incr_parser}->{incr_parsing}){Carp::croak("incr_text can not be called when the incremental parser already started parsing")}$_[0]->{_incr_parser}->{incr_text}=$_[1]if (@_ > 1);$_[0]->{_incr_parser}->{incr_text}}1;
JSON_BACKPORTPP_COMPAT5005

$fatpacked{"JSON/backportPP/Compat5006.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_COMPAT5006';
  package JSON::backportPP56;use 5.006;use strict;my@properties;$JSON::PP56::VERSION='1.08';BEGIN {sub utf8::is_utf8 {my$len=length $_[0];{use bytes;return$len!=length $_[0]}}sub utf8::upgrade {}sub utf8::downgrade ($;$) {return 1 unless (utf8::is_utf8($_[0]));if (_is_valid_utf8($_[0])){my$downgrade;for my$c (unpack("U*",$_[0])){if ($c < 256){$downgrade .= pack("C",$c)}else {$downgrade .= pack("U",$c)}}$_[0]=$downgrade;return 1}else {Carp::croak("Wide character in subroutine entry")unless ($_[1]);0}}sub utf8::encode ($) {if (utf8::is_utf8($_[0])){$_[0]=pack("C*",unpack("C*",$_[0]))}else {$_[0]=pack("U*",unpack("C*",$_[0]));$_[0]=pack("C*",unpack("C*",$_[0]))}}sub utf8::decode ($) {if (_is_valid_utf8($_[0])){utf8::downgrade($_[0]);$_[0]=pack("U*",unpack("U*",$_[0]))}}*JSON::PP::JSON_PP_encode_ascii=\&_encode_ascii;*JSON::PP::JSON_PP_encode_latin1=\&_encode_latin1;*JSON::PP::JSON_PP_decode_surrogates=\&JSON::PP::_decode_surrogates;*JSON::PP::JSON_PP_decode_unicode=\&JSON::PP::_decode_unicode;unless (defined&B::SVp_NOK){eval q{ sub B::SVp_NOK () { 0x02000000; } }}}sub _encode_ascii {join('',map {$_ <= 127 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',JSON::PP::_encode_surrogates($_))}_unpack_emu($_[0]))}sub _encode_latin1 {join('',map {$_ <= 255 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',JSON::PP::_encode_surrogates($_))}_unpack_emu($_[0]))}sub _unpack_emu {return!utf8::is_utf8($_[0])? unpack('C*',$_[0]): _is_valid_utf8($_[0])? unpack('U*',$_[0]): unpack('C*',$_[0])}sub _is_valid_utf8 {my$str=$_[0];my$is_utf8;while ($str =~ /(?:
            (
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
            )
          | (.)
      )/xg){if (defined $1){$is_utf8=1 if (!defined$is_utf8)}else {$is_utf8=0 if (!defined$is_utf8);if ($is_utf8){return}}}return$is_utf8}1;
JSON_BACKPORTPP_COMPAT5006

$fatpacked{"List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIST_UTIL';
  package List::Util;use strict;use warnings;require Exporter;our@ISA=qw(Exporter);our@EXPORT_OK=qw(all any first min max minstr maxstr none notall product reduce reductions sum sum0 sample shuffle uniq uniqint uniqnum uniqstr zip zip_longest zip_shortest mesh mesh_longest mesh_shortest head tail pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst);our$VERSION="1.62";our$XS_VERSION=$VERSION;$VERSION =~ tr/_//d;require XSLoader;XSLoader::load('List::Util',$XS_VERSION);our$RAND;sub import {my$pkg=caller;no strict 'refs';${"${pkg}::a"}=${"${pkg}::a"};${"${pkg}::b"}=${"${pkg}::b"};goto&Exporter::import}sub List::Util::_Pair::key {shift->[0]}sub List::Util::_Pair::value {shift->[1]}sub List::Util::_Pair::TO_JSON {[@{+shift}]}1;
LIST_UTIL

$fatpacked{"List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIST_UTIL_XS';
  package List::Util::XS;use strict;use warnings;use List::Util;our$VERSION="1.62";$VERSION =~ tr/_//d;1;
LIST_UTIL_XS

$fatpacked{"Log/Log4perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL';
  package Log::Log4perl;END {local($?);Log::Log4perl::Logger::cleanup()}use 5.006;use strict;use warnings;use Carp;use Log::Log4perl::Util;use Log::Log4perl::Logger;use Log::Log4perl::Level;use Log::Log4perl::Config;use Log::Log4perl::Appender;our$VERSION='1.55';our$caller_depth=0;our%ALLOWED_CODE_OPS=('safe'=>[':browse' ],'restrictive'=>[':default' ],);our%WRAPPERS_REGISTERED=map {$_=>1}qw(Log::Log4perl);our@ALLOWED_CODE_OPS_IN_CONFIG_FILE;our%VARS_SHARED_WITH_SAFE_COMPARTMENT=(main=>['%ENV' ],);our$ALLOW_CODE_IN_CONFIG_FILE=1;our$JOIN_MSG_ARRAY_CHAR='';our$DOM_VERSION_REQUIRED='1.29';our$CHATTY_DESTROY_METHODS=0;our$LOGDIE_MESSAGE_ON_STDERR=1;our$LOGEXIT_CODE=1;our%IMPORT_CALLED;our$EASY_CLOSURES={};our$STRINGIFY_DIE_MESSAGE=1;use constant _INTERNAL_DEBUG=>0;sub import {my($class)=shift;my$caller_pkg=caller();return 1 if$IMPORT_CALLED{$caller_pkg}++;my(%tags)=map {$_=>1}@_;if(exists$tags{':easy'}){$tags{':levels'}=1;$tags{':nowarn'}=1;$tags{'get_logger'}=1}if(exists$tags{':no_extra_logdie_message'}){$Log::Log4perl::LOGDIE_MESSAGE_ON_STDERR=0;delete$tags{':no_extra_logdie_message'}}if(exists$tags{get_logger}){no strict qw(refs);*{"$caller_pkg\::get_logger"}=*get_logger;delete$tags{get_logger}}if(exists$tags{':levels'}){for my$key (keys%Log::Log4perl::Level::PRIORITY){my$name="$caller_pkg\::$key";my$value=$Log::Log4perl::Level::PRIORITY{$key};no strict qw(refs);*{"$name"}=\$value}delete$tags{':levels'}}if(exists$tags{':easy'}){delete$tags{':easy'};my$logger=get_logger("$caller_pkg");for(qw(TRACE DEBUG INFO WARN ERROR FATAL ALWAYS)){my$level=$_;$level="OFF" if$level eq "ALWAYS";my$lclevel=lc($_);easy_closure_create($caller_pkg,$_,sub {Log::Log4perl::Logger::init_warn()unless $Log::Log4perl::Logger::INITIALIZED or $Log::Log4perl::Logger::NON_INIT_WARNED;$logger->{$level}->($logger,@_,$level)},$logger)}for(qw(LOGCROAK LOGCLUCK LOGCARP LOGCONFESS)){my$method="Log::Log4perl::Logger::" .lc($_);easy_closure_create($caller_pkg,$_,sub {unshift @_,$logger;goto &$method},$logger)}easy_closure_create($caller_pkg,"LOGDIE",sub {Log::Log4perl::Logger::init_warn()unless $Log::Log4perl::Logger::INITIALIZED or $Log::Log4perl::Logger::NON_INIT_WARNED;$logger->{FATAL}->($logger,@_,"FATAL");$Log::Log4perl::LOGDIE_MESSAGE_ON_STDERR ? CORE::die(Log::Log4perl::Logger::callerline(join '',@_)): exit$Log::Log4perl::LOGEXIT_CODE},$logger);easy_closure_create($caller_pkg,"LOGEXIT",sub {Log::Log4perl::Logger::init_warn()unless $Log::Log4perl::Logger::INITIALIZED or $Log::Log4perl::Logger::NON_INIT_WARNED;$logger->{FATAL}->($logger,@_,"FATAL");exit$Log::Log4perl::LOGEXIT_CODE},$logger);easy_closure_create($caller_pkg,"LOGWARN",sub {Log::Log4perl::Logger::init_warn()unless $Log::Log4perl::Logger::INITIALIZED or $Log::Log4perl::Logger::NON_INIT_WARNED;$logger->{WARN}->($logger,@_,"WARN");CORE::warn(Log::Log4perl::Logger::callerline(join '',@_))if$Log::Log4perl::LOGDIE_MESSAGE_ON_STDERR},$logger)}if(exists$tags{':nowarn'}){$Log::Log4perl::Logger::NON_INIT_WARNED=1;delete$tags{':nowarn'}}if(exists$tags{':nostrict'}){$Log::Log4perl::Logger::NO_STRICT=1;delete$tags{':nostrict'}}if(exists$tags{':resurrect'}){my$FILTER_MODULE="Filter::Util::Call";if(!Log::Log4perl::Util::module_available($FILTER_MODULE)){die "$FILTER_MODULE required with :resurrect" ."(install from CPAN)"}eval "require $FILTER_MODULE" or die "Cannot pull in $FILTER_MODULE";Filter::Util::Call::filter_add(sub {my($status);s/^\s*###l4p// if ($status=Filter::Util::Call::filter_read())> 0;$status});delete$tags{':resurrect'}}if(keys%tags){die "Unknown Option(s): @{[keys %tags]}"}}sub initialized {return$Log::Log4perl::Logger::INITIALIZED}sub new {die "THIS CLASS ISN'T FOR DIRECT USE. " ."PLEASE CHECK 'perldoc " .__PACKAGE__ ."'."}sub reset {return Log::Log4perl::Logger->reset()}sub init_once {init(@_)unless$Log::Log4perl::Logger::INITIALIZED}sub init {my($class,@args)=@_;if ($class ne __PACKAGE__){unshift(@args,$class)}return Log::Log4perl::Config->init(@args)}sub init_and_watch {my($class,@args)=@_;if ($class ne __PACKAGE__){unshift(@args,$class)}return Log::Log4perl::Config->init_and_watch(@args)}sub easy_init {my($class,@args)=@_;if(ref($class)or $class =~ /^\d+$/){unshift@args,$class}Log::Log4perl->reset();my@loggers=();my%default=(level=>$DEBUG,file=>"STDERR",utf8=>undef,category=>"",layout=>"%d %m%n",);if(!@args){push@loggers,\%default}else {for my$arg (@args){if($arg =~ /^\d+$/){my%logger=(%default,level=>$arg);push@loggers,\%logger}elsif(ref($arg)eq "HASH"){my%logger=(%default,%$arg);push@loggers,\%logger}else {carp "All arguments to easy_init should be either " ."an integer log level or a hash reference."}}}for my$logger (@loggers){my$app;if($logger->{file}=~ /^stderr$/i){$app=Log::Log4perl::Appender->new("Log::Log4perl::Appender::Screen",utf8=>$logger->{utf8})}elsif($logger->{file}=~ /^stdout$/i){$app=Log::Log4perl::Appender->new("Log::Log4perl::Appender::Screen",stderr=>0,utf8=>$logger->{utf8})}else {my$binmode;if($logger->{file}=~ s/^(:.*?)>/>/){$binmode=$1}$logger->{file}=~ /^(>)?(>)?/;my$mode=($2 ? "append" : "write");$logger->{file}=~ s/.*>+\s*//g;$app=Log::Log4perl::Appender->new("Log::Log4perl::Appender::File",filename=>$logger->{file},mode=>$mode,utf8=>$logger->{utf8},binmode=>$binmode,)}my$layout=Log::Log4perl::Layout::PatternLayout->new($logger->{layout});$app->layout($layout);my$log=Log::Log4perl->get_logger($logger->{category});$log->level($logger->{level});$log->add_appender($app)}$Log::Log4perl::Logger::INITIALIZED=1}sub wrapper_register {my$wrapper=$_[-1];$WRAPPERS_REGISTERED{$wrapper }=1}sub get_logger {my$category;if(@_==0){my$level=0;do {$category=scalar caller($level++)}while exists$WRAPPERS_REGISTERED{$category }}elsif(@_==1){$category=$_[0];my$level=0;while(exists$WRAPPERS_REGISTERED{$category }){$category=scalar caller($level++)}}else {$category=$_[1]}return Log::Log4perl::Logger->get_logger($category)}sub caller_depth_offset {my($level)=@_;my$category;{my$category=scalar caller($level + 1);if(defined$category and exists$WRAPPERS_REGISTERED{$category }){$level++;redo}}return$level}sub appenders {return \%Log::Log4perl::Logger::APPENDER_BY_NAME}sub add_appender {my($class,$appender)=@_;my$name=$appender->name();die "Mandatory parameter 'name' missing in appender" unless defined$name;Log::Log4perl->appenders()->{$name }=$appender}sub appender_thresholds_adjust {shift if $_[0]eq __PACKAGE__;my($delta,$appenders)=@_;my$retval=0;if($delta==0){return}if(defined$appenders){$appenders=[map {die "Unkown appender: '$_'" unless exists $Log::Log4perl::Logger::APPENDER_BY_NAME{$_};$Log::Log4perl::Logger::APPENDER_BY_NAME{$_}}@$appenders]}else {$appenders=[values %{Log::Log4perl::appenders()}]unless defined$appenders}for my$app (@$appenders){my$old_thres=$app->threshold();my$new_thres;if($delta > 0){$new_thres=Log::Log4perl::Level::get_higher_level($old_thres,$delta)}else {$new_thres=Log::Log4perl::Level::get_lower_level($old_thres,-$delta)}++$retval if ($app->threshold($new_thres)==$new_thres)}return$retval}sub appender_by_name {shift if $_[0]eq __PACKAGE__;my($name)=@_;if(defined$name and exists$Log::Log4perl::Logger::APPENDER_BY_NAME{$name}){return$Log::Log4perl::Logger::APPENDER_BY_NAME{$name}->{appender}}else {return undef}}sub eradicate_appender {shift if $_[0]eq __PACKAGE__;Log::Log4perl::Logger->eradicate_appender(@_)}sub infiltrate_lwp {no warnings qw(redefine);my$l4p_wrapper=sub {my($prio,@message)=@_;local$Log::Log4perl::caller_depth=$Log::Log4perl::caller_depth + 2;get_logger(scalar caller(1))->log($prio,@message)};*LWP::Debug::trace=sub {$l4p_wrapper->($INFO,@_)};*LWP::Debug::conns=*LWP::Debug::debug=sub {$l4p_wrapper->($DEBUG,@_)}}sub easy_closure_create {my($caller_pkg,$entry,$code,$logger)=@_;no strict 'refs';print("easy_closure: Setting shortcut $caller_pkg\::$entry ","(logger=$logger\n")if _INTERNAL_DEBUG;$EASY_CLOSURES->{$caller_pkg }->{$entry }=$logger;*{"$caller_pkg\::$entry"}=$code}sub easy_closure_cleanup {my($caller_pkg,$entry)=@_;no warnings 'redefine';no strict 'refs';my$logger=$EASY_CLOSURES->{$caller_pkg }->{$entry };print("easy_closure: Nuking easy shortcut $caller_pkg\::$entry ","(logger=$logger\n")if _INTERNAL_DEBUG;*{"$caller_pkg\::$entry"}=sub {};delete$EASY_CLOSURES->{$caller_pkg }->{$entry }}sub easy_closure_category_cleanup {my($caller_pkg)=@_;if(!exists$EASY_CLOSURES->{$caller_pkg }){return 1}for my$entry (keys %{$EASY_CLOSURES->{$caller_pkg }}){easy_closure_cleanup($caller_pkg,$entry)}delete$EASY_CLOSURES->{$caller_pkg }}sub easy_closure_global_cleanup {for my$caller_pkg (keys %$EASY_CLOSURES){easy_closure_category_cleanup($caller_pkg)}}sub easy_closure_logger_remove {my($class,$logger)=@_;PKG: for my$caller_pkg (keys %$EASY_CLOSURES){for my$entry (keys %{$EASY_CLOSURES->{$caller_pkg }}){if($logger==$EASY_CLOSURES->{$caller_pkg }->{$entry }){easy_closure_category_cleanup($caller_pkg);next PKG}}}}sub remove_logger {my ($class,$logger)=@_;Log::Log4perl->easy_closure_logger_remove($logger);delete$Log::Log4perl::Logger::LOGGERS_BY_NAME->{$logger->{category}}}1;
LOG_LOG4PERL

$fatpacked{"Log/Log4perl/Appender.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER';
  package Log::Log4perl::Appender;use 5.006;use strict;use warnings;use Log::Log4perl::Level;use Carp;use constant _INTERNAL_DEBUG=>0;our$unique_counter=0;sub reset {$unique_counter=0}sub unique_name {$unique_counter++;my$unique_name=sprintf("app%03d",$unique_counter);return$unique_name}sub new {my($class,$appenderclass,%params)=@_;eval {die "'$appenderclass' not a valid class name " if $appenderclass =~ /[^:\w]/;if(!$appenderclass->can('new')){eval "require $appenderclass";die $@ if $@}};$@ and die "ERROR: can't load appenderclass '$appenderclass'\n$@";print "Appender class $appenderclass loaded OK ($@)\n" if _INTERNAL_DEBUG;$params{name}=unique_name()unless exists$params{name};if ($appenderclass eq 'Log::Dispatch::File' && !exists$params{mode}){$params{mode}='append'}print "Calling $appenderclass new\n" if _INTERNAL_DEBUG;my$appender=$appenderclass->new(min_level=>'debug',map {$_=>$params{$_}}keys%params,);print "Calling $appenderclass new returned OK\n" if _INTERNAL_DEBUG;my$self={appender=>$appender,name=>$params{name},layout=>undef,level=>$ALL,composite=>0,};$self->{warp_message}=$params{warp_message};if (!$INC{'Log/Log4perl/Config.pm'}){require Log::Log4perl::Config}if($self->{warp_message}and my$cref=Log::Log4perl::Config::compile_if_perl($self->{warp_message})){$self->{warp_message}=$cref}bless$self,$class;return$self}sub composite {my ($self,$flag)=@_;$self->{composite}=$flag if defined$flag;return$self->{composite}}sub threshold {my ($self,$level)=@_;print "Setting threshold to $level\n" if _INTERNAL_DEBUG;if(defined$level){$self->{level}=($level =~ /^(\d+)$/)? $level : Log::Log4perl::Level::to_priority($level)}return$self->{level}}sub log {my ($self,$p,$category,$level,$cache)=@_;if($self->{level}> $ Log::Log4perl::Level::PRIORITY{$level}){print "$self->{level} > $level, aborting\n" if _INTERNAL_DEBUG;return undef}if($self->{filter}){if($self->{filter}->ok(%$p,log4p_category=>$category,log4p_level=>$level)){print "Filter $self->{filter}->{name} passes\n" if _INTERNAL_DEBUG}else {print "Filter $self->{filter}->{name} blocks\n" if _INTERNAL_DEBUG;return undef}}unless($self->composite()){if (!defined$self->{warp_message}){if (ref$p->{message}eq "ARRAY"){for my$i (0..$#{$p->{message}}){if(!defined$p->{message}->[$i ]){local$Carp::CarpLevel=$Carp::CarpLevel + $Log::Log4perl::caller_depth + 1;carp "Warning: Log message argument #" .($i+1)." undefined"}}$p->{message}=join($Log::Log4perl::JOIN_MSG_ARRAY_CHAR,@{$p->{message}})}}elsif (!$self->{warp_message}){}elsif (ref($self->{warp_message})eq "CODE"){$p->{message}=[$self->{warp_message}->(@{$p->{message}})]}else {no strict qw(refs);$p->{message}=[$self->{warp_message}->(@{$p->{message}})]}$p->{message}=$self->{layout}->render($p->{message},$category,$level,3 + $Log::Log4perl::caller_depth,)if$self->layout()}my$args=[%$p,log4p_category=>$category,log4p_level=>$level];if(defined$cache){$$cache=$args}else {$self->{appender}->log(@$args)}return 1}sub log_cached {my ($self,$cache)=@_;$self->{appender}->log(@$cache)}sub name {my($self,$name)=@_;if($name){$self->{name}=$name}return$self->{name}}sub layout {my($self,$layout)=@_;if($layout){$self->{layout}=$layout}elsif (!$self->{layout}){$self->{layout}=Log::Log4perl::Layout::SimpleLayout ->new($self->{name})}return$self->{layout}}sub filter {my ($self,$filter)=@_;if($filter){print "Setting filter to $filter->{name}\n" if _INTERNAL_DEBUG;$self->{filter}=$filter}return$self->{filter}}sub AUTOLOAD {my$self=shift;no strict qw(vars);$AUTOLOAD =~ s/.*:://;if(!defined$self->{appender}){die "Can't locate object method $AUTOLOAD() in ",__PACKAGE__}return$self->{appender}->$AUTOLOAD(@_)}sub DESTROY {for my$key (keys %{$_[0]}){delete $_[0]->{$key}}}1;
LOG_LOG4PERL_APPENDER

$fatpacked{"Log/Log4perl/Appender/Buffer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_BUFFER';
  package Log::Log4perl::Appender::Buffer;use strict;use warnings;our@ISA=qw(Log::Log4perl::Appender);our$VERSION='1.53';sub new {my($class,%options)=@_;my$self={appender=>undef,buffer=>[],options=>{max_messages=>undef,trigger=>undef,trigger_level=>undef,},level=>0,%options,};if($self->{trigger_level}){$self->{trigger}=level_trigger($self->{trigger_level})}push @{$options{l4p_depends_on}},$self->{appender};push @{$options{l4p_post_config_subs}},sub {$self->post_init()};bless$self,$class}sub log {my($self,%params)=@_;local$Log::Log4perl::caller_depth=$Log::Log4perl::caller_depth + 2;if(defined$self->{max_messages}and @{$self->{buffer}}==$self->{max_messages}){shift @{$self->{buffer}}}$self->{app}->SUPER::log(\%params,$params{log4p_category},$params{log4p_level},\my$cache);if(defined$cache){push @{$self->{buffer}},$cache}$self->flush()if$self->{trigger}->($self,\%params)}sub flush {my($self)=@_;for my$cache (@{$self->{buffer}}){$self->{app}->SUPER::log_cached($cache)}$self->{buffer}=[]}sub post_init {my($self)=@_;if(!exists$self->{appender}){die "No appender defined for " .__PACKAGE__}my$appenders=Log::Log4perl->appenders();my$appender=Log::Log4perl->appenders()->{$self->{appender}};if(!defined$appender){die "Appender $self->{appender} not defined (yet) when " .__PACKAGE__ ." needed it"}$self->{app}=$appender}sub level_trigger {my($level)=@_;return sub {my($self,$params)=@_;return Log::Log4perl::Level::to_priority($params->{log4p_level})>= Log::Log4perl::Level::to_priority($level)}}sub DESTROY {my($self)=@_}1;
LOG_LOG4PERL_APPENDER_BUFFER

$fatpacked{"Log/Log4perl/Appender/DBI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_DBI';
  package Log::Log4perl::Appender::DBI;our@ISA=qw(Log::Log4perl::Appender);use Carp;use strict;use DBI;sub new {my($proto,%p)=@_;my$class=ref$proto || $proto;my$self=bless {},$class;$self->_init(%p);my%defaults=(reconnect_attempts=>1,reconnect_sleep=>0,);for (keys%defaults){if(exists$p{$_}){$self->{$_}=$p{$_}}else {$self->{$_}=$defaults{$_}}}for my$pnum (keys %{$p{params}}){$self->{bind_value_layouts}{$pnum}=Log::Log4perl::Layout::PatternLayout->new({ConversionPattern=>{value=>$p{params}->{$pnum}},undef_column_value=>undef,})}$self->{SQL}=$p{sql};$self->{MAX_COL_SIZE}=$p{max_col_size};$self->{BUFFERSIZE}=$p{bufferSize}|| 1;if ($p{usePreparedStmt}){$self->{sth}=$self->create_statement($p{sql});$self->{usePreparedStmt}=1}else{$self->{layout}=Log::Log4perl::Layout::PatternLayout->new({ConversionPattern=>{value=>$p{sql}},undef_column_value=>undef,})}if ($self->{usePreparedStmt}&& $self->{bufferSize}){warn "Log4perl: you've defined both usePreparedStmt and bufferSize \n"."in your appender '$p{name}'--\n"."I'm going to ignore bufferSize and just use a prepared stmt\n"}return$self}sub _init {my$self=shift;my%params=@_;if ($params{dbh}){$self->{dbh}=$params{dbh}}else {$self->{connect}=sub {DBI->connect(@params{qw(datasource username password)},{PrintError=>0,$params{attrs}? %{$params{attrs}}: ()})or croak "Log4perl: $DBI::errstr"};$self->{dbh}=$self->{connect}->();$self->{_mine}=1}}sub create_statement {my ($self,$stmt)=@_;$stmt || croak "Log4perl: sql not set in Log4perl::Appender::DBI";return$self->{dbh}->prepare($stmt)|| croak "Log4perl: DBI->prepare failed $DBI::errstr\n$stmt"}sub log {my$self=shift;my%p=@_;chomp$p{message}unless ref$p{message};my$qmarks=$self->calculate_bind_values(\%p);if ($self->{usePreparedStmt}){$self->query_execute($self->{sth},@$qmarks)}else{my$stmt=$self->{layout}->render($p{message},$p{log4p_category},$p{log4p_level},5 + $Log::Log4perl::caller_depth,);push @{$self->{BUFFER}},$stmt,$qmarks;$self->check_buffer()}}sub query_execute {my($self,$sth,@qmarks)=@_;my$errstr="[no error]";for my$attempt (0..$self->{reconnect_attempts}){if(!$sth->execute(@qmarks)){$errstr=$self->{dbh}->errstr();if($self->{dbh}->ping()){croak "Log4perl: DBI appender error: '$errstr'"}if($attempt==$self->{reconnect_attempts}){croak "Log4perl: DBI appender failed to " .($self->{reconnect_attempts}==1 ? "" : "re")."connect " ."to database after " ."$self->{reconnect_attempts} attempt" .($self->{reconnect_attempts}==1 ? "" : "s")." (last error error was [$errstr]"}if(!$self->{dbh}->ping()){if($attempt){sleep($self->{reconnect_sleep})if$self->{reconnect_sleep}}eval {$self->{dbh}=$self->{connect}->()}}if ($self->{usePreparedStmt}){$sth=$self->create_statement($self->{SQL});$self->{sth}=$sth if$self->{sth}}else {$sth=$self->create_statement($self->{pending_stmt})}next}return 1}croak "Log4perl: DBI->execute failed $errstr, \n"."on $self->{SQL}\n @qmarks"}sub calculate_bind_values {my ($self,$p)=@_;my@qmarks;my$user_ph_idx=0;my$i=0;if ($self->{bind_value_layouts}){my$prev_pnum=0;my$max_pnum=0;my@pnums=sort {$a <=> $b}keys %{$self->{bind_value_layouts}};$max_pnum=$pnums[-1];for my$pnum (1..$max_pnum){my$msg;if ($self->{bind_value_layouts}{$pnum}){$msg=$self->{bind_value_layouts}{$pnum}->render($p->{message},$p->{log4p_category},$p->{log4p_level},5 + $Log::Log4perl::caller_depth,)}elsif (ref$p->{message}eq 'ARRAY' && @{$p->{message}}){$msg=$p->{message}->[$i++]}elsif (ref$p->{message}eq 'ARRAY'){$msg=undef;$p->{message}=undef}elsif (!ref$p->{message}){$msg=$p->{message};$p->{message}=undef}if ($self->{MAX_COL_SIZE}&& length($msg)> $self->{MAX_COL_SIZE}){substr($msg,$self->{MAX_COL_SIZE})=''}push@qmarks,$msg}}if (ref$p->{message}eq 'ARRAY' && @{$p->{message}}){push@qmarks,@{$p->{message}}[$i..@{$p->{message}}-1]}return \@qmarks}sub check_buffer {my$self=shift;return unless ($self->{BUFFER}&& ref$self->{BUFFER}eq 'ARRAY');if (scalar @{$self->{BUFFER}}>= $self->{BUFFERSIZE}* 2){my ($sth,$stmt,$prev_stmt);$prev_stmt="";while (@{$self->{BUFFER}}){my ($stmt,$qmarks)=splice (@{$self->{BUFFER}},0,2);$self->{pending_stmt}=$stmt;if ($stmt ne $prev_stmt){$sth->finish if$sth;$sth=$self->create_statement($stmt)}$self->query_execute($sth,@$qmarks);$prev_stmt=$stmt}$sth->finish;my$dbh=$self->{dbh};if ($dbh &&!$dbh->{AutoCommit}){$dbh->commit}}}sub DESTROY {my$self=shift;$self->{BUFFERSIZE}=1;$self->check_buffer();if ($self->{_mine}&& $self->{dbh}){$self->{dbh}->disconnect}}1;
LOG_LOG4PERL_APPENDER_DBI

$fatpacked{"Log/Log4perl/Appender/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_FILE';
  package Log::Log4perl::Appender::File;our@ISA=qw(Log::Log4perl::Appender);use warnings;use strict;use Log::Log4perl::Config::Watch;use Fcntl;use File::Path;use File::Spec::Functions qw(splitpath catpath);use constant _INTERNAL_DEBUG=>0;use constant SYSWRITE_UTF8_OK=>($] < 5.024);sub new {my($class,@options)=@_;my$self={name=>"unknown name",umask=>undef,owner=>undef,group=>undef,autoflush=>1,syswrite=>0,mode=>"append",binmode=>undef,utf8=>0,recreate=>0,recreate_check_interval=>30,recreate_check_signal=>undef,recreate_pid_write=>undef,create_at_logtime=>0,header_text=>undef,mkpath=>0,mkpath_umask=>0,@options,};if($self->{create_at_logtime}){$self->{recreate}=1}for my$param ('umask','mkpath_umask'){if(defined$self->{$param}and $self->{$param}=~ /^0/){$self->{$param}=oct($self->{$param})}}die "Mandatory parameter 'filename' missing" unless exists$self->{filename};bless$self,$class;if($self->{recreate_pid_write}){print "Creating pid file"," $self->{recreate_pid_write}\n" if _INTERNAL_DEBUG;open FILE,">$self->{recreate_pid_write}" or die "Cannot open $self->{recreate_pid_write}";print FILE "$$\n";close FILE}print "Calling syswrite_encoder\n" if _INTERNAL_DEBUG;$self->{syswrite_encoder}=$self->syswrite_encoder();print "syswrite_encoder returned\n" if _INTERNAL_DEBUG;$self->file_open()unless$self->{create_at_logtime};return$self}sub syswrite_encoder {my($self)=@_;if(!SYSWRITE_UTF8_OK and $self->{syswrite}and $self->{utf8}){print "Requiring Encode\n" if _INTERNAL_DEBUG;eval {require Encode};print "Requiring Encode returned: $@\n" if _INTERNAL_DEBUG;if($@){die "syswrite and utf8 requires Encode.pm"}else {return sub {Encode::encode_utf8($_[0])}}}return undef}sub filename {my($self)=@_;return$self->{filename}}sub file_open {my($self)=@_;my$arrows=">";my$sysmode=(O_CREAT|O_WRONLY);if($self->{mode}eq "append"){$arrows=">>";$sysmode |= O_APPEND}elsif ($self->{mode}eq "pipe"){$arrows="|"}else {$sysmode |= O_TRUNC}my$fh=do {local*FH;*FH};my$didnt_exist=!-e $self->{filename};if($didnt_exist && $self->{mkpath}){my ($volume,$path,$file)=splitpath($self->{filename});if($path ne '' &&!-e $path){my$old_umask=umask($self->{mkpath_umask})if defined$self->{mkpath_umask};my$options={};for my$param (qw(owner group)){$options->{$param}=$self->{$param}if defined$self->{$param}}eval {mkpath(catpath($volume,$path,''),$options)};umask($old_umask)if defined$old_umask;die "Can't create path ${path} ($!)" if $@}}my$old_umask=umask($self->{umask})if defined$self->{umask};eval {if($self->{syswrite}){sysopen$fh,"$self->{filename}",$sysmode or die "Can't sysopen $self->{filename} ($!)"}else {open$fh,"$arrows$self->{filename}" or die "Can't open $self->{filename} ($!)"}};umask($old_umask)if defined$old_umask;die $@ if $@;if($didnt_exist and (defined$self->{owner}or defined$self->{group})){eval {$self->perms_fix()};if($@){unlink$self->{filename};die $@}}if($self->{recreate}){$self->{watcher}=Log::Log4perl::Config::Watch->new(file=>$self->{filename},(defined$self->{recreate_check_interval}? (check_interval=>$self->{recreate_check_interval}): ()),(defined$self->{recreate_check_signal}? (signal=>$self->{recreate_check_signal}): ()),)}$self->{fh}=$fh;if ($self->{autoflush}and!$self->{syswrite}){my$oldfh=select$self->{fh};$|=1;select$oldfh}if (defined$self->{binmode}){binmode$self->{fh},$self->{binmode}}if ($self->{utf8}){if(SYSWRITE_UTF8_OK or!$self->{syswrite}){binmode$self->{fh},":utf8"}}if(defined$self->{header_text}){if($self->{header_text}!~ /\n\Z/){$self->{header_text}.= "\n"}local$self->{recreate}=0;$self->log(message=>$self->{header_text})}}sub file_close {my($self)=@_;if(defined$self->{fh}){$self->close_with_care($self->{fh })}undef$self->{fh}}sub perms_fix {my($self)=@_;my ($uid_org,$gid_org)=(stat$self->{filename})[4,5];my ($uid,$gid)=($uid_org,$gid_org);if(!defined$uid){die "stat of $self->{filename} failed ($!)"}my$needs_fixing=0;if(defined$self->{owner}){$uid=$self->{owner};if($self->{owner}!~ /^\d+$/){$uid=(getpwnam($self->{owner}))[2];die "Unknown user: $self->{owner}" unless defined$uid}}if(defined$self->{group}){$gid=$self->{group};if($self->{group}!~ /^\d+$/){$gid=getgrnam($self->{group});die "Unknown group: $self->{group}" unless defined$gid}}if($uid!=$uid_org or $gid!=$gid_org){chown($uid,$gid,$self->{filename})or die "chown('$uid', '$gid') on '$self->{filename}' failed: $!"}}sub file_switch {my($self,$new_filename)=@_;print "Switching file from $self->{filename} to $new_filename\n" if _INTERNAL_DEBUG;$self->file_close();$self->{filename}=$new_filename;$self->file_open()}sub log {my($self,%params)=@_;if($self->{recreate}){if($self->{recreate_check_signal}){if(!$self->{watcher}or $self->{watcher}->{signal_caught}){$self->file_switch($self->{filename});$self->{watcher}->{signal_caught}=0}}else {if(!$self->{watcher}or $self->{watcher}->file_has_moved()){$self->file_switch($self->{filename})}}}my$fh=$self->{fh};if($self->{syswrite}){my$rc=syswrite($fh,$self->{syswrite_encoder }? $self->{syswrite_encoder }->($params{message}): $params{message});if(!defined$rc){die "Cannot syswrite to '$self->{filename}': $!"}}else {print$fh $params{message}or die "Cannot write to '$self->{filename}': $!"}}sub DESTROY {my($self)=@_;if ($self->{fh}){my$fh=$self->{fh};$self->close_with_care($fh)}}sub close_with_care {my($self,$fh)=@_;my$prev_rc=$?;my$rc=close$fh;if(!$rc){if($self->{mode }eq "pipe" and $!{ECHILD }){if($Log::Log4perl::CHATTY_DESTROY_METHODS){warn "$$: pipe closed with ECHILD error -- guess that's ok"}$?=$prev_rc}else {warn "Can't close $self->{filename} ($!)"}}return$rc}1;
LOG_LOG4PERL_APPENDER_FILE

$fatpacked{"Log/Log4perl/Appender/Limit.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_LIMIT';
  package Log::Log4perl::Appender::Limit;use strict;use warnings;use Storable;our@ISA=qw(Log::Log4perl::Appender);our$VERSION='1.53';sub new {my($class,%options)=@_;my$self={max_until_flushed=>undef,max_until_discarded=>undef,appender_method_on_flush =>undef,appender=>undef,accumulate=>1,persistent=>undef,block_period=>3600,buffer=>[],%options,};push @{$options{l4p_depends_on}},$self->{appender};push @{$options{l4p_post_config_subs}},sub {$self->post_init()};bless$self,$class;if(defined$self->{persistent}){$self->restore()}return$self}sub log {my($self,%params)=@_;local$Log::Log4perl::caller_depth=$Log::Log4perl::caller_depth + 2;my$discard=0;if(defined$self->{max_until_discarded}and scalar @{$self->{buffer}}>= $self->{max_until_discarded}- 1){$discard=1}my$flush=0;if(defined$self->{max_until_flushed}and scalar @{$self->{buffer}}>= $self->{max_until_flushed}- 1){$flush=1}if(!$flush and (exists$self->{sent_last}and $self->{sent_last}+ $self->{block_period}> time())){return if$discard;$self->{app}->SUPER::log(\%params,$params{log4p_category},$params{log4p_level},\my$cache);push @{$self->{buffer}},$cache if$self->{accumulate};$self->save()if$self->{persistent};return}$self->flush();$self->{app}->SUPER::log(\%params,$params{log4p_category},$params{log4p_level});$self->{sent_last}=time();$self->save()if$self->{persistent}}sub post_init {my($self)=@_;if(!exists$self->{appender}){die "No appender defined for " .__PACKAGE__}my$appenders=Log::Log4perl->appenders();my$appender=Log::Log4perl->appenders()->{$self->{appender}};if(!defined$appender){die "Appender $self->{appender} not defined (yet) when " .__PACKAGE__ ." needed it"}$self->{app}=$appender}sub save {my($self)=@_;my$pdata=[$self->{buffer},$self->{sent_last}];store$pdata,$self->{persistent}or die "Cannot save messages in $self->{persistent} ($!)"}sub restore {my($self)=@_;if(-f $self->{persistent}){my$pdata=retrieve$self->{persistent}or die "Cannot retrieve messages from $self->{persistent} ($!)";($self->{buffer},$self->{sent_last})=@$pdata}}sub flush {my($self)=@_;for(@{$self->{buffer}}){$self->{app}->SUPER::log_cached($_)}if($self->{appender_method_on_flush}){no strict 'refs';my$method=$self->{appender_method_on_flush};$self->{app}->$method()}$self->{buffer}=[]}sub DESTROY {my($self)=@_}1;
LOG_LOG4PERL_APPENDER_LIMIT

$fatpacked{"Log/Log4perl/Appender/RRDs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_RRDS';
  package Log::Log4perl::Appender::RRDs;our@ISA=qw(Log::Log4perl::Appender);use warnings;use strict;use RRDs;sub new {my($class,@options)=@_;my$self={name=>"unknown name",dbname=>undef,rrdupd_params=>[],@options,};die "Mandatory parameter 'dbname' missing" unless defined$self->{dbname};bless$self,$class;return$self}sub log {my($self,%params)=@_;RRDs::update($self->{dbname},@{$params{rrdupd_params}},$params{message})or die "Cannot update rrd $self->{dbname} ","with $params{message} ($!)"}1;
LOG_LOG4PERL_APPENDER_RRDS

$fatpacked{"Log/Log4perl/Appender/Screen.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_SCREEN';
  package Log::Log4perl::Appender::Screen;our@ISA=qw(Log::Log4perl::Appender);use warnings;use strict;use IO::Handle;sub new {my($class,@options)=@_;my$self={autoflush=>0,name=>"unknown name",stderr=>1,utf8=>undef,@options,};if($self->{utf8}){if($self->{stderr}){binmode STDERR,":utf8"}else {binmode STDOUT,":utf8"}}if($self->{autoflush}){if($self->{stderr}){STDERR->autoflush(1)}else {STDOUT->autoflush(1)}}bless$self,$class}sub log {my($self,%params)=@_;my$fh=\*STDOUT;if (ref$self->{stderr}){$fh=\*STDERR if$self->{stderr}{$params{'log4p_level'}}|| $self->{stderr}{lc$params{'log4p_level'}}}elsif ($self->{stderr}){$fh=\*STDERR}print$fh $params{message}}1;
LOG_LOG4PERL_APPENDER_SCREEN

$fatpacked{"Log/Log4perl/Appender/ScreenColoredLevels.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_SCREENCOLOREDLEVELS';
  package Log::Log4perl::Appender::ScreenColoredLevels;use Log::Log4perl::Appender::Screen;our@ISA=qw(Log::Log4perl::Appender::Screen);use warnings;use strict;use Term::ANSIColor qw();use Log::Log4perl::Level;BEGIN {$Term::ANSIColor::EACHLINE="\n"}sub new {my($class,%options)=@_;my%specific_options=(color=>{});for my$option (keys%specific_options){$specific_options{$option }=delete$options{$option }if exists$options{$option }}my$self=$class->SUPER::new(%options);@$self{keys%specific_options }=values%specific_options;bless$self,__PACKAGE__;for my$level (keys %{$self->{color}}){my$uclevel=uc($level);$self->{color}->{$uclevel}=$self->{color}->{$level}}my%default_colors=(TRACE=>'yellow',DEBUG=>'',INFO=>'green',WARN=>'blue',ERROR=>'magenta',FATAL=>'red',);for my$level (keys%default_colors){if (!exists$self->{'color' }->{$level }){$self->{'color' }->{$level }=$default_colors{$level }}}bless$self,$class}sub log {my($self,%params)=@_;my$msg=$params{'message' };if (my$color=$self->{'color' }->{$params{'log4p_level' }}){$msg=Term::ANSIColor::colored($msg,$color)}my$fh=\*STDOUT;if (ref$self->{stderr}){$fh=\*STDERR if$self->{stderr}{$params{'log4p_level'}}|| $self->{stderr}{lc$params{'log4p_level'}}}elsif ($self->{stderr}){$fh=\*STDERR}print$fh $msg}1;
LOG_LOG4PERL_APPENDER_SCREENCOLOREDLEVELS

$fatpacked{"Log/Log4perl/Appender/Socket.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_SOCKET';
  package Log::Log4perl::Appender::Socket;our@ISA=qw(Log::Log4perl::Appender);use warnings;use strict;use IO::Socket::INET;sub new {my($class,@options)=@_;my$self={name=>"unknown name",silent_recovery=>0,no_warning=>0,PeerAddr=>"localhost",Proto=>'tcp',Timeout=>5,@options,};bless$self,$class;unless ($self->{defer_connection}){unless($self->connect(@options)){if($self->{silent_recovery}){if(!$self->{no_warning}){warn "Connect to $self->{PeerAddr}:$self->{PeerPort} failed: $!"}return$self}die "Connect to $self->{PeerAddr}:$self->{PeerPort} failed: $!"}$self->{socket}->autoflush(1)}return$self}sub connect {my($self,@options)=@_;$self->{socket}=IO::Socket::INET->new(@options);return$self->{socket}}sub log {my($self,%params)=@_;{if(($self->{silent_recovery}or $self->{defer_connection})and !defined$self->{socket}){if(!$self->connect(%$self)){return undef}}eval {$self->{socket}->send($params{message})};if($@){warn "Send to " .ref($self)." failed ($@), retrying once...";if($self->connect(%$self)){redo}if($self->{silent_recovery}){return undef}warn "Reconnect to $self->{PeerAddr}:$self->{PeerPort} " ."failed: $!";return undef}};return 1}sub DESTROY {my($self)=@_;undef$self->{socket}}1;
LOG_LOG4PERL_APPENDER_SOCKET

$fatpacked{"Log/Log4perl/Appender/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_STRING';
  package Log::Log4perl::Appender::String;our@ISA=qw(Log::Log4perl::Appender);sub new {my$proto=shift;my$class=ref$proto || $proto;my%params=@_;my$self={name=>"unknown name",string=>"",%params,};bless$self,$class}sub log {my$self=shift;my%params=@_;$self->{string}.= $params{message}}sub string {my($self,$new)=@_;if(defined$new){$self->{string}=$new}return$self->{string}}1;
LOG_LOG4PERL_APPENDER_STRING

$fatpacked{"Log/Log4perl/Appender/Synchronized.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_SYNCHRONIZED';
  package Log::Log4perl::Appender::Synchronized;use strict;use warnings;use Log::Log4perl::Util::Semaphore;our@ISA=qw(Log::Log4perl::Appender);our$VERSION='1.53';sub new {my($class,%options)=@_;my$self={appender=>undef,key=>'_l4p',level=>0,%options,};my@values=();for my$param (qw(uid gid mode destroy key)){push@values,$param,$self->{$param}if defined$self->{$param}}$self->{sem}=Log::Log4perl::Util::Semaphore->new(@values);push @{$options{l4p_depends_on}},$self->{appender};push @{$options{l4p_post_config_subs}},sub {$self->post_init()};bless$self,$class}sub log {my($self,%params)=@_;$self->{sem}->semlock();$Log::Log4perl::caller_depth +=2;$self->{app}->SUPER::log(\%params,$params{log4p_category},$params{log4p_level});$Log::Log4perl::caller_depth -=2;$self->{sem}->semunlock()}sub post_init {my($self)=@_;if(!exists$self->{appender}){die "No appender defined for " .__PACKAGE__}my$appenders=Log::Log4perl->appenders();my$appender=Log::Log4perl->appenders()->{$self->{appender}};if(!defined$appender){die "Appender $self->{appender} not defined (yet) when " .__PACKAGE__ ." needed it"}$self->{app}=$appender}1;
LOG_LOG4PERL_APPENDER_SYNCHRONIZED

$fatpacked{"Log/Log4perl/Appender/TestArrayBuffer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_TESTARRAYBUFFER';
  package Log::Log4perl::Appender::TestArrayBuffer;use base qw(Log::Log4perl::Appender::TestBuffer);sub log {my$self=shift;my%params=@_;$self->{buffer}.= "[$params{level}]: " if$LOG_PRIORITY;if(ref($params{message})eq "ARRAY"){$self->{buffer}.= "[" .join(',',@{$params{message}})."]"}else {$self->{buffer}.= $params{message}}}1;
LOG_LOG4PERL_APPENDER_TESTARRAYBUFFER

$fatpacked{"Log/Log4perl/Appender/TestBuffer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_TESTBUFFER';
  package Log::Log4perl::Appender::TestBuffer;our@ISA=qw(Log::Log4perl::Appender);our%POPULATION=();our$LOG_PRIORITY=0;our$DESTROY_MESSAGES="";sub new {my$proto=shift;my$class=ref$proto || $proto;my%params=@_;my$self={name=>"unknown name",%params,};bless$self,$class;$self->{stderr}=exists$params{stderr}? $params{stderr}: 1;$self->{buffer}="";$POPULATION{$self->{name}}=$self;return$self}sub log {my$self=shift;my%params=@_;if(!defined$params{level}){die "No level defined in log() call of " .__PACKAGE__}$self->{buffer}.= "[$params{level}]: " if$LOG_PRIORITY;$self->{buffer}.= $params{message}}sub clear {my($self)=@_;$self->{buffer}=""}sub buffer {my($self,$new)=@_;if(defined$new){$self->{buffer}=$new}return$self->{buffer}}sub reset {my($self)=@_;%POPULATION=();$self->{buffer}=""}sub DESTROY {my($self)=@_;$DESTROY_MESSAGES .= __PACKAGE__ ." destroyed"}sub by_name {my($self,$name)=@_;die "No name given" unless defined$name;return$POPULATION{$name}}1;
LOG_LOG4PERL_APPENDER_TESTBUFFER

$fatpacked{"Log/Log4perl/Appender/TestFileCreeper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_TESTFILECREEPER';
  package Log::Log4perl::Appender::TestFileCreeper;use warnings;use strict;use Log::Log4perl::Appender::File;our@ISA=qw(Log::Log4perl::Appender::File);sub log {my($self,%params)=@_;my$fh=$self->{fh};for (split //,$params{message}){print$fh $_;my$oldfh=select$self->{fh};$|=1;select$oldfh}}1;
LOG_LOG4PERL_APPENDER_TESTFILECREEPER

$fatpacked{"Log/Log4perl/Catalyst.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_CATALYST';
  package Log::Log4perl::Catalyst;use strict;use Log::Log4perl qw(:levels);use Log::Log4perl::Logger;our$VERSION='1.53';our$CATALYST_APPENDER_SUFFIX="catalyst_buffer";our$LOG_LEVEL_ADJUSTMENT=1;init();sub init {my@levels=qw[trace debug info warn error fatal];Log::Log4perl->wrapper_register(__PACKAGE__);for my$level (@levels){no strict 'refs';*{$level}=sub {my ($self,@message)=@_;local$Log::Log4perl::caller_depth=$Log::Log4perl::caller_depth + $LOG_LEVEL_ADJUSTMENT;my$logger=Log::Log4perl->get_logger();$logger->$level(@message);return 1};*{"is_$level"}=sub {my ($self,@message)=@_;local$Log::Log4perl::caller_depth=$Log::Log4perl::caller_depth + $LOG_LEVEL_ADJUSTMENT;my$logger=Log::Log4perl->get_logger();my$func="is_" .$level;return$logger->$func}}}sub new {my($class,$config,%options)=@_;my$self={autoflush=>0,abort=>0,watch_delay=>0,%options,};if(!Log::Log4perl->initialized()){if(defined$config){if($self->{watch_delay}){Log::Log4perl::init_and_watch($config,$self->{watch_delay})}else {Log::Log4perl::init($config)}}else {Log::Log4perl->easy_init({level=>$DEBUG,layout=>"[%d] [catalyst] [%p] %m%n",})}}if(!$options{autoflush}){for my$appender (values%Log::Log4perl::Logger::APPENDER_BY_NAME){next if$appender->{name}=~ /_$CATALYST_APPENDER_SUFFIX$/;my$buf_app_name="$appender->{name}_$CATALYST_APPENDER_SUFFIX";my$buf_app=Log::Log4perl::Appender->new('Log::Log4perl::Appender::Buffer',name=>$buf_app_name,appender=>$appender->{name},trigger=>sub {0},);Log::Log4perl->add_appender($buf_app);$buf_app->post_init();$buf_app->composite(1);for my$logger (values %$Log::Log4perl::Logger::LOGGERS_BY_NAME){if(defined$logger->remove_appender($appender->{name},0,1)){$logger->add_appender($buf_app)}}}}bless$self,$class;return$self}sub _flush {my ($self)=@_;for my$appender (values%Log::Log4perl::Logger::APPENDER_BY_NAME){next if$appender->{name}!~ /_$CATALYST_APPENDER_SUFFIX$/;if ($self->abort){$appender->{appender}{buffer}=[]}else {$appender->flush()}}$self->abort(undef)}sub abort {my$self=shift;$self->{abort}=$_[0]if @_;return$self->{abort}}sub levels {return 0}sub enable {return 0}sub disable {return 0}1;
LOG_LOG4PERL_CATALYST

$fatpacked{"Log/Log4perl/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_CONFIG';
  package Log::Log4perl::Config;use 5.006;use strict;use warnings;use Log::Log4perl::Logger;use Log::Log4perl::Level;use Log::Log4perl::Config::PropertyConfigurator;use Log::Log4perl::JavaMap;use Log::Log4perl::Filter;use Log::Log4perl::Filter::Boolean;use Log::Log4perl::Config::Watch;use constant _INTERNAL_DEBUG=>0;our$CONFIG_FILE_READS=0;our$CONFIG_INTEGRITY_CHECK=1;our$CONFIG_INTEGRITY_ERROR=undef;our$WATCHER;our$DEFAULT_WATCH_DELAY=60;our$OPTS={};our$OLD_CONFIG;our$LOGGERS_DEFINED;our$UTF8=0;sub init {Log::Log4perl::Logger->reset();undef$WATCHER;return _init(@_)}sub utf8 {my($class,$flag)=@_;$UTF8=$flag if defined$flag;return$UTF8}sub watcher {return$WATCHER}sub init_and_watch {my ($class,$config,$delay,$opts)=@_;if(defined$WATCHER){$config=$WATCHER->file();if(defined$Log::Log4perl::Config::Watch::SIGNAL_CAUGHT){$delay=$WATCHER->signal()}else {$delay=$WATCHER->check_interval()}}print "init_and_watch ($config-$delay). Resetting.\n" if _INTERNAL_DEBUG;Log::Log4perl::Logger->reset();defined ($delay)or $delay=$DEFAULT_WATCH_DELAY;if (ref$config){die "Log4perl can only watch a file, not a string of " ."configuration information"}elsif ($config =~ m!^(https?|ftp|wais|gopher|file):!){die "Log4perl can only watch a file, not a url like $config"}if($delay =~ /\D/){$WATCHER=Log::Log4perl::Config::Watch->new(file=>$config,signal=>$delay,l4p_internal=>1,)}else {$WATCHER=Log::Log4perl::Config::Watch->new(file=>$config,check_interval=>$delay,l4p_internal=>1,)}if(defined$opts){die "Parameter $opts needs to be a hash ref" if ref($opts)ne "HASH";$OPTS=$opts}eval {_init($class,$config)};if($@){die "$@" unless defined$OLD_CONFIG;_init($class,undef,$OLD_CONFIG);warn "Loading new config failed, reverted to old one\n"}}sub _init {my($class,$config,$data)=@_;my%additivity=();$LOGGERS_DEFINED=0;print "Calling _init\n" if _INTERNAL_DEBUG;my%appenders_created=();my@post_config_subs=();$data=config_read($config)unless defined$data;if(_INTERNAL_DEBUG){require Data::Dumper;Data::Dumper->import();print Data::Dumper::Dumper($data)}my@loggers=();my%filter_names=();my$system_wide_threshold;if(exists$data->{rootlogger}and !exists$data->{rootLogger}){$data->{rootLogger}=$data->{rootlogger}}if(exists$data->{rootLogger}){$LOGGERS_DEFINED++;push@loggers,["",$data->{rootLogger}->{value}]}if(exists$data->{threshold}){$system_wide_threshold=$data->{threshold}->{value}}if (exists$data->{oneMessagePerAppender}){$Log::Log4perl::one_message_per_appender=$data->{oneMessagePerAppender}->{value}}if(exists$data->{utcDateTimes}){require Log::Log4perl::DateFormat;$Log::Log4perl::DateFormat::GMTIME=!!$data->{utcDateTimes}->{value}}my%boolean_filters=();for my$key (qw(logger category additivity PatternLayout filter)){if(exists$data->{$key}){for my$path (@{leaf_paths($data->{$key})}){print "Path before: @$path\n" if _INTERNAL_DEBUG;my$value=boolean_to_perlish(pop @$path);pop @$path;if($key eq "additivity"){$additivity{join('.',@$path)}=$value}elsif ($key eq "PatternLayout"){&add_global_cspec(@$path[-1],$value)}elsif ($key eq "filter"){print "Found entry @$path\n" if _INTERNAL_DEBUG;$filter_names{@$path[0]}++}else {if (ref($value)eq "ARRAY"){die "Multiple definitions of logger ".join('.',@$path)." in log4perl config"}$LOGGERS_DEFINED++;push@loggers,[join('.',@$path),$value]}}}}for my$filter_name (sort keys%filter_names){print "Checking filter $filter_name\n" if _INTERNAL_DEBUG;if($data->{filter}->{$filter_name}->{value}eq "Log::Log4perl::Filter::Boolean"){print "Boolean filter ($filter_name)\n" if _INTERNAL_DEBUG;$boolean_filters{$filter_name}++;next}my$type=$data->{filter}->{$filter_name}->{value};if(my$code=compile_if_perl($type)){$type=$code}print "Filter $filter_name is of type $type\n" if _INTERNAL_DEBUG;my$filter;if(ref($type)eq "CODE"){$filter=Log::Log4perl::Filter->new($filter_name,$type)}else {die "Filter class '$type' doesn't exist" unless Log::Log4perl::Util::module_available($type);eval "require $type" or die "Require of $type failed ($!)";$filter=$type->new(name=>$filter_name,map {$_=>$data->{filter}->{$filter_name}->{$_}->{value}}grep {$_ ne "value"}sort keys %{$data->{filter}->{$filter_name}})}$filter->register()}for my$name (sort keys%boolean_filters){my$logic=$data->{filter}->{$name}->{logic}->{value};die "No logic defined for boolean filter $name" unless defined$logic;my$filter=Log::Log4perl::Filter::Boolean->new(name=>$name,logic=>$logic);$filter->register()}for (@loggers){my($name,$value)=@$_;my$logger=Log::Log4perl::Logger->get_logger($name);my ($level,@appnames)=split /\s*,\s*/,$value;$logger->level(Log::Log4perl::Level::to_priority($level),'dont_reset_all');if(exists$additivity{$name}){$logger->additivity($additivity{$name},1)}for my$appname (@appnames){my$appender=create_appender_instance($data,$appname,\%appenders_created,\@post_config_subs,$system_wide_threshold);$logger->add_appender($appender,'dont_reset_all');set_appender_by_name($appname,$appender,\%appenders_created)}}for(@post_config_subs){$_->()}Log::Log4perl::Logger::reset_all_output_methods();if($Log::Log4perl::Config::CONFIG_INTEGRITY_CHECK and !config_is_sane()){warn "Log::Log4perl configuration looks suspicious: ","$CONFIG_INTEGRITY_ERROR"}$OLD_CONFIG=$data;$Log::Log4perl::Logger::INITIALIZED=1}sub config_is_sane {if(!$LOGGERS_DEFINED){$CONFIG_INTEGRITY_ERROR="No loggers defined";return 0}if(scalar keys%Log::Log4perl::Logger::APPENDER_BY_NAME==0){$CONFIG_INTEGRITY_ERROR="No appenders defined";return 0}return 1}sub create_appender_instance {my($data,$appname,$appenders_created,$post_config_subs,$system_wide_threshold)=@_;my$appenderclass=get_appender_by_name($data,$appname,$appenders_created);print "appenderclass=$appenderclass\n" if _INTERNAL_DEBUG;my$appender;if (ref$appenderclass){$appender=$appenderclass}else {die "ERROR: you didn't tell me how to " ."implement your appender '$appname'" unless$appenderclass;if (Log::Log4perl::JavaMap::translate($appenderclass)){print "Trying to map Java $appname\n" if _INTERNAL_DEBUG;$appender=Log::Log4perl::JavaMap::get($appname,$data->{appender}->{$appname})}else{my@params=grep {$_ ne "layout" and $_ ne "value"}sort keys %{$data->{appender}->{$appname}};my%param=();for my$pname (@params){if (exists$data->{appender}{$appname}{$pname}{value}){$param{$pname}=$data->{appender}{$appname}{$pname}{value}}else{$param{$pname}={map {$_=>$data->{appender}{$appname}{$pname}{$_}{value}}sort keys %{$data->{appender}{$appname}{$pname}}}}}my$depends_on=[];$appender=Log::Log4perl::Appender->new($appenderclass,name=>$appname,l4p_post_config_subs=>$post_config_subs,l4p_depends_on=>$depends_on,%param,);for my$dependency (@$depends_on){$appender->composite(1);next if exists$appenders_created->{$appname};my$app=create_appender_instance($data,$dependency,$appenders_created,$post_config_subs);$ Log::Log4perl::Logger::APPENDER_BY_NAME{$dependency}=$app}}}add_layout_by_name($data,$appender,$appname)unless $appender->composite();my$threshold=$data->{appender}->{$appname}->{Threshold}->{value};if(defined$system_wide_threshold and !defined$threshold){$threshold=$system_wide_threshold}if(defined$threshold){$appender->threshold($ Log::Log4perl::Level::PRIORITY{$threshold})}my$filtername=$data->{appender}->{$appname}->{Filter}->{value};if(defined$filtername){my$filter=Log::Log4perl::Filter::by_name($filtername);die "Filter $filtername doesn't exist" unless defined$filter;$appender->filter($filter)}if(defined$system_wide_threshold and defined$threshold and $ Log::Log4perl::Level::PRIORITY{$system_wide_threshold}> $ Log::Log4perl::Level::PRIORITY{$threshold}){$appender->threshold($ Log::Log4perl::Level::PRIORITY{$system_wide_threshold})}if(exists$data->{appender}->{$appname}->{threshold}){die "invalid keyword 'threshold' - perhaps you meant 'Threshold'?"}return$appender}sub add_layout_by_name {my($data,$appender,$appender_name)=@_;my$layout_class=$data->{appender}->{$appender_name}->{layout}->{value};die "Layout not specified for appender $appender_name" unless$layout_class;$layout_class =~ s/org.apache.log4j./Log::Log4perl::Layout::/;if(!Log::Log4perl::Util::module_available($layout_class)){if(Log::Log4perl::Util::module_available("Log::Log4perl::Layout::$layout_class")){$layout_class="Log::Log4perl::Layout::$layout_class"}else {die "ERROR: trying to set layout for $appender_name to " ."'$layout_class' failed ($@)"}}Log::Log4perl::Util::module_available($layout_class)or die "Require to $layout_class failed ($@)";$appender->layout($layout_class->new($data->{appender}->{$appender_name}->{layout},))}sub get_appender_by_name {my($data,$name,$appenders_created)=@_;if (exists$appenders_created->{$name}){return$appenders_created->{$name}}else {return$data->{appender}->{$name}->{value}}}sub set_appender_by_name {my($appname,$appender,$appenders_created)=@_;$appenders_created->{$appname}||= $appender}sub add_global_cspec {my ($letter,$perlcode)=@_;die "error: only single letters allowed in log4j.PatternLayout.cspec.$letter" unless ($letter =~ /^[a-zA-Z]$/);Log::Log4perl::Layout::PatternLayout::add_global_cspec($letter,$perlcode)}my$LWP_USER_AGENT;sub set_LWP_UserAgent {$LWP_USER_AGENT=shift}sub config_read {my($config)=@_;die "Configuration not defined" unless defined$config;my@text;my$parser;$CONFIG_FILE_READS++;my$base_configurator=Log::Log4perl::Config::BaseConfigurator->new(utf8=>$UTF8,);my$data={};if (ref($config)eq 'HASH'){print "Reading config from hash\n" if _INTERNAL_DEBUG;@text=();for my$key (sort keys %$config){if(ref($config->{$key})eq "CODE"){$config->{$key}=$config->{$key}->()}push@text,$key .'=' .$config->{$key}."\n"}}elsif (ref$config eq 'SCALAR'){print "Reading config from scalar\n" if _INTERNAL_DEBUG;@text=split(/\n/,$$config)}elsif (ref$config eq 'GLOB' or ref$config eq 'IO::File'){print "Reading config from file handle\n" if _INTERNAL_DEBUG;@text=@{$base_configurator->file_h_read($config)}}elsif (ref$config){print "Reading config from parser object\n" if _INTERNAL_DEBUG;$data=$config->parse();return$data}elsif ($config =~ m|^ldap://|){if(!Log::Log4perl::Util::module_available("Net::LDAP")){die "Log4perl: missing Net::LDAP needed to parse LDAP urls\n$@\n"}require Net::LDAP;require Log::Log4perl::Config::LDAPConfigurator;return Log::Log4perl::Config::LDAPConfigurator->new->parse($config)}else {if ($config =~ /^(https?|ftp|wais|gopher|file):/){my ($result,$ua);die "LWP::UserAgent not available" unless Log::Log4perl::Util::module_available("LWP::UserAgent");require LWP::UserAgent;unless (defined$LWP_USER_AGENT){$LWP_USER_AGENT=LWP::UserAgent->new;$LWP_USER_AGENT->env_proxy}$ua=$LWP_USER_AGENT;my$req=new HTTP::Request GET=>$config;my$res=$ua->request($req);if ($res->is_success){@text=split(/\n/,$res->content)}else {die "Log4perl couln't get $config, ".$res->message." "}}else {print "Reading config from file '$config'\n" if _INTERNAL_DEBUG;print "Reading ",-s $config," bytes.\n" if _INTERNAL_DEBUG;$base_configurator->file($config);@text=@{$base_configurator->text()}}}print "Reading $config: [@text]\n" if _INTERNAL_DEBUG;if(!grep /\S/,@text){return$data}if ($text[0]=~ /^<\?xml /){die "XML::DOM not available" unless Log::Log4perl::Util::module_available("XML::DOM");require XML::DOM;require Log::Log4perl::Config::DOMConfigurator;XML::DOM->VERSION($Log::Log4perl::DOM_VERSION_REQUIRED);$parser=Log::Log4perl::Config::DOMConfigurator->new();$data=$parser->parse(\@text)}else {$parser=Log::Log4perl::Config::PropertyConfigurator->new();$data=$parser->parse(\@text)}$data=$parser->parse_post_process($data,leaf_paths($data));return$data}sub unlog4j {my ($string)=@_;$string =~ s#^org\.apache\.##;$string =~ s#^log4j\.##;$string =~ s#^l4p\.##;$string =~ s#^log4perl\.##i;$string =~ s#\.#::#g;return$string}sub leaf_paths {my ($root)=@_;my@stack=();my@result=();push@stack,[$root,[]];while(@stack){my$item=pop@stack;my($node,$path)=@$item;if(ref($node)eq "HASH"){for(sort keys %$node){push@stack,[$node->{$_},[@$path,$_]]}}else {push@result,[@$path,$node]}}return \@result}sub leaf_path_to_hash {my($leaf_path,$data)=@_;my$ref=\$data;for my$part (@$leaf_path[0..$#$leaf_path-1]){$ref=\$$ref->{$part }}return$ref}sub eval_if_perl {my($value)=@_;if(my$cref=compile_if_perl($value)){return$cref->()}return$value}sub compile_if_perl {my($value)=@_;if($value =~ /^\s*sub\s*{/){my$mask;unless(Log::Log4perl::Config->allow_code()){die "\$Log::Log4perl::Config->allow_code() setting " ."prohibits Perl code in config file"}if(defined($mask=Log::Log4perl::Config->allowed_code_ops())){return compile_in_safe_cpt($value,$mask)}elsif($mask=Log::Log4perl::Config->allowed_code_ops_convenience_map(Log::Log4perl::Config->allow_code())){return compile_in_safe_cpt($value,$mask)}elsif(Log::Log4perl::Config->allow_code()==1){my$cref=eval "package main; $value" or die "Can't evaluate '$value' ($@)";return$cref}else {die "Invalid value for \$Log::Log4perl::Config->allow_code(): '".Log::Log4perl::Config->allow_code()."'"}}return undef}sub compile_in_safe_cpt {my($value,$allowed_ops)=@_;require Safe;my$safe=Safe->new();$safe->permit_only(@{$allowed_ops});for(sort keys %{Log::Log4perl::Config->vars_shared_with_safe_compartment()}){my$toshare=Log::Log4perl::Config->vars_shared_with_safe_compartment($_);$safe->share_from($_,$toshare)or die "Can't share @{ $toshare } with Safe compartment"}my$cref=$safe->reval("package main; $value")or die "Can't evaluate '$value' in Safe compartment ($@)";return$cref}sub boolean_to_perlish {my($value)=@_;$value=1 if$value =~ /^true$/i;$value=0 if$value =~ /^false$/i;return$value}sub vars_shared_with_safe_compartment {my($class,@args)=@_;if(defined$class and $class ne __PACKAGE__){unshift@args,$class}if(@args==1 && ref$args[0]eq 'HASH'){%Log::Log4perl::VARS_SHARED_WITH_SAFE_COMPARTMENT=%{$args[0]}}elsif(@args==1){return$Log::Log4perl::VARS_SHARED_WITH_SAFE_COMPARTMENT{$args[0]}}elsif(@args==2){$Log::Log4perl::VARS_SHARED_WITH_SAFE_COMPARTMENT{$args[0]}=$args[1]}return wantarray ? %Log::Log4perl::VARS_SHARED_WITH_SAFE_COMPARTMENT : \%Log::Log4perl::VARS_SHARED_WITH_SAFE_COMPARTMENT}sub allowed_code_ops {my($class,@args)=@_;if(defined$class and $class ne __PACKAGE__){unshift@args,$class}if(@args){@Log::Log4perl::ALLOWED_CODE_OPS_IN_CONFIG_FILE=@args}else {unless(@Log::Log4perl::ALLOWED_CODE_OPS_IN_CONFIG_FILE){return}}return wantarray ? @Log::Log4perl::ALLOWED_CODE_OPS_IN_CONFIG_FILE : \@Log::Log4perl::ALLOWED_CODE_OPS_IN_CONFIG_FILE}sub allowed_code_ops_convenience_map {my($class,@args)=@_;if(defined$class and $class ne __PACKAGE__){unshift@args,$class}if(@args==1 && ref$args[0]eq 'HASH'){%Log::Log4perl::ALLOWED_CODE_OPS=%{$args[0]}}elsif(@args==1){return$Log::Log4perl::ALLOWED_CODE_OPS{$args[0]}}elsif(@args==2){if(ref$args[1]ne 'ARRAY'){die "invalid mask (not an array ref) for convenience name '$args[0]'"}$Log::Log4perl::ALLOWED_CODE_OPS{$args[0]}=$args[1]}return wantarray ? %Log::Log4perl::ALLOWED_CODE_OPS : \%Log::Log4perl::ALLOWED_CODE_OPS}sub allow_code {my($class,@args)=@_;if(defined$class and $class ne __PACKAGE__){unshift@args,$class}if(@args){$Log::Log4perl::ALLOW_CODE_IN_CONFIG_FILE=$args[0]}return$Log::Log4perl::ALLOW_CODE_IN_CONFIG_FILE}sub var_subst {my($varname,$subst_hash)=@_;$varname =~ s/\s+//g;if(exists$subst_hash->{$varname}){print "Replacing variable: '$varname' => '$subst_hash->{$varname}'\n" if _INTERNAL_DEBUG;return$subst_hash->{$varname}}elsif(exists$ENV{$varname}){print "Replacing ENV variable: '$varname' => '$ENV{$varname}'\n" if _INTERNAL_DEBUG;return$ENV{$varname}}die "Undefined Variable '$varname'"}1;
LOG_LOG4PERL_CONFIG

$fatpacked{"Log/Log4perl/Config/BaseConfigurator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_CONFIG_BASECONFIGURATOR';
  package Log::Log4perl::Config::BaseConfigurator;use warnings;use strict;use constant _INTERNAL_DEBUG=>0;*eval_if_perl=\&Log::Log4perl::Config::eval_if_perl;*compile_if_perl=\&Log::Log4perl::Config::compile_if_perl;*leaf_path_to_hash=\&Log::Log4perl::Config::leaf_path_to_hash;sub new {my($class,%options)=@_;my$self={utf8=>0,%options,};bless$self,$class;$self->file($self->{file})if exists$self->{file};$self->text($self->{text})if exists$self->{text};return$self}sub text {my($self,$text)=@_;if(defined$text){if(ref$text eq "ARRAY"){$self->{text}=$text}else {$self->{text}=[split "\n",$text]}}return$self->{text}}sub file {my($self,$filename)=@_;open my$fh,"$filename" or die "Cannot open $filename ($!)";if($self->{utf8 }){binmode$fh,":utf8"}$self->file_h_read($fh);close$fh}sub file_h_read {my($self,$fh)=@_;local $/="\n";$self->{text}=[<$fh>]}sub parse {die __PACKAGE__ ."::parse() is a virtual method. " ."It must be implemented " ."in a derived class (currently: ",ref(shift),")"}sub parse_post_process {my($self,$data,$leaf_paths)=@_;for my$path (@{Log::Log4perl::Config::leaf_paths($data)}){print "path=@$path\n" if _INTERNAL_DEBUG;if(0){}elsif($path->[0]eq "appender" and $path->[2]eq "trigger"){my$ref=leaf_path_to_hash($path,$data);my$code=compile_if_perl($$ref);if(_INTERNAL_DEBUG){if($code){print "Code compiled: $$ref\n"}else {print "Not compiled: $$ref\n"}}$$ref=$code if defined$code}elsif ($path->[0]eq "filter"){}elsif ($path->[0]eq "appender" and $path->[2]eq "warp_message"){}elsif ($path->[0]eq "appender" and $path->[3]eq "cspec" or $path->[1]eq "cspec"){}else {my$ref=leaf_path_to_hash($path,$data);if(_INTERNAL_DEBUG){print "Calling eval_if_perl on $$ref\n"}$$ref=eval_if_perl($$ref)}}return$data}1;
LOG_LOG4PERL_CONFIG_BASECONFIGURATOR

$fatpacked{"Log/Log4perl/Config/DOMConfigurator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_CONFIG_DOMCONFIGURATOR';
  package Log::Log4perl::Config::DOMConfigurator;use Log::Log4perl::Config::BaseConfigurator;our@ISA=qw(Log::Log4perl::Config::BaseConfigurator);use XML::DOM;use Log::Log4perl::Level;use strict;use constant _INTERNAL_DEBUG=>0;our$VERSION=0.03;our$APPENDER_TAG=qr/^((log4j|log4perl):)?appender$/;our$FILTER_TAG=qr/^(log4perl:)?filter$/;our$FILTER_REF_TAG=qr/^(log4perl:)?filter-ref$/;our$PARSER_CLASS='XML::DOM::Parser';our$LOG4J_PREFIX='log4j';our$LOG4PERL_PREFIX='log4perl';*eval_if_perl=\&Log::Log4perl::Config::eval_if_perl;*unlog4j=\&Log::Log4perl::Config::unlog4j;sub parse {my($self,$newtext)=@_;$self->text($newtext)if defined$newtext;my$text=$self->{text};my$parser=$PARSER_CLASS->new;my$doc=$parser->parse (join('',@$text));my$l4p_tree={};my$config=$doc->getElementsByTagName("$LOG4J_PREFIX:configuration")->item(0)|| $doc->getElementsByTagName("$LOG4PERL_PREFIX:configuration")->item(0);my$threshold=uc(subst($config->getAttribute('threshold')));if ($threshold){$l4p_tree->{threshold}{value}=$threshold}if (subst($config->getAttribute('oneMessagePerAppender'))eq 'true'){$l4p_tree->{oneMessagePerAppender}{value}=1}for my$kid ($config->getChildNodes){next unless$kid->getNodeType==ELEMENT_NODE;my$tag_name=$kid->getTagName;if ($tag_name =~ $APPENDER_TAG){&parse_appender($l4p_tree,$kid)}elsif ($tag_name eq 'category' || $tag_name eq 'logger'){&parse_category($l4p_tree,$kid)}elsif ($tag_name eq 'root'){&parse_root($l4p_tree,$kid)}elsif ($tag_name =~ $FILTER_TAG){&parse_l4p_filter($l4p_tree,$kid)}elsif ($tag_name eq 'renderer'){warn "Log4perl: ignoring renderer tag in config, unimplemented"}elsif ($tag_name eq 'PatternLayout'){&parse_patternlayout($l4p_tree,$kid)}}$doc->dispose;return$l4p_tree}sub parse_patternlayout {my ($l4p_tree,$node)=@_;my$l4p_branch={};for my$child ($node->getChildNodes){next unless$child->getNodeType==ELEMENT_NODE;my$name=subst($child->getAttribute('name'));my$value;for my$grandkid ($child->getChildNodes){if ($grandkid->getNodeType==TEXT_NODE){$value .= $grandkid->getData}}$value =~ s/^ +//;$value =~ s/ +$//;$l4p_branch->{$name}{value}=subst($value)}$l4p_tree->{PatternLayout}{cspec}=$l4p_branch}sub parse_root {my ($l4p_tree,$node)=@_;my$l4p_branch={};&parse_children_of_logger_element($l4p_branch,$node);$l4p_tree->{category}{value}=$l4p_branch->{value}}sub parse_l4p_filter {my ($l4p_tree,$node)=@_;my$l4p_branch={};my$name=subst($node->getAttribute('name'));my$class=subst($node->getAttribute('class'));my$value=subst($node->getAttribute('value'));if ($class && $value){die "Log4perl: only one of class or value allowed, not both, " ."in XMLConfig filter '$name'"}elsif ($class || $value){$l4p_branch->{value}=($value || $class)}for my$child ($node->getChildNodes){if ($child->getNodeType==ELEMENT_NODE){my$tag_name=$child->getTagName();if ($tag_name =~ /^(param|param-nested|param-text)$/){&parse_any_param($l4p_branch,$child)}}elsif ($child->getNodeType==TEXT_NODE){my$text=$child->getData;next unless$text =~ /\S/;if ($class && $value){die "Log4perl: only one of class, value or PCDATA allowed, " ."in XMLConfig filter '$name'"}$l4p_branch->{value}.= subst($text)}}$l4p_tree->{filter}{$name}=$l4p_branch}sub parse_category {my ($l4p_tree,$node)=@_;my$name=subst($node->getAttribute('name'));$l4p_tree->{category}||= {};my$ptr=$l4p_tree->{category};for my$part (split /\.|::/,$name){$ptr->{$part}={}unless exists$ptr->{$part};$ptr=$ptr->{$part}}my$l4p_branch=$ptr;my$class=subst($node->getAttribute('class'));$class && $class ne 'Log::Log4perl' && $class ne 'org.apache.log4j.Logger' && warn "setting category $name to class $class ignored, only Log::Log4perl implemented";my$additivity=subst(subst($node->getAttribute('additivity')));if (length$additivity > 0){$l4p_tree->{additivity}||= {};my$add_ptr=$l4p_tree->{additivity};for my$part (split /\.|::/,$name){$add_ptr->{$part}={}unless exists$add_ptr->{$part};$add_ptr=$add_ptr->{$part}}$add_ptr->{value}=&parse_boolean($additivity)}&parse_children_of_logger_element($l4p_branch,$node)}sub parse_children_of_logger_element {my ($l4p_branch,$node)=@_;my (@appenders,$priority);for my$child ($node->getChildNodes){next unless$child->getNodeType==ELEMENT_NODE;my$tag_name=$child->getTagName();if ($tag_name eq 'param'){my$name=subst($child->getAttribute('name'));my$value=subst($child->getAttribute('value'));if ($value =~ /^(all|debug|info|warn|error|fatal|off|null)^/){$value=uc$value}$l4p_branch->{$name}={value=>$value}}elsif ($tag_name eq 'appender-ref'){push@appenders,subst($child->getAttribute('ref'))}elsif ($tag_name eq 'level' || $tag_name eq 'priority'){$priority=&parse_level($child)}}$l4p_branch->{value}=$priority.', '.join(',',@appenders);return}sub parse_level {my$node=shift;my$level=uc (subst($node->getAttribute('value')));die "Log4perl: invalid level in config: $level" unless Log::Log4perl::Level::is_valid($level);return$level}sub parse_appender {my ($l4p_tree,$node)=@_;my$name=subst($node->getAttribute("name"));my$l4p_branch={};my$class=subst($node->getAttribute("class"));$l4p_branch->{value}=$class;print "looking at $name----------------------\n" if _INTERNAL_DEBUG;for my$child ($node->getChildNodes){next unless$child->getNodeType==ELEMENT_NODE;my$tag_name=$child->getTagName();my$name=unlog4j(subst($child->getAttribute('name')));if ($tag_name =~ /^(param|param-nested|param-text)$/){&parse_any_param($l4p_branch,$child);my$value}elsif ($tag_name =~ /($LOG4PERL_PREFIX:)?layout/){$l4p_branch->{layout}=parse_layout($child)}elsif ($tag_name =~ $FILTER_TAG){$l4p_branch->{Filter}=parse_filter($child)}elsif ($tag_name =~ $FILTER_REF_TAG){$l4p_branch->{Filter}=parse_filter_ref($child)}elsif ($tag_name eq 'errorHandler'){die "errorHandlers not supported yet"}elsif ($tag_name eq 'appender-ref'){die "Log4perl: in config file, <appender-ref> tag is unsupported in <appender>"}else{die "Log4perl: in config file, <$tag_name> is unsupported\n"}}$l4p_tree->{appender}{$name}=$l4p_branch}sub parse_any_param {my ($l4p_branch,$child)=@_;my$tag_name=$child->getTagName();my$name=subst($child->getAttribute('name'));my$value;print "parse_any_param: <$tag_name name=$name\n" if _INTERNAL_DEBUG;if ($tag_name eq 'param-nested'){if ($l4p_branch->{$name}){die "Log4perl: in config file, multiple param-nested tags for $name not supported"}$l4p_branch->{$name}=&parse_param_nested($child);return}elsif ($tag_name eq 'param'){$value=subst($child->getAttribute('value'));print "parse_param_nested: got param $name = $value\n" if _INTERNAL_DEBUG;if ($value =~ /^(all|debug|info|warn|error|fatal|off|null)$/){$value=uc$value}if ($name !~ /warp_message|filter/ && $child->getParentNode->getAttribute('name')ne 'cspec'){$value=eval_if_perl($value)}}elsif ($tag_name eq 'param-text'){for my$grandkid ($child->getChildNodes){if ($grandkid->getNodeType==TEXT_NODE){$value .= $grandkid->getData}}if ($name !~ /warp_message|filter/ && $child->getParentNode->getAttribute('name')ne 'cspec'){$value=eval_if_perl($value)}}$value=subst($value);if (defined$l4p_branch->{$name}{value}){if (ref$l4p_branch->{$name}{value}ne 'ARRAY'){my$temp=$l4p_branch->{$name}{value};$l4p_branch->{$name}{value}=[$temp]}push @{$l4p_branch->{$name}{value}},$value}else{$l4p_branch->{$name}={value=>$value}}}sub parse_param_nested {my ($node)=shift;my$l4p_branch={};for my$child ($node->getChildNodes){next unless$child->getNodeType==ELEMENT_NODE;my$tag_name=$child->getTagName();if ($tag_name =~ /^param|param-nested|param-text$/){&parse_any_param($l4p_branch,$child)}}return$l4p_branch}sub parse_filter {my$node=shift;my$filter_tree={};my$class_name=subst($node->getAttribute('class'));$filter_tree->{value}=$class_name;print "\tparsing filter on class $class_name\n" if _INTERNAL_DEBUG;for my$child ($node->getChildNodes){next unless$child->getNodeType==ELEMENT_NODE;my$tag_name=$child->getTagName();if ($tag_name =~ 'param|param-nested|param-text'){&parse_any_param($filter_tree,$child)}else{die "Log4perl: don't know what to do with a ".$child->getTagName()."inside a filter element"}}return$filter_tree}sub parse_filter_ref {my$node=shift;my$filter_tree={};my$filter_id=subst($node->getAttribute('id'));$filter_tree->{value}=$filter_id;return$filter_tree}sub parse_layout {my$node=shift;my$layout_tree={};my$class_name=subst($node->getAttribute('class'));$layout_tree->{value}=$class_name;print "\tparsing layout $class_name\n" if _INTERNAL_DEBUG;for my$child ($node->getChildNodes){next unless$child->getNodeType==ELEMENT_NODE;if ($child->getTagName()eq 'param'){my$name=subst($child->getAttribute('name'));my$value=subst($child->getAttribute('value'));if ($value =~ /^(all|debug|info|warn|error|fatal|off|null)$/){$value=uc$value}print "\tparse_layout: got param $name = $value\n" if _INTERNAL_DEBUG;$layout_tree->{$name}{value}=$value}elsif ($child->getTagName()eq 'cspec'){my$name=subst($child->getAttribute('name'));my$value;for my$grandkid ($child->getChildNodes){if ($grandkid->getNodeType==TEXT_NODE){$value .= $grandkid->getData}}$value =~ s/^ +//;$value =~ s/ +$//;$layout_tree->{cspec}{$name}{value}=subst($value)}}return$layout_tree}sub parse_boolean {my$a=shift;if ($a eq '0' || lc$a eq 'false'){return '0'}elsif ($a eq '1' || lc$a eq 'true'){return '1'}else{return$a}}sub subst {my$val=shift;$val =~ s/\$\{(.*?)}/
                        Log::Log4perl::Config::var_subst($1, {})/gex;return$val}1;
LOG_LOG4PERL_CONFIG_DOMCONFIGURATOR

$fatpacked{"Log/Log4perl/Config/PropertyConfigurator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_CONFIG_PROPERTYCONFIGURATOR';
  package Log::Log4perl::Config::PropertyConfigurator;use Log::Log4perl::Config::BaseConfigurator;use warnings;use strict;our@ISA=qw(Log::Log4perl::Config::BaseConfigurator);our%NOT_A_MULT_VALUE=map {$_=>1}qw(conversionpattern);*eval_if_perl=\&Log::Log4perl::Config::eval_if_perl;*compile_if_perl=\&Log::Log4perl::Config::compile_if_perl;*unlog4j=\&Log::Log4perl::Config::unlog4j;use constant _INTERNAL_DEBUG=>0;our$COMMENT_REGEX=qr/[#;!]/;sub parse {my($self,$newtext)=@_;$self->text($newtext)if defined$newtext;my$text=$self->{text};die "Config parser has nothing to parse" unless defined$text;my$data={};my%var_subst=();while (@$text){local $_=shift @$text;s/^\s*$COMMENT_REGEX.*//;next unless /\S/;my@parts=();while (/(.+?)\\\s*$/){my$prev=$1;my$next=shift(@$text);$next =~ s/^ +//g;$next =~ s/^$COMMENT_REGEX.*//;$_=$prev.$next;chomp}if(my($key,$val)=/(\S+?)\s*=\s*(.*)/){my$key_org=$key;$val =~ s/\s+$//;$var_subst{$key}=$val;$val =~ s/\$\{(.*?)\}/
                        Log::Log4perl::Config::var_subst($1, \%var_subst)/gex;$key=unlog4j($key);my$how_deep=0;my$ptr=$data;for my$part (split /\.|::/,$key){push@parts,$part;$ptr->{$part}={}unless exists$ptr->{$part};$ptr=$ptr->{$part};++$how_deep}if (exists$ptr->{value}&& $how_deep > 2 && defined$parts[0]&& lc($parts[0])eq "appender" && defined$parts[2]&&!exists$NOT_A_MULT_VALUE{lc($parts[2])}){if (ref ($ptr->{value})ne 'ARRAY'){my$temp=$ptr->{value};$ptr->{value}=[];push (@{$ptr->{value}},$temp)}push (@{$ptr->{value}},$val)}else{if(defined$ptr->{value}){if(!$Log::Log4perl::Logger::NO_STRICT){die "$key_org redefined"}}$ptr->{value}=$val}}}$self->{data}=$data;return$data}sub value {my($self,$path)=@_;$path=unlog4j($path);my@p=split /::/,$path;my$found=0;my$r=$self->{data};while (my$n=shift@p){if (exists$r->{$n}){$r=$r->{$n};$found=1}else {$found=0}}if($found and exists$r->{value}){return$r->{value}}else {return undef}}1;
LOG_LOG4PERL_CONFIG_PROPERTYCONFIGURATOR

$fatpacked{"Log/Log4perl/Config/Watch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_CONFIG_WATCH';
  package Log::Log4perl::Config::Watch;use constant _INTERNAL_DEBUG=>0;our$NEXT_CHECK_TIME;our$SIGNAL_CAUGHT;our$L4P_TEST_CHANGE_DETECTED;our$L4P_TEST_CHANGE_CHECKED;sub new {my($class,%options)=@_;my$self={file=>"",check_interval=>30,l4p_internal=>0,signal=>undef,%options,_last_checked_at=>0,_last_timestamp=>0,};bless$self,$class;if($self->{signal}){print "Setting up signal handler for '$self->{signal}'\n" if _INTERNAL_DEBUG;my$old_sig_handler=$SIG{$self->{signal}};$SIG{$self->{signal}}=sub {print "Caught $self->{signal} signal\n" if _INTERNAL_DEBUG;$self->force_next_check();$old_sig_handler->(@_)if$old_sig_handler and ref$old_sig_handler eq 'CODE'};$self->{signal_caught}=0;$SIGNAL_CAUGHT=0 if$self->{l4p_internal}}else {$self->change_detected(undef,1);$self->file_has_moved(undef,1)}return$self}sub force_next_check {my($self)=@_;$self->{signal_caught}=1;$self->{next_check_time}=0;if($self->{l4p_internal}){$SIGNAL_CAUGHT=1;$NEXT_CHECK_TIME=0}}sub force_next_check_reset {my($self)=@_;$self->{signal_caught}=0;$SIGNAL_CAUGHT=0 if$self->{l4p_internal}}sub file {my($self)=@_;return$self->{file}}sub signal {my($self)=@_;return$self->{signal}}sub check_interval {my($self)=@_;return$self->{check_interval}}sub file_has_moved {my($self,$time,$force)=@_;my$task=sub {my@stat=stat($self->{file});my$has_moved=0;if(!$stat[0]){print "File is gone\n" if _INTERNAL_DEBUG;return 1}my$current_inode="$stat[0]:$stat[1]";print "Current inode: $current_inode\n" if _INTERNAL_DEBUG;if(exists$self->{_file_inode}and $self->{_file_inode}ne $current_inode){print "Inode changed from $self->{_file_inode} to ","$current_inode\n" if _INTERNAL_DEBUG;$has_moved=1}$self->{_file_inode}=$current_inode;return$has_moved};return$self->check($time,$task,$force)}sub change_detected {my($self,$time,$force)=@_;my$task=sub {my@stat=stat($self->{file});my$new_timestamp=$stat[9];$L4P_TEST_CHANGE_CHECKED=1;if(!defined$new_timestamp){if($self->{l4p_internal}){return undef}$L4P_TEST_CHANGE_DETECTED=1;return 1}if($new_timestamp > $self->{_last_timestamp}){$self->{_last_timestamp}=$new_timestamp;print "Change detected (file=$self->{file} store=$new_timestamp)\n" if _INTERNAL_DEBUG;$L4P_TEST_CHANGE_DETECTED=1;return 1}print "$self->{file} unchanged (file=$new_timestamp ","stored=$self->{_last_timestamp})!\n" if _INTERNAL_DEBUG;return ""};return$self->check($time,$task,$force)}sub check {my($self,$time,$task,$force)=@_;$time=time()unless defined$time;if($self->{signal_caught}or $SIGNAL_CAUGHT){$force=1;$self->force_next_check_reset();print "Caught signal, forcing check\n" if _INTERNAL_DEBUG}print "Soft check (file=$self->{file} time=$time)\n" if _INTERNAL_DEBUG;if(!$force and $self->{_last_checked_at}+ $self->{check_interval}> $time){print "No need to check\n" if _INTERNAL_DEBUG;return ""}$self->{_last_checked_at}=$time;$self->{next_check_time}=$time + $self->{check_interval};$NEXT_CHECK_TIME=$self->{next_check_time}if$self->{l4p_internal};print "Hard check (file=$self->{file} time=$time)\n" if _INTERNAL_DEBUG;return$task->($time)}1;
LOG_LOG4PERL_CONFIG_WATCH

$fatpacked{"Log/Log4perl/DateFormat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_DATEFORMAT';
  package Log::Log4perl::DateFormat;use warnings;use strict;use Carp qw(croak);our$GMTIME=0;my@MONTH_NAMES=qw(January February March April May June July August September October November December);my@WEEK_DAYS=qw(Sunday Monday Tuesday Wednesday Thursday Friday Saturday);sub new {my($class,$format)=@_;my$self={stack=>[],fmt=>undef,};bless$self,$class;if($format eq "ABSOLUTE"){$format="HH:mm:ss,SSS"}elsif($format eq "DATE"){$format="dd MMM yyyy HH:mm:ss,SSS"}elsif($format eq "ISO8601"){$format="yyyy-MM-dd HH:mm:ss,SSS"}elsif($format eq "APACHE"){$format="[EEE MMM dd HH:mm:ss yyyy]"}if($format){$self->prepare($format)}return$self}sub prepare {my($self,$format)=@_;my$fmt="";for my$chunk (split /('(?:''|[^'])*')/,$format){if ($chunk =~ /\A'(.*)'\z/){my$literal=$1;$literal =~ s/''/'/g;$literal =~ s/\%/\%\%/g;$fmt .= $literal}elsif ($chunk =~ /'/){croak "bad date format \"$format\": " ."unmatched single quote in chunk \"$chunk\""}else {$chunk =~ s/(([GyMdhHmsSEeDFwWakKzZ])\2*)/$self->rep($1)/ge;$fmt .= $chunk}}return$self->{fmt}=$fmt}sub rep {my ($self,$string)=@_;my$first=substr$string,0,1;my$len=length$string;my$time=time();my@g=gmtime($time);my@t=localtime($time);my$z=$t[1]-$g[1]+($t[2]-$g[2])*60+($t[7]-$g[7])*1440+ ($t[5]-$g[5])*(525600+(abs($t[7]-$g[7])>364)*1440);my$offset=sprintf("%+.2d%.2d",$z/60,"00");if($first eq "G"){return "AD"}elsif($first eq "e"){push @{$self->{stack}},[0,sub {return $_[1]}];return "%d"}elsif($first eq "y"){if($len >= 4){push @{$self->{stack}},[5,sub {return $_[0]+ 1900}];return "%04d"}else {push @{$self->{stack}},[5,sub {$_[0]% 100}];return "%02d"}}elsif($first eq "M"){if($len >= 3){push @{$self->{stack}},[4,sub {return$MONTH_NAMES[$_[0]]}];if($len >= 4){return "%s"}else {return "%.3s"}}elsif($len==2){push @{$self->{stack}},[4,sub {$_[0]+1}];return "%02d"}else {push @{$self->{stack}},[4,sub {$_[0]+1}];return "%d"}}elsif($first eq "d"){push @{$self->{stack}},[3,sub {return $_[0]}];return "%0" .$len ."d"}elsif($first eq "h"){push @{$self->{stack}},[2,sub {($_[0]% 12)|| 12}];return "%0" .$len ."d"}elsif($first eq "H"){push @{$self->{stack}},[2,sub {return $_[0]}];return "%0" .$len ."d"}elsif($first eq "m"){push @{$self->{stack}},[1,sub {return $_[0]}];return "%0" .$len ."d"}elsif($first eq "s"){push @{$self->{stack}},[0,sub {return $_[0]}];return "%0" .$len ."d"}elsif($first eq "E"){push @{$self->{stack}},[6,sub {$WEEK_DAYS[$_[0]]}];if($len >= 4){return "%${len}s"}else {return "%.3s"}}elsif($first eq "D"){push @{$self->{stack}},[7,sub {$_[0]+ 1}];return "%0" .$len ."d"}elsif($first eq "a"){push @{$self->{stack}},[2,sub {$_[0]< 12 ? "AM" : "PM"}];return "%${len}s"}elsif($first eq "S"){push @{$self->{stack}},[9,sub {substr sprintf("%06d",$_[0]),0,$len}];return "%s"}elsif($first eq "Z"){push @{$self->{stack}},[10,sub {$offset}];return "%s"}else {return "-- '$first' not (yet) implemented --"}return$string}sub format {my($self,$secs,$msecs)=@_;$msecs=0 unless defined$msecs;my@time;if($GMTIME){@time=gmtime($secs)}else {@time=localtime($secs)}push@time,$msecs;my@values=();for(@{$self->{stack}}){my($val,$code)=@$_;if($code){push@values,$code->($time[$val],$secs)}else {push@values,$time[$val]}}return sprintf($self->{fmt},@values)}1;
LOG_LOG4PERL_DATEFORMAT

$fatpacked{"Log/Log4perl/FAQ.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_FAQ';
  1;
LOG_LOG4PERL_FAQ

$fatpacked{"Log/Log4perl/Filter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_FILTER';
  package Log::Log4perl::Filter;use 5.006;use strict;use warnings;use Log::Log4perl::Level;use Log::Log4perl::Config;use constant _INTERNAL_DEBUG=>0;our%FILTERS_DEFINED=();sub new {my($class,$name,$action)=@_;print "Creating filter $name\n" if _INTERNAL_DEBUG;my$self={name=>$name };bless$self,$class;if(ref($action)eq "CODE"){$self->{ok}=$action}else {die "Code for ($name/$action) not properly defined"}return$self}sub register {my($self)=@_;by_name($self->{name},$self)}sub by_name {my($name,$value)=@_;if(defined$value){$FILTERS_DEFINED{$name}=$value}if(exists$FILTERS_DEFINED{$name}){return$FILTERS_DEFINED{$name}}else {return undef}}sub reset {%FILTERS_DEFINED=()}sub ok {my($self,%p)=@_;print "Calling $self->{name}'s ok method\n" if _INTERNAL_DEBUG;die "This is to be overridden by the filter" unless defined$self->{ok};local($_)=join $ Log::Log4perl::JOIN_MSG_ARRAY_CHAR,@{$p{message}};print "\$_ is '$_'\n" if _INTERNAL_DEBUG;my$decision=$self->{ok}->(%p);print "$self->{name}'s ok'ed: ",($decision ? "yes" : "no"),"\n" if _INTERNAL_DEBUG;return$decision}1;
LOG_LOG4PERL_FILTER

$fatpacked{"Log/Log4perl/Filter/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_FILTER_BOOLEAN';
  package Log::Log4perl::Filter::Boolean;use 5.006;use strict;use warnings;use Log::Log4perl::Level;use Log::Log4perl::Config;use constant _INTERNAL_DEBUG=>0;use base qw(Log::Log4perl::Filter);sub new {my ($class,%options)=@_;my$self={params=>{},%options,};bless$self,$class;print "Compiling '$options{logic}'\n" if _INTERNAL_DEBUG;$self->compile_logic($options{logic});return$self}sub ok {my ($self,%p)=@_;return$self->eval_logic(\%p)}sub compile_logic {my ($self,$logic)=@_;while($logic =~ /([\w_-]+)/g){my$filter=Log::Log4perl::Filter::by_name($1);die "Filter $1 required by Boolean filter, but not defined" unless$filter;$self->{params}->{$1}=$filter}my$plist=join ', ',map {'$' .$_}keys %{$self->{params}};$logic =~ s/([\w_-]+)/\&\$$1/g;my$func=<<EOT;print "func=$func\n" if _INTERNAL_DEBUG;my$eval_func=eval$func;if(!$eval_func){die "Syntax error in Boolean filter logic: $eval_func"}$self->{eval_func}=$eval_func}sub eval_logic {my($self,$p)=@_;my@plist=();for my$param (keys %{$self->{params}}){print "Passing filter $param\n" if _INTERNAL_DEBUG;push(@plist,sub {return$self->{params}->{$param}->ok(%$p)? 1 : 0})}print "Passing in (",join(', ',@plist),")\n" if _INTERNAL_DEBUG;return$self->{eval_func}->(@plist)}1;
          sub { 
              my($plist) = \@_;
              $logic;
          }
  EOT
LOG_LOG4PERL_FILTER_BOOLEAN

$fatpacked{"Log/Log4perl/Filter/LevelMatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_FILTER_LEVELMATCH';
  package Log::Log4perl::Filter::LevelMatch;use 5.006;use strict;use warnings;use Log::Log4perl::Level;use Log::Log4perl::Config;use Log::Log4perl::Util qw(params_check);use constant _INTERNAL_DEBUG=>0;use base qw(Log::Log4perl::Filter);sub new {my ($class,%options)=@_;my$self={LevelToMatch=>'',AcceptOnMatch=>1,%options,};params_check($self,[qw(LevelToMatch) ],[qw(name AcceptOnMatch) ]);$self->{AcceptOnMatch}=Log::Log4perl::Config::boolean_to_perlish($self->{AcceptOnMatch});bless$self,$class;return$self}sub ok {my ($self,%p)=@_;if($self->{LevelToMatch}eq $p{log4p_level}){print "Levels match\n" if _INTERNAL_DEBUG;return$self->{AcceptOnMatch}}else {print "Levels don't match\n" if _INTERNAL_DEBUG;return!$self->{AcceptOnMatch}}}1;
LOG_LOG4PERL_FILTER_LEVELMATCH

$fatpacked{"Log/Log4perl/Filter/LevelRange.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_FILTER_LEVELRANGE';
  package Log::Log4perl::Filter::LevelRange;use 5.006;use strict;use warnings;use Log::Log4perl::Level;use Log::Log4perl::Config;use Log::Log4perl::Util qw(params_check);use constant _INTERNAL_DEBUG=>0;use base "Log::Log4perl::Filter";sub new {my ($class,%options)=@_;my$self={LevelMin=>'DEBUG',LevelMax=>'FATAL',AcceptOnMatch=>1,%options,};params_check($self,[qw(LevelMin LevelMax) ],[qw(name AcceptOnMatch) ]);$self->{AcceptOnMatch}=Log::Log4perl::Config::boolean_to_perlish($self->{AcceptOnMatch});bless$self,$class;return$self}sub ok {my ($self,%p)=@_;if(Log::Log4perl::Level::to_priority($self->{LevelMin})<= Log::Log4perl::Level::to_priority($p{log4p_level})and Log::Log4perl::Level::to_priority($self->{LevelMax})>= Log::Log4perl::Level::to_priority($p{log4p_level})){return$self->{AcceptOnMatch}}else {return!$self->{AcceptOnMatch}}}1;
LOG_LOG4PERL_FILTER_LEVELRANGE

$fatpacked{"Log/Log4perl/Filter/MDC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_FILTER_MDC';
  package Log::Log4perl::Filter::MDC;use strict;use warnings;use Log::Log4perl::Util qw(params_check);use base "Log::Log4perl::Filter";sub new {my ($class,%options)=@_;my$self={%options};params_check($self,[qw(KeyToMatch RegexToMatch)]);$self->{RegexToMatch}=qr/$self->{RegexToMatch}/;bless$self,$class;return$self}sub ok {my ($self,%p)=@_;my$context=Log::Log4perl::MDC->get_context;my$value=$context->{$self->{KeyToMatch}};return 1 if defined$value && $value =~ $self->{RegexToMatch};return 0}1;
LOG_LOG4PERL_FILTER_MDC

$fatpacked{"Log/Log4perl/Filter/StringMatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_FILTER_STRINGMATCH';
  package Log::Log4perl::Filter::StringMatch;use 5.006;use strict;use warnings;use Log::Log4perl::Config;use Log::Log4perl::Util qw(params_check);use constant _INTERNAL_DEBUG=>0;use base "Log::Log4perl::Filter";sub new {my ($class,%options)=@_;print join('-',%options)if _INTERNAL_DEBUG;my$self={StringToMatch=>undef,AcceptOnMatch=>1,%options,};params_check($self,[qw(StringToMatch) ],[qw(name AcceptOnMatch) ]);$self->{AcceptOnMatch}=Log::Log4perl::Config::boolean_to_perlish($self->{AcceptOnMatch});$self->{StringToMatch}=qr($self->{StringToMatch});bless$self,$class;return$self}sub ok {my ($self,%p)=@_;local($_)=join $ Log::Log4perl::JOIN_MSG_ARRAY_CHAR,@{$p{message}};if($_ =~ $self->{StringToMatch}){print "Strings match\n" if _INTERNAL_DEBUG;return$self->{AcceptOnMatch}}else {print "Strings don't match ($_/$self->{StringToMatch})\n" if _INTERNAL_DEBUG;return!$self->{AcceptOnMatch}}}1;
LOG_LOG4PERL_FILTER_STRINGMATCH

$fatpacked{"Log/Log4perl/InternalDebug.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_INTERNALDEBUG';
  package Log::Log4perl::InternalDebug;use warnings;use strict;use File::Temp qw(tempfile);use File::Spec;require Log::Log4perl::Resurrector;sub enable {unshift@INC,\&internal_debug_loader}sub internal_debug_fh {my($file)=@_;local($/)=undef;open FILE,"<$file" or die "Cannot open $file";my$text=<FILE>;close FILE;my($tmp_fh,$tmpfile)=tempfile(UNLINK=>1);$text =~ s/_INTERNAL_DEBUG(?!\s*=>)/1/g;print$tmp_fh $text;seek$tmp_fh,0,0;return$tmp_fh}sub internal_debug_loader {my ($code,$module)=@_;if($module !~ m#^Log/Log4perl#){return undef}my$path=$module;if(!-f $path){$path=Log::Log4perl::Resurrector::pm_search($module)}my$fh=internal_debug_fh($path);my$abs_path=File::Spec->rel2abs($path);$INC{$module}=$abs_path;return$fh}sub resurrector_init {unshift@INC,\&resurrector_loader}sub import {enable()}1;
LOG_LOG4PERL_INTERNALDEBUG

$fatpacked{"Log/Log4perl/JavaMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_JAVAMAP';
  package Log::Log4perl::JavaMap;use Carp;use strict;use constant _INTERNAL_DEBUG=>0;our%translate=('org.apache.log4j.ConsoleAppender'=>'Log::Log4perl::JavaMap::ConsoleAppender','org.apache.log4j.FileAppender'=>'Log::Log4perl::JavaMap::FileAppender','org.apache.log4j.RollingFileAppender'=>'Log::Log4perl::JavaMap::RollingFileAppender','org.apache.log4j.TestBuffer'=>'Log::Log4perl::JavaMap::TestBuffer','org.apache.log4j.jdbc.JDBCAppender'=>'Log::Log4perl::JavaMap::JDBCAppender','org.apache.log4j.SyslogAppender'=>'Log::Log4perl::JavaMap::SyslogAppender','org.apache.log4j.NTEventLogAppender'=>'Log::Log4perl::JavaMap::NTEventLogAppender',);our%user_defined;sub get {my ($appender_name,$appender_data)=@_;print "Trying to map $appender_name\n" if _INTERNAL_DEBUG;$appender_data->{value}|| die "ERROR: you didn't tell me how to implement your appender " ."'$appender_name'";my$perl_class=$translate{$appender_data->{value}}|| $user_defined{$appender_data->{value}}|| die "ERROR:  I don't know how to make a '$appender_data->{value}' " ."to implement your appender '$appender_name', that's not a " ."supported class\n";eval {eval "require $perl_class";die $@ if $@};$@ and die "ERROR: trying to set appender for $appender_name to " ."$appender_data->{value} using $perl_class failed\n$@  \n";my$app=$perl_class->new($appender_name,$appender_data);return$app}sub translate {my$java_class=shift;return$translate{$java_class}|| $user_defined{$java_class}}1;
LOG_LOG4PERL_JAVAMAP

$fatpacked{"Log/Log4perl/JavaMap/ConsoleAppender.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_JAVAMAP_CONSOLEAPPENDER';
  package Log::Log4perl::JavaMap::ConsoleAppender;use Carp;use strict;use Log::Dispatch::Screen;sub new {my ($class,$appender_name,$data)=@_;my$stderr;if (my$t=$data->{Target}{value}){if ($t eq 'System.out'){$stderr=0}elsif ($t eq 'System.err'){$stderr=1}else{die "ERROR: illegal value '$t' for $data->{value}.Target' in appender $appender_name\n"}}elsif (defined$data->{stderr}{value}){$stderr=$data->{stderr}{value}}else{$stderr=0}return Log::Log4perl::Appender->new("Log::Dispatch::Screen",name=>$appender_name,stderr=>$stderr)}1;
LOG_LOG4PERL_JAVAMAP_CONSOLEAPPENDER

$fatpacked{"Log/Log4perl/JavaMap/FileAppender.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_JAVAMAP_FILEAPPENDER';
  package Log::Log4perl::JavaMap::FileAppender;use Carp;use strict;use Log::Dispatch::File;sub new {my ($class,$appender_name,$data)=@_;my$stderr;my$filename=$data->{File}{value}|| $data->{filename}{value}|| die "'File' not supplied for appender '$appender_name', required for a '$data->{value}'\n";my$mode;if (defined($data->{Append}{value})){if (lc$data->{Append}{value}eq 'true' || $data->{Append}{value}==1){$mode='append'}elsif (lc$data->{Append}{value}eq 'false' || $data->{Append}{value}==0){$mode='write'}elsif($data->{Append}=~ /^(write|append)$/){$mode=$data->{Append}}else{die "'$data->{Append}' is not a legal value for Append for appender '$appender_name', '$data->{value}'\n"}}else{$mode='append'}my$autoflush;if (defined($data->{BufferedIO}{value})){if (lc$data->{BufferedIO}{value}eq 'true' || $data->{BufferedIO}{value}){$autoflush=1}elsif (lc$data->{BufferedIO}{value}eq 'true' ||!$data->{BufferedIO}{value}){$autoflush=0}else{die "'$data->{BufferedIO}' is not a legal value for BufferedIO for appender '$appender_name', '$data->{value}'\n"}}else{$autoflush=1}return Log::Log4perl::Appender->new("Log::Dispatch::File",name=>$appender_name,filename=>$filename,mode=>$mode,autoflush=>$autoflush,)}1;
LOG_LOG4PERL_JAVAMAP_FILEAPPENDER

$fatpacked{"Log/Log4perl/JavaMap/JDBCAppender.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_JAVAMAP_JDBCAPPENDER';
  package Log::Log4perl::JavaMap::JDBCAppender;use Carp;use strict;sub new {my ($class,$appender_name,$data)=@_;my$stderr;my$pwd=$data->{password}{value}|| die "'password' not supplied for appender '$appender_name', required for a '$data->{value}'\n";my$username=$data->{user}{value}|| $data->{username}{value}|| die "'user' not supplied for appender '$appender_name', required for a '$data->{value}'\n";my$sql=$data->{sql}{value}|| die "'sql' not supplied for appender '$appender_name', required for a '$data->{value}'\n";my$dsn;my$databaseURL=$data->{URL}{value};if ($databaseURL){$databaseURL =~ m|^jdbc:(.+?):(.+?)://(.+?):(.+?);(.+)|;my$driverName=$1;my$databaseName=$2;my$hostname=$3;my$port=$4;my$params=$5;$dsn="dbi:$driverName:database=$databaseName;host=$hostname;port=$port;$params"}elsif ($data->{datasource}{value}){$dsn=$data->{datasource}{value}}else{die "'databaseURL' not supplied for appender '$appender_name', required for a '$data->{value}'\n"}my%bind_value_params;for my$p (keys %{$data->{params}}){$bind_value_params{$p}=$data->{params}{$p}{value}}return Log::Log4perl::Appender->new("Log::Log4perl::Appender::DBI",datasource=>$dsn,username=>$username,password=>$pwd,sql=>$sql,params=>\%bind_value_params,warp_message=>$data->{warp_message}{value},)}1;
LOG_LOG4PERL_JAVAMAP_JDBCAPPENDER

$fatpacked{"Log/Log4perl/JavaMap/NTEventLogAppender.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_JAVAMAP_NTEVENTLOGAPPENDER';
  package Log::Log4perl::JavaMap::NTEventLogAppender;use Carp;use strict;sub new {my ($class,$appender_name,$data)=@_;my$stderr;my ($source,);if (defined$data->{Source}{value}){$source=$data->{Source}{value}}elsif (defined$data->{source}{value}){$source=$data->{source}{value}}else{$source='user'}return Log::Log4perl::Appender->new("Log::Dispatch::Win32EventLog",name=>$appender_name,source=>$source,min_level=>'debug',)}1;
LOG_LOG4PERL_JAVAMAP_NTEVENTLOGAPPENDER

$fatpacked{"Log/Log4perl/JavaMap/RollingFileAppender.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_JAVAMAP_ROLLINGFILEAPPENDER';
  package Log::Log4perl::JavaMap::RollingFileAppender;use Carp;use strict;use Log::Dispatch::FileRotate 1.10;sub new {my ($class,$appender_name,$data)=@_;my$stderr;my$filename=$data->{File}{value}|| $data->{filename}{value}|| die "'File' not supplied for appender '$appender_name', required for a '$data->{value}'\n";my$mode;if (defined($data->{Append}{value})){if (lc$data->{Append}{value}eq 'true' || $data->{Append}{value}==1){$mode='append'}elsif (lc$data->{Append}{value}eq 'false' || $data->{Append}{value}==0){$mode='write'}elsif($data->{Append}=~ /^(write|append)$/){$mode=$data->{Append}}else{die "'$data->{Append}' is not a legal value for Append for appender '$appender_name', '$data->{value}'\n"}}else{$mode='append'}my$autoflush;if (defined($data->{BufferedIO}{value})){if (lc$data->{BufferedIO}{value}eq 'true' || $data->{BufferedIO}{value}){$autoflush=1}elsif (lc$data->{BufferedIO}{value}eq 'true' ||!$data->{BufferedIO}{value}){$autoflush=0}else{die "'$data->{BufferedIO}' is not a legal value for BufferedIO for appender '$appender_name', '$data->{value}'\n"}}else{$autoflush=1}my$max;if (defined$data->{MaxBackupIndex}{value}){$max=$data->{MaxBackupIndex}{value}}elsif (defined$data->{max}{value}){$max=$data->{max}{value}}else{$max=1}my$size;if (defined$data->{MaxFileSize}{value}){$size=$data->{MaxFileSize}{value}}elsif (defined$data->{size}{value}){$size=$data->{size}{value}}else{$size=10_000_000}return Log::Log4perl::Appender->new("Log::Dispatch::FileRotate",name=>$appender_name,filename=>$filename,mode=>$mode,autoflush=>$autoflush,size=>$size,max=>$max,)}1;
LOG_LOG4PERL_JAVAMAP_ROLLINGFILEAPPENDER

$fatpacked{"Log/Log4perl/JavaMap/SyslogAppender.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_JAVAMAP_SYSLOGAPPENDER';
  package Log::Log4perl::JavaMap::SyslogAppender;use Carp;use strict;use Log::Dispatch::Syslog;sub new {my ($class,$appender_name,$data)=@_;my$stderr;my ($ident,$logopt,$facility,$socket,);if (defined$data->{Facility}{value}){$facility=$data->{Facility}{value}}elsif (defined$data->{facility}{value}){$facility=$data->{facility}{value}}else{$facility='user'}if (defined$data->{Ident}{value}){$ident=$data->{Ident}{value}}elsif (defined$data->{ident}{value}){$ident=$data->{ident}{value}}else{$ident=$0}return Log::Log4perl::Appender->new("Log::Dispatch::Syslog",name=>$appender_name,facility=>$facility,ident=>$ident,min_level=>'debug',)}1;
LOG_LOG4PERL_JAVAMAP_SYSLOGAPPENDER

$fatpacked{"Log/Log4perl/JavaMap/TestBuffer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_JAVAMAP_TESTBUFFER';
  package Log::Log4perl::JavaMap::TestBuffer;use Carp;use strict;use Log::Log4perl::Appender::TestBuffer;use constant _INTERNAL_DEBUG=>0;sub new {my ($class,$appender_name,$data)=@_;my$stderr;return Log::Log4perl::Appender->new("Log::Log4perl::Appender::TestBuffer",name=>$appender_name)}1;
LOG_LOG4PERL_JAVAMAP_TESTBUFFER

$fatpacked{"Log/Log4perl/Layout.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_LAYOUT';
  package Log::Log4perl::Layout;use Log::Log4perl::Layout::SimpleLayout;use Log::Log4perl::Layout::PatternLayout;use Log::Log4perl::Layout::PatternLayout::Multiline;sub appender_name {my ($self,$arg)=@_;if ($arg){die "setting appender_name unimplemented until it makes sense"}return$self->{appender_name}}sub define {}sub render {die "subclass must implement render"}1;
LOG_LOG4PERL_LAYOUT

$fatpacked{"Log/Log4perl/Layout/NoopLayout.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_LAYOUT_NOOPLAYOUT';
  package Log::Log4perl::Layout::NoopLayout;sub new {my$class=shift;$class=ref ($class)|| $class;my$self={format=>undef,info_needed=>{},stack=>[],};bless$self,$class;return$self}sub render {return $_[1];}1;
LOG_LOG4PERL_LAYOUT_NOOPLAYOUT

$fatpacked{"Log/Log4perl/Layout/PatternLayout.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_LAYOUT_PATTERNLAYOUT';
  package Log::Log4perl::Layout::PatternLayout;use 5.006;use strict;use warnings;use constant _INTERNAL_DEBUG=>0;use Carp;use Log::Log4perl::Util;use Log::Log4perl::Level;use Log::Log4perl::DateFormat;use Log::Log4perl::NDC;use Log::Log4perl::MDC;use Log::Log4perl::Util::TimeTracker;use File::Spec;use File::Basename;our$TIME_HIRES_AVAILABLE_WARNED=0;our$HOSTNAME;our%GLOBAL_USER_DEFINED_CSPECS=();our$CSPECS='cCdFHIlLmMnpPrRtTxX%';BEGIN {$HOSTNAME="unknown.host";if(Log::Log4perl::Util::module_available("Sys::Hostname")){require Sys::Hostname;$HOSTNAME=Sys::Hostname::hostname()}}use base qw(Log::Log4perl::Layout);no strict qw(refs);sub new {my$class=shift;$class=ref ($class)|| $class;my$options=ref $_[0]eq "HASH" ? shift : {};my$layout_string=@_ ? shift : '%m%n';my$self={format=>undef,info_needed=>{},stack=>[],CSPECS=>$CSPECS,dontCollapseArrayRefs=>$options->{dontCollapseArrayRefs}{value},last_time=>undef,undef_column_value=>(exists$options->{undef_column_value }? $options->{undef_column_value }: "[undef]"),};$self->{timer}=Log::Log4perl::Util::TimeTracker->new(time_function=>$options->{time_function});if(exists$options->{ConversionPattern}->{value}){$layout_string=$options->{ConversionPattern}->{value}}if(exists$options->{message_chomp_before_newline}){$self->{message_chomp_before_newline}=$options->{message_chomp_before_newline}->{value}}else {$self->{message_chomp_before_newline}=1}bless$self,$class;for my$f (keys%GLOBAL_USER_DEFINED_CSPECS){$self->{CSPECS}.= $f;$self->{USER_DEFINED_CSPECS}{$f}=$GLOBAL_USER_DEFINED_CSPECS{$f}}for my$f (keys %{$options->{cspec}}){$self->add_layout_cspec($f,$options->{cspec}{$f}{value})}$layout_string =~ s/\\n/\n/g;$layout_string =~ s/\\r/\r/g;$self->define($layout_string);return$self}sub define {my($self,$format)=@_;if($self->{message_chomp_before_newline}and $format =~ /%m%n/){$self->{message_chompable}=1}else {$self->{message_chompable}=0}$format =~ s/%(-?\d*(?:\.\d+)?) 
                         ([$self->{CSPECS}])
                         (?:{(.*?)})*/
                         rep($self, $1, $2, $3);
                        /gex;$self->{printformat}=$format}sub rep {my($self,$num,$op,$curlies)=@_;return "%%" if$op eq "%";if($op eq "d"){if(defined$curlies){$curlies=Log::Log4perl::DateFormat->new($curlies)}else {$curlies=Log::Log4perl::DateFormat->new("yyyy/MM/dd HH:mm:ss")}}elsif($op eq "m"){$curlies=$self->curlies_csv_parse($curlies)}push @{$self->{stack}},[$op,$curlies];$self->{info_needed}->{$op}++;return "%${num}s"}sub curlies_csv_parse {my($self,$curlies)=@_;my$data={};if(defined$curlies and length$curlies){$curlies =~ s/\s//g;for my$field (split /,/,$curlies){my($key,$value)=split /=/,$field;$data->{$key}=$value}}return$data}sub render {my($self,$message,$category,$priority,$caller_level)=@_;$caller_level=0 unless defined$caller_level;my%info=();$info{m}=$message;chomp$info{m}if$self->{message_chompable};my@results=();my$caller_offset=Log::Log4perl::caller_depth_offset($caller_level);if($self->{info_needed}->{L}or $self->{info_needed}->{F}or $self->{info_needed}->{C}or $self->{info_needed}->{l}or $self->{info_needed}->{M}or $self->{info_needed}->{T}or 0){my ($package,$filename,$line,$subroutine,$hasargs,$wantarray,$evaltext,$is_require,$hints,$bitmask)=caller($caller_offset);unless(defined$bitmask){for($package,$filename,$line,$subroutine,$hasargs,$wantarray,$evaltext,$is_require,$hints,$bitmask){$_='[undef]' unless defined $_}}$info{L}=$line;$info{F}=$filename;$info{C}=$package;if($self->{info_needed}->{M}or $self->{info_needed}->{l}or 0){my$levels_up=1;{my@callinfo=caller($caller_offset+$levels_up);if(_INTERNAL_DEBUG){callinfo_dump($caller_offset,\@callinfo)}$subroutine=$callinfo[3];if(defined$subroutine and $subroutine eq "(eval)"){print "Inside an eval, one up\n" if _INTERNAL_DEBUG;$levels_up++;redo}}$subroutine="main::" unless$subroutine;print "Subroutine is '$subroutine'\n" if _INTERNAL_DEBUG;$info{M}=$subroutine;$info{l}="$subroutine $filename ($line)"}}$info{X}="[No curlies defined]";$info{x}=Log::Log4perl::NDC->get()if$self->{info_needed}->{x};$info{c}=$category;$info{d}=1;$info{n}="\n";$info{p}=$priority;$info{P}=$$;$info{H}=$HOSTNAME;my$current_time;if($self->{info_needed}->{r}or $self->{info_needed}->{R}){if(!$TIME_HIRES_AVAILABLE_WARNED++ and !$self->{timer}->hires_available()){warn "Requested %r/%R pattern without installed Time::HiRes\n"}$current_time=[$self->{timer}->gettimeofday()]}if($self->{info_needed}->{r}){$info{r}=$self->{timer}->milliseconds($current_time)}if($self->{info_needed}->{R}){$info{R}=$self->{timer}->delta_milliseconds($current_time)}if($self->{info_needed}->{T}){local$Carp::CarpLevel=$Carp::CarpLevel + $caller_offset;my$mess=Carp::longmess();chomp($mess);$mess =~ s/(?:\A\s*at.*\n|^\s*)//mg;$mess =~ s/\n/, /g;$info{T}=$mess}$info{t}="N/A";for my$e (@{$self->{stack}}){my($op,$curlies)=@$e;my$result;if(exists$self->{USER_DEFINED_CSPECS}->{$op}){next unless$self->{info_needed}->{$op};$self->{curlies}=$curlies;$result=$self->{USER_DEFINED_CSPECS}->{$op}->($self,$message,$category,$priority,$caller_offset+1)}elsif(exists$info{$op}){$result=$info{$op};if($curlies){$result=$self->curly_action($op,$curlies,$info{$op},$self->{printformat},\@results)}else {if($op eq 'd'){$result=$info{$op}->format($self->{timer}->gettimeofday())}}}else {warn "Format %'$op' not implemented (yet)";$result="FORMAT-ERROR"}$result=$self->{undef_column_value}unless defined$result;push@results,$result}if(scalar@results==1 and !defined$results[0]){return undef}return (sprintf$self->{printformat},@results)}sub curly_action {my($self,$ops,$curlies,$data,$printformat,$results)=@_;if($ops eq "c"){$data=shrink_category($data,$curlies)}elsif($ops eq "C"){$data=shrink_category($data,$curlies)}elsif($ops eq "X"){$data=Log::Log4perl::MDC->get($curlies)}elsif($ops eq "d"){$data=$curlies->format($self->{timer}->gettimeofday())}elsif($ops eq "M"){$data=shrink_category($data,$curlies)}elsif($ops eq "m"){if(exists$curlies->{chomp}){chomp$data}if(exists$curlies->{indent}){if(defined$curlies->{indent}){$data =~ s/\n/ "\n" . (" " x $curlies->{indent})/ge}else {no warnings;my$indent=length sprintf$printformat,@$results;$data =~ s/\n/ "\n" . (" " x $indent)/ge}}}elsif($ops eq "F"){my@parts=File::Spec->splitdir($data);if(@parts > $curlies){splice@parts,0,@parts - $curlies}$data=File::Spec->catfile(@parts)}elsif($ops eq "p"){$data=substr$data,0,$curlies}return$data}sub shrink_category {my($category,$len)=@_;my@components=split /\.|::/,$category;if(@components > $len){splice@components,0,@components - $len;$category=join '.',@components}return$category}sub add_global_cspec {unless($Log::Log4perl::ALLOW_CODE_IN_CONFIG_FILE){die "\$Log::Log4perl::ALLOW_CODE_IN_CONFIG_FILE setting " ."prohibits user defined cspecs"}my ($letter,$perlcode)=@_;croak "Illegal value '$letter' in call to add_global_cspec()" unless ($letter =~ /^[a-zA-Z]$/);croak "Missing argument for perlcode for 'cspec.$letter' "."in call to add_global_cspec()" unless$perlcode;croak "Please don't redefine built-in cspecs [$CSPECS]\n"."like you do for \"cspec.$letter\"\n " if ($CSPECS =~/$letter/);if (ref$perlcode eq 'CODE'){$GLOBAL_USER_DEFINED_CSPECS{$letter}=$perlcode}elsif (!ref$perlcode){$GLOBAL_USER_DEFINED_CSPECS{$letter}=Log::Log4perl::Config::compile_if_perl($perlcode);if ($@){die qq{Compilation failed for your perl code for }.qq{"log4j.PatternLayout.cspec.$letter":\n}.qq{This is the error message: \t$@\n}.qq{This is the code that failed: \n$perlcode\n}}croak "eval'ing your perlcode for 'log4j.PatternLayout.cspec.$letter' "."doesn't return a coderef \n"."Here is the perl code: \n\t$perlcode\n " unless (ref$GLOBAL_USER_DEFINED_CSPECS{$letter}eq 'CODE')}else{croak "I don't know how to handle perlcode=$perlcode "."for 'cspec.$letter' in call to add_global_cspec()"}}sub add_layout_cspec {my ($self,$letter,$perlcode)=@_;unless($Log::Log4perl::ALLOW_CODE_IN_CONFIG_FILE){die "\$Log::Log4perl::ALLOW_CODE_IN_CONFIG_FILE setting " ."prohibits user defined cspecs"}croak "Illegal value '$letter' in call to add_layout_cspec()" unless ($letter =~ /^[a-zA-Z]$/);croak "Missing argument for perlcode for 'cspec.$letter' "."in call to add_layout_cspec()" unless$perlcode;croak "Please don't redefine built-in cspecs [$CSPECS] \n"."like you do for 'cspec.$letter'" if ($CSPECS =~/$letter/);if (ref$perlcode eq 'CODE'){$self->{USER_DEFINED_CSPECS}{$letter}=$perlcode}elsif (!ref$perlcode){$self->{USER_DEFINED_CSPECS}{$letter}=Log::Log4perl::Config::compile_if_perl($perlcode);if ($@){die qq{Compilation failed for your perl code for }.qq{"cspec.$letter":\n}.qq{This is the error message: \t$@\n}.qq{This is the code that failed: \n$perlcode\n}}croak "eval'ing your perlcode for 'cspec.$letter' "."doesn't return a coderef \n"."Here is the perl code: \n\t$perlcode\n " unless (ref$self->{USER_DEFINED_CSPECS}{$letter}eq 'CODE')}else{croak "I don't know how to handle perlcode=$perlcode "."for 'cspec.$letter' in call to add_layout_cspec()"}$self->{CSPECS}.= $letter}sub callinfo_dump {my($level,$info)=@_;my@called_by=caller(0);$called_by[1]=basename$called_by[1];print "caller($level) at $called_by[1]-$called_by[2] returned ";my@by_idx;my$i=0;for my$field (qw(package filename line subroutine hasargs wantarray evaltext is_require hints bitmask)){$by_idx[$i]=$field;$i++}$i=0;for my$value (@$info){my$field=$by_idx[$i ];print "$field=",(defined$info->[$i]? $info->[$i]: "[undef]")," ";$i++}print "\n"}1;
LOG_LOG4PERL_LAYOUT_PATTERNLAYOUT

$fatpacked{"Log/Log4perl/Layout/PatternLayout/Multiline.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_LAYOUT_PATTERNLAYOUT_MULTILINE';
  package Log::Log4perl::Layout::PatternLayout::Multiline;use base qw(Log::Log4perl::Layout::PatternLayout);sub render {my($self,$message,$category,$priority,$caller_level)=@_;my@messages=split /\r?\n/,$message;$caller_level=0 unless defined$caller_level;my$result='';for my$msg (@messages){$result .= $self->SUPER::render($msg,$category,$priority,$caller_level + 1)}return$result}1;
LOG_LOG4PERL_LAYOUT_PATTERNLAYOUT_MULTILINE

$fatpacked{"Log/Log4perl/Layout/SimpleLayout.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_LAYOUT_SIMPLELAYOUT';
  package Log::Log4perl::Layout::SimpleLayout;use 5.006;use strict;use warnings;use Log::Log4perl::Level;no strict qw(refs);use base qw(Log::Log4perl::Layout);sub new {my$class=shift;$class=ref ($class)|| $class;my$self={format=>undef,info_needed=>{},stack=>[],};bless$self,$class;return$self}sub render {my($self,$message,$category,$priority,$caller_level)=@_;return "$priority - $message\n"}1;
LOG_LOG4PERL_LAYOUT_SIMPLELAYOUT

$fatpacked{"Log/Log4perl/Level.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_LEVEL';
  package Log::Log4perl::Level;use 5.006;use strict;use warnings;use Carp;use constant ALL_INT=>0;use constant TRACE_INT=>5000;use constant DEBUG_INT=>10000;use constant INFO_INT=>20000;use constant WARN_INT=>30000;use constant ERROR_INT=>40000;use constant FATAL_INT=>50000;use constant OFF_INT=>(2 ** 31)- 1;no strict qw(refs);use vars qw(%PRIORITY %LEVELS %SYSLOG %L4P_TO_LD);%PRIORITY=();%LEVELS=()unless (%LEVELS);%SYSLOG=()unless (%SYSLOG);%L4P_TO_LD=()unless (%L4P_TO_LD);sub add_priority {my ($prio,$intval,$syslog,$log_dispatch_level)=@_;$prio=uc($prio);$PRIORITY{$prio}=$intval;$LEVELS{$intval}=$prio;$log_dispatch_level=7 unless defined$log_dispatch_level;$L4P_TO_LD{$prio}=$log_dispatch_level;$SYSLOG{$prio}=$syslog if defined($syslog)}add_priority("OFF",OFF_INT,-1,7);add_priority("FATAL",FATAL_INT,0,7);add_priority("ERROR",ERROR_INT,3,4);add_priority("WARN",WARN_INT,4,3);add_priority("INFO",INFO_INT,6,1);add_priority("DEBUG",DEBUG_INT,7,0);add_priority("TRACE",TRACE_INT,8,0);add_priority("ALL",ALL_INT,8,0);sub numerically {$a <=> $b}sub import {my($class,$namespace)=@_;if(defined$namespace){$namespace .= "::" unless$namespace =~ /::$/}else {$namespace=caller(0)."::"}for my$key (keys%PRIORITY){my$name="$namespace$key";my$value=$PRIORITY{$key};*{"$name"}=\$value;my$nameint="$namespace${key}_INT";my$func=uc($key)."_INT";*{"$nameint"}=\&$func}}sub new {}sub to_priority {my($string)=@_;if(exists$PRIORITY{$string}){return$PRIORITY{$string}}else{croak "level '$string' is not a valid error level (".join ('|',keys%PRIORITY),')'}}sub to_level {my ($priority)=@_;if (exists$LEVELS{$priority}){return$LEVELS{$priority}}else {croak("priority '$priority' is not a valid error level number (",join("|",sort numerically keys%LEVELS),"
            )")}}sub to_LogDispatch_string {my($priority)=@_;confess "do what? no priority?" unless defined$priority;my$string;if(exists$LEVELS{$priority}){$string=$LEVELS{$priority}}if($priority==$PRIORITY{WARN}){$string="WARNING"}if($priority==$PRIORITY{FATAL}){$string="EMERGENCY"}return$string}sub is_valid {my$q=shift;if ($q =~ /[A-Z]/){return exists$PRIORITY{$q}}else{return$LEVELS{$q}}}sub get_higher_level {my ($old_priority,$delta)=@_;$delta ||= 1;my$new_priority=0;for (1..$delta){for my$p (sort numerically keys%LEVELS){if ($p > $old_priority){$new_priority=$p;last}}$old_priority=$new_priority}return$new_priority}sub get_lower_level {my ($old_priority,$delta)=@_;$delta ||= 1;my$new_priority=0;for (1..$delta){for my$p (reverse sort numerically keys%LEVELS){if ($p < $old_priority){$new_priority=$p;last}}$old_priority=$new_priority}return$new_priority}sub isGreaterOrEqual {my$lval=shift;my$rval=shift;return$lval <= $rval}1;
LOG_LOG4PERL_LEVEL

$fatpacked{"Log/Log4perl/Logger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_LOGGER';
  package Log::Log4perl::Logger;use 5.006;use strict;use warnings;use Log::Log4perl;use Log::Log4perl::Level;use Log::Log4perl::Layout;use Log::Log4perl::Appender;use Log::Log4perl::Appender::String;use Log::Log4perl::Filter;use Carp;$Carp::Internal{"Log::Log4perl"}++;$Carp::Internal{"Log::Log4perl::Logger"}++;use constant _INTERNAL_DEBUG=>0;our$ROOT_LOGGER;our$LOGGERS_BY_NAME={};our%APPENDER_BY_NAME=();our$INITIALIZED=0;our$NON_INIT_WARNED;our$DIE_DEBUG=0;our$DIE_DEBUG_BUFFER="";our$STRING_APP_NAME="_l4p_warn";our$STRING_APP=Log::Log4perl::Appender->new("Log::Log4perl::Appender::String",name=>$STRING_APP_NAME);$STRING_APP->layout(Log::Log4perl::Layout::PatternLayout->new("%m"));our$STRING_APP_CODEREF=generate_coderef([[$STRING_APP_NAME,$STRING_APP]]);__PACKAGE__->reset();sub warning_render {my($logger,@message)=@_;$STRING_APP->string("");$STRING_APP_CODEREF->($logger,@message,Log::Log4perl::Level::to_level($ALL));return$STRING_APP->string()}sub cleanup {Log::Log4perl->easy_closure_global_cleanup();$LOGGERS_BY_NAME={};undef$ROOT_LOGGER;%APPENDER_BY_NAME=();undef$INITIALIZED}sub DESTROY {CORE::warn "Destroying logger $_[0] ($_[0]->{category})" if$Log::Log4perl::CHATTY_DESTROY_METHODS}sub reset {$ROOT_LOGGER=__PACKAGE__->_new("",$OFF);%APPENDER_BY_NAME=();undef$INITIALIZED;undef$NON_INIT_WARNED;Log::Log4perl::Appender::reset();for my$logger (values %$LOGGERS_BY_NAME){$logger->{appender_names}=[];next if$logger eq $ROOT_LOGGER;$logger->{level}=undef;$logger->level()}Log::Log4perl::Filter::reset()}sub _new {my($class,$category,$level)=@_;print("_new: $class/$category/",defined$level ? $level : "undef","\n")if _INTERNAL_DEBUG;die "usage: __PACKAGE__->_new(category)" unless defined$category;$category =~ s/::/./g;if(exists$LOGGERS_BY_NAME->{$category}){print "_new: exists already\n" if _INTERNAL_DEBUG;return$LOGGERS_BY_NAME->{$category}}my$self={category=>$category,num_appenders=>0,additivity=>1,level=>$level,layout=>undef,};bless$self,$class;$level ||= $self->level();$LOGGERS_BY_NAME->{$category}=$self;$self->set_output_methods;print("Created logger $self ($category)\n")if _INTERNAL_DEBUG;return$self}sub category {my ($self)=@_;return$self->{category }}sub reset_all_output_methods {print "reset_all_output_methods: \n" if _INTERNAL_DEBUG;for my$loggername (keys %$LOGGERS_BY_NAME){$LOGGERS_BY_NAME->{$loggername}->set_output_methods}$ROOT_LOGGER->set_output_methods}sub set_output_methods {my ($self)=@_;my (@appenders,%seen);my ($level)=$self->level();print "set_output_methods: $self->{category}/$level\n" if _INTERNAL_DEBUG;for(my$logger=$self;$logger;$logger=parent_logger($logger)){for my$appender_name (@{$logger->{appender_names}}){next if$seen{$appender_name}++ && $Log::Log4perl::one_message_per_appender;push (@appenders,[$appender_name,$APPENDER_BY_NAME{$appender_name},])}last unless$logger->{additivity}}my$noop=generate_noop_coderef();my$coderef=(!@appenders ? $noop : &generate_coderef(\@appenders));my%priority=%Log::Log4perl::Level::PRIORITY;for my$levelname (keys%priority){if (Log::Log4perl::Level::isGreaterOrEqual($level,$priority{$levelname})){print "  ($priority{$levelname} <= $level)\n" if _INTERNAL_DEBUG;$self->{$levelname}=$coderef;$self->{"is_$levelname"}=generate_is_xxx_coderef("1");print "Setting is_$levelname to 1\n" if _INTERNAL_DEBUG}else{print "  ($priority{$levelname} > $level)\n" if _INTERNAL_DEBUG;$self->{$levelname}=$noop;$self->{"is_$levelname"}=generate_is_xxx_coderef("0");print "Setting is_$levelname to 0\n" if _INTERNAL_DEBUG}print("  Setting [$self] $self->{category}.$levelname to ",($self->{$levelname}==$noop ? "NOOP" : ("Coderef [$coderef]: " .scalar@appenders ." appenders")),"\n")if _INTERNAL_DEBUG}}sub generate_coderef {my$appenders=shift;print "generate_coderef: ",scalar @$appenders," appenders\n" if _INTERNAL_DEBUG;my$watch_check_code=generate_watch_code("logger",1);return sub {my$logger=shift;my$level=pop;my$message;my$appenders_fired=0;$message=[map {ref $_ eq "HASH" && exists $_->{filter}&& ref $_->{filter}eq 'CODE' ? $_->{filter}->($_->{value}): ref $_ eq "CODE" ? $_->(): $_}@_];print("coderef: $logger->{category}\n")if _INTERNAL_DEBUG;if(defined$Log::Log4perl::Config::WATCHER){return unless$watch_check_code->($logger,@_,$level)}for my$a (@$appenders){my ($appender_name,$appender)=@$a;print("  Sending message '<$message->[0]>' ($level) " ."to $appender_name\n")if _INTERNAL_DEBUG;$appender->log({name=>$appender_name,level=>$Log::Log4perl::Level::L4P_TO_LD{$level},message=>$message,},$logger->{category},$level,)and $appenders_fired++}return$appenders_fired}}sub generate_noop_coderef {my$watch_delay_code;my$watch_check_code=generate_watch_code("logger",1);my$coderef;if(defined$Log::Log4perl::Config::WATCHER){$coderef=$watch_check_code}else {$coderef=sub {undef}}return$coderef}sub generate_is_xxx_coderef {my($return_token)=@_;return generate_watch_code("checker",$return_token)}sub generate_watch_code {my($type,$return_token)=@_;print "generate_watch_code:\n" if _INTERNAL_DEBUG;if(!defined$Log::Log4perl::Config::WATCHER){return sub {$return_token}}my$cond=generate_watch_conditional();return sub {print "exe_watch_code:\n" if _INTERNAL_DEBUG;if(_INTERNAL_DEBUG){print "Next check: ","$Log::Log4perl::Config::Watch::NEXT_CHECK_TIME "," Now: ",time()," Mod: ",(stat($Log::Log4perl::Config::WATCHER->file()))[9],"\n"}if($cond->()){my$init_permitted=1;if(exists$Log::Log4perl::Config::OPTS->{preinit_callback }){print "Calling preinit_callback\n" if _INTERNAL_DEBUG;$init_permitted=$Log::Log4perl::Config::OPTS->{preinit_callback }->(Log::Log4perl::Config->watcher()->file());print "Callback returned $init_permitted\n" if _INTERNAL_DEBUG}if($init_permitted){Log::Log4perl->init_and_watch()}else {return 1}my$logger=shift;my$level=pop;if($type eq "checker"){return$logger->$level()}elsif($type eq "logger"){my$methodname=lc($level);local$Log::Log4perl::caller_depth=$Log::Log4perl::caller_depth + 3;$logger=Log::Log4perl::get_logger($logger->{category});$logger->$methodname(@_);return undef}else {die "internal error: unknown type"}}else {if(_INTERNAL_DEBUG){print "Conditional returned false\n"}return$return_token}}}sub generate_watch_conditional {if(defined$Log::Log4perl::Config::Watch::SIGNAL_CAUGHT){return sub {return$Log::Log4perl::Config::Watch::SIGNAL_CAUGHT}}return sub {return (time()> $Log::Log4perl::Config::Watch::NEXT_CHECK_TIME and $Log::Log4perl::Config::WATCHER->change_detected())}}sub parent_string {my($string)=@_;if($string eq ""){return undef}my@components=split /\./,$string;if(@components==1){return ""}pop@components;return join('.',@components)}sub level {my($self,$level,$dont_reset_all)=@_;if(defined$level){croak "invalid level '$level'" unless Log::Log4perl::Level::is_valid($level);if ($level =~ /\D/){$level=Log::Log4perl::Level::to_priority($level)}$self->{level}=$level;&reset_all_output_methods unless$dont_reset_all;return$level}if(defined$self->{level}){return$self->{level}}for(my$logger=$self;$logger;$logger=parent_logger($logger)){if($logger->{category}eq ""){return$ROOT_LOGGER->{level}}if(defined$LOGGERS_BY_NAME->{$logger->{category}}->{level}){return$LOGGERS_BY_NAME->{$logger->{category}}->{level}}}die "We should never get here."}sub parent_logger {my($logger)=@_;if($logger->{category}eq ""){return undef}my$parent_class=parent_string($logger->{category});while($parent_class ne "" and !exists$LOGGERS_BY_NAME->{$parent_class}){$parent_class=parent_string($parent_class);$logger=$LOGGERS_BY_NAME->{$parent_class}}if($parent_class eq ""){$logger=$ROOT_LOGGER}else {$logger=$LOGGERS_BY_NAME->{$parent_class}}return$logger}sub get_root_logger {my($class)=@_;return$ROOT_LOGGER}sub additivity {my($self,$onoff,$no_reinit)=@_;if(defined$onoff){$self->{additivity}=$onoff}if(!$no_reinit){$self->set_output_methods()}return$self->{additivity}}sub get_logger {my($class,$category)=@_;unless(defined$ROOT_LOGGER){Carp::confess "Internal error: Root Logger not initialized."}return$ROOT_LOGGER if$category eq "";my$logger=$class->_new($category);return$logger}sub add_appender {my($self,$appender,$dont_reset_all)=@_;$INITIALIZED=1;my$appender_name=$appender->name();$self->{num_appenders}++;unless (grep{$_ eq $appender_name}@{$self->{appender_names}}){$self->{appender_names}=[sort @{$self->{appender_names}},$appender_name]}$APPENDER_BY_NAME{$appender_name}=$appender;reset_all_output_methods unless$dont_reset_all;return$appender}sub remove_appender {my($self,$appender_name,$dont_reset_all,$sloppy)=@_;my%appender_names=map {$_=>1}@{$self->{appender_names}};if(!exists$appender_names{$appender_name}){die "No such appender: $appender_name" unless$sloppy;return undef}delete$appender_names{$appender_name};$self->{num_appenders}--;$self->{appender_names}=[sort keys%appender_names];&reset_all_output_methods unless$dont_reset_all}sub eradicate_appender {shift if $_[0]eq __PACKAGE__;my($appender_name,$dont_reset_all)=@_;return 0 unless exists $APPENDER_BY_NAME{$appender_name};for my$logger (values %$LOGGERS_BY_NAME){$logger->remove_appender($appender_name,0,1)}$ROOT_LOGGER->remove_appender($appender_name,0,1);delete$APPENDER_BY_NAME{$appender_name};&reset_all_output_methods unless$dont_reset_all;return 1}sub has_appenders {my($self)=@_;return$self->{num_appenders}}sub log {my ($self,$priority,@messages)=@_;confess("log: No priority given!")unless defined($priority);$_[0]=$LOGGERS_BY_NAME->{$_[0]->{category}}if defined$Log::Log4perl::Config::WATCHER;init_warn()unless$INITIALIZED or $NON_INIT_WARNED;croak "priority $priority isn't numeric" if ($priority =~ /\D/);my$which=Log::Log4perl::Level::to_level($priority);$self->{$which}->($self,@messages,Log::Log4perl::Level::to_level($priority))}sub create_custom_level {my$level=shift || die("create_custom_level: " ."forgot to pass in a level string!");my$after=shift || die("create_custom_level: " ."forgot to pass in a level after which to " ."place the new level!");my$syslog_equiv=shift;my$log_dispatch_level=shift;die("create_custom_level must be called before init or " ."first get_logger() call")if ($INITIALIZED);my%PRIORITY=%Log::Log4perl::Level::PRIORITY;die("create_custom_level: no such level \"$after\"! Use one of: ",join(", ",sort keys%PRIORITY))unless$PRIORITY{$after};my$next_prio=Log::Log4perl::Level::get_lower_level($PRIORITY{$after},1);my$cust_prio=int(($PRIORITY{$after}+ $next_prio)/ 2);die(qq{create_custom_level: Calculated level of $cust_prio already exists!
        This should only happen if you've made some insane number of custom
        levels (like 15 one after another)
        You can usually fix this by re-arranging your code from:
        create_custom_level("cust1", X);
        create_custom_level("cust2", X);
        create_custom_level("cust3", X);
        create_custom_level("cust4", X);
        create_custom_level("cust5", X);
        into:
        create_custom_level("cust3", X);
        create_custom_level("cust5", X);
        create_custom_level("cust4", 4);
        create_custom_level("cust2", cust3);
        create_custom_level("cust1", cust2);
     })if (${Log::Log4perl::Level::LEVELS{$cust_prio}});Log::Log4perl::Level::add_priority($level,$cust_prio,$syslog_equiv,$log_dispatch_level);print("Adding prio $level at $cust_prio\n")if _INTERNAL_DEBUG;my$name="Log::Log4perl::Logger::";my$key=$level;no strict qw(refs);*{"$name$key"}=\${Log::Log4perl::Level::PRIORITY{$level}};$name=caller(0)."::";*{"$name$key"}=\${Log::Log4perl::Level::PRIORITY{$level}};use strict qw(refs);create_log_level_methods($level);return 0}sub create_log_level_methods {my$level=shift || die("create_log_level_methods: " ."forgot to pass in a level string!");my$lclevel=lc($level);my$levelint=uc($level)."_INT";my$initial_cap=ucfirst($lclevel);no strict qw(refs);*{__PACKAGE__ ."::$lclevel"}=sub {if(_INTERNAL_DEBUG){my$level_disp=(defined $_[0]->{level}? $_[0]->{level}: "[undef]");print "$lclevel: ($_[0]->{category}/$level_disp) [@_]\n"}init_warn()unless$INITIALIZED or $NON_INIT_WARNED;$_[0]->{$level}->(@_,$level)if defined $_[0]->{$level}};my$islevel="is_" .$level;my$islclevel="is_" .$lclevel;*{__PACKAGE__ ."::is_$lclevel"}=sub {$_[0]->{$islevel}->($_[0],$islclevel)};*{__PACKAGE__ ."::is".$initial_cap."Enabled"}=\&{__PACKAGE__ ."::is_$lclevel"};use strict qw(refs);return 0}for my$level (keys%Log::Log4perl::Level::PRIORITY){create_log_level_methods($level)}sub init_warn {CORE::warn "Log4perl: Seems like no initialization happened. " ."Forgot to call init()?\n";$NON_INIT_WARNED=1}sub callerline {my$message=join ('',@_);my$caller_offset=Log::Log4perl::caller_depth_offset($Log::Log4perl::caller_depth + 1);my ($pack,$file,$line)=caller($caller_offset);if (not chomp$message){$message .= " at $file line $line";if (defined&Thread::tid){my$tid=Thread->self->tid;$message .= " thread $tid" if$tid}}return ($message,"\n")}sub and_warn {my$self=shift;CORE::warn(callerline($self->warning_render(@_)))}sub and_die {my$self=shift;my$arg=$_[0];my($msg)=callerline($self->warning_render(@_));if($DIE_DEBUG){$DIE_DEBUG_BUFFER="DIE_DEBUG: $msg"}else {if($Log::Log4perl::STRINGIFY_DIE_MESSAGE){die("$msg\n")}die$arg}}sub logwarn {my$self=shift;local$Log::Log4perl::caller_depth=$Log::Log4perl::caller_depth + 1;if ($self->is_warn()){my@chomped=@_;chomp($chomped[-1]);$self->warn(@chomped)}$self->and_warn(@_)}sub logdie {my$self=shift;local$Log::Log4perl::caller_depth=$Log::Log4perl::caller_depth + 1;if ($self->is_fatal()){my@chomped=@_;chomp($chomped[-1]);$self->fatal(@chomped)}$Log::Log4perl::LOGDIE_MESSAGE_ON_STDERR ? $self->and_die(@_): exit($Log::Log4perl::LOGEXIT_CODE)}sub logexit {my$self=shift;local$Log::Log4perl::caller_depth=$Log::Log4perl::caller_depth + 1;if ($self->is_fatal()){my@chomped=@_;chomp($chomped[-1]);$self->fatal(@chomped)}exit$Log::Log4perl::LOGEXIT_CODE}sub logcluck {my$self=shift;local$Log::Log4perl::caller_depth=$Log::Log4perl::caller_depth + 1;local$Carp::CarpLevel=$Carp::CarpLevel + 1;my$msg=$self->warning_render(@_);if ($self->is_warn()){my$message=Carp::longmess($msg);for (split(/\n/,$message)){$self->warn("$_\n")}}Carp::cluck($msg)}sub logcarp {my$self=shift;local$Carp::CarpLevel=$Carp::CarpLevel + 1;local$Log::Log4perl::caller_depth=$Log::Log4perl::caller_depth + 1;my$msg=$self->warning_render(@_);if ($self->is_warn()){my$message=Carp::shortmess($msg);for (split(/\n/,$message)){$self->warn("$_\n")}}Carp::carp($msg)}sub logcroak {my$self=shift;my$arg=$_[0];my$msg=$self->warning_render(@_);local$Carp::CarpLevel=$Carp::CarpLevel + 1;local$Log::Log4perl::caller_depth=$Log::Log4perl::caller_depth + 1;if ($self->is_fatal()){my$message=Carp::shortmess($msg);for (split(/\n/,$message)){$self->fatal("$_\n")}}my$croak_msg=$arg;if($Log::Log4perl::STRINGIFY_DIE_MESSAGE){$croak_msg=$msg}$Log::Log4perl::LOGDIE_MESSAGE_ON_STDERR ? Carp::croak($croak_msg): exit($Log::Log4perl::LOGEXIT_CODE)}sub logconfess {my$self=shift;my$arg=$_[0];local$Carp::CarpLevel=$Carp::CarpLevel + 1;local$Log::Log4perl::caller_depth=$Log::Log4perl::caller_depth + 1;my$msg=$self->warning_render(@_);if ($self->is_fatal()){my$message=Carp::longmess($msg);for (split(/\n/,$message)){$self->fatal("$_\n")}}my$confess_msg=$arg;if($Log::Log4perl::STRINGIFY_DIE_MESSAGE){$confess_msg=$msg}$Log::Log4perl::LOGDIE_MESSAGE_ON_STDERR ? confess($confess_msg): exit($Log::Log4perl::LOGEXIT_CODE)}sub error_warn {my$self=shift;local$Log::Log4perl::caller_depth=$Log::Log4perl::caller_depth + 1;if ($self->is_error()){$self->error(@_)}$self->and_warn(@_)}sub error_die {my$self=shift;local$Log::Log4perl::caller_depth=$Log::Log4perl::caller_depth + 1;my$msg=$self->warning_render(@_);if ($self->is_error()){$self->error($msg)}$Log::Log4perl::LOGDIE_MESSAGE_ON_STDERR ? $self->and_die($msg): exit($Log::Log4perl::LOGEXIT_CODE)}sub more_logging {my ($self)=shift;return$self->dec_level(@_)}sub inc_level {my ($self,$delta)=@_;$delta ||= 1;$self->level(Log::Log4perl::Level::get_higher_level($self->level(),$delta));$self->set_output_methods}sub less_logging {my ($self)=shift;return$self->inc_level(@_)}sub dec_level {my ($self,$delta)=@_;$delta ||= 1;$self->level(Log::Log4perl::Level::get_lower_level($self->level(),$delta));$self->set_output_methods}1;
LOG_LOG4PERL_LOGGER

$fatpacked{"Log/Log4perl/MDC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_MDC';
  package Log::Log4perl::MDC;use 5.006;use strict;use warnings;our%MDC_HASH=();sub get {my($class,$key)=@_;if($class ne __PACKAGE__){$key=$class}if(exists$MDC_HASH{$key}){return$MDC_HASH{$key}}else {return undef}}sub put {my($class,$key,$value)=@_;if($class ne __PACKAGE__){$value=$key;$key=$class}$MDC_HASH{$key}=$value}sub remove {%MDC_HASH=();1}sub get_context {return \%MDC_HASH}1;
LOG_LOG4PERL_MDC

$fatpacked{"Log/Log4perl/NDC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_NDC';
  package Log::Log4perl::NDC;use 5.006;use strict;use warnings;our@NDC_STACK=();our$MAX_SIZE=5;sub get {if(@NDC_STACK){return join " ",@NDC_STACK}else {return "[undef]"}}sub pop {if(@NDC_STACK){return pop@NDC_STACK}else {return undef}}sub push {my($self,$text)=@_;unless(defined$text){$text=$self}if(@NDC_STACK >= $MAX_SIZE){CORE::pop(@NDC_STACK)}return push@NDC_STACK,$text}sub remove {@NDC_STACK=()}
LOG_LOG4PERL_NDC

$fatpacked{"Log/Log4perl/Resurrector.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_RESURRECTOR';
  package Log::Log4perl::Resurrector;use warnings;use strict;use if $^O eq "MSWin32","Win32";use File::Temp qw(tempfile);use File::Spec;use constant INTERNAL_DEBUG=>0;our$resurrecting='';sub import {resurrector_init()}sub resurrector_fh {my($file)=@_;local($/)=undef;open FILE,"<$file" or die "Cannot open $file";my$text=<FILE>;close FILE;print "Read ",length($text)," bytes from $file\n" if INTERNAL_DEBUG;my($tmp_fh,$tmpfile)=tempfile(UNLINK=>1);print "Opened tmpfile $tmpfile\n" if INTERNAL_DEBUG;$text =~ s/^\s*###l4p//mg;print "Text=[$text]\n" if INTERNAL_DEBUG;print$tmp_fh $text;seek$tmp_fh,0,0;return$tmp_fh}sub resurrector_loader {my ($code,$module)=@_;print "resurrector_loader called with $module\n" if INTERNAL_DEBUG;if($resurrecting eq $module){print "ignoring $module (recursion)\n" if INTERNAL_DEBUG;return undef}local$resurrecting=$module;if($module =~ m#^Log/Log4perl/Appender#){print "Ignoring $module (Log4perl-internal)\n" if INTERNAL_DEBUG;return undef}my$path=$module;if(!-f $module){$path=pm_search($module);if(!defined$path){print "File $module not found\n" if INTERNAL_DEBUG;return undef}print "File $module found in $path\n" if INTERNAL_DEBUG}print "Resurrecting module $path\n" if INTERNAL_DEBUG;my$fh=resurrector_fh($path);my$abs_path=File::Spec->rel2abs($path);print "Setting %INC entry of $module to $abs_path\n" if INTERNAL_DEBUG;$INC{$module}=$abs_path;return$fh}sub pm_search {my($pmfile)=@_;for(@INC){next if ref($_);my$path=File::Spec->catfile($_,$pmfile);return$path if -f $path}return undef}sub resurrector_init {unshift@INC,\&resurrector_loader}1;
LOG_LOG4PERL_RESURRECTOR

$fatpacked{"Log/Log4perl/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_UTIL';
  package Log::Log4perl::Util;require Exporter;our@EXPORT_OK=qw(params_check);our@ISA=qw(Exporter);use File::Spec;sub params_check {my($hash,$required,$optional)=@_;my$pkg=caller();my%hash_copy=%$hash;if(defined$required){for my$p (@$required){if(!exists$hash->{$p }or !defined$hash->{$p }){die "$pkg: Required parameter $p missing."}delete$hash_copy{$p }}}if(defined$optional){for my$p (@$optional){delete$hash_copy{$p }}if(scalar keys%hash_copy){die "$pkg: Unknown parameter: ",join(",",keys%hash_copy)}}}sub module_available {my($full_name)=@_;return 0 if$full_name =~ /[^\w:]/;$full_name =~ s#::#/#g;$full_name .= '.pm';return 1 if$INC{$full_name};eval {local$SIG{__DIE__}=sub {};require$full_name};return!$@}sub tmpfile_name {my$name=File::Spec->catfile(File::Spec->tmpdir(),'l4p-tmpfile-' ."$$-" .int(rand(9999999)));$name =~ s#\\#/#g;return$name}1;
LOG_LOG4PERL_UTIL

$fatpacked{"Log/Log4perl/Util/Semaphore.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_UTIL_SEMAPHORE';
  package Log::Log4perl::Util::Semaphore;use IPC::SysV qw(IPC_RMID IPC_CREAT IPC_EXCL SEM_UNDO IPC_NOWAIT IPC_SET IPC_STAT SETVAL);use IPC::Semaphore;use POSIX qw(EEXIST);use strict;use warnings;use constant INTERNAL_DEBUG=>0;sub new {my($class,%options)=@_;my$self={key=>undef,mode=>undef,uid=>undef,gid=>undef,destroy=>undef,semop_wait=>.1,semop_retries=>1,creator=>$$,%options,};$self->{ikey}=unpack("i",pack("A4",$self->{key}));if(defined$self->{uid}and $self->{uid}=~ /\D/){$self->{uid}=(getpwnam$self->{uid})[2]}bless$self,$class;$self->init();my@values=();for my$param (qw(mode uid gid)){push@values,$param,$self->{$param}if defined$self->{$param}}$self->semset(@values)if@values;return$self}sub init {my($self)=@_;print "Semaphore init '$self->{key}'/'$self->{ikey}'\n" if INTERNAL_DEBUG;$self->{id}=semget($self->{ikey},1,&IPC_EXCL|&IPC_CREAT|($self->{mode}||0777),);if(!defined$self->{id}and $!==EEXIST){print "Semaphore '$self->{key}' already exists\n" if INTERNAL_DEBUG;defined($self->{id}=semget($self->{ikey},1,0))or die "semget($self->{ikey}) failed: $!"}elsif($!){die "Cannot create semaphore $self->{key}/$self->{ikey} ($!)"}print "Semaphore has id $self->{id}\n" if INTERNAL_DEBUG}sub status_as_string {my($self,@values)=@_;my$sem=IPC::Semaphore->new($self->{ikey},1,0);my$values=join('/',$sem->getall());my$ncnt=$sem->getncnt(0);my$pidlast=$sem->getpid(0);my$zcnt=$sem->getzcnt(0);my$id=$sem->id();return <<EOT}sub semsetval {my($self,%keyvalues)=@_;my$sem=IPC::Semaphore->new($self->{ikey},1,0);$sem->setval(%keyvalues)}sub semset {my($self,@values)=@_;print "Setting values for semaphore $self->{key}/$self->{ikey}\n" if INTERNAL_DEBUG;my$sem=IPC::Semaphore->new($self->{ikey},1,0);$sem->set(@values)}sub semlock {my($self)=@_;my$operation=pack("s!*",0,0,0,0,1,SEM_UNDO);print "Locking semaphore '$self->{key}'\n" if INTERNAL_DEBUG;$self->semop($self->{id},$operation)}sub semunlock {my($self)=@_;print "Unlocking semaphore '$self->{key}'\n" if INTERNAL_DEBUG;semctl$self->{id},0,SETVAL,0}sub remove {my($self)=@_;print "Removing semaphore '$self->{key}/$self->{id}'\n" if INTERNAL_DEBUG;semctl ($self->{id},0,&IPC_RMID,0)or die "Removing semaphore $self->{key} failed: $!"}sub DESTROY {my($self)=@_;if($self->{destroy}&& $$==$self->{creator}){$self->remove()}}sub semop {my($self,@args)=@_;my$retries=$self->{semop_retries};my$rc;{$rc=semop($args[0],$args[1]);if(!$rc and $! =~ /temporarily unavailable/ and $retries-- > 0){$rc='undef' unless defined$rc;print "semop failed (rc=$rc), retrying\n",$self->status_as_string if INTERNAL_DEBUG;select undef,undef,undef,$self->{semop_wait};redo}}$rc or die "semop(@args) failed: $! ";$rc}1;
  Semaphore Status
  Key ...................................... $self->{key}
  iKey ..................................... $self->{ikey}
  Id ....................................... $id
  Values ................................... $values
  Processes waiting for counter increase ... $ncnt
  Processes waiting for counter to hit 0 ... $zcnt
  Last process to perform an operation ..... $pidlast
  EOT
LOG_LOG4PERL_UTIL_SEMAPHORE

$fatpacked{"Log/Log4perl/Util/TimeTracker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_UTIL_TIMETRACKER';
  package Log::Log4perl::Util::TimeTracker;use 5.006;use strict;use warnings;use Log::Log4perl::Util;use Carp;our$TIME_HIRES_AVAILABLE;BEGIN {$TIME_HIRES_AVAILABLE=0;if(Log::Log4perl::Util::module_available("Time::HiRes")){require Time::HiRes;$TIME_HIRES_AVAILABLE=1}}sub new {my$class=shift;$class=ref ($class)|| $class;my$self={reset_time=>undef,@_,};$self->{time_function}=\&_gettimeofday unless defined$self->{time_function};bless$self,$class;$self->reset();return$self}sub hires_available {return$TIME_HIRES_AVAILABLE}sub _gettimeofday {if($TIME_HIRES_AVAILABLE){return (Time::HiRes::gettimeofday())}else {return (time(),0)}}sub gettimeofday {my($self)=@_;my($seconds,$microseconds)=$self->{time_function}->();$microseconds=0 if!defined$microseconds;return($seconds,$microseconds)}sub reset {my($self)=@_;my$current_time=[$self->gettimeofday()];$self->{reset_time}=$current_time;$self->{last_call_time}=$current_time;return$current_time}sub time_diff {my($time_from,$time_to)=@_;my$seconds=$time_to->[0]- $time_from->[0];my$milliseconds=int(($time_to->[1]- $time_from->[1])/ 1000);if($milliseconds < 0){$milliseconds=1000 + $milliseconds;$seconds--}return($seconds,$milliseconds)}sub milliseconds {my($self,$current_time)=@_;$current_time=[$self->gettimeofday()]unless defined$current_time;my($seconds,$milliseconds)=time_diff($self->{reset_time},$current_time);return$seconds*1000 + $milliseconds}sub delta_milliseconds {my($self,$current_time)=@_;$current_time=[$self->gettimeofday()]unless defined$current_time;my($seconds,$milliseconds)=time_diff($self->{last_call_time},$current_time);$self->{last_call_time}=$current_time;return$seconds*1000 + $milliseconds}1;
LOG_LOG4PERL_UTIL_TIMETRACKER

$fatpacked{"Module/Build.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD';
  package Module::Build;use 5.006;use strict;use warnings;use File::Spec ();use File::Path ();use File::Basename ();use Perl::OSType ();use Module::Build::Base;our@ISA=qw(Module::Build::Base);our$VERSION='0.4231';$VERSION=eval$VERSION;sub _interpose_module {my ($self,$mod)=@_;eval "use $mod";die $@ if $@;no strict 'refs';my$top_class=$mod;while (@{"${top_class}::ISA"}){last if ${"${top_class}::ISA"}[0]eq $ISA[0];$top_class=${"${top_class}::ISA"}[0]}@{"${top_class}::ISA"}=@ISA;@ISA=($mod)}if (grep {-e File::Spec->catfile($_,qw(Module Build Platform),$^O).'.pm'}@INC){__PACKAGE__->_interpose_module("Module::Build::Platform::$^O")}elsif (my$ostype=os_type()){__PACKAGE__->_interpose_module("Module::Build::Platform::$ostype")}else {warn "Unknown OS type '$^O' - using default settings\n"}sub os_type {return Perl::OSType::os_type()}sub is_vmsish {return Perl::OSType::is_os_type('VMS')}sub is_windowsish {return Perl::OSType::is_os_type('Windows')}sub is_unixish {return Perl::OSType::is_os_type('Unix')}1;
MODULE_BUILD

$fatpacked{"Module/Build/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_BASE';
  package Module::Build::Base;use 5.006;use strict;use warnings;our$VERSION='0.4231';$VERSION=eval$VERSION;use Carp;use Cwd ();use File::Copy ();use File::Find ();use File::Path ();use File::Basename ();use File::Spec 0.82 ();use File::Compare ();use Module::Build::Dumper ();use Text::ParseWords ();use Module::Metadata;use Module::Build::Notes;use Module::Build::Config;use version;sub new {my$self=shift()->_construct(@_);$self->{invoked_action}=$self->{action}||= 'Build_PL';$self->cull_args(@ARGV);die "Too early to specify a build action '$self->{action}'.  Do 'Build $self->{action}' instead.\n" if$self->{action}&& $self->{action}ne 'Build_PL';$self->check_manifest;$self->auto_require;if(grep {!$_}$self->check_prereq,$self->check_autofeatures){$self->log_warn(<<EOF);unless ($self->dist_name eq 'Module-Build' || $ENV{PERL5_CPANPLUS_IS_RUNNING}|| $ENV{PERL5_CPAN_IS_RUNNING}){$self->log_warn("Run 'Build installdeps' to install missing prerequisites.\n\n")}}$self->{properties}{_added_to_INC}=[$self->_added_to_INC ];$self->set_bundle_inc;$self->dist_name;$self->dist_version;$self->release_status;$self->_guess_module_name unless$self->module_name;$self->_find_nested_builds;return$self}sub resume {my$package=shift;my$self=$package->_construct(@_);$self->read_config;my@added_earlier=@{$self->{properties}{_added_to_INC}|| []};@INC=($self->_added_to_INC,@added_earlier,$self->_default_INC);unless ($package->isa($self->build_class)){my$build_class=$self->build_class;my$config_dir=$self->config_dir || '_build';my$build_lib=File::Spec->catdir($config_dir,'lib');unshift(@INC,$build_lib);unless ($build_class->can('new')){eval "require $build_class; 1" or die "Failed to re-load '$build_class': $@"}return$build_class->resume(@_)}unless ($self->_perl_is_same($self->{properties}{perl})){my$perl=$self->find_perl_interpreter;die(<<"DIEFATAL")}$self->cull_args(@ARGV);unless ($self->allow_mb_mismatch){my$mb_version=$Module::Build::VERSION;if ($mb_version ne $self->{properties}{mb_version}){$self->log_warn(<<"MISMATCH")}}$self->{invoked_action}=$self->{action}||= 'build';return$self}sub new_from_context {my ($package,%args)=@_;$package->run_perl_script('Build.PL',[],[$package->unparse_args(\%args)]);return$package->resume}sub current {local@ARGV;return shift()->resume}sub _construct {my ($package,%input)=@_;my$args=delete$input{args}|| {};my$config=delete$input{config}|| {};my$self=bless {args=>{%$args},config=>Module::Build::Config->new(values=>$config),properties=>{base_dir=>$package->cwd,mb_version=>$Module::Build::VERSION,%input,},phash=>{},stash=>{},},$package;$self->_set_defaults;my ($p,$ph)=($self->{properties},$self->{phash});for (qw(notes config_data features runtime_params cleanup auto_features)){my$file=File::Spec->catfile($self->config_dir,$_);$ph->{$_}=Module::Build::Notes->new(file=>$file);$ph->{$_}->restore if -e $file;if (exists$p->{$_}){my$vals=delete$p->{$_};for my$k (sort keys %$vals){$self->$_($k,$vals->{$k})}}}$p->{perl}=$self->find_perl_interpreter or $self->log_warn("Warning: Can't locate your perl binary");my$blibdir=sub {File::Spec->catdir($p->{blib},@_)};$p->{bindoc_dirs}||= [$blibdir->("script")];$p->{libdoc_dirs}||= [$blibdir->("lib"),$blibdir->("arch")];$p->{dist_author}=[$p->{dist_author}]if defined$p->{dist_author}and not ref$p->{dist_author};$p->{requires}=delete$p->{prereq}if defined$p->{prereq};$p->{script_files}=delete$p->{scripts}if defined$p->{scripts};for ('extra_compiler_flags','extra_linker_flags'){$p->{$_}=[$self->split_like_shell($p->{$_})]if exists$p->{$_}}for ('include_dirs'){$p->{$_}=[$p->{$_}]if exists$p->{$_}&&!ref$p->{$_}}$self->add_to_cleanup(@{delete$p->{add_to_cleanup}})if$p->{add_to_cleanup};return$self}sub log_info {my$self=shift;print @_ if ref($self)&& ($self->verbose ||!$self->quiet)}sub log_verbose {my$self=shift;print @_ if ref($self)&& $self->verbose}sub log_debug {my$self=shift;print @_ if ref($self)&& $self->debug}sub log_warn {shift;if (@_ and $_[-1]!~ /\n$/){my (undef,$file,$line)=caller();warn @_," at $file line $line.\n"}else {warn @_}}sub _default_install_paths {my$self=shift;my$c=$self->{config};my$p={};my@libstyle=$c->get('installstyle')? File::Spec->splitdir($c->get('installstyle')): qw(lib perl5);my$arch=$c->get('archname');my$version=$c->get('version');my$bindoc=$c->get('installman1dir')|| undef;my$libdoc=$c->get('installman3dir')|| undef;my$binhtml=$c->get('installhtml1dir')|| $c->get('installhtmldir')|| undef;my$libhtml=$c->get('installhtml3dir')|| $c->get('installhtmldir')|| undef;$p->{install_sets}={core=>{lib=>$c->get('installprivlib'),arch=>$c->get('installarchlib'),bin=>$c->get('installbin'),script=>$c->get('installscript'),bindoc=>$bindoc,libdoc=>$libdoc,binhtml=>$binhtml,libhtml=>$libhtml,},site=>{lib=>$c->get('installsitelib'),arch=>$c->get('installsitearch'),bin=>$c->get('installsitebin')|| $c->get('installbin'),script=>$c->get('installsitescript')|| $c->get('installsitebin')|| $c->get('installscript'),bindoc=>$c->get('installsiteman1dir')|| $bindoc,libdoc=>$c->get('installsiteman3dir')|| $libdoc,binhtml=>$c->get('installsitehtml1dir')|| $binhtml,libhtml=>$c->get('installsitehtml3dir')|| $libhtml,},vendor=>{lib=>$c->get('installvendorlib'),arch=>$c->get('installvendorarch'),bin=>$c->get('installvendorbin')|| $c->get('installbin'),script=>$c->get('installvendorscript')|| $c->get('installvendorbin')|| $c->get('installscript'),bindoc=>$c->get('installvendorman1dir')|| $bindoc,libdoc=>$c->get('installvendorman3dir')|| $libdoc,binhtml=>$c->get('installvendorhtml1dir')|| $binhtml,libhtml=>$c->get('installvendorhtml3dir')|| $libhtml,},};$p->{original_prefix}={core=>$c->get('installprefixexp')|| $c->get('installprefix')|| $c->get('prefixexp')|| $c->get('prefix')|| '',site=>$c->get('siteprefixexp'),vendor=>$c->get('usevendorprefix')? $c->get('vendorprefixexp'): '',};$p->{original_prefix}{site}||= $p->{original_prefix}{core};$p->{install_base_relpaths}={lib=>['lib','perl5'],arch=>['lib','perl5',$arch],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],};$p->{prefix_relpaths}={core=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],},vendor=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],},site=>{lib=>[@libstyle,'site_perl'],arch=>[@libstyle,'site_perl',$version,$arch],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],},};return$p}sub _find_nested_builds {my$self=shift;my$r=$self->recurse_into or return;my ($file,@r);if (!ref($r)&& $r eq 'auto'){local*DH;opendir DH,$self->base_dir or die "Can't scan directory " .$self->base_dir ." for nested builds: $!";while (defined($file=readdir DH)){my$subdir=File::Spec->catdir($self->base_dir,$file);next unless -d $subdir;push@r,$subdir if -e File::Spec->catfile($subdir,'Build.PL')}}$self->recurse_into(\@r)}sub cwd {return Cwd::cwd()}sub _quote_args {my ($self,@args)=@_;my@quoted;for (@args){if (/^[^\s*?!\$<>;\\|'"\[\]\{\}]+$/){push@quoted,$_}else {s/('+)/'"$1"'/g;push@quoted,qq('$_')}}return join " ",@quoted}sub _backticks {my ($self,@cmd)=@_;if ($self->have_forkpipe){local*FH;my$pid=open*FH,"-|";if ($pid){return wantarray ? <FH> : join '',<FH>}else {die "Can't execute @cmd: $!\n" unless defined$pid;exec {$cmd[0]}@cmd}}else {my$cmd=$self->_quote_args(@cmd);return `$cmd`}}sub have_forkpipe {1}sub _perl_is_same {my ($self,$perl)=@_;my@cmd=($perl);if ($ENV{PERL_CORE}){push@cmd,'-I' .File::Spec->catdir(File::Basename::dirname($perl),'lib')}push@cmd,qw(-MConfig=myconfig -e print -e myconfig);return$self->_backticks(@cmd)eq Config->myconfig}{my$known_perl;sub find_perl_interpreter {my$self=shift;return$known_perl if defined($known_perl);return$known_perl=$self->_discover_perl_interpreter}}sub _discover_perl_interpreter {my$proto=shift;my$c=ref($proto)? $proto->{config}: 'Module::Build::Config';my$perl=$^X;my$perl_basename=File::Basename::basename($perl);my@potential_perls;push(@potential_perls,$perl)if File::Spec->file_name_is_absolute($perl);my$abs_perl=File::Spec->rel2abs($perl);push(@potential_perls,$abs_perl);if ($ENV{PERL_CORE}){require ExtUtils::CBuilder;my$perl_src=Cwd::realpath(ExtUtils::CBuilder->perl_src);if (defined($perl_src)&& length($perl_src)){my$uninstperl=File::Spec->rel2abs(File::Spec->catfile($perl_src,$perl_basename));push(@potential_perls,$uninstperl)}}else {push(@potential_perls,$c->get('perlpath'));push(@potential_perls,map File::Spec->catfile($_,$perl_basename),File::Spec->path())}my$exe=$c->get('exe_ext');for my$thisperl (@potential_perls){if (defined$exe){$thisperl .= $exe unless$thisperl =~ m/$exe$/i}if (-f $thisperl && $proto->_perl_is_same($thisperl)){return$thisperl}}my@paths=map File::Basename::dirname($_),@potential_perls;die "Can't locate the perl binary used to run this script " ."in (@paths)\n"}sub find_command {my ($self,$command)=@_;if(File::Spec->file_name_is_absolute($command)){return$self->_maybe_command($command)}else {for my$dir (File::Spec->path){my$abs=File::Spec->catfile($dir,$command);return$abs if$abs=$self->_maybe_command($abs)}}}sub _maybe_command {my($self,$file)=@_;return$file if -x $file &&!-d $file;return}sub _is_interactive {return -t STDIN && (-t STDOUT ||!(-f STDOUT || -c STDOUT))}sub _is_unattended {my$self=shift;return$ENV{PERL_MM_USE_DEFAULT}|| (!$self->_is_interactive && eof STDIN)}sub _readline {my$self=shift;return undef if$self->_is_unattended;my$answer=<STDIN>;chomp$answer if defined$answer;return$answer}sub prompt {my$self=shift;my$mess=shift or die "prompt() called without a prompt message";my@def;@def=(shift)if @_;my@dispdef=scalar(@def)? ('[',(defined($def[0])? $def[0].' ' : ''),']'): (' ','');local $|=1;print "$mess ",@dispdef;if ($self->_is_unattended &&!@def){die <<EOF}my$ans=$self->_readline();if (!defined($ans)or!length($ans)){print "$dispdef[1]\n";$ans=scalar(@def)? $def[0]: ''}return$ans}sub y_n {my$self=shift;my ($mess,$def)=@_;die "y_n() called without a prompt message" unless$mess;die "Invalid default value: y_n() default must be 'y' or 'n'" if$def && $def !~ /^[yn]/i;my$answer;while (1){$answer=$self->prompt(@_);return 1 if$answer =~ /^y/i;return 0 if$answer =~ /^n/i;local $|=1;print "Please answer 'y' or 'n'.\n"}}sub current_action {shift->{action}}sub invoked_action {shift->{invoked_action}}sub notes {shift()->{phash}{notes}->access(@_)}sub config_data {shift()->{phash}{config_data}->access(@_)}sub runtime_params {shift->{phash}{runtime_params}->read(@_ ? shift : ())}sub auto_features {shift()->{phash}{auto_features}->access(@_)}sub features {my$self=shift;my$ph=$self->{phash};if (@_){my$key=shift;if ($ph->{features}->exists($key)){return$ph->{features}->access($key,@_)}if (my$info=$ph->{auto_features}->access($key)){my$disabled;for my$type (@{$self->prereq_action_types}){next if$type eq 'description' || $type eq 'recommends' ||!exists$info->{$type};my$prereqs=$info->{$type};for my$modname (sort keys %$prereqs){my$spec=$prereqs->{$modname};my$status=$self->check_installed_status($modname,$spec);if ((!$status->{ok})xor ($type =~ /conflicts$/)){return 0}if (!eval "require $modname; 1"){return 0}}}return 1}return$ph->{features}->access($key,@_)}my%features;my%auto_features=$ph->{auto_features}->access();while (my ($name,$info)=each%auto_features){my$failures=$self->prereq_failures($info);my$disabled=grep(/^(?:\w+_)?(?:requires|conflicts)$/,keys %$failures)? 1 : 0;$features{$name}=$disabled ? 0 : 1}%features=(%features,$ph->{features}->access());return wantarray ? %features : \%features}BEGIN {*feature=\&features}sub _mb_feature {my$self=shift;if (($self->module_name || '')eq 'Module::Build'){return$self->feature(@_)}else {require Module::Build::ConfigData;return Module::Build::ConfigData->feature(@_)}}sub _warn_mb_feature_deps {my$self=shift;my$name=shift;$self->log_warn("The '$name' feature is not available.  Please install missing\n" ."feature dependencies and try again.\n".$self->_feature_deps_msg($name)."\n")}sub add_build_element {my ($self,$elem)=@_;my$elems=$self->build_elements;push @$elems,$elem unless grep {$_ eq $elem}@$elems}sub ACTION_config_data {my$self=shift;return unless$self->has_config_data;my$module_name=$self->module_name or die "The config_data feature requires that 'module_name' be set";my$notes_name=$module_name .'::ConfigData';my$notes_pm=File::Spec->catfile($self->blib,'lib',split /::/,"$notes_name.pm");return if$self->up_to_date(['Build.PL',$self->config_file('config_data'),$self->config_file('features')],$notes_pm);$self->log_verbose("Writing config notes to $notes_pm\n");File::Path::mkpath(File::Basename::dirname($notes_pm));Module::Build::Notes->write_config_data (file=>$notes_pm,module=>$module_name,config_module=>$notes_name,config_data=>scalar$self->config_data,feature=>scalar$self->{phash}{features}->access(),auto_features=>scalar$self->auto_features,)}{my%valid_properties=(__PACKAGE__,{});my%additive_properties;sub _mb_classes {my$class=ref($_[0])|| $_[0];return ($class,$class->mb_parents)}sub valid_property {my ($class,$prop)=@_;return grep exists($valid_properties{$_}{$prop}),$class->_mb_classes}sub valid_properties {return keys %{shift->valid_properties_defaults()}}sub valid_properties_defaults {my%out;for my$class (reverse shift->_mb_classes){@out{keys %{$valid_properties{$class}}}=map {$_->()}values %{$valid_properties{$class}}}return \%out}sub array_properties {map {exists$additive_properties{$_}->{ARRAY}? @{$additive_properties{$_}->{ARRAY}}: ()}shift->_mb_classes}sub hash_properties {map {exists$additive_properties{$_}->{HASH}? @{$additive_properties{$_}->{HASH}}: ()}shift->_mb_classes}sub add_property {my ($class,$property)=(shift,shift);die "Property '$property' already exists" if$class->valid_property($property);my%p=@_==1 ? (default=>shift): @_;my$type=ref$p{default};$valid_properties{$class}{$property}=$type eq 'CODE' ? $p{default}: $type eq 'HASH' ? sub {return {%{$p{default}}}}: $type eq 'ARRAY'? sub {return [@{$p{default}}]}: sub {return$p{default}};push @{$additive_properties{$class}->{$type}},$property if$type;unless ($class->can($property)){my$sub=$type eq 'HASH' ? _make_hash_accessor($property,\%p): _make_accessor($property,\%p);no strict 'refs';*{"$class\::$property"}=$sub}return$class}sub property_error {my$self=shift;die 'ERROR: ',@_}sub _set_defaults {my$self=shift;$self->{properties}{build_class}||= ref$self;$self->{properties}{orig_dir}||= $self->{properties}{base_dir};my$defaults=$self->valid_properties_defaults;for my$prop (keys %$defaults){$self->{properties}{$prop}=$defaults->{$prop}unless exists$self->{properties}{$prop}}for my$prop ($self->array_properties){$self->{properties}{$prop}=[@{$defaults->{$prop}}]unless exists$self->{properties}{$prop}}for my$prop ($self->hash_properties){$self->{properties}{$prop}={%{$defaults->{$prop}}}unless exists$self->{properties}{$prop}}}}sub _make_hash_accessor {my ($property,$p)=@_;my$check=$p->{check}|| sub {1};return sub {my$self=shift;unless(ref($self)){carp("\n$property not a class method (@_)");return}my$x=$self->{properties};return$x->{$property}unless @_;my$prop=$x->{$property};if (defined $_[0]&&!ref $_[0]){if (@_==1){return exists$prop->{$_[0]}? $prop->{$_[0]}: undef}elsif (@_ % 2==0){my%new=(%{$prop},@_);local $_=\%new;$x->{$property}=\%new if$check->($self);return$x->{$property}}else {die "Unexpected arguments for property '$property'\n"}}else {die "Unexpected arguments for property '$property'\n" if defined $_[0]&& ref $_[0]ne 'HASH';local $_=$_[0];$x->{$property}=shift if$check->($self)}}}sub _make_accessor {my ($property,$p)=@_;my$check=$p->{check}|| sub {1};return sub {my$self=shift;unless(ref($self)){carp("\n$property not a class method (@_)");return}my$x=$self->{properties};return$x->{$property}unless @_;local $_=$_[0];$x->{$property}=shift if$check->($self);return$x->{$property}}}__PACKAGE__->add_property(auto_configure_requires=>1);__PACKAGE__->add_property(blib=>'blib');__PACKAGE__->add_property(build_class=>'Module::Build');__PACKAGE__->add_property(build_elements=>[qw(PL support pm xs share_dir pod script)]);__PACKAGE__->add_property(build_script=>'Build');__PACKAGE__->add_property(build_bat=>0);__PACKAGE__->add_property(bundle_inc=>[]);__PACKAGE__->add_property(bundle_inc_preload=>[]);__PACKAGE__->add_property(config_dir=>'_build');__PACKAGE__->add_property(dynamic_config=>1);__PACKAGE__->add_property(include_dirs=>[]);__PACKAGE__->add_property(license=>'unknown');__PACKAGE__->add_property(metafile=>'META.yml');__PACKAGE__->add_property(mymetafile=>'MYMETA.yml');__PACKAGE__->add_property(metafile2=>'META.json');__PACKAGE__->add_property(mymetafile2=>'MYMETA.json');__PACKAGE__->add_property(recurse_into=>[]);__PACKAGE__->add_property(use_rcfile=>1);__PACKAGE__->add_property(create_packlist=>1);__PACKAGE__->add_property(allow_mb_mismatch=>0);__PACKAGE__->add_property(config=>undef);__PACKAGE__->add_property(test_file_exts=>['.t']);__PACKAGE__->add_property(use_tap_harness=>0);__PACKAGE__->add_property(cpan_client=>'cpan');__PACKAGE__->add_property(tap_harness_args=>{});__PACKAGE__->add_property(pureperl_only=>0);__PACKAGE__->add_property(allow_pureperl=>0);__PACKAGE__->add_property('installdirs',default=>'site',check=>sub {return 1 if /^(core|site|vendor)$/;return shift->property_error($_ eq 'perl' ? 'Perhaps you meant installdirs to be "core" rather than "perl"?' : 'installdirs must be one of "core", "site", or "vendor"');return shift->property_error("Perhaps you meant 'core'?")if $_ eq 'perl';return 0},);{__PACKAGE__->add_property(html_css=>'')}{my@prereq_action_types=qw(requires build_requires test_requires conflicts recommends);for my$type (@prereq_action_types){__PACKAGE__->add_property($type=>{})}__PACKAGE__->add_property(prereq_action_types=>\@prereq_action_types)}__PACKAGE__->add_property($_=>{})for qw(get_options install_base_relpaths install_path install_sets meta_add meta_merge original_prefix prefix_relpaths configure_requires);__PACKAGE__->add_property($_)for qw(PL_files autosplit base_dir bindoc_dirs c_source cover create_license create_makefile_pl create_readme debugger destdir dist_abstract dist_author dist_name dist_suffix dist_version dist_version_from extra_compiler_flags extra_linker_flags has_config_data install_base libdoc_dirs magic_number mb_version module_name needs_compiler orig_dir perl pm_files pod_files pollute prefix program_name quiet recursive_test_files release_status script_files scripts share_dir sign test_files verbose debug xs_files extra_manify_args);sub config {my$self=shift;my$c=ref($self)? $self->{config}: 'Module::Build::Config';return$c->all_config unless @_;my$key=shift;return$c->get($key)unless @_;my$val=shift;return$c->set($key=>$val)}sub mb_parents {my@in_stack=(shift);my%seen=($in_stack[0]=>1);my ($current,@out);while (@in_stack){next unless defined($current=shift@in_stack)&& $current->isa('Module::Build::Base');push@out,$current;next if$current eq 'Module::Build::Base';no strict 'refs';unshift@in_stack,map {my$c=$_;substr($c,0,2)="main::" if substr($c,0,2)eq '::';$seen{$c}++ ? (): $c}@{"$current\::ISA"}}shift@out;return@out}sub extra_linker_flags {shift->_list_accessor('extra_linker_flags',@_)}sub extra_compiler_flags {shift->_list_accessor('extra_compiler_flags',@_)}sub _list_accessor {(my$self,local $_)=(shift,shift);my$p=$self->{properties};$p->{$_}=[@_]if @_;$p->{$_}=[]unless exists$p->{$_};return ref($p->{$_})? $p->{$_}: [$p->{$_}]}sub subclass {my ($pack,%opts)=@_;my$build_dir='_build';$pack->delete_filetree($build_dir)if -e $build_dir;die "Must provide 'code' or 'class' option to subclass()\n" unless$opts{code}or $opts{class};$opts{code}||= '';$opts{class}||= 'MyModuleBuilder';my$filename=File::Spec->catfile($build_dir,'lib',split '::',$opts{class}).'.pm';my$filedir=File::Basename::dirname($filename);$pack->log_verbose("Creating custom builder $filename in $filedir\n");File::Path::mkpath($filedir);die "Can't create directory $filedir: $!" unless -d $filedir;open(my$fh,'>',$filename)or die "Can't create $filename: $!";print$fh <<EOF;close$fh;unshift@INC,File::Spec->catdir(File::Spec->rel2abs($build_dir),'lib');eval "use $opts{class}";die $@ if $@;return$opts{class}}sub _guess_module_name {my$self=shift;my$p=$self->{properties};return if$p->{module_name};if ($p->{dist_version_from}&& -e $p->{dist_version_from}){my$mi=Module::Metadata->new_from_file($self->dist_version_from);$p->{module_name}=$mi->name}else {my$mod_path=my$mod_name=$p->{dist_name};$mod_name =~ s{-}{::}g;$mod_path =~ s{-}{/}g;$mod_path .= ".pm";if (-e $mod_path || -e "lib/$mod_path"){$p->{module_name}=$mod_name}else {$self->log_warn(<< 'END_WARN')}}}sub dist_name {my$self=shift;my$p=$self->{properties};my$me='dist_name';return$p->{$me}if defined$p->{$me};die "Can't determine distribution name, must supply either 'dist_name' or 'module_name' parameter" unless$self->module_name;($p->{$me}=$self->module_name)=~ s/::/-/g;return$p->{$me}}sub release_status {my ($self)=@_;my$me='release_status';my$p=$self->{properties};if (!defined$p->{$me}){$p->{$me}=$self->_is_dev_version ? 'testing' : 'stable'}unless ($p->{$me}=~ qr/\A(?:stable|testing|unstable)\z/){die "Illegal value '$p->{$me}' for $me\n"}if ($p->{$me}eq 'stable' && $self->_is_dev_version){my$version=$self->dist_version;die "Illegal value '$p->{$me}' with version '$version'\n"}return$p->{$me}}sub dist_suffix {my ($self)=@_;my$p=$self->{properties};my$me='dist_suffix';return$p->{$me}if defined$p->{$me};if ($self->release_status eq 'stable'){$p->{$me}=""}else {$p->{$me}=$self->_is_dev_version ? "" : "TRIAL" }return$p->{$me}}sub dist_version_from {my ($self)=@_;my$p=$self->{properties};my$me='dist_version_from';if ($self->module_name){$p->{$me}||= join('/','lib',split(/::/,$self->module_name)).'.pm'}return$p->{$me}|| undef}sub dist_version {my ($self)=@_;my$p=$self->{properties};my$me='dist_version';return$p->{$me}if defined$p->{$me};if (my$dist_version_from=$self->dist_version_from){my$version_from=File::Spec->catfile(split(qr{/},$dist_version_from));my$pm_info=Module::Metadata->new_from_file($version_from)or die "Can't find file $version_from to determine version";$p->{$me}=$self->normalize_version($pm_info->version());unless (defined$p->{$me}){die "Can't determine distribution version from $version_from"}}die ("Can't determine distribution version, must supply either 'dist_version',\n"."'dist_version_from', or 'module_name' parameter")unless defined$p->{$me};return$p->{$me}}sub _is_dev_version {my ($self)=@_;my$dist_version=$self->dist_version;my$version_obj=eval {version->new($dist_version)};return $@ ? 0 : $version_obj->is_alpha}sub dist_author {shift->_pod_parse('author')}sub dist_abstract {shift->_pod_parse('abstract')}sub _pod_parse {my ($self,$part)=@_;my$p=$self->{properties};my$member="dist_$part";return$p->{$member}if defined$p->{$member};my$docfile=$self->_main_docfile or return;open(my$fh,'<',$docfile)or return;require Module::Build::PodParser;my$parser=Module::Build::PodParser->new(fh=>$fh);my$method="get_$part";return$p->{$member}=$parser->$method()}sub version_from_file {return Module::Metadata->new_from_file($_[1])->version()}sub find_module_by_name {return Module::Metadata->find_module_by_name(@_[1,2])}{my%unlink_list_for_pid;sub _unlink_on_exit {my$self=shift;for my$f (@_){push @{$unlink_list_for_pid{$$}},$f if -f $f}return 1}END {for my$f (map glob($_),@{$unlink_list_for_pid{$$}|| []}){next unless -e $f;File::Path::rmtree($f,0,0)}}}sub add_to_cleanup {my$self=shift;my%files=map {$self->localize_file_path($_),1}@_;$self->{phash}{cleanup}->write(\%files)}sub cleanup {my$self=shift;my$all=$self->{phash}{cleanup}->read;return wantarray ? sort keys %$all : keys %$all}sub config_file {my$self=shift;return unless -d $self->config_dir;return File::Spec->catfile($self->config_dir,@_)}sub read_config {my ($self)=@_;my$file=$self->config_file('build_params')or die "Can't find 'build_params' in " .$self->config_dir;open(my$fh,'<',$file)or die "Can't read '$file': $!";my$ref=eval do {local $/;<$fh>};die if $@;close$fh;my$c;($self->{args},$c,$self->{properties})=@$ref;$self->{config}=Module::Build::Config->new(values=>$c)}sub has_config_data {my$self=shift;return scalar grep$self->{phash}{$_}->has_data(),qw(config_data features auto_features)}sub _write_data {my ($self,$filename,$data)=@_;my$file=$self->config_file($filename);open(my$fh,'>',$file)or die "Can't create '$file': $!";unless (ref($data)){print$fh $data;return}print {$fh}Module::Build::Dumper->_data_dump($data);close$fh}sub write_config {my ($self)=@_;File::Path::mkpath($self->{properties}{config_dir});-d $self->{properties}{config_dir}or die "Can't mkdir $self->{properties}{config_dir}: $!";my@items=@{$self->prereq_action_types};$self->_write_data('prereqs',{map {$_,$self->$_()}@items });$self->_write_data('build_params',[$self->{args},$self->{config}->values_set,$self->{properties}]);$self->_write_data('magicnum',$self->magic_number(int rand 1_000_000));$self->{phash}{$_}->write()foreach qw(notes cleanup features auto_features config_data runtime_params)}{my%packlist_map=('^File::Spec'=>'Cwd','^Devel::AssertOS'=>'Devel::CheckOS',);sub _find_packlist {my ($self,$inst,$mod)=@_;my$lookup=$mod;my$packlist=eval {$inst->packlist($lookup)};if (!$packlist){while (my ($re,$new_mod)=each%packlist_map){if ($mod =~ qr/$re/){$lookup=$new_mod;$packlist=eval {$inst->packlist($lookup)};last}}}return$packlist ? $lookup : undef}sub set_bundle_inc {my$self=shift;my$bundle_inc=$self->{properties}{bundle_inc};my$bundle_inc_preload=$self->{properties}{bundle_inc_preload};return unless inc::latest->can('loaded_modules');require ExtUtils::Installed;my$inst=eval {ExtUtils::Installed->new(extra_libs=>[@INC])};if ($@){$self->log_warn(<< "EUI_ERROR");return}my@bundle_list=map {[$_,0 ]}inc::latest->loaded_modules;while(@bundle_list){my ($mod,$prereq)=@{shift@bundle_list};my$lookup=$self->_find_packlist($inst,$mod);if (!$lookup){die << "NO_PACKLIST"}else {push @{$prereq ? $bundle_inc_preload : $bundle_inc},$lookup}}}}sub check_autofeatures {my ($self)=@_;my$features=$self->auto_features;return 1 unless %$features;my$longest=sub {my@str=@_ or croak("no strings given");my@len=map({length($_)}@str);my$max=0;my$longest;for my$i (0..$#len){($max,$longest)=($len[$i],$str[$i])if($len[$i]> $max)}return($longest)};my$max_name_len=length($longest->(keys %$features));my ($num_disabled,$log_text)=(0,"\nChecking optional features...\n");for my$name (sort keys %$features){$log_text .= $self->_feature_deps_msg($name,$max_name_len)}$num_disabled=()=$log_text =~ /disabled/g;if ($num_disabled){$self->log_warn($log_text);return 0}else {$self->log_verbose($log_text);return 1}}sub _feature_deps_msg {my ($self,$name,$max_name_len)=@_;$max_name_len ||= length$name;my$features=$self->auto_features;my$info=$features->{$name};my$feature_text="$name" .'.' x ($max_name_len - length($name)+ 4);my ($log_text,$disabled)=('','');if (my$failures=$self->prereq_failures($info)){$disabled=grep(/^(?:\w+_)?(?:requires|conflicts)$/,keys %$failures)? 1 : 0;$feature_text .= $disabled ? "disabled\n" : "enabled\n";for my$type (@{$self->prereq_action_types}){next unless exists$failures->{$type};$feature_text .= "  $type:\n";my$prereqs=$failures->{$type};for my$module (sort keys %$prereqs){my$status=$prereqs->{$module};my$required=($type =~ /^(?:\w+_)?(?:requires|conflicts)$/)? 1 : 0;my$prefix=($required)? '!' : '*';$feature_text .= "    $prefix $status->{message}\n"}}}else {$feature_text .= "enabled\n"}$log_text .= $feature_text if$disabled || $self->verbose;return$log_text}sub auto_config_requires {my ($self)=@_;my$p=$self->{properties};if ($self->dist_name ne 'Module-Build' && $self->auto_configure_requires &&!exists$p->{configure_requires}{'Module::Build'}){(my$ver=$VERSION)=~ s/^(\d+\.\d\d).*$/$1/;$self->log_warn(<<EOM);$self->_add_prereq('configure_requires','Module::Build',$ver)}if (inc::latest->can('loaded_module')){for my$mod (inc::latest->loaded_modules){next if exists$p->{configure_requires}{$mod};$self->_add_prereq('configure_requires',$mod,$mod->VERSION)}}return}sub auto_require {my ($self)=@_;my$p=$self->{properties};my$xs_files=$self->find_xs_files;if (!defined$p->{needs_compiler}){if ($self->pureperl_only && $self->allow_pureperl){$self->needs_compiler(0)}else {$self->needs_compiler(keys %$xs_files || defined$self->c_source)}}if ($self->needs_compiler){$self->_add_prereq('build_requires','ExtUtils::CBuilder',0);if (!$self->have_c_compiler){$self->log_warn(<<'EOM')}}if ($self->share_dir){$self->_add_prereq('requires','File::ShareDir','1.00')}return}sub _add_prereq {my ($self,$type,$module,$version)=@_;my$p=$self->{properties};$version=0 unless defined$version;if (exists$p->{$type}{$module}){return if$self->compare_versions($version,'<=',$p->{$type}{$module})}$self->log_verbose("Adding to $type\: $module => $version\n");$p->{$type}{$module}=$version;return 1}sub prereq_failures {my ($self,$info)=@_;my@types=@{$self->prereq_action_types};$info ||= {map {$_,$self->$_()}@types};my$out;for my$type (@types){my$prereqs=$info->{$type};for my$modname (keys %$prereqs){my$spec=$prereqs->{$modname};my$status=$self->check_installed_status($modname,$spec);if ($type =~ /^(?:\w+_)?conflicts$/){next if!$status->{ok};$status->{conflicts}=delete$status->{need};$status->{message}="$modname ($status->{have}) conflicts with this distribution"}elsif ($type =~ /^(?:\w+_)?recommends$/){next if$status->{ok};$status->{message}=(!ref($status->{have})&& $status->{have}eq '<none>' ? "$modname is not installed" : "$modname ($status->{have}) is installed, but we prefer to have $spec")}else {next if$status->{ok}}$out->{$type}{$modname}=$status}}return$out}sub _enum_prereqs {my$self=shift;my%prereqs;for my$type (@{$self->prereq_action_types}){if ($self->can($type)){my$prereq=$self->$type()|| {};$prereqs{$type}=$prereq if %$prereq}}return \%prereqs}sub check_prereq {my$self=shift;my$info=$self->_enum_prereqs;return 1 unless$info;my$log_text="Checking prerequisites...\n";my$failures=$self->prereq_failures($info);if ($failures){$self->log_warn($log_text);for my$type (@{$self->prereq_action_types}){my$prereqs=$failures->{$type};$self->log_warn("  ${type}:\n")if keys %$prereqs;for my$module (sort keys %$prereqs){my$status=$prereqs->{$module};my$prefix=($type =~ /^(?:\w+_)?recommends$/)? "* " : "! ";$self->log_warn("    $prefix $status->{message}\n")}}return 0}else {$self->log_verbose($log_text ."Looks good\n\n");return 1}}sub perl_version {my ($self)=@_;return $^V ? $self->perl_version_to_float(sprintf "%vd",$^V): $]}sub perl_version_to_float {my ($self,$version)=@_;return$version if grep(/\./,$version)< 2;$version =~ s/\./../;$version =~ s/\.(\d+)/sprintf '%03d', $1/eg;return$version}sub _parse_conditions {my ($self,$spec)=@_;return ">= 0" if not defined$spec;if ($spec =~ /^\s*([\w.]+)\s*$/){return (">= $spec")}else {return split /\s*,\s*/,$spec}}sub try_require {my ($self,$modname,$spec)=@_;my$status=$self->check_installed_status($modname,defined($spec)? $spec : 0);return unless$status->{ok};my$path=$modname;$path =~ s{::}{/}g;$path .= ".pm";if (defined$INC{$path}){return 1}elsif (exists$INC{$path}){return}else {return eval "require $modname"}}sub check_installed_status {my ($self,$modname,$spec)=@_;my%status=(need=>$spec);if ($modname eq 'perl'){$status{have}=$self->perl_version}elsif (eval {no strict;$status{have}=${"${modname}::VERSION"}}){}else {my$pm_info=Module::Metadata->new_from_module($modname);unless (defined($pm_info)){@status{qw(have message) }=('<none>',"$modname is not installed");return \%status}$status{have}=eval {$pm_info->version()};if ($spec and!defined($status{have})){@status{qw(have message) }=(undef,"Couldn't find a \$VERSION in prerequisite $modname");return \%status}}my@conditions=$self->_parse_conditions($spec);for (@conditions){my ($op,$version)=/^\s*  (<=?|>=?|==|!=)  \s*  ([\w.]+)  \s*$/x or die "Invalid prerequisite condition '$_' for $modname";$version=$self->perl_version_to_float($version)if$modname eq 'perl';next if$op eq '>=' and!$version;unless ($self->compare_versions($status{have},$op,$version)){$status{message}="$modname ($status{have}) is installed, but we need version $op $version";return \%status}}$status{ok}=1;return \%status}sub compare_versions {my$self=shift;my ($v1,$op,$v2)=@_;$v1=version->new($v1)unless eval {$v1->isa('version')};my$eval_str="\$v1 $op \$v2";my$result=eval$eval_str;$self->log_warn("error comparing versions: '$eval_str' $@")if $@;return$result}sub check_installed_version {my ($self,$modname,$spec)=@_;my$status=$self->check_installed_status($modname,$spec);if ($status->{ok}){return$status->{have}if$status->{have}and "$status->{have}" ne '<none>';return '0 but true'}$@=$status->{message};return 0}sub make_executable {my$self=shift;for (@_){my$current_mode=(stat $_)[2];chmod$current_mode | oct(111),$_}}sub is_executable {my ($self,$file)=@_;return -x $file}sub _startperl {shift()->config('startperl')}sub _added_to_INC {my$self=shift;my%seen;$seen{$_}++ foreach$self->_default_INC;return grep!$seen{$_}++,@INC}{my@default_inc;sub _default_INC {my$self=shift;return@default_inc if@default_inc;local$ENV{PERL5LIB};my$perl=ref($self)? $self->perl : $self->find_perl_interpreter;my@inc=$self->_backticks($perl,'-le','print for @INC');chomp@inc;return@default_inc=@inc}}sub print_build_script {my ($self,$fh)=@_;my$build_package=$self->build_class;my$closedata="";my$config_requires;if (-f $self->metafile){my$meta=eval {$self->read_metafile($self->metafile)};$config_requires=$meta && $meta->{prereqs}{configure}{requires}{'Module::Build'}}$config_requires ||= 0;my%q=map {$_,$self->$_()}qw(config_dir base_dir);$q{base_dir}=Win32::GetShortPathName($q{base_dir})if$self->is_windowsish;$q{magic_numfile}=$self->config_file('magicnum');my@myINC=$self->_added_to_INC;for (@myINC,values%q){$_=File::Spec->canonpath($_)unless$self->is_vmsish;s/([\\\'])/\\$1/g}my$quoted_INC=join ",\n",map "     '$_'",@myINC;my$shebang=$self->_startperl;my$magic_number=$self->magic_number;my$dot_in_inc_code=$INC[-1]eq '.' ? <<'END' : '';print$fh <<EOF}sub create_mymeta {my ($self)=@_;my ($meta_obj,$mymeta);my@metafiles=($self->metafile2,$self->metafile,);my@mymetafiles=($self->mymetafile2,$self->mymetafile,);for my$f (@mymetafiles){if ($self->delete_filetree($f)){$self->log_verbose("Removed previous '$f'\n")}}if ($self->try_require("CPAN::Meta","2.142060")){for my$file (@metafiles){next unless -f $file;$meta_obj=eval {CPAN::Meta->load_file($file,{lazy_validation=>0 })};last if$meta_obj}}my$mymeta_obj;if ($meta_obj){my%updated=(%{$meta_obj->as_struct({version=>2.0 })},prereqs=>$self->_normalize_prereqs,dynamic_config=>0,generated_by=>"Module::Build version $Module::Build::VERSION",);$mymeta_obj=CPAN::Meta->new(\%updated,{lazy_validation=>0 })}else {$mymeta_obj=$self->_get_meta_object(quiet=>0,dynamic=>0,fatal=>1,auto=>0)}my@created=$self->_write_meta_files($mymeta_obj,'MYMETA');$self->log_warn("Could not create MYMETA files\n")unless@created;return 1}sub create_build_script {my ($self)=@_;$self->write_config;$self->create_mymeta;my ($build_script,$dist_name,$dist_version)=map$self->$_(),qw(build_script dist_name dist_version);if ($self->delete_filetree($build_script)){$self->log_verbose("Removed previous script '$build_script'\n")}$self->log_info("Creating new '$build_script' script for ","'$dist_name' version '$dist_version'\n");open(my$fh,'>',$build_script)or die "Can't create '$build_script': $!";$self->print_build_script($fh);close$fh;$self->make_executable($build_script);return 1}sub check_manifest {my$self=shift;return unless -e 'MANIFEST';require ExtUtils::Manifest;local ($^W,$ExtUtils::Manifest::Quiet)=(0,1);$self->log_verbose("Checking whether your kit is complete...\n");if (my@missed=ExtUtils::Manifest::manicheck()){$self->log_warn("WARNING: the following files are missing in your kit:\n","\t",join("\n\t",@missed),"\n","Please inform the author.\n\n")}else {$self->log_verbose("Looks good\n\n")}}sub dispatch {my$self=shift;local$self->{_completed_actions}={};if (@_){my ($action,%p)=@_;my$args=$p{args}? delete($p{args}): {};local$self->{invoked_action}=$action;local$self->{args}={%{$self->{args}},%$args};local$self->{properties}={%{$self->{properties}},%p};return$self->_call_action($action)}die "No build action specified" unless$self->{action};local$self->{invoked_action}=$self->{action};$self->_call_action($self->{action})}sub _call_action {my ($self,$action)=@_;return if$self->{_completed_actions}{$action}++;local$self->{action}=$action;my$method=$self->can_action($action);die "No action '$action' defined, try running the 'help' action.\n" unless$method;$self->log_debug("Starting ACTION_$action\n");my$rc=$self->$method();$self->log_debug("Finished ACTION_$action\n");return$rc}sub can_action {my ($self,$action)=@_;return$self->can("ACTION_$action")}sub cull_options {my$self=shift;my (@argv)=@_;return({},@argv)unless(ref($self));my$specs=$self->get_options;return({},@argv)unless($specs and %$specs);require Getopt::Long;my@specs;my$args={};for my$k (sort keys %$specs){my$v=$specs->{$k};die "Option specification '$k' conflicts with a " .ref$self ." option of the same name" if$self->valid_property($k);push@specs,$k .(defined$v->{type}? $v->{type}: '');push@specs,$v->{store}if exists$v->{store};$args->{$k}=$v->{default}if exists$v->{default}}local@ARGV=@argv;if (@specs){Getopt::Long::Configure('pass_through');Getopt::Long::GetOptions($args,@specs)}return$args,@ARGV}sub unparse_args {my ($self,$args)=@_;my@out;for my$k (sort keys %$args){my$v=$args->{$k};push@out,(ref$v eq 'HASH' ? map {+"--$k","$_=$v->{$_}"}sort keys %$v : ref$v eq 'ARRAY' ? map {+"--$k",$_}@$v : ("--$k",$v))}return@out}sub args {my$self=shift;return wantarray ? %{$self->{args}}: $self->{args}unless @_;my$key=shift;$self->{args}{$key}=shift if @_;return$self->{args}{$key}}sub _translate_option {my$self=shift;my$opt=shift;(my$tr_opt=$opt)=~ tr/-/_/;return$tr_opt if grep$tr_opt =~ /^(?:no_?)?$_$/,qw(create_license create_makefile_pl create_readme extra_compiler_flags extra_linker_flags install_base install_path meta_add meta_merge test_files use_rcfile use_tap_harness tap_harness_args cpan_client pureperl_only allow_pureperl);return$opt}my%singular_argument=map {($_=>1)}qw/install_base prefix destdir installdirs verbose quiet uninst debug sign/;sub _read_arg {my ($self,$args,$key,$val)=@_;$key=$self->_translate_option($key);if (exists$args->{$key}and not $singular_argument{$key}){$args->{$key}=[$args->{$key}]unless ref$args->{$key};push @{$args->{$key}},$val}else {$args->{$key}=$val}}sub _optional_arg {my$self=shift;my$opt=shift;my$argv=shift;$opt=$self->_translate_option($opt);my@bool_opts=qw(build_bat create_license create_readme pollute quiet uninst use_rcfile verbose debug sign use_tap_harness pureperl_only allow_pureperl);if (grep$opt =~ /^no[-_]?$_$/,@bool_opts){$opt =~ s/^no-?//;return ($opt,0)}return ($opt,shift(@$argv))unless grep $_ eq $opt,@bool_opts;my$arg=1;$arg=shift(@$argv)if @$argv && $argv->[0]=~ /^\d+$/;return ($opt,$arg)}sub read_args {my$self=shift;(my$args,@_)=$self->cull_options(@_);my%args=%$args;my$opt_re=qr/[\w\-]+/;my ($action,@argv);while (@_){local $_=shift;if (/^(?:--)?($opt_re)=(.*)$/){$self->_read_arg(\%args,$1,$2)}elsif (/^--($opt_re)$/){my($opt,$arg)=$self->_optional_arg($1,\@_);$self->_read_arg(\%args,$opt,$arg)}elsif (/^($opt_re)$/ and!defined($action)){$action=$1}else {push@argv,$_}}$args{ARGV}=\@argv;for ('extra_compiler_flags','extra_linker_flags'){$args{$_}=[$self->split_like_shell($args{$_})]if exists$args{$_}}for ('include_dirs'){$args{$_}=[$args{$_}]if exists$args{$_}&&!ref$args{$_}}for ($self->hash_properties,'config'){next unless exists$args{$_};my%hash;$args{$_}||= [];$args{$_}=[$args{$_}]unless ref$args{$_};for my$arg (@{$args{$_}}){$arg =~ /($opt_re)=(.*)/ or die "Malformed '$_' argument: '$arg' should be something like 'foo=bar'";$hash{$1}=$2}$args{$_}=\%hash}for my$key (qw(prefix install_base destdir)){next if!defined$args{$key};$args{$key}=$self->_detildefy($args{$key})}for my$key (qw(install_path)){next if!defined$args{$key};for my$subkey (keys %{$args{$key}}){next if!defined$args{$key}{$subkey};my$subkey_ext=$self->_detildefy($args{$key}{$subkey});if ($subkey eq 'html'){$args{$key}{binhtml}=$subkey_ext;$args{$key}{libhtml}=$subkey_ext}else {$args{$key}{$subkey}=$subkey_ext}}}if ($args{makefile_env_macros}){require Module::Build::Compat;%args=(%args,Module::Build::Compat->makefile_to_build_macros)}return \%args,$action}sub _detildefy {}sub _merge_arglist {my($self,$opts1,$opts2)=@_;$opts1 ||= {};$opts2 ||= {};my%new_opts=%$opts1;while (my ($key,$val)=each %$opts2){if (exists($opts1->{$key})){if (ref($val)eq 'HASH'){while (my ($k,$v)=each %$val){$new_opts{$key}{$k}=$v unless exists($opts1->{$key}{$k})}}}else {$new_opts{$key}=$val}}return%new_opts}sub _home_dir {my@home_dirs;push(@home_dirs,$ENV{HOME})if$ENV{HOME};push(@home_dirs,File::Spec->catpath($ENV{HOMEDRIVE},$ENV{HOMEPATH},''))if$ENV{HOMEDRIVE}&& $ENV{HOMEPATH};my@other_home_envs=qw(USERPROFILE APPDATA WINDIR SYS$LOGIN);push(@home_dirs,map$ENV{$_},grep$ENV{$_},@other_home_envs);my@real_home_dirs=grep -d,@home_dirs;return wantarray ? @real_home_dirs : shift(@real_home_dirs)}sub _find_user_config {my$self=shift;my$file=shift;for my$dir ($self->_home_dir){my$path=File::Spec->catfile($dir,$file);return$path if -e $path}return undef}sub read_modulebuildrc {my($self,$action)=@_;return ()unless$self->use_rcfile;my$modulebuildrc;if (exists($ENV{MODULEBUILDRC})&& $ENV{MODULEBUILDRC}eq 'NONE'){return ()}elsif (exists($ENV{MODULEBUILDRC})&& -e $ENV{MODULEBUILDRC}){$modulebuildrc=$ENV{MODULEBUILDRC}}elsif (exists($ENV{MODULEBUILDRC})){$self->log_warn("WARNING: Can't find resource file " ."'$ENV{MODULEBUILDRC}' defined in environment.\n" ."No options loaded\n");return ()}else {$modulebuildrc=$self->_find_user_config('.modulebuildrc');return ()unless$modulebuildrc}open(my$fh,'<',$modulebuildrc)or die "Can't open $modulebuildrc: $!";my%options;my$buffer='';while (defined(my$line=<$fh>)){chomp($line);$line =~ s/#.*$//;next unless length($line);if ($line =~ /^\S/){if ($buffer){my($action,$options)=split(/\s+/,$buffer,2);$options{$action}.= $options .' ';$buffer=''}$buffer=$line}else {$buffer .= $line}}if ($buffer){my($action,$options)=split(/\s+/,$buffer,2);$options{$action}.= $options .' '}my ($global_opts)=$self->read_args($self->split_like_shell($options{'*'}|| ''));if ($action eq 'fakeinstall' &&!exists$options{fakeinstall}){$action='install'}my ($action_opts)=$self->read_args($self->split_like_shell($options{$action}|| ''));return$self->_merge_arglist($action_opts,$global_opts)}sub merge_modulebuildrc {my($self,$action,%cmdline_opts)=@_;my%rc_opts=$self->read_modulebuildrc($action || $self->{action}|| 'build');my%new_opts=$self->_merge_arglist(\%cmdline_opts,\%rc_opts);$self->merge_args($action,%new_opts)}sub merge_args {my ($self,$action,%args)=@_;$self->{action}=$action if defined$action;my%additive=map {$_=>1}$self->hash_properties;while (my ($key,$val)=each%args){$self->{phash}{runtime_params}->access($key=>$val)if$self->valid_property($key);if ($key eq 'config'){$self->config($_=>$val->{$_})foreach keys %$val}else {my$add_to=$additive{$key}? $self->{properties}{$key}: $self->valid_property($key)? $self->{properties}: $self->{args};if ($additive{$key}){$add_to->{$_}=$val->{$_}foreach keys %$val}else {$add_to->{$key}=$val}}}}sub cull_args {my$self=shift;my@arg_list=@_;unshift@arg_list,$self->split_like_shell($ENV{PERL_MB_OPT})if$ENV{PERL_MB_OPT};my ($args,$action)=$self->read_args(@arg_list);$self->merge_args($action,%$args);$self->merge_modulebuildrc($action,%$args)}sub super_classes {my ($self,$class,$seen)=@_;$class ||= ref($self)|| $self;$seen ||= {};no strict 'refs';my@super=grep {not $seen->{$_}++}$class,@{$class .'::ISA'};return@super,map {$self->super_classes($_,$seen)}@super}sub known_actions {my ($self)=@_;my%actions;no strict 'refs';for my$class ($self->super_classes){for (keys %{$class .'::'}){$actions{$1}++ if /^ACTION_(\w+)/}}return wantarray ? sort keys%actions : \%actions}sub get_action_docs {my ($self,$action)=@_;my$actions=$self->known_actions;die "No known action '$action'" unless$actions->{$action};my ($files_found,@docs)=(0);for my$class ($self->super_classes){(my$file=$class)=~ s{::}{/}g;$file=$INC{$file .'.pm'}or next;open(my$fh,'<',$file)or next;$files_found++;local $_;while (<$fh>){last if /^=head1 ACTIONS\s/}my$style;while (<$fh>){last if /^=head1 /;if(/^=(item|head2)\s+\Q$action\E\b/){$style=$1;push@docs,$_;last}}$style or next;if($style eq 'item'){my ($found,$inlist)=(0,0);while (<$fh>){if (/^=(item|back)/){last unless$inlist}push@docs,$_;++$inlist if /^=over/;--$inlist if /^=back/}}else {while (<$fh>){last if(/^=(?:head[12]|cut)/);push@docs,$_}}}unless ($files_found){$@="Couldn't find any documentation to search";return}unless (@docs){$@="Couldn't find any docs for action '$action'";return}return join '',@docs}sub ACTION_prereq_report {my$self=shift;$self->log_info($self->prereq_report)}sub ACTION_prereq_data {my$self=shift;$self->log_info(Module::Build::Dumper->_data_dump($self->prereq_data))}sub prereq_data {my$self=shift;my@types=('configure_requires',@{$self->prereq_action_types});my$info={map {$_=>$self->$_()}grep {%{$self->$_()}}@types };return$info}sub prereq_report {my$self=shift;my$info=$self->prereq_data;my$output='';for my$type (sort keys %$info){my$prereqs=$info->{$type};$output .= "\n$type:\n";my$mod_len=2;my$ver_len=4;my%mods;for my$modname (sort keys %$prereqs){my$spec=$prereqs->{$modname};my$len=length$modname;$mod_len=$len if$len > $mod_len;$spec ||= '0';$len=length$spec;$ver_len=$len if$len > $ver_len;my$mod=$self->check_installed_status($modname,$spec);$mod->{name}=$modname;$mod->{ok}||= 0;$mod->{ok}=!$mod->{ok}if$type =~ /^(\w+_)?conflicts$/;$mods{lc$modname}=$mod}my$space=q{ } x ($mod_len - 3);my$vspace=q{ } x ($ver_len - 3);my$sline=q{-} x ($mod_len - 3);my$vline=q{-} x ($ver_len - 3);my$disposition=($type =~ /^(\w+_)?conflicts$/)? 'Clash' : 'Need';$output .= "    Module $space  $disposition $vspace  Have\n"."    ------$sline+------$vline-+----------\n";for my$k (sort keys%mods){my$mod=$mods{$k};my$space=q{ } x ($mod_len - length$k);my$vspace=q{ } x ($ver_len - length$mod->{need});my$f=$mod->{ok}? ' ' : '!';$output .= "  $f $mod->{name} $space     $mod->{need}  $vspace   ".(defined($mod->{have})? $mod->{have}: "")."\n"}}return$output}sub ACTION_help {my ($self)=@_;my$actions=$self->known_actions;if (@{$self->{args}{ARGV}}){my$msg=eval {$self->get_action_docs($self->{args}{ARGV}[0],$actions)};print $@ ? "$@\n" : $msg;return}print <<EOF;print$self->_action_listing($actions);print "\nRun `Build help <action>` for details on an individual action.\n";print "See `perldoc Module::Build` for complete documentation.\n"}sub _action_listing {my ($self,$actions)=@_;my@actions=sort keys %$actions;@actions=map$actions[($_ + ($_ % 2)* @actions)/ 2],0..$#actions;my$out='';while (my ($one,$two)=splice@actions,0,2){$out .= sprintf("  %-12s                   %-12s\n",$one,$two||'')}$out =~ s{\s*$}{}mg;return$out}sub ACTION_retest {my ($self)=@_;local@INC=@INC;@INC=grep {ref()|| -d}@INC if@INC > 100;$self->do_tests}sub ACTION_testall {my ($self)=@_;my@types;for my$action (grep {$_ ne 'all'}$self->get_test_types){push(@types,$action)}$self->generic_test(types=>['default',@types])}sub get_test_types {my ($self)=@_;my$t=$self->{properties}->{test_types};return (defined$t ? (wantarray ? sort keys %$t : keys %$t): ())}sub ACTION_test {my ($self)=@_;$self->generic_test(type=>'default')}sub generic_test {my$self=shift;(@_ % 2)and croak('Odd number of elements in argument hash');my%args=@_;my$p=$self->{properties};my@types=((exists($args{type})? $args{type}: ()),(exists($args{types})? @{$args{types}}: ()),);@types or croak "need some types of tests to check";my%test_types=(default=>$p->{test_file_exts},(defined($p->{test_types})? %{$p->{test_types}}: ()),);for my$type (@types){croak "$type not defined in test_types!" unless defined$test_types{$type }}local$p->{test_file_exts}=[map {ref $_ ? @$_ : $_}@test_types{@types}];$self->depends_on('code');local@INC=@INC;unshift@INC,(File::Spec->catdir($p->{base_dir},$self->blib,'lib'),File::Spec->catdir($p->{base_dir},$self->blib,'arch'));@INC=grep {ref()|| -d}@INC if@INC > 100;$self->do_tests}sub do_tests {my$self=shift;my$tests=$self->find_test_files;local$ENV{PERL_DL_NONLAZY}=1;if(@$tests){my$args=$self->tap_harness_args;if($self->use_tap_harness or ($args and %$args)){my$aggregate=$self->run_tap_harness($tests);if ($aggregate->has_errors){die "Errors in testing.  Cannot continue.\n"}}else {$self->run_test_harness($tests)}}else {$self->log_info("No tests defined.\n")}$self->run_visual_script}sub run_tap_harness {my ($self,$tests)=@_;require TAP::Harness::Env;my$aggregate=TAP::Harness::Env->create({lib=>[@INC],verbosity=>$self->{properties}{verbose},switches=>[$self->harness_switches ],%{$self->tap_harness_args},})->runtests(@$tests);return$aggregate}sub run_test_harness {my ($self,$tests)=@_;require Test::Harness;local$Test::Harness::verbose=$self->verbose || 0;local$Test::Harness::switches=join ' ',$self->harness_switches;Test::Harness::runtests(@$tests)}sub run_visual_script {my$self=shift;$self->run_perl_script('visual.pl','-Mblib='.$self->blib)if -e 'visual.pl'}sub harness_switches {my$self=shift;my@res;push@res,qw(-w -d) if$self->{properties}{debugger};push@res,'-MDevel::Cover' if$self->{properties}{cover};return@res}sub test_files {my$self=shift;my$p=$self->{properties};if (@_){return$p->{test_files}=(@_==1 ? shift : [@_])}return$self->find_test_files}sub expand_test_dir {my ($self,$dir)=@_;my$exts=$self->{properties}{test_file_exts};return sort map {@{$self->rscan_dir($dir,qr{^[^.].*\Q$_\E$})}}@$exts if$self->recursive_test_files;return sort map {glob File::Spec->catfile($dir,"*$_")}@$exts}sub ACTION_testdb {my ($self)=@_;local$self->{properties}{debugger}=1;$self->depends_on('test')}sub ACTION_testcover {my ($self)=@_;unless (Module::Metadata->find_module_by_name('Devel::Cover')){warn("Cannot run testcover action unless Devel::Cover is installed.\n");return}$self->add_to_cleanup('coverage','cover_db');$self->depends_on('code');if (-e 'cover_db'){my$pm_files=$self->rscan_dir (File::Spec->catdir($self->blib,'lib'),$self->file_qr('\.pm$'));my$cover_files=$self->rscan_dir('cover_db',sub {-f $_ and not /\.html$/});$self->do_system(qw(cover -delete))unless$self->up_to_date($pm_files,$cover_files)&& $self->up_to_date($self->test_files,$cover_files)}local$self->{properties}{cover}=1;$self->depends_on('test');$self->do_system('cover')}sub ACTION_code {my ($self)=@_;my$blib=$self->blib;$self->add_to_cleanup($blib);File::Path::mkpath(File::Spec->catdir($blib,'arch'));if (my$split=$self->autosplit){$self->autosplit_file($_,$blib)for ref($split)? @$split : ($split)}for my$element (@{$self->build_elements}){my$method="process_${element}_files";$method="process_files_by_extension" unless$self->can($method);$self->$method($element)}$self->depends_on('config_data')}sub ACTION_build {my$self=shift;$self->log_info("Building " .$self->dist_name ."\n");$self->depends_on('code');$self->depends_on('docs')}sub process_files_by_extension {my ($self,$ext)=@_;my$method="find_${ext}_files";my$files=$self->can($method)? $self->$method(): $self->_find_file_by_type($ext,'lib');for my$file (sort keys %$files){$self->copy_if_modified(from=>$file,to=>File::Spec->catfile($self->blib,$files->{$file}))}}sub process_support_files {my$self=shift;my$p=$self->{properties};return unless$p->{c_source};return if$self->pureperl_only && $self->allow_pureperl;my$files;if (ref($p->{c_source})eq "ARRAY"){push @{$p->{include_dirs}},@{$p->{c_source}};for my$path (@{$p->{c_source}}){push @$files,@{$self->rscan_dir($path,$self->file_qr('\.c(c|p|pp|xx|\+\+)?$'))}}}else {push @{$p->{include_dirs}},$p->{c_source};$files=$self->rscan_dir($p->{c_source},$self->file_qr('\.c(c|p|pp|xx|\+\+)?$'))}for my$file (@$files){push @{$p->{objects}},$self->compile_c($file)}}sub process_share_dir_files {my$self=shift;my$files=$self->_find_share_dir_files;return unless$files;my$share_prefix=File::Spec->catdir($self->blib,qw/lib auto share/);for my$file (sort keys %$files){$self->copy_if_modified(from=>$file,to=>File::Spec->catfile($share_prefix,$files->{$file}))}}sub _find_share_dir_files {my$self=shift;my$share_dir=$self->share_dir;return unless$share_dir;my@file_map;if ($share_dir->{dist}){my$prefix="dist/".$self->dist_name;push@file_map,$self->_share_dir_map($prefix,$share_dir->{dist})}if ($share_dir->{module}){for my$mod (sort keys %{$share_dir->{module}}){(my$altmod=$mod)=~ s{::}{-}g;my$prefix="module/$altmod";push@file_map,$self->_share_dir_map($prefix,$share_dir->{module}{$mod})}}return {@file_map }}sub _share_dir_map {my ($self,$prefix,$list)=@_;my%files;for my$dir (@$list){for my$f (@{$self->rscan_dir($dir,sub {-f})}){$f =~ s{\A.*?\Q$dir\E/}{};$files{"$dir/$f"}="$prefix/$f"}}return%files}sub process_PL_files {my ($self)=@_;my$files=$self->find_PL_files;for my$file (sort keys %$files){my$to=$files->{$file};unless ($self->up_to_date($file,$to)){$self->run_perl_script($file,[],[@$to])or die "$file failed";$self->add_to_cleanup(@$to)}}}sub process_xs_files {my$self=shift;return if$self->pureperl_only && $self->allow_pureperl;my$files=$self->find_xs_files;croak 'Can\'t build xs files under --pureperl-only' if %$files && $self->pureperl_only;for my$from (sort keys %$files){my$to=$files->{$from};unless ($from eq $to){$self->add_to_cleanup($to);$self->copy_if_modified(from=>$from,to=>$to)}$self->process_xs($to)}}sub process_pod_files {shift()->process_files_by_extension(shift())}sub process_pm_files {shift()->process_files_by_extension(shift())}sub process_script_files {my$self=shift;my$files=$self->find_script_files;return unless keys %$files;my$script_dir=File::Spec->catdir($self->blib,'script');File::Path::mkpath($script_dir);for my$file (sort keys %$files){my$result=$self->copy_if_modified($file,$script_dir,'flatten')or next;$self->fix_shebang_line($result)unless$self->is_vmsish;$self->make_executable($result)}}sub find_PL_files {my$self=shift;if (my$files=$self->{properties}{PL_files}){if (ref$files eq 'ARRAY'){return {map {$_,[/^(.*)\.PL$/]}map$self->localize_file_path($_),@$files }}elsif (ref$files eq 'HASH'){my%out;while (my ($file,$to)=each %$files){$out{$self->localize_file_path($file)}=[map$self->localize_file_path($_),ref$to ? @$to : ($to)]}return \%out}else {die "'PL_files' must be a hash reference or array reference"}}return unless -d 'lib';return {map {$_,[/^(.*)\.PL$/i ]}@{$self->rscan_dir('lib',$self->file_qr('\.PL$'))}}}sub find_pm_files {shift->_find_file_by_type('pm','lib')}sub find_pod_files {shift->_find_file_by_type('pod','lib')}sub find_xs_files {shift->_find_file_by_type('xs','lib')}sub find_script_files {my$self=shift;if (my$files=$self->script_files){return {map {$self->localize_file_path($_),$files->{$_}}keys %$files }}return {}}sub find_test_files {my$self=shift;my$p=$self->{properties};if (my$files=$p->{test_files}){$files=[sort keys %$files]if ref$files eq 'HASH';$files=[map {-d $_ ? $self->expand_test_dir($_): $_}map glob,$self->split_like_shell($files)];return [map$self->localize_file_path($_),@$files ]}else {my@tests;push@tests,'test.pl' if -e 'test.pl';push@tests,$self->expand_test_dir('t')if -e 't' and -d _;return \@tests}}sub _find_file_by_type {my ($self,$type,$dir)=@_;if (my$files=$self->{properties}{"${type}_files"}){return {map$self->localize_file_path($_),%$files }}return {}unless -d $dir;return {map {$_,$_}map$self->localize_file_path($_),grep!/\.\#/,@{$self->rscan_dir($dir,$self->file_qr("\\.$type\$"))}}}sub localize_file_path {my ($self,$path)=@_;return File::Spec->catfile(split m{/},$path)}sub localize_dir_path {my ($self,$path)=@_;return File::Spec->catdir(split m{/},$path)}sub fix_shebang_line {my ($self,@files)=@_;my$c=ref($self)? $self->{config}: 'Module::Build::Config';my ($does_shbang)=$c->get('sharpbang')=~ /^\s*\#\!/;for my$file (@files){open(my$FIXIN,'<',$file)or die "Can't process '$file': $!";local $/="\n";chomp(my$line=<$FIXIN>);next unless$line =~ s/^\s*\#!\s*//;my ($cmd,$arg)=(split(' ',$line,2),'');next unless$cmd =~ /perl/i;my$interpreter=$self->{properties}{perl};$self->log_verbose("Changing sharpbang in $file to $interpreter\n");my$shb='';$shb .= $c->get('sharpbang')."$interpreter $arg\n" if$does_shbang;open(my$FIXOUT,'>',"$file.new")or die "Can't create new $file: $!\n";local $\;undef $/;print$FIXOUT $shb,<$FIXIN>;close$FIXIN;close$FIXOUT;rename($file,"$file.bak")or die "Can't rename $file to $file.bak: $!";rename("$file.new",$file)or die "Can't rename $file.new to $file: $!";$self->delete_filetree("$file.bak")or $self->log_warn("Couldn't clean up $file.bak, leaving it there");$self->do_system($c->get('eunicefix'),$file)if$c->get('eunicefix')ne ':'}}sub ACTION_testpod {my$self=shift;$self->depends_on('docs');eval q{use Test::Pod 0.95; 1} or die "The 'testpod' action requires Test::Pod version 0.95";my@files=sort keys %{$self->_find_pods($self->libdoc_dirs)},keys %{$self->_find_pods ($self->bindoc_dirs,exclude=>[$self->file_qr('\.bat$')])}or die "Couldn't find any POD files to test\n";{package Module::Build::PodTester;Test::Pod->import(tests=>scalar@files);pod_file_ok($_)foreach@files}}sub ACTION_testpodcoverage {my$self=shift;$self->depends_on('docs');eval q{use Test::Pod::Coverage 1.00; 1} or die "The 'testpodcoverage' action requires ","Test::Pod::Coverage version 1.00";local@INC=@INC;my$p=$self->{properties};unshift(@INC,File::Spec->catdir($p->{base_dir},$self->blib,'lib'),);all_pod_coverage_ok()}sub ACTION_docs {my$self=shift;$self->depends_on('code');$self->depends_on('manpages','html')}sub _is_default_installable {my$self=shift;my$type=shift;return ($self->install_destination($type)&& ($self->install_path($type)|| $self->install_sets($self->installdirs)->{$type}))? 1 : 0}sub _is_ActivePerl {my$self=shift;unless (exists($self->{_is_ActivePerl})){$self->{_is_ActivePerl}=(eval {require ActivePerl::DocTools}|| 0)}return$self->{_is_ActivePerl}}sub _is_ActivePPM {my$self=shift;unless (exists($self->{_is_ActivePPM})){$self->{_is_ActivePPM}=(eval {require ActivePerl::PPM}|| 0)}return$self->{_is_ActivePPM}}sub ACTION_manpages {my$self=shift;return unless$self->_mb_feature('manpage_support');$self->depends_on('code');my%extra_manify_args=$self->{properties}{'extra_manify_args'}? %{$self->{properties}{'extra_manify_args'}}: ();for my$type (qw(bin lib)){next unless ($self->invoked_action eq 'manpages' || $self->_is_default_installable("${type}doc"));my$files=$self->_find_pods($self->{properties}{"${type}doc_dirs"},exclude=>[$self->file_qr('\.bat$')]);next unless %$files;my$sub=$self->can("manify_${type}_pods");$self->$sub(%extra_manify_args)if defined($sub)}}sub manify_bin_pods {my$self=shift;my%podman_args=(section=>1,@_);my$files=$self->_find_pods($self->{properties}{bindoc_dirs},exclude=>[$self->file_qr('\.bat$')]);return unless keys %$files;my$mandir=File::Spec->catdir($self->blib,'bindoc');File::Path::mkpath($mandir,0,oct(777));require Pod::Man;for my$file (sort keys %$files){my$parser=Pod::Man->new(%podman_args);my$manpage=$self->man1page_name($file).'.' .$self->config('man1ext');my$outfile=File::Spec->catfile($mandir,$manpage);next if$self->up_to_date($file,$outfile);$self->log_verbose("Manifying $file -> $outfile\n");eval {$parser->parse_from_file($file,$outfile);1}or $self->log_warn("Error creating '$outfile': $@\n");$files->{$file}=$outfile}}sub manify_lib_pods {my$self=shift;my%podman_args=(section=>3,@_);my$files=$self->_find_pods($self->{properties}{libdoc_dirs});return unless keys %$files;my$mandir=File::Spec->catdir($self->blib,'libdoc');File::Path::mkpath($mandir,0,oct(777));require Pod::Man;for my$file (sort keys %$files){my$parser=Pod::Man->new(%podman_args);my$manpage=$self->man3page_name($files->{$file}).'.' .$self->config('man3ext');my$outfile=File::Spec->catfile($mandir,$manpage);next if$self->up_to_date($file,$outfile);$self->log_verbose("Manifying $file -> $outfile\n");eval {$parser->parse_from_file($file,$outfile);1}or $self->log_warn("Error creating '$outfile': $@\n");$files->{$file}=$outfile}}sub _find_pods {my ($self,$dirs,%args)=@_;my%files;for my$spec (@$dirs){my$dir=$self->localize_dir_path($spec);next unless -e $dir;FILE: foreach my$file (@{$self->rscan_dir($dir)}){for my$regexp (@{$args{exclude}}){next FILE if$file =~ $regexp}$file=$self->localize_file_path($file);$files{$file}=File::Spec->abs2rel($file,$dir)if$self->contains_pod($file)}}return \%files}sub contains_pod {my ($self,$file)=@_;return '' unless -T $file;open(my$fh,'<',$file)or die "Can't open $file: $!";while (my$line=<$fh>){return 1 if$line =~ /^\=(?:head|pod|item)/}return ''}sub ACTION_html {my$self=shift;return unless$self->_mb_feature('HTML_support');$self->depends_on('code');for my$type (qw(bin lib)){next unless ($self->invoked_action eq 'html' || $self->_is_default_installable("${type}html"));$self->htmlify_pods($type)}}sub htmlify_pods {my$self=shift;my$type=shift;my$htmldir=shift || File::Spec->catdir($self->blib,"${type}html");$self->add_to_cleanup('pod2htm*');my$pods=$self->_find_pods($self->{properties}{"${type}doc_dirs"},exclude=>[$self->file_qr('\.(?:bat|com|html)$')]);return unless %$pods;unless (-d $htmldir){File::Path::mkpath($htmldir,0,oct(755))or die "Couldn't mkdir $htmldir: $!"}my@rootdirs=($type eq 'bin')? qw(bin) : $self->installdirs eq 'core' ? qw(lib) : qw(site lib);my$podroot=$ENV{PERL_CORE}? File::Basename::dirname($ENV{PERL_CORE}): $self->original_prefix('core');my$htmlroot=$self->install_sets('core')->{libhtml};my$podpath;unless (defined$self->args('html_links')and!$self->args('html_links')){my@podpath=((map {File::Spec->abs2rel($_,$podroot)}grep {-d}($self->install_sets('core','lib'),$self->install_sets('core','bin'),$self->install_sets('site','lib'),)),File::Spec->rel2abs($self->blib));$podpath=$ENV{PERL_CORE}? File::Spec->catdir($podroot,'lib'): join(":",map {tr,:\\,|/,;$_}@podpath)}my$blibdir=join('/',File::Spec->splitdir((File::Spec->splitpath(File::Spec->rel2abs($htmldir),1))[1]),'');my ($with_ActiveState,$htmltool);if ($with_ActiveState=$self->_is_ActivePerl && eval {require ActivePerl::DocTools::Pod;1}){my$tool_v=ActiveState::DocTools::Pod->VERSION;$htmltool="ActiveState::DocTools::Pod";$htmltool .= " $tool_v" if$tool_v && length$tool_v}else {require Module::Build::PodParser;require Pod::Html;$htmltool="Pod::Html " .Pod::Html->VERSION}$self->log_verbose("Converting Pod to HTML with $htmltool\n");my$errors=0;POD: foreach my$pod (sort keys %$pods){my ($name,$path)=File::Basename::fileparse($pods->{$pod},$self->file_qr('\.(?:pm|plx?|pod)$'));my@dirs=File::Spec->splitdir(File::Spec->canonpath($path));pop(@dirs)if scalar(@dirs)&& $dirs[-1]eq File::Spec->curdir;my$fulldir=File::Spec->catdir($htmldir,@rootdirs,@dirs);my$tmpfile=File::Spec->catfile($fulldir,"${name}.tmp");my$outfile=File::Spec->catfile($fulldir,"${name}.html");my$infile=File::Spec->abs2rel($pod);next if$self->up_to_date($infile,$outfile);unless (-d $fulldir){File::Path::mkpath($fulldir,0,oct(755))or die "Couldn't mkdir $fulldir: $!"}$self->log_verbose("HTMLifying $infile -> $outfile\n");if ($with_ActiveState){my$depth=@rootdirs + @dirs;my%opts=(infile=>$infile,outfile=>$tmpfile,(defined($podpath)? (podpath=>$podpath): ()),podroot=>$podroot,index=>1,depth=>$depth,);eval {ActivePerl::DocTools::Pod::pod2html(map {($_,$opts{$_})}sort keys%opts);1}or $self->log_warn("[$htmltool] pod2html (" .join(", ",map {"q{$_} => q{$opts{$_}}"}(sort keys%opts)).") failed: $@")}else {my$path2root=File::Spec->catdir((File::Spec->updir)x @dirs);open(my$fh,'<',$infile)or die "Can't read $infile: $!";my$abstract=Module::Build::PodParser->new(fh=>$fh)->get_abstract();my$title=join('::',(@dirs,$name));$title .= " - $abstract" if$abstract;my@opts=("--title=$title",(defined($podpath)? "--podpath=$podpath" : ()),"--infile=$infile","--outfile=$tmpfile","--podroot=$podroot",($path2root ? "--htmlroot=$path2root" : ()),);unless (eval{Pod::Html->VERSION(1.12)}){push(@opts,('--flush'))}if (eval{Pod::Html->VERSION(1.12)}){push(@opts,('--header','--backlink'))}elsif (eval{Pod::Html->VERSION(1.03)}){push(@opts,('--header','--backlink=Back to Top'))}$self->log_verbose("P::H::pod2html @opts\n");{my$orig=Cwd::getcwd();eval {Pod::Html::pod2html(@opts);1}or $self->log_warn("[$htmltool] pod2html( " .join(", ",map {"q{$_}"}@opts).") failed: $@");chdir($orig)}}if (!-r $tmpfile){$errors++;next POD}open(my$fh,'<',$tmpfile)or die "Can't read $tmpfile: $!";my$html=join('',<$fh>);close$fh;if (!$self->_is_ActivePerl){$html =~ s#^<!DOCTYPE .*?>#<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">#im;$html =~ s#<html xmlns="http://www.w3.org/1999/xhtml">#<html>#i;$html =~ s#<head>#<head>\n<!-- saved from url=(0017)http://localhost/ -->#i}$html =~ s/\Q$blibdir\E//g;open($fh,'>',$outfile)or die "Can't write $outfile: $!";print$fh $html;close$fh;unlink($tmpfile)}return!$errors}sub man1page_name {my$self=shift;return File::Basename::basename(shift)}sub man3page_name {my$self=shift;my ($vol,$dirs,$file)=File::Spec->splitpath(shift);my@dirs=File::Spec->splitdir(File::Spec->canonpath($dirs));$file =~ s/\.p(?:od|m|l)\z//i;return join($self->manpage_separator,@dirs,$file)}sub manpage_separator {return '::'}sub ACTION_diff {my$self=shift;$self->depends_on('build');my$local_lib=File::Spec->rel2abs('lib');my@myINC=grep {$_ ne $local_lib}@INC;push@myINC,map$self->install_destination($_),qw(lib arch);my@flags=@{$self->{args}{ARGV}};@flags=$self->split_like_shell($self->{args}{flags}|| '')unless@flags;my$installmap=$self->install_map;delete$installmap->{read};delete$installmap->{write};my$text_suffix=$self->file_qr('\.(pm|pod)$');for my$localdir (sort keys %$installmap){my@localparts=File::Spec->splitdir($localdir);my$files=$self->rscan_dir($localdir,sub {-f});for my$file (@$files){my@parts=File::Spec->splitdir($file);@parts=@parts[@localparts .. $#parts];my$installed=Module::Metadata->find_module_by_name(join('::',@parts),\@myINC);if (not $installed){print "Only in lib: $file\n";next}my$status=File::Compare::compare($installed,$file);next if$status==0;die "Can't compare $installed and $file: $!" if$status==-1;if ($file =~ $text_suffix){$self->do_system('diff',@flags,$installed,$file)}else {print "Binary files $file and $installed differ\n"}}}}sub ACTION_pure_install {shift()->depends_on('install')}sub ACTION_install {my ($self)=@_;require ExtUtils::Install;$self->depends_on('build');$self->_do_in_dir(".",sub {ExtUtils::Install::install($self->install_map,$self->verbose,0,$self->{args}{uninst}||0)});if ($self->_is_ActivePerl && $self->{_completed_actions}{html}){$self->log_info("Building ActivePerl Table of Contents\n");eval {ActivePerl::DocTools::WriteTOC(verbose=>$self->verbose ? 1 : 0);1}or $self->log_warn("AP::DT:: WriteTOC() failed: $@")}if ($self->_is_ActivePPM){my$F_perllocal=File::Spec->catfile($self->install_sets('core','lib'),'perllocal.pod');my$dt_stamp=time;$self->log_info("For ActivePerl's PPM: touch '$F_perllocal'\n");open my$perllocal,">>",$F_perllocal;close$perllocal;utime($dt_stamp,$dt_stamp,$F_perllocal)}}sub ACTION_fakeinstall {my ($self)=@_;require ExtUtils::Install;my$eui_version=ExtUtils::Install->VERSION;if ($eui_version < 1.32){$self->log_warn("The 'fakeinstall' action requires Extutils::Install 1.32 or later.\n" ."(You only have version $eui_version).");return}$self->depends_on('build');ExtUtils::Install::install($self->install_map,!$self->quiet,1,$self->{args}{uninst}||0)}sub ACTION_versioninstall {my ($self)=@_;die "You must have only.pm 0.25 or greater installed for this operation: $@\n" unless eval {require only;'only'->VERSION(0.25);1};$self->depends_on('build');my%onlyargs=map {exists($self->{args}{$_})? ($_=>$self->{args}{$_}): ()}qw(version versionlib);only::install::install(%onlyargs)}sub ACTION_installdeps {my ($self)=@_;my$info=$self->_enum_prereqs;if (!$info){$self->log_info("No prerequisites detected\n");return}my$failures=$self->prereq_failures($info);if (!$failures){$self->log_info("All prerequisites satisfied\n");return}my@install;for my$type (sort keys %$failures){my$prereqs=$failures->{$type};if($type =~ m/^(?:\w+_)?requires$/){push(@install,sort keys %$prereqs);next}$self->log_info("Checking optional dependencies:\n");for my$module (sort keys %$prereqs){push(@install,$module)if($self->y_n("Install $module?",'y'))}}return unless@install;my ($command,@opts)=$self->split_like_shell($self->cpan_client);if (!File::Spec->file_name_is_absolute($command)){my@loc=('site','vendor','');my@bindirs=File::Basename::dirname($self->perl);push@bindirs,map {($self->config->{"install${_}bin"},$self->config->{"install${_}script"})}@loc;for my$d (@bindirs){my$abs_cmd=$self->find_command(File::Spec->catfile($d,$command));if (defined$abs_cmd){$command=$abs_cmd;last}}}$self->do_system($command,@opts,@install)}sub ACTION_clean {my ($self)=@_;$self->log_info("Cleaning up build files\n");for my$item (map glob($_),$self->cleanup){$self->delete_filetree($item)}}sub ACTION_realclean {my ($self)=@_;$self->depends_on('clean');$self->log_info("Cleaning up configuration files\n");$self->delete_filetree($self->config_dir,$self->mymetafile,$self->mymetafile2,$self->build_script)}sub ACTION_ppd {my ($self)=@_;require Module::Build::PPMMaker;my$ppd=Module::Build::PPMMaker->new();my$file=$ppd->make_ppd(%{$self->{args}},build=>$self);$self->add_to_cleanup($file)}sub ACTION_ppmdist {my ($self)=@_;$self->depends_on('build');my$ppm=$self->ppm_name;$self->delete_filetree($ppm);$self->log_info("Creating $ppm\n");$self->add_to_cleanup($ppm,"$ppm.tar.gz");my%types=(lib=>'lib',arch=>'arch',bin=>'bin',script=>'script',bindoc=>'man1',libdoc=>'man3',binhtml=>undef,libhtml=>undef,);for my$type ($self->install_types){next if exists($types{$type})&&!defined($types{$type});my$dir=File::Spec->catdir($self->blib,$type);next unless -e $dir;my$files=$self->rscan_dir($dir);for my$file (@$files){next unless -f $file;my$rel_file=File::Spec->abs2rel(File::Spec->rel2abs($file),File::Spec->rel2abs($dir));my$to_file=File::Spec->catfile($ppm,'blib',exists($types{$type})? $types{$type}: $type,$rel_file);$self->copy_if_modified(from=>$file,to=>$to_file)}}for my$type (qw(bin lib)){$self->htmlify_pods($type,File::Spec->catdir($ppm,'blib','html'))}my$target=File::Spec->catfile(File::Spec->updir,$ppm);$self->_do_in_dir($ppm,sub {$self->make_tarball('blib',$target)});$self->depends_on('ppd');$self->delete_filetree($ppm)}sub ACTION_pardist {my ($self)=@_;if (not eval {require PAR::Dist;PAR::Dist->VERSION(0.17)}){$self->log_warn("In order to create .par distributions, you need to\n" ."install PAR::Dist first.");return()}$self->depends_on('build');return PAR::Dist::blib_to_par(name=>$self->dist_name,version=>$self->dist_version,)}sub ACTION_dist {my ($self)=@_;$self->dispatch('distdir');my$dist_dir=$self->dist_dir;$self->make_tarball($dist_dir);$self->delete_filetree($dist_dir)}sub ACTION_distcheck {my ($self)=@_;$self->_check_manifest_skip unless$self->invoked_action eq 'distclean';require ExtUtils::Manifest;local $^W;my ($missing,$extra)=ExtUtils::Manifest::fullcheck();return unless @$missing || @$extra;my$msg="MANIFEST appears to be out of sync with the distribution\n";if ($self->invoked_action eq 'distcheck'){die$msg}else {warn$msg}}sub _check_mymeta_skip {my$self=shift;my$maniskip=shift || 'MANIFEST.SKIP';require ExtUtils::Manifest;local $^W;my$skip_factory=ExtUtils::Manifest->can('maniskip')|| ExtUtils::Manifest->can('_maniskip');my$mymetafile=$self->mymetafile;for my$file ($self->mymetafile,$self->mymetafile2){unless ($skip_factory && $skip_factory->($maniskip)->($file)){$self->log_warn("File '$maniskip' does not include '$file'. Adding it now.\n");my$safe=quotemeta($file);$self->_append_maniskip("^$safe\$",$maniskip)}}}sub _add_to_manifest {my ($self,$manifest,$lines)=@_;$lines=[$lines]unless ref$lines;my$existing_files=$self->_read_manifest($manifest);return unless defined($existing_files);@$lines=grep {!exists$existing_files->{$_}}@$lines or return;my$mode=(stat$manifest)[2];chmod($mode | oct(222),$manifest)or die "Can't make $manifest writable: $!";open(my$fh,'<',$manifest)or die "Can't read $manifest: $!";my$last_line=(<$fh>)[-1]|| "\n";my$has_newline=$last_line =~ /\n$/;close$fh;open($fh,'>>',$manifest)or die "Can't write to $manifest: $!";print$fh "\n" unless$has_newline;print$fh map "$_\n",@$lines;close$fh;chmod($mode,$manifest);$self->log_verbose(map "Added to $manifest: $_\n",@$lines)}sub _sign_dir {my ($self,$dir)=@_;unless (eval {require Module::Signature;1}){$self->log_warn("Couldn't load Module::Signature for 'distsign' action:\n $@\n");return}{my$manifest=File::Spec->catfile($dir,'MANIFEST');die "Signing a distribution requires a MANIFEST file" unless -e $manifest;$self->_add_to_manifest($manifest,"SIGNATURE    Added here by Module::Build")}$self->_do_in_dir($dir,sub {local$Module::Signature::Quiet=1;Module::Signature::sign()})}sub _do_in_dir {my ($self,$dir,$do)=@_;my$start_dir=File::Spec->rel2abs($self->cwd);chdir$dir or die "Can't chdir() to $dir: $!";eval {$do->()};my@err=$@ ? ($@): ();chdir$start_dir or push@err,"Can't chdir() back to $start_dir: $!";die join "\n",@err if@err}sub ACTION_distsign {my ($self)=@_;{local$self->{properties}{sign}=0;$self->depends_on('distdir')unless -d $self->dist_dir}$self->_sign_dir($self->dist_dir)}sub ACTION_skipcheck {my ($self)=@_;require ExtUtils::Manifest;local $^W;ExtUtils::Manifest::skipcheck()}sub ACTION_distclean {my ($self)=@_;$self->depends_on('realclean');$self->depends_on('distcheck')}sub do_create_makefile_pl {my$self=shift;require Module::Build::Compat;$self->log_info("Creating Makefile.PL\n");eval {Module::Build::Compat->create_makefile_pl($self->create_makefile_pl,$self,@_)};if ($@){1 while unlink 'Makefile.PL';die "$@\n"}$self->_add_to_manifest('MANIFEST','Makefile.PL')}sub do_create_license {my$self=shift;$self->log_info("Creating LICENSE file\n");if (!$self->_mb_feature('license_creation')){$self->_warn_mb_feature_deps('license_creation');die "Aborting.\n"}my$l=$self->license or die "Can't create LICENSE file: No license specified\n";my$license=$self->_software_license_object or die << "HERE";$self->delete_filetree('LICENSE');open(my$fh,'>','LICENSE')or die "Can't write LICENSE file: $!";print$fh $license->fulltext;close$fh;$self->_add_to_manifest('MANIFEST','LICENSE')}sub do_create_readme {my$self=shift;$self->delete_filetree('README');my$docfile=$self->_main_docfile;unless ($docfile){$self->log_warn(<<EOF);return}if (eval {require Pod::Readme;Pod::Readme->can('new')}){$self->log_info("Creating README using Pod::Readme\n");my$parser=Pod::Readme->new;$parser->parse_from_file($docfile,'README',@_)}elsif (eval {require Pod::Text;1}){$self->log_info("Creating README using Pod::Text\n");if (open(my$fh,'>','README')){local $^W=0;no strict "refs";my$old_parse_file;$old_parse_file=\&{"Pod::Simple::parse_file"}and local *{"Pod::Simple::parse_file"}=sub {my$self=shift;$self->output_fh($_[1])if $_[1];$self->$old_parse_file($_[0])}if$Pod::Text::VERSION ==3.01;Pod::Text::pod2text($docfile,$fh);close$fh}else {$self->log_warn("Cannot create 'README' file: Can't open file for writing\n");return}}else {$self->log_warn("Can't load Pod::Readme or Pod::Text to create README\n");return}$self->_add_to_manifest('MANIFEST','README')}sub _main_docfile {my$self=shift;if (my$pm_file=$self->dist_version_from){(my$pod_file=$pm_file)=~ s/.pm$/.pod/;return (-e $pod_file ? $pod_file : $pm_file)}else {return undef}}sub do_create_bundle_inc {my$self=shift;my$dist_inc=File::Spec->catdir($self->dist_dir,'inc');require inc::latest;inc::latest->write($dist_inc,@{$self->bundle_inc_preload});inc::latest->bundle_module($_,$dist_inc)for @{$self->bundle_inc};return 1}sub ACTION_distdir {my ($self)=@_;if (@{$self->bundle_inc}&&!$self->_mb_feature('inc_bundling_support')){$self->_warn_mb_feature_deps('inc_bundling_support');die "Aborting.\n"}$self->depends_on('distmeta');my$dist_files=$self->_read_manifest('MANIFEST')or die "Can't create distdir without a MANIFEST file - run 'manifest' action first.\n";delete$dist_files->{SIGNATURE};die "No files found in MANIFEST - try running 'manifest' action?\n" unless ($dist_files and keys %$dist_files);my$metafile=$self->metafile;$self->log_warn("*** Did you forget to add $metafile to the MANIFEST?\n")unless exists$dist_files->{$metafile};my$dist_dir=$self->dist_dir;$self->delete_filetree($dist_dir);$self->log_info("Creating $dist_dir\n");$self->add_to_cleanup($dist_dir);for my$file (sort keys %$dist_files){next if$file =~ m{^MYMETA\.};my$new=$self->copy_if_modified(from=>$file,to_dir=>$dist_dir,verbose=>0)}$self->do_create_bundle_inc if @{$self->bundle_inc};$self->_sign_dir($dist_dir)if$self->{properties}{sign}}sub ACTION_disttest {my ($self)=@_;$self->depends_on('distdir');$self->_do_in_dir ($self->dist_dir,sub {local$ENV{AUTHOR_TESTING}=1;local$ENV{RELEASE_TESTING}=1;$self->run_perl_script('Build.PL')or die "Error executing 'Build.PL' in dist directory: $!";$self->run_perl_script($self->build_script)or die "Error executing $self->build_script in dist directory: $!";$self->run_perl_script($self->build_script,[],['test'])or die "Error executing 'Build test' in dist directory"})}sub ACTION_distinstall {my ($self,@args)=@_;$self->depends_on('distdir');$self->_do_in_dir ($self->dist_dir,sub {$self->run_perl_script('Build.PL')or die "Error executing 'Build.PL' in dist directory: $!";$self->run_perl_script($self->build_script)or die "Error executing $self->build_script in dist directory: $!";$self->run_perl_script($self->build_script,[],['install'])or die "Error executing 'Build install' in dist directory"})}sub _eumanifest_has_include {my$self=shift;require ExtUtils::Manifest;return eval {ExtUtils::Manifest->VERSION(1.50);1}}sub _default_maniskip {my$self=shift;my$default_maniskip;for my$dir (@INC){$default_maniskip=File::Spec->catfile($dir,"ExtUtils","MANIFEST.SKIP");last if -r $default_maniskip}return$default_maniskip}sub _slurp {my$self=shift;my$file=shift;my$mode=shift || "";open my$fh,"<$mode",$file or croak "Can't open $file for reading: $!";local $/;return <$fh>}sub _spew {my$self=shift;my$file=shift;my$content=shift || "";my$mode=shift || "";open my$fh,">$mode",$file or croak "Can't open $file for writing: $!";print {$fh}$content;close$fh}sub _case_tolerant {my$self=shift;if (ref$self){$self->{_case_tolerant}=File::Spec->case_tolerant unless defined($self->{_case_tolerant});return$self->{_case_tolerant}}else {return File::Spec->case_tolerant}}sub _append_maniskip {my$self=shift;my$skip=shift;my$file=shift || 'MANIFEST.SKIP';return unless defined$skip && length$skip;open(my$fh,'>>',$file)or die "Can't open $file: $!";print$fh "$skip\n";close$fh}sub _write_default_maniskip {my$self=shift;my$file=shift || 'MANIFEST.SKIP';open(my$fh,'>',$file)or die "Can't open $file: $!";my$content=$self->_eumanifest_has_include ? "#!include_default\n" : $self->_slurp($self->_default_maniskip);$content .= <<'EOF';$content .= '\b'.$self->dist_name.'-[\d\.\_]+'."\n";print$fh $content;close$fh;return}sub _check_manifest_skip {my ($self)=@_;my$maniskip='MANIFEST.SKIP';if (!-e $maniskip){$self->log_warn("File '$maniskip' does not exist: Creating a temporary '$maniskip'\n");$self->_write_default_maniskip($maniskip);$self->_unlink_on_exit($maniskip)}else {$self->_check_mymeta_skip($maniskip)}return}sub ACTION_manifest {my ($self)=@_;$self->_check_manifest_skip;require ExtUtils::Manifest;local ($^W,$ExtUtils::Manifest::Quiet)=(0,1);ExtUtils::Manifest::mkmanifest()}sub ACTION_manifest_skip {my ($self)=@_;if (-e 'MANIFEST.SKIP'){$self->log_warn("MANIFEST.SKIP already exists.\n");return 0}$self->log_info("Creating a new MANIFEST.SKIP file\n");return$self->_write_default_maniskip;return -e 'MANIFEST.SKIP'}sub file_qr {return shift->{_case_tolerant}? qr($_[0])i : qr($_[0])}sub dist_dir {my ($self)=@_;my$dir=join "-",$self->dist_name,$self->dist_version;$dir .= "-" .$self->dist_suffix if$self->dist_suffix;return$dir}sub ppm_name {my$self=shift;return 'PPM-' .$self->dist_dir}sub _files_in {my ($self,$dir)=@_;return unless -d $dir;local*DH;opendir DH,$dir or die "Can't read directory $dir: $!";my@files;while (defined (my$file=readdir DH)){my$full_path=File::Spec->catfile($dir,$file);next if -d $full_path;push@files,$full_path}return@files}sub share_dir {my$self=shift;my$p=$self->{properties};$p->{share_dir}=shift if @_;if (!defined$p->{share_dir}){return}elsif (!ref$p->{share_dir}){$p->{share_dir}={dist=>[$p->{share_dir}]}}elsif (ref$p->{share_dir}eq 'ARRAY'){$p->{share_dir}={dist=>$p->{share_dir}}}elsif (ref$p->{share_dir}eq 'HASH'){my$share_dir=$p->{share_dir};if (defined$share_dir->{dist}){if (!ref$share_dir->{dist}){$share_dir->{dist}=[$share_dir->{dist}]}elsif (ref$share_dir->{dist}ne 'ARRAY'){die "'dist' key in 'share_dir' must be scalar or arrayref"}}if (defined$share_dir->{module}){my$mod_hash=$share_dir->{module};if (ref$mod_hash eq 'HASH'){for my$k (sort keys %$mod_hash){if (!ref$mod_hash->{$k}){$mod_hash->{$k}=[$mod_hash->{$k}]}elsif(ref$mod_hash->{$k}ne 'ARRAY'){die "modules in 'module' key of 'share_dir' must be scalar or arrayref"}}}else {die "'module' key in 'share_dir' must be hashref"}}}else {die "'share_dir' must be hashref, arrayref or string"}return$p->{share_dir}}sub script_files {my$self=shift;for ($self->{properties}{script_files}){$_=shift if @_;next unless $_;return $_ if ref $_ eq 'HASH';return $_={map {$_,1}@$_ }if ref $_ eq 'ARRAY';die "'script_files' must be a hashref, arrayref, or string" if ref();return $_={map {$_,1}$self->_files_in($_)}if -d $_;return $_={$_=>1}}my%pl_files=map {File::Spec->canonpath($_)=>1}keys %{$self->PL_files || {}};my@bin_files=$self->_files_in('bin');my%bin_map=map {$_=>File::Spec->canonpath($_)}@bin_files;return $_={map {$_=>1}grep!$pl_files{$bin_map{$_}},@bin_files }}BEGIN {*scripts=\&script_files}{my%licenses=(perl=>'Perl_5',apache=>'Apache_2_0',apache_1_1=>'Apache_1_1',artistic=>'Artistic_1',artistic_2=>'Artistic_2',lgpl=>'LGPL_2_1',lgpl2=>'LGPL_2_1',lgpl3=>'LGPL_3_0',bsd=>'BSD',gpl=>'GPL_1',gpl2=>'GPL_2',gpl3=>'GPL_3',mit=>'MIT',mozilla=>'Mozilla_1_1',restrictive=>'Restricted',open_source=>undef,unrestricted=>undef,unknown=>undef,);my%license_urls=(perl=>'http://dev.perl.org/licenses/',apache=>'http://apache.org/licenses/LICENSE-2.0',apache_1_1=>'http://apache.org/licenses/LICENSE-1.1',artistic=>'http://opensource.org/licenses/artistic-license.php',artistic_2=>'http://opensource.org/licenses/artistic-license-2.0.php',lgpl=>'http://opensource.org/licenses/lgpl-license.php',lgpl2=>'http://opensource.org/licenses/lgpl-2.1.php',lgpl3=>'http://opensource.org/licenses/lgpl-3.0.html',bsd=>'http://opensource.org/licenses/bsd-license.php',gpl=>'http://opensource.org/licenses/gpl-license.php',gpl2=>'http://opensource.org/licenses/gpl-2.0.php',gpl3=>'http://opensource.org/licenses/gpl-3.0.html',mit=>'http://opensource.org/licenses/mit-license.php',mozilla=>'http://opensource.org/licenses/mozilla1.1.php',restrictive=>undef,open_source=>undef,unrestricted=>undef,unknown=>undef,);sub valid_licenses {return \%licenses}sub _license_url {return$license_urls{$_[1]}}}sub _software_license_class {my ($self,$license)=@_;if ($self->valid_licenses->{$license}&& eval {require Software::LicenseUtils;Software::LicenseUtils->VERSION(0.103009)}){my@classes=Software::LicenseUtils->guess_license_from_meta_key($license,1);if (@classes==1){eval "require $classes[0]";return$classes[0]}}LICENSE: for my$l ($self->valid_licenses->{$license },$license){next unless defined$l;my$trial="Software::License::" .$l;if (eval "require Software::License; Software::License->VERSION(0.014); require $trial; 1"){return$trial}}return}sub _software_license_object {my ($self)=@_;return unless defined(my$license=$self->license);my$class=$self->_software_license_class($license)or return;my$author=join(" & ",@{$self->dist_author})|| 'unknown';my$sl=eval {$class->new({holder=>$author})};if ($@){$self->log_warn("Error getting '$class' object: $@")}return$sl}sub _hash_merge {my ($self,$h,$k,$v)=@_;if (ref$h->{$k}eq 'ARRAY'){push @{$h->{$k}},ref$v ? @$v : $v}elsif (ref$h->{$k}eq 'HASH'){$h->{$k}{$_}=$v->{$_}foreach keys %$v}else {$h->{$k}=$v}}sub ACTION_distmeta {my ($self)=@_;$self->do_create_makefile_pl if$self->create_makefile_pl;$self->do_create_readme if$self->create_readme;$self->do_create_license if$self->create_license;$self->do_create_metafile}sub do_create_metafile {my$self=shift;return if$self->{wrote_metadata};my$p=$self->{properties};unless ($p->{license}){$self->log_warn("No license specified, setting license = 'unknown'\n");$p->{license}='unknown'}my@metafiles=($self->metafile,$self->metafile2);$self->delete_filetree($_)for@metafiles;local@INC=@INC;if (($self->module_name || '')eq 'Module::Build'){$self->depends_on('config_data');push@INC,File::Spec->catdir($self->blib,'lib')}my$meta_obj=$self->_get_meta_object(quiet=>1,fatal=>1,auto=>1);my@created=$self->_write_meta_files($meta_obj,'META');if (@created){$self->{wrote_metadata}=1;$self->_add_to_manifest('MANIFEST',$_)for@created}return 1}sub _write_meta_files {my$self=shift;my ($meta,$file)=@_;$file =~ s{\.(?:yml|json)$}{};my@created;push@created,"$file\.yml" if$meta && $meta->save("$file\.yml",{version=>"1.4"});push@created,"$file\.json" if$meta && $meta->save("$file\.json");if (@created){$self->log_info("Created " .join(" and ",@created)."\n")}return@created}sub _get_meta_object {my$self=shift;my%args=@_;return unless$self->try_require("CPAN::Meta","2.142060");my$meta;eval {my$data=$self->get_metadata(fatal=>$args{fatal},auto=>$args{auto},);$data->{dynamic_config}=$args{dynamic}if defined$args{dynamic};$meta=CPAN::Meta->create($data)};if ($@ &&!$args{quiet}){$self->log_warn("Could not get valid metadata. Error is: $@\n")}return$meta}sub read_metafile {my$self=shift;my ($metafile)=@_;return unless$self->try_require("CPAN::Meta","2.110420");my$meta=CPAN::Meta->load_file($metafile);return$meta->as_struct({version=>"2.0"})}sub normalize_version {my ($self,$version)=@_;$version=0 unless defined$version and length$version;if ($version =~ /[=<>!,]/){}elsif (ref$version eq 'version'){$version=$version->is_qv ? $version->normal : $version->stringify}elsif ($version =~ /^[^v][^.]*\.[^.]+\./){$version="v$version"}else {}return$version}my%prereq_map=(requires=>[qw/runtime requires/],configure_requires=>[qw/configure requires/],build_requires=>[qw/build requires/ ],test_requires=>[qw/test requires/ ],test_recommends=>[qw/test recommends/ ],recommends=>[qw/runtime recommends/ ],conflicts=>[qw/runtime conflicts/ ],);sub _normalize_prereqs {my ($self)=@_;my$p=$self->{properties};my%prereq_types;for my$type ('configure_requires',@{$self->prereq_action_types}){if (exists$p->{$type}and keys %{$p->{$type}}){my ($phase,$relation)=@{$prereq_map{$type}};for my$mod (keys %{$p->{$type}}){$prereq_types{$phase}{$relation}{$mod}=$self->normalize_version($p->{$type}{$mod})}}}return \%prereq_types}sub _get_license {my$self=shift;my$license=$self->license;my ($meta_license,$meta_license_url);my$valid_licenses=$self->valid_licenses();if (my$sl=$self->_software_license_object){$meta_license=$sl->meta2_name;$meta_license_url=$sl->url}elsif (exists$valid_licenses->{$license}){$meta_license=$valid_licenses->{$license}? lc$valid_licenses->{$license}: $license;$meta_license_url=$self->_license_url($license)}else {$self->log_warn("Can not determine license type for '" .$self->license ."'\nSetting META license field to 'unknown'.\n");$meta_license='unknown'}return ($meta_license,$meta_license_url)}sub get_metadata {my ($self,%args)=@_;my$fatal=$args{fatal}|| 0;my$p=$self->{properties};$self->auto_config_requires if$args{auto};for my$f (qw(dist_name dist_version dist_author dist_abstract license)){my$field=$self->$f();unless (defined$field and length$field){my$err="ERROR: Missing required field '$f' for metafile\n";if ($fatal){die$err}else {$self->log_warn($err)}}}my%metadata=(name=>$self->dist_name,version=>$self->normalize_version($self->dist_version),author=>$self->dist_author,abstract=>$self->dist_abstract,generated_by=>"Module::Build version $Module::Build::VERSION",'meta-spec'=>{version=>'2',url=>'http://search.cpan.org/perldoc?CPAN::Meta::Spec',},dynamic_config=>exists$p->{dynamic_config}? $p->{dynamic_config}: 1,release_status=>$self->release_status,);my ($meta_license,$meta_license_url)=$self->_get_license;$metadata{license}=[$meta_license ];$metadata{resources}{license}=[$meta_license_url ]if defined$meta_license_url;$metadata{prereqs}=$self->_normalize_prereqs;if (exists$p->{no_index}){$metadata{no_index}=$p->{no_index}}elsif (my$pkgs=eval {$self->find_dist_packages}){$metadata{provides}=$pkgs if %$pkgs}else {$self->log_warn("$@\nWARNING: Possible missing or corrupt 'MANIFEST' file.\n" ."Nothing to enter for 'provides' field in metafile.\n")}if (my$add=$self->meta_add){if (not exists$add->{'meta-spec'}or $add->{'meta-spec'}{version}!=2){require CPAN::Meta::Converter;if (CPAN::Meta::Converter->VERSION('2.141170')){$add=CPAN::Meta::Converter->new($add)->upgrade_fragment;delete$add->{prereqs}}else {$self->log_warn("Can't meta_add without CPAN::Meta 2.141170")}}while (my($k,$v)=each %{$add}){$metadata{$k}=$v}}if (my$merge=$self->meta_merge){if (eval {require CPAN::Meta::Merge}){%metadata=%{CPAN::Meta::Merge->new(default_version=>'1.4')->merge(\%metadata,$merge)}}else {$self->log_warn("Can't merge without CPAN::Meta::Merge")}}return \%metadata}sub prepare_metadata {my ($self,$node,$keys,$args)=@_;unless (ref$node eq 'HASH'){croak "prepare_metadata() requires a hashref argument to hold output\n"}croak 'Keys argument to prepare_metadata is no longer supported' if$keys;%{$node}=%{$self->get_meta(%{$args})};return$node}sub _read_manifest {my ($self,$file)=@_;return undef unless -e $file;require ExtUtils::Manifest;local ($^W,$ExtUtils::Manifest::Quiet)=(0,1);return scalar ExtUtils::Manifest::maniread($file)}sub find_dist_packages {my$self=shift;my$manifest=$self->_read_manifest('MANIFEST')or die "Can't find dist packages without a MANIFEST file\nRun 'Build manifest' to generate one\n";my%dist_files=map {$self->localize_file_path($_)=>$_}keys %$manifest;my@pm_files=sort grep {$_ !~ m{^t}}grep {exists$dist_files{$_}}keys %{$self->find_pm_files};return$self->find_packages_in_files(\@pm_files,\%dist_files)}sub find_packages_in_files {my ($self,$file_list,$filename_map)=@_;my(%prime,%alt);for my$file (@{$file_list}){my$mapped_filename=$filename_map->{$file};my@path=split(/\//,$mapped_filename);(my$prime_package=join('::',@path[1..$#path]))=~ s/\.pm$//;my$pm_info=Module::Metadata->new_from_file($file);for my$package ($pm_info->packages_inside){next if$package eq 'main';next if$package eq 'DB';next if grep /^_/,split(/::/,$package);my$version=$pm_info->version($package);if ($package eq $prime_package){if (exists($prime{$package})){die "Unexpected conflict in '$package'; multiple versions found.\n"}else {$prime{$package}{file}=$mapped_filename;$prime{$package}{version}=$version if defined($version)}}else {push(@{$alt{$package}},{file=>$mapped_filename,version=>$version,})}}}for my$package (sort keys(%alt)){my$result=$self->_resolve_module_versions($alt{$package});if (exists($prime{$package})){if ($result->{err}){$self->log_warn("Found conflicting versions for package '$package'\n" ."  $prime{$package}{file} ($prime{$package}{version})\n" .$result->{err})}elsif (defined($result->{version})){if (exists($prime{$package}{version})&& defined($prime{$package}{version})){if ($self->compare_versions($prime{$package}{version},'!=',$result->{version})){$self->log_warn("Found conflicting versions for package '$package'\n" ."  $prime{$package}{file} ($prime{$package}{version})\n" ."  $result->{file} ($result->{version})\n")}}else {$prime{$package}{file}=$result->{file};$prime{$package}{version}=$result->{version}}}else {}}else {if ($result->{err}){$self->log_warn("Found conflicting versions for package '$package'\n" .$result->{err})}$prime{$package}{file}=$result->{file};$prime{$package}{version}=$result->{version}if defined($result->{version})}}for my$provides (values%prime){if ($provides->{version}){$provides->{version}=$self->normalize_version($provides->{version})}else {delete$provides->{version}}}return \%prime}sub _resolve_module_versions {my$self=shift;my$packages=shift;my($file,$version);my$err='';for my$p (@$packages){if (defined($p->{version})){if (defined($version)){if ($self->compare_versions($version,'!=',$p->{version})){$err .= "  $p->{file} ($p->{version})\n"}else {}}else {$file=$p->{file};$version=$p->{version}}}$file ||= $p->{file}if defined($p->{file})}if ($err){$err="  $file ($version)\n" .$err}my%result=(file=>$file,version=>$version,err=>$err);return \%result}sub make_tarball {my ($self,$dir,$file)=@_;$file ||= $dir;$self->log_info("Creating $file.tar.gz\n");if ($self->{args}{tar}){my$tar_flags=$self->verbose ? 'cvf' : 'cf';$self->do_system($self->split_like_shell($self->{args}{tar}),$tar_flags,"$file.tar",$dir);$self->do_system($self->split_like_shell($self->{args}{gzip}),"$file.tar")if$self->{args}{gzip}}else {eval {require Archive::Tar && Archive::Tar->VERSION(1.09);1}or die "You must install Archive::Tar 1.09+ to make a distribution tarball\n"."or specify a binary tar program with the '--tar' option.\n"."See the documentation for the 'dist' action.\n";my$files=$self->rscan_dir($dir);$Archive::Tar::DO_NOT_USE_PREFIX=(grep {length($_)>= 100}@$files)? 0 : 1;my$tar=Archive::Tar->new;$tar->add_files(@$files);for my$f ($tar->get_files){$f->mode($f->mode & ~022)}$tar->write("$file.tar.gz",1)}}sub install_path {my$self=shift;my($type,$value)=(@_,'<empty>');Carp::croak('Type argument missing')unless defined($type);my$map=$self->{properties}{install_path};return$map unless @_;unless (defined($value)){delete($map->{$type});return undef}if ($value eq '<empty>'){return undef unless exists$map->{$type};return$map->{$type}}return$map->{$type}=$value}sub install_sets {my ($self,$dirs,$key,$value)=@_;$dirs=$self->installdirs unless defined$dirs;if (@_==4 && defined$dirs && defined$key){$self->{properties}{install_sets}{$dirs}{$key}=$value}my$map={$self->_merge_arglist($self->{properties}{install_sets},$self->_default_install_paths->{install_sets})};if (defined$dirs && defined$key){return$map->{$dirs}{$key}}elsif (defined$dirs){return$map->{$dirs}}else {croak "Can't determine installdirs for install_sets()"}}sub original_prefix {my ($self,$key,$value)=@_;if (@_==3 && defined$key){$self->{properties}{original_prefix}{$key}=$value}my$map={$self->_merge_arglist($self->{properties}{original_prefix},$self->_default_install_paths->{original_prefix})};return$map unless defined$key;return$map->{$key}}sub install_base_relpaths {my$self=shift;if (@_ > 1){$self->_set_relpaths($self->{properties}{install_base_relpaths},@_)}my$map={$self->_merge_arglist($self->{properties}{install_base_relpaths},$self->_default_install_paths->{install_base_relpaths})};return$map unless @_;my$relpath=$map->{$_[0]};return defined$relpath ? File::Spec->catdir(@$relpath): undef}sub prefix_relpaths {my$self=shift;my$installdirs=shift || $self->installdirs or croak "Can't determine installdirs for prefix_relpaths()";if (@_ > 1){$self->{properties}{prefix_relpaths}{$installdirs}||= {};$self->_set_relpaths($self->{properties}{prefix_relpaths}{$installdirs},@_)}my$map={$self->_merge_arglist($self->{properties}{prefix_relpaths}{$installdirs},$self->_default_install_paths->{prefix_relpaths}{$installdirs})};return$map unless @_;my$relpath=$map->{$_[0]};return defined$relpath ? File::Spec->catdir(@$relpath): undef}sub _set_relpaths {my$self=shift;my($map,$type,$value)=@_;Carp::croak('Type argument missing')unless defined($type);if (!defined($value)){$map->{$type}=undef;return}else {Carp::croak("Value must be a relative path")if File::Spec::Unix->file_name_is_absolute($value);my@value=split(/\//,$value);$map->{$type}=\@value}}sub prefix_relative {my ($self,$type)=@_;my$installdirs=$self->installdirs;my$relpath=$self->install_sets($installdirs)->{$type};return$self->_prefixify($relpath,$self->original_prefix($installdirs),$type,)}sub _prefixify {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;$rprefix .= '/' if$sprefix =~ m|/$|;$self->log_verbose("  prefixify $path from $sprefix to $rprefix\n")if defined($path)&& length($path);if(!defined($path)|| (length($path)==0)){$self->log_verbose("  no path to prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}elsif(!File::Spec->file_name_is_absolute($path)){$self->log_verbose("    path is relative, not prefixifying.\n")}elsif($path !~ s{^\Q$sprefix\E\b}{}s){$self->log_verbose("    cannot prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}$self->log_verbose("    now $path in $rprefix\n");return$path}sub _prefixify_default {my$self=shift;my$type=shift;my$rprefix=shift;my$default=$self->prefix_relpaths($self->installdirs,$type);if(!$default){$self->log_verbose("    no default install location for type '$type', using prefix '$rprefix'.\n");return$rprefix}else {return$default}}sub install_destination {my ($self,$type)=@_;return$self->install_path($type)if$self->install_path($type);if ($self->install_base){my$relpath=$self->install_base_relpaths($type);return$relpath ? File::Spec->catdir($self->install_base,$relpath): undef}if ($self->prefix){my$relpath=$self->prefix_relative($type);return$relpath ? File::Spec->catdir($self->prefix,$relpath): undef}return$self->install_sets($self->installdirs)->{$type}}sub install_types {my$self=shift;my%types;if ($self->install_base){%types=%{$self->install_base_relpaths}}elsif ($self->prefix){%types=%{$self->prefix_relpaths}}else {%types=%{$self->install_sets($self->installdirs)}}%types=(%types,%{$self->install_path});return sort keys%types}sub install_map {my ($self,$blib)=@_;$blib ||= $self->blib;my(%map,@skipping);for my$type ($self->install_types){my$localdir=File::Spec->catdir($blib,$type);next unless -e $localdir;if (my$dest=$self->install_destination($type)){$map{$localdir}=$dest}else {push(@skipping,$type)}}$self->log_warn("WARNING: Can't figure out install path for types: @skipping\n" ."Files will not be installed.\n")if@skipping;if ($self->create_packlist and my$module_name=$self->module_name){my$archdir=$self->install_destination('arch');my@ext=split /::/,$module_name;$map{write}=File::Spec->catfile($archdir,'auto',@ext,'.packlist')}if (length(my$destdir=$self->destdir || '')){for (keys%map){my ($volume,$path,$file)=File::Spec->splitpath($map{$_},0);my@dirs=File::Spec->splitdir($path);$path=File::Spec->catdir($destdir,@dirs);if ($file ne ''){$map{$_}=File::Spec->catfile($path,$file)}else {$map{$_}=$path}}}$map{read}='';return \%map}sub depends_on {my$self=shift;for my$action (@_){$self->_call_action($action)}}sub rscan_dir {my ($self,$dir,$pattern)=@_;my@result;local $_;my$subr=!$pattern ? sub {push@result,$File::Find::name}: !ref($pattern)|| (ref$pattern eq 'Regexp')? sub {push@result,$File::Find::name if /$pattern/}: ref($pattern)eq 'CODE' ? sub {push@result,$File::Find::name if$pattern->()}: die "Unknown pattern type";File::Find::find({wanted=>$subr,no_chdir=>1,preprocess=>sub {sort @_}},$dir);return \@result}sub delete_filetree {my$self=shift;my$deleted=0;for (@_){next unless -e $_;$self->log_verbose("Deleting $_\n");File::Path::rmtree($_,0,0);die "Couldn't remove '$_': $!\n" if -e $_;$deleted++}return$deleted}sub autosplit_file {my ($self,$file,$to)=@_;require AutoSplit;my$dir=File::Spec->catdir($to,'lib','auto');AutoSplit::autosplit($file,$dir)}sub cbuilder {my$self=shift;my$s=$self->{stash};return$s->{_cbuilder}if$s->{_cbuilder};require ExtUtils::CBuilder;return$s->{_cbuilder}=ExtUtils::CBuilder->new(config=>$self->config,($self->quiet ? (quiet=>1): ()),)}sub have_c_compiler {my ($self)=@_;my$p=$self->{properties};return$p->{_have_c_compiler}if defined$p->{_have_c_compiler};$self->log_verbose("Checking if compiler tools configured... ");my$b=$self->cbuilder;my$have=$b && eval {$b->have_compiler};$self->log_verbose($have ? "ok.\n" : "failed.\n");return$p->{_have_c_compiler}=$have}sub compile_c {my ($self,$file,%args)=@_;if (!$self->have_c_compiler){die "Error: no compiler detected to compile '$file'.  Aborting\n"}my$b=$self->cbuilder;my$obj_file=$b->object_file($file);$self->add_to_cleanup($obj_file);return$obj_file if$self->up_to_date($file,$obj_file);$b->compile(source=>$file,defines=>$args{defines},object_file=>$obj_file,include_dirs=>$self->include_dirs,extra_compiler_flags=>$self->extra_compiler_flags,);return$obj_file}sub link_c {my ($self,$spec)=@_;my$p=$self->{properties};$self->add_to_cleanup($spec->{lib_file});my$objects=$p->{objects}|| [];return$spec->{lib_file}if$self->up_to_date([$spec->{obj_file},@$objects],$spec->{lib_file});my$module_name=$spec->{module_name}|| $self->module_name;$self->cbuilder->link(module_name=>$module_name,objects=>[$spec->{obj_file},@$objects],lib_file=>$spec->{lib_file},extra_linker_flags=>$self->extra_linker_flags);return$spec->{lib_file}}sub compile_xs {my ($self,$file,%args)=@_;$self->log_verbose("$file -> $args{outfile}\n");if (eval {require ExtUtils::ParseXS;1}){ExtUtils::ParseXS::process_file(filename=>$file,prototypes=>0,output=>$args{outfile},)}else {my$xsubpp=Module::Metadata->find_module_by_name('ExtUtils::xsubpp')or die "Can't find ExtUtils::xsubpp in INC (@INC)";my@typemaps;push@typemaps,Module::Metadata->find_module_by_name('ExtUtils::typemap',\@INC);my$lib_typemap=Module::Metadata->find_module_by_name('typemap',[File::Basename::dirname($file),File::Spec->rel2abs('.')]);push@typemaps,$lib_typemap if$lib_typemap;@typemaps=map {+'-typemap',$_}@typemaps;my$cf=$self->{config};my$perl=$self->{properties}{perl};my@command=($perl,"-I".$cf->get('installarchlib'),"-I".$cf->get('installprivlib'),$xsubpp,'-noprototypes',@typemaps,$file);$self->log_info("@command\n");open(my$fh,'>',$args{outfile})or die "Couldn't write $args{outfile}: $!";print {$fh}$self->_backticks(@command);close$fh}}sub split_like_shell {my ($self,$string)=@_;return ()unless defined($string);return @$string if ref$string eq 'ARRAY';$string =~ s/^\s+|\s+$//g;return ()unless length($string);return Text::ParseWords::shellwords($string)}sub oneliner {my($self,$cmd,$switches,$args)=@_;$switches=[]unless defined$switches;$args=[]unless defined$args;$cmd =~ s{^\n+}{};$cmd =~ s{\n+$}{};my$perl=ref($self)? $self->perl : $self->find_perl_interpreter;return$self->_quote_args($perl,@$switches,'-e',$cmd,@$args)}sub run_perl_script {my ($self,$script,$preargs,$postargs)=@_;for ($preargs,$postargs){$_=[$self->split_like_shell($_)]unless ref()}return$self->run_perl_command([@$preargs,$script,@$postargs])}sub run_perl_command {my ($self,$args)=@_;$args=[$self->split_like_shell($args)]unless ref($args);my$perl=ref($self)? $self->perl : $self->find_perl_interpreter;local$ENV{PERL5LIB}=join$self->config('path_sep'),$self->_added_to_INC;return$self->do_system($perl,@$args)}sub _infer_xs_spec {my$self=shift;my$file=shift;my$cf=$self->{config};my%spec;my($v,$d,$f)=File::Spec->splitpath($file);my@d=File::Spec->splitdir($d);(my$file_base=$f)=~ s/\.[^.]+$//i;$spec{base_name}=$file_base;$spec{src_dir}=File::Spec->catpath($v,$d,'');shift(@d)while@d && ($d[0]eq 'lib' || $d[0]eq '');pop(@d)while@d && $d[-1]eq '';$spec{module_name}=join('::',(@d,$file_base));$spec{archdir}=File::Spec->catdir($self->blib,'arch','auto',@d,$file_base);$spec{c_file}=File::Spec->catfile($spec{src_dir},"${file_base}.c");$spec{obj_file}=File::Spec->catfile($spec{src_dir},"${file_base}".$cf->get('obj_ext'));require DynaLoader;my$modfname=defined&DynaLoader::mod2fname ? DynaLoader::mod2fname([@d,$file_base]): $file_base;$spec{bs_file}=File::Spec->catfile($spec{archdir},"$modfname.bs");$spec{lib_file}=File::Spec->catfile($spec{archdir},"$modfname.".$cf->get('dlext'));return \%spec}sub process_xs {my ($self,$file)=@_;my$spec=$self->_infer_xs_spec($file);(my$file_base=$file)=~ s/\.[^.]+$//;$self->add_to_cleanup($spec->{c_file});unless ($self->up_to_date($file,$spec->{c_file})){$self->compile_xs($file,outfile=>$spec->{c_file})}my$v=$self->dist_version;$self->compile_c($spec->{c_file},defines=>{VERSION=>qq{"$v"},XS_VERSION=>qq{"$v"}});File::Path::mkpath($spec->{archdir},0,oct(777))unless -d $spec->{archdir};$self->add_to_cleanup($spec->{bs_file});unless ($self->up_to_date($file,$spec->{bs_file})){require ExtUtils::Mkbootstrap;$self->log_info("ExtUtils::Mkbootstrap::Mkbootstrap('$spec->{bs_file}')\n");ExtUtils::Mkbootstrap::Mkbootstrap($spec->{bs_file});open(my$fh,'>>',$spec->{bs_file});utime((time)x2,$spec->{bs_file})}$self->link_c($spec)}sub do_system {my ($self,@cmd)=@_;$self->log_verbose("@cmd\n");my%seen;my$sep=$self->config('path_sep');local$ENV{PERL5LIB}=(!exists($ENV{PERL5LIB})? '' : length($ENV{PERL5LIB})< 500 ? $ENV{PERL5LIB}: join$sep,grep {!$seen{$_}++ and -d $_}split($sep,$ENV{PERL5LIB}));my$status=system(@cmd);if ($status and $! =~ /Argument list too long/i){my$env_entries='';for (sort keys%ENV){$env_entries .= "$_=>".length($ENV{$_})."; "}warn "'Argument list' was 'too long', env lengths are $env_entries"}return!$status}sub copy_if_modified {my$self=shift;my%args=(@_ > 3 ? (@_): (from=>shift,to_dir=>shift,flatten=>shift));$args{verbose}=!$self->quiet unless exists$args{verbose};my$file=$args{from};unless (defined$file and length$file){die "No 'from' parameter given to copy_if_modified"}$args{flatten}=1 if File::Spec->file_name_is_absolute($file);my$to_path;if (defined$args{to}and length$args{to}){$to_path=$args{to}}elsif (defined$args{to_dir}and length$args{to_dir}){$to_path=File::Spec->catfile($args{to_dir},$args{flatten}? File::Basename::basename($file): $file)}else {die "No 'to' or 'to_dir' parameter given to copy_if_modified"}return if$self->up_to_date($file,$to_path);{local$self->{properties}{quiet}=1;$self->delete_filetree($to_path)}File::Path::mkpath(File::Basename::dirname($to_path),0,oct(777));$self->log_verbose("Copying $file -> $to_path\n");if ($^O eq 'os2'){chmod 0666,$to_path;File::Copy::syscopy($file,$to_path,0x1)or die "Can't copy('$file', '$to_path'): $!"}else {File::Copy::copy($file,$to_path)or die "Can't copy('$file', '$to_path'): $!"}my$mode=oct(444)| ($self->is_executable($file)? oct(111): 0);chmod($mode,$to_path);return$to_path}sub up_to_date {my ($self,$source,$derived)=@_;$source=[$source]unless ref$source;$derived=[$derived]unless ref$derived;return 0 if @$source &&!@$derived || grep {not -e}@$derived;my$most_recent_source=time / (24*60*60);for my$file (@$source){unless (-e $file){$self->log_warn("Can't find source file $file for up-to-date check");next}$most_recent_source=-M _ if -M _ < $most_recent_source}for my$derived (@$derived){return 0 if -M $derived > $most_recent_source}return 1}sub dir_contains {my ($self,$first,$second)=@_;($first,$second)=map File::Spec->canonpath($_),($first,$second);my@first_dirs=File::Spec->splitdir($first);my@second_dirs=File::Spec->splitdir($second);return 0 if@second_dirs < @first_dirs;my$is_same=($self->_case_tolerant ? sub {lc(shift())eq lc(shift())}: sub {shift()eq shift()});while (@first_dirs){return 0 unless$is_same->(shift@first_dirs,shift@second_dirs)}return 1}1;
  
  ERRORS/WARNINGS FOUND IN PREREQUISITES.  You may wish to install the versions
  of the modules indicated above before proceeding with this installation
  
  EOF
  * FATAL ERROR: Perl interpreter mismatch. Configuration was initially
    created with '$self->{properties}{perl}'
    but we are now using '$perl'.  You must
    run 'Build realclean' or 'make realclean' and re-configure.
  DIEFATAL
  * WARNING: Configuration was initially created with Module::Build
    version '$self->{properties}{mb_version}' but we are now using version '$mb_version'.
    If errors occur, you must re-run the Build.PL or Makefile.PL script.
  MISMATCH
  ERROR: This build seems to be unattended, but there is no default value
  for this question.  Aborting.
  EOF
  package $opts{class};
  use $pack;
  \@ISA = qw($pack);
  $opts{code}
  1;
  EOF
  No 'module_name' was provided and it could not be inferred
  from other properties.  This will prevent a packlist from
  being written for this file.  Please set either 'module_name'
  or 'dist_version_from' in Build.PL.
  END_WARN
  Bundling in inc/ is disabled because ExtUtils::Installed could not
  create a list of your installed modules.  Here is the error:
  $@
  EUI_ERROR
  Could not find a packlist for '$mod'.  If it's a core module, try
  force installing it from CPAN.
  NO_PACKLIST
  Module::Build was not found in configure_requires! Adding it now
  automatically as: configure_requires => { 'Module::Build' => $ver }
  EOM
  Warning: ExtUtils::CBuilder not installed or no compiler detected
  Proceeding with configuration, but compilation may fail during Build
  
  EOM
      if ($INC[-1] ne '.') {
          push @INC, '.';
      }
  END
  $shebang
  
  use strict;
  use Cwd;
  use File::Basename;
  use File::Spec;
  
  sub magic_number_matches {
    return 0 unless -e '$q{magic_numfile}';
    my \$FH;
    open \$FH, '<','$q{magic_numfile}' or return 0;
    my \$filenum = <\$FH>;
    close \$FH;
    return \$filenum == $magic_number;
  }
  
  my \$progname;
  my \$orig_dir;
  BEGIN {
    \$^W = 1;  # Use warnings
    \$progname = basename(\$0);
    \$orig_dir = Cwd::cwd();
    my \$base_dir = '$q{base_dir}';
    if (!magic_number_matches()) {
      unless (chdir(\$base_dir)) {
        die ("Couldn't chdir(\$base_dir), aborting\\n");
      }
      unless (magic_number_matches()) {
        die ("Configuration seems to be out of date, please re-run 'perl Build.PL' again.\\n");
      }
    }
    unshift \@INC,
      (
  $quoted_INC
      );
  $dot_in_inc_code
  }
  
  close(*DATA) unless eof(*DATA); # ensure no open handles to this script
  
  use $build_package;
  Module::Build->VERSION(q{$config_requires});
  
  # Some platforms have problems setting \$^X in shebang contexts, fix it up here
  \$^X = Module::Build->find_perl_interpreter;
  
  if (-e 'Build.PL' and not $build_package->up_to_date('Build.PL', \$progname)) {
     warn "Warning: Build.PL has been altered.  You may need to run 'perl Build.PL' again.\\n";
  }
  
  # This should have just enough arguments to be able to bootstrap the rest.
  my \$build = $build_package->resume (
    properties => {
      config_dir => '$q{config_dir}',
      orig_dir => \$orig_dir,
    },
  );
  
  \$build->dispatch;
  EOF
  
   Usage: $0 <action> --arg1=value --arg2=value ...
   Example: $0 test --verbose=1
  
   Actions defined:
  EOF
  Can't create LICENSE file: '$l' is not a valid license key
  or Software::License subclass;
  HERE
  Cannot create README: can't determine which file contains documentation;
  Must supply either 'dist_version_from', or 'module_name' parameter.
  EOF
  # Avoid configuration metadata file
  ^MYMETA\.
  
  # Avoid Module::Build generated and utility files.
  \bBuild$
  \bBuild.bat$
  \b_build
  \bBuild.COM$
  \bBUILD.COM$
  \bbuild.com$
  ^MANIFEST\.SKIP
  
  # Avoid archives of this distribution
  EOF
MODULE_BUILD_BASE

$fatpacked{"Module/Build/Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_COMPAT';
  package Module::Build::Compat;use strict;use warnings;our$VERSION='0.4231';use File::Basename ();use File::Spec;use Config;use Module::Build;use Module::Metadata;use version;use Data::Dumper;my%convert_installdirs=(PERL=>'core',SITE=>'site',VENDOR=>'vendor',);my%makefile_to_build=(TEST_VERBOSE=>'verbose',VERBINST=>'verbose',INC=>sub {map {(extra_compiler_flags=>$_)}Module::Build->split_like_shell(shift)},POLLUTE=>sub {(extra_compiler_flags=>'-DPERL_POLLUTE')},INSTALLDIRS=>sub {(installdirs=>$convert_installdirs{uc shift()})},LIB=>sub {my$lib=shift;my%config=(installprivlib=>$lib,installsitelib=>$lib,installarchlib=>"$lib/$Config{archname}",installsitearch=>"$lib/$Config{archname}");return map {(config=>"$_=$config{$_}")}sort keys%config},(map {my$name=$_;$name=>sub {my@ret=(config=>lc($name)."=" .shift);print STDERR "# Converted to @ret\n";return@ret}}qw(INSTALLARCHLIB INSTALLSITEARCH INSTALLVENDORARCH INSTALLPRIVLIB INSTALLSITELIB INSTALLVENDORLIB INSTALLBIN INSTALLSITEBIN INSTALLVENDORBIN INSTALLSCRIPT INSTALLSITESCRIPT INSTALLVENDORSCRIPT INSTALLMAN1DIR INSTALLSITEMAN1DIR INSTALLVENDORMAN1DIR INSTALLMAN3DIR INSTALLSITEMAN3DIR INSTALLVENDORMAN3DIR)),map {$_,lc($_)}qw(DESTDIR PREFIX INSTALL_BASE UNINST),);my%macro_to_build=%makefile_to_build;delete$macro_to_build{LIB};sub _merge_prereq {my ($req,$breq)=@_;$req ||= {};$breq ||= {};for my$p ($req,$breq){for my$k (sort keys %$p){next if$k eq 'perl';my$v_obj=eval {version->new($p->{$k})};if (!defined$v_obj){die "A prereq of the form '$p->{$k}' for '$k' is not supported by Module::Build::Compat ( use a simpler version like '0.05' or 'v1.4.25' )\n"}if ($v_obj->is_qv){my$proper_ver=$v_obj->numify;warn "Dotted-decimal prereq '$p->{$k}' for '$k' is not portable - converting it to '$proper_ver'\n";$p->{$k}=$proper_ver}}}my$merge={%$req };for my$k (keys %$breq){my$v1=$merge->{$k}|| 0;my$v2=$breq->{$k};$merge->{$k}=$v1 > $v2 ? $v1 : $v2}return %$merge}sub create_makefile_pl {my ($package,$type,$build,%args)=@_;die "Don't know how to build Makefile.PL of type '$type'" unless$type =~ /^(small|passthrough|traditional)$/;if ($type eq 'passthrough'){$build->log_warn(<<"HERE")}my$fh;if ($args{fh}){$fh=$args{fh}}else {$args{file}||= 'Makefile.PL';local$build->{properties}{quiet}=1;$build->delete_filetree($args{file});open($fh,'>',"$args{file}")or die "Can't write $args{file}: $!"}print {$fh}"# Note: this file was auto-generated by ",__PACKAGE__," version $VERSION\n";my$requires=$build->requires;if (my$minimum_perl=$requires->{perl}){my$min_ver=version->new($minimum_perl)->numify;print {$fh}"require $min_ver;\n"}my$subclass_load='';if (ref($build)ne "Module::Build"){my$subclass_dir=$package->subclass_dir($build);if (File::Spec->file_name_is_absolute($subclass_dir)){my$base_dir=$build->base_dir;if ($build->dir_contains($base_dir,$subclass_dir)){$subclass_dir=File::Spec->abs2rel($subclass_dir,$base_dir);$subclass_dir=$package->unixify_dir($subclass_dir);$subclass_load="use lib '$subclass_dir';"}}else {$subclass_dir=$package->unixify_dir($subclass_dir);$subclass_load="use lib '$subclass_dir';"}}if ($type eq 'small'){printf {$fh}<<'EOF',$subclass_load,ref($build),ref($build)}elsif ($type eq 'passthrough'){printf {$fh}<<'EOF',$subclass_load,ref($build),ref($build)}elsif ($type eq 'traditional'){my (%MM_Args,%prereq);if (eval "use Tie::IxHash 1.2; 1"){tie%MM_Args,'Tie::IxHash';tie%prereq,'Tie::IxHash'}my%name=($build->module_name ? (NAME=>$build->module_name): (DISTNAME=>$build->dist_name));my%version=($build->dist_version_from ? (VERSION_FROM=>$build->dist_version_from): (VERSION=>$build->dist_version));%MM_Args=(%name,%version);%prereq=_merge_prereq($build->requires,$build->build_requires);%prereq=map {$_,$prereq{$_}}sort keys%prereq;delete$prereq{perl};$MM_Args{PREREQ_PM}=\%prereq;$MM_Args{INSTALLDIRS}=$build->installdirs eq 'core' ? 'perl' : $build->installdirs;$MM_Args{EXE_FILES}=[sort keys %{$build->script_files}]if$build->script_files;$MM_Args{PL_FILES}=$build->PL_files || {};if ($build->recursive_test_files){$MM_Args{test}={TESTS=>join q{ },$package->_test_globs($build)}}local$Data::Dumper::Terse=1;my$args=Data::Dumper::Dumper(\%MM_Args);$args =~ s/\{(.*)\}/($1)/s;print$fh <<"EOF"}}sub _test_globs {my ($self,$build)=@_;return map {File::Spec->catfile($_,'*.t')}@{$build->rscan_dir('t',sub {-d $File::Find::name})}}sub subclass_dir {my ($self,$build)=@_;return (Module::Metadata->find_module_dir_by_name(ref$build)|| File::Spec->catdir($build->config_dir,'lib'))}sub unixify_dir {my ($self,$path)=@_;return join '/',File::Spec->splitdir($path)}sub makefile_to_build_args {my$class=shift;my@out;for my$arg (@_){next if$arg eq '';my ($key,$val)=($arg =~ /^(\w+)=(.+)/ ? ($1,$2): die "Malformed argument '$arg'");($val)=Module::Build->_detildefy($val)if$val =~ /^~/;if (exists$makefile_to_build{$key}){my$trans=$makefile_to_build{$key};push@out,$class->_argvify(ref($trans)? $trans->($val): ($trans=>$val))}elsif (exists$Config{lc($key)}){push@out,$class->_argvify(config=>lc($key)."=$val")}else {push@out,$class->_argvify("\L$key"=>$val)}}return@out}sub _argvify {my ($self,@pairs)=@_;my@out;while (@pairs){my ($k,$v)=splice@pairs,0,2;push@out,("--$k",$v)}return@out}sub makefile_to_build_macros {my@out;my%config;for my$macro (sort keys%macro_to_build){my$trans=$macro_to_build{$macro};next unless exists$ENV{$macro}&& length$ENV{$macro};my$val=$ENV{$macro};my@args=ref($trans)? $trans->($val): ($trans=>$val);while (@args){my ($k,$v)=splice(@args,0,2);if ($k eq 'config'){if ($v =~ /^([^=]+)=(.*)$/){$config{$1}=$2}else {warn "Couldn't parse config '$v'\n"}}else {push@out,($k=>$v)}}}push@out,(config=>\%config)if%config;return@out}sub run_build_pl {my ($pack,%in)=@_;$in{script}||= 'Build.PL';my@args=$in{args}? $pack->makefile_to_build_args(@{$in{args}}): ();print "# running $in{script} @args\n";Module::Build->run_perl_script($in{script},[],\@args)or die "Couldn't run $in{script}: $!"}sub fake_makefile {my ($self,%args)=@_;unless (exists$args{build_class}){warn "Unknown 'build_class', defaulting to 'Module::Build'\n";$args{build_class}='Module::Build'}my$class=$args{build_class};my$perl=$class->find_perl_interpreter;$perl='MCR ' .$perl if$self->_is_vms_mms;my$noop=($class->is_windowsish ? 'rem>nul' : $self->_is_vms_mms ? 'Continue' : 'true');my$filetype=$class->is_vmsish ? '.COM' : '';my$Build='Build' .$filetype .' --makefile_env_macros 1';my$unlink=$class->oneliner('1 while unlink $ARGV[0]',[],[$args{makefile}]);$unlink =~ s/\$/\$\$/g unless$class->is_vmsish;my$maketext=join '',map {"$_=\n"}sort keys%macro_to_build;$maketext .= ($^O eq 'os2' ? "SHELL = sh\n\n" : $^O eq 'MSWin32' && $Config{make}=~ /gmake/ ? "SHELL = $ENV{COMSPEC}\n\n" : "\n\n");$maketext .= <<"EOF";for my$action ($class->known_actions){next if$action =~ /^(all|distclean|realclean|force_do_it)$/;$maketext .= <<"EOF"}if ($self->_is_vms_mms){$maketext .= "\n.FIRST\n\t\@ $noop\n";for my$macro (sort keys%macro_to_build){$maketext .= ".IFDEF $macro\n\tDEFINE $macro \"\$($macro)\"\n.ENDIF\n"}$maketext .= "\n"}else {$maketext .= "\n.EXPORT : " .join(' ',sort keys%macro_to_build)."\n\n"}return$maketext}sub fake_prereqs {my$file=File::Spec->catfile('_build','prereqs');open(my$fh,'<',"$file")or die "Can't read $file: $!";my$prereqs=eval do {local $/;<$fh>};close$fh;my%merged=_merge_prereq($prereqs->{requires},$prereqs->{build_requires});my@prereq;for (sort keys%merged){next if $_ eq 'perl';push@prereq,"$_=>q[$merged{$_}]"}return unless@prereq;return "#     PREREQ_PM => { " .join(", ",@prereq)." }\n\n"}sub write_makefile {my ($pack,%in)=@_;unless (exists$in{build_class}){warn "Unknown 'build_class', defaulting to 'Module::Build'\n";$in{build_class}='Module::Build'}my$class=$in{build_class};$in{makefile}||= $pack->_is_vms_mms ? 'Descrip.MMS' : 'Makefile';open MAKE,"> $in{makefile}" or die "Cannot write $in{makefile}: $!";print MAKE$pack->fake_prereqs;print MAKE$pack->fake_makefile(%in);close MAKE}sub _is_vms_mms {return Module::Build->is_vmsish && ($Config{make}=~ m/MM[SK]/i)}1;
  
  IMPORTANT NOTE: The '$type' style of Makefile.PL is deprecated and
  may be removed in a future version of Module::Build in favor of the
  'configure_requires' property.  See Module::Build::Compat
  documentation for details.
  
  HERE
      use Module::Build::Compat 0.02;
      %s
      Module::Build::Compat->run_build_pl(args => \@ARGV);
      require %s;
      Module::Build::Compat->write_makefile(build_class => '%s');
  EOF
  
      unless (eval "use Module::Build::Compat 0.02; 1" ) {
        print "This module requires Module::Build to install itself.\n";
  
        require ExtUtils::MakeMaker;
        my $yn = ExtUtils::MakeMaker::prompt
  	('  Install Module::Build now from CPAN?', 'y');
  
        unless ($yn =~ /^y/i) {
  	die " *** Cannot install without Module::Build.  Exiting ...\n";
        }
  
        require Cwd;
        require File::Spec;
        require CPAN;
  
        # Save this 'cause CPAN will chdir all over the place.
        my $cwd = Cwd::cwd();
  
        CPAN::Shell->install('Module::Build::Compat');
        CPAN::Shell->expand("Module", "Module::Build::Compat")->uptodate
  	or die "Couldn't install Module::Build, giving up.\n";
  
        chdir $cwd or die "Cannot chdir() back to $cwd: $!";
      }
      eval "use Module::Build::Compat 0.02; 1" or die $@;
      %s
      Module::Build::Compat->run_build_pl(args => \@ARGV);
      my $build_script = 'Build';
      $build_script .= '.com' if $^O eq 'VMS';
      exit(0) unless(-e $build_script); # cpantesters convention
      require %s;
      Module::Build::Compat->write_makefile(build_class => '%s');
  EOF
  use ExtUtils::MakeMaker;
  WriteMakefile
  $args;
  EOF
  all : force_do_it
  	$perl $Build
  realclean : force_do_it
  	$perl $Build realclean
  	$unlink
  distclean : force_do_it
  	$perl $Build distclean
  	$unlink
  
  
  force_do_it :
  	@ $noop
  EOF
  $action : force_do_it
  	$perl $Build $action
  EOF
MODULE_BUILD_COMPAT

$fatpacked{"Module/Build/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_CONFIG';
  package Module::Build::Config;use strict;use warnings;our$VERSION='0.4231';$VERSION=eval$VERSION;use Config;sub new {my ($pack,%args)=@_;return bless {stack=>{},values=>$args{values}|| {},},$pack}sub get {my ($self,$key)=@_;return$self->{values}{$key}if ref($self)&& exists$self->{values}{$key};return$Config{$key}}sub set {my ($self,$key,$val)=@_;$self->{values}{$key}=$val}sub push {my ($self,$key,$val)=@_;push @{$self->{stack}{$key}},$self->{values}{$key}if exists$self->{values}{$key};$self->{values}{$key}=$val}sub pop {my ($self,$key)=@_;my$val=delete$self->{values}{$key};if (exists$self->{stack}{$key}){$self->{values}{$key}=pop @{$self->{stack}{$key}};delete$self->{stack}{$key}unless @{$self->{stack}{$key}}}return$val}sub values_set {my$self=shift;return undef unless ref($self);return$self->{values}}sub all_config {my$self=shift;my$v=ref($self)? $self->{values}: {};return {%Config,%$v}}1;
MODULE_BUILD_CONFIG

$fatpacked{"Module/Build/ConfigData.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_CONFIGDATA';
  package Module::Build::ConfigData;use strict;my$arrayref=eval do {local $/;<DATA>}or die "Couldn't load ConfigData data: $@";close DATA;my ($config,$features,$auto_features)=@$arrayref;sub config {$config->{$_[1]}}sub set_config {$config->{$_[1]}=$_[2]}sub set_feature {$features->{$_[1]}=0+!!$_[2]}sub auto_feature_names {sort grep!exists$features->{$_},keys %$auto_features}sub feature_names {my@features=(sort keys %$features,auto_feature_names());@features}sub config_names {sort keys %$config}sub write {my$me=__FILE__;require Data::Dumper;my$mode_orig=(stat$me)[2]& 07777;chmod($mode_orig | 0222,$me);open(my$fh,'+<',$me)or die "Can't rewrite $me: $!";seek($fh,0,0);while (<$fh>){last if /^__DATA__$/}die "Couldn't find __DATA__ token in $me" if eof($fh);seek($fh,tell($fh),0);my$data=[$config,$features,$auto_features];print($fh 'do{ my ' .Data::Dumper->new([$data],['x'])->Purity(1)->Dump().'$x; }');truncate($fh,tell($fh));close$fh;chmod($mode_orig,$me)or warn "Couldn't restore permissions on $me: $!"}sub feature {my ($package,$key)=@_;return$features->{$key}if exists$features->{$key};my$info=$auto_features->{$key}or return 0;require Module::Build;for my$type (sort keys %$info){my$prereqs=$info->{$type};next if$type eq 'description' || $type eq 'recommends';for my$modname (sort keys %$prereqs){my$status=Module::Build->check_installed_status($modname,$prereqs->{$modname});if ((!$status->{ok})xor ($type =~ /conflicts$/)){return 0}if (!eval "require $modname; 1"){return 0}}}return 1}__DATA__ do{ my $x = [
         {},
         {},
         {
           'HTML_support' => {
                               'description' => 'Create HTML documentation',
                               'requires' => {
                                               'Pod::Html' => 0
                                             }
                             },
           'PPM_support' => {
                              'description' => 'Generate PPM files for distributions'
                            },
           'dist_authoring' => {
                                 'description' => 'Create new distributions',
                                 'recommends' => {
                                                   'Module::Signature' => '0.21',
                                                   'Pod::Readme' => '0.04'
                                                 },
                                 'requires' => {
                                                 'Archive::Tar' => '1.09'
                                               }
                               },
           'inc_bundling_support' => {
                                       'description' => 'Bundle Module::Build in inc/',
                                       'requires' => {
                                                       'ExtUtils::Install' => '1.54',
                                                       'ExtUtils::Installed' => '1.999',
                                                       'inc::latest' => '0.5'
                                                     }
                                     },
           'license_creation' => {
                                   'description' => 'Create licenses automatically in distributions',
                                   'requires' => {
                                                   'Software::License' => '0.103009'
                                                 }
                                 },
           'manpage_support' => {
                                  'description' => 'Create Unix man pages',
                                  'requires' => {
                                                  'Pod::Man' => 0
                                                }
                                }
         }
       ];
  $x; }
MODULE_BUILD_CONFIGDATA

$fatpacked{"Module/Build/Cookbook.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_COOKBOOK';
  package Module::Build::Cookbook;use strict;use warnings;our$VERSION='0.4231';
MODULE_BUILD_COOKBOOK

$fatpacked{"Module/Build/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_DUMPER';
  package Module::Build::Dumper;use strict;use warnings;our$VERSION='0.4231';use Data::Dumper;sub _data_dump {my ($self,$data)=@_;return ("do{ my " .Data::Dumper->new([$data],['x'])->Purity(1)->Terse(0)->Sortkeys(1)->Dump().'$x; }')}1;
MODULE_BUILD_DUMPER

$fatpacked{"Module/Build/Notes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_NOTES';
  package Module::Build::Notes;use strict;use warnings;our$VERSION='0.4231';$VERSION=eval$VERSION;use Data::Dumper;use Module::Build::Dumper;sub new {my ($class,%args)=@_;my$file=delete$args{file}or die "Missing required parameter 'file' to new()";my$self=bless {disk=>{},new=>{},file=>$file,%args,},$class}sub restore {my$self=shift;open(my$fh,'<',$self->{file})or die "Can't read $self->{file}: $!";$self->{disk}=eval do {local $/;<$fh>};die $@ if $@;close$fh;$self->{new}={}}sub access {my$self=shift;return$self->read()unless @_;my$key=shift;return$self->read($key)unless @_;my$value=shift;$self->write({$key=>$value });return$self->read($key)}sub has_data {my$self=shift;return keys %{$self->read()}> 0}sub exists {my ($self,$key)=@_;return exists($self->{new}{$key})|| exists($self->{disk}{$key})}sub read {my$self=shift;if (@_){my$key=shift;return$self->{new}{$key}if exists$self->{new}{$key};return$self->{disk}{$key}}my$out=(keys %{$self->{new}}? {%{$self->{disk}},%{$self->{new}}}: $self->{disk});return wantarray ? %$out : $out}sub _same {my ($self,$x,$y)=@_;return 1 if!defined($x)and!defined($y);return 0 if!defined($x)or!defined($y);return$x eq $y}sub write {my ($self,$href)=@_;$href ||= {};@{$self->{new}}{keys %$href }=values %$href;for my$key (keys %{$self->{new}}){next if ref$self->{new}{$key};next if ref$self->{disk}{$key}or!exists$self->{disk}{$key};delete$self->{new}{$key}if$self->_same($self->{new}{$key},$self->{disk}{$key})}if (my$file=$self->{file}){my ($vol,$dir,$base)=File::Spec->splitpath($file);$dir=File::Spec->catpath($vol,$dir,'');return unless -e $dir && -d $dir;return if -e $file and!keys %{$self->{new}};@{$self->{disk}}{keys %{$self->{new}}}=values %{$self->{new}};$self->_dump($file,$self->{disk});$self->{new}={}}return$self->read}sub _dump {my ($self,$file,$data)=@_;open(my$fh,'>',$file)or die "Can't create '$file': $!";print {$fh}Module::Build::Dumper->_data_dump($data);close$fh}my$orig_template=do {local $/;<DATA>};close DATA;sub write_config_data {my ($self,%args)=@_;my$template=$orig_template;$template =~ s/NOTES_NAME/$args{config_module}/g;$template =~ s/MODULE_NAME/$args{module}/g;$template =~ s/=begin private\n//;$template =~ s/=end private/=cut/;$template =~ s{$_\n}{} for '=begin private','=end private';open(my$fh,'>',$args{file})or die "Can't create '$args{file}': $!";print {$fh}$template;print {$fh}"\n__DATA__\n";print {$fh}Module::Build::Dumper->_data_dump([$args{config_data},$args{feature},$args{auto_features}]);close$fh}1;__DATA__ package NOTES_NAME;
  use strict;
  my $arrayref = eval do {local $/; <DATA>}
    or die "Couldn't load ConfigData data: $@";
  close DATA;
  my ($config, $features, $auto_features) = @$arrayref;
  
  sub config { $config->{$_[1]} }
  
  sub set_config { $config->{$_[1]} = $_[2] }
  sub set_feature { $features->{$_[1]} = 0+!!$_[2] }  # Constrain to 1 or 0
  
  sub auto_feature_names { sort grep !exists $features->{$_}, keys %$auto_features }
  
  sub feature_names {
    my @features = (sort keys %$features, auto_feature_names());
    @features;
  }
  
  sub config_names  { sort keys %$config }
  
  sub write {
    my $me = __FILE__;
  
    # Can't use Module::Build::Dumper here because M::B is only a
    # build-time prereq of this module
    require Data::Dumper;
  
    my $mode_orig = (stat $me)[2] & 07777;
    chmod($mode_orig | 0222, $me); # Make it writeable
    open(my $fh, '+<', $me) or die "Can't rewrite $me: $!";
    seek($fh, 0, 0);
    while (<$fh>) {
      last if /^__DATA__$/;
    }
    die "Couldn't find __DATA__ token in $me" if eof($fh);
  
    seek($fh, tell($fh), 0);
    my $data = [$config, $features, $auto_features];
    print($fh 'do{ my '
  	      . Data::Dumper->new([$data],['x'])->Purity(1)->Dump()
  	      . '$x; }' );
    truncate($fh, tell($fh));
    close $fh;
  
    chmod($mode_orig, $me)
      or warn "Couldn't restore permissions on $me: $!";
  }
  
  sub feature {
    my ($package, $key) = @_;
    return $features->{$key} if exists $features->{$key};
  
    my $info = $auto_features->{$key} or return 0;
  
    require Module::Build;  # XXX should get rid of this
    foreach my $type (sort keys %$info) {
      my $prereqs = $info->{$type};
      next if $type eq 'description' || $type eq 'recommends';
  
      foreach my $modname (sort keys %$prereqs) {
        my $status = Module::Build->check_installed_status($modname, $prereqs->{$modname});
        if ((!$status->{ok}) xor ($type =~ /conflicts$/)) { return 0; }
        if ( ! eval "require $modname; 1" ) { return 0; }
      }
    }
    return 1;
  }
  
  =begin private
  
  =head1 NAME
  
  NOTES_NAME - Configuration for MODULE_NAME
  
  =head1 SYNOPSIS
  
    use NOTES_NAME;
    $value = NOTES_NAME->config('foo');
    $value = NOTES_NAME->feature('bar');
  
    @names = NOTES_NAME->config_names;
    @names = NOTES_NAME->feature_names;
  
    NOTES_NAME->set_config(foo => $new_value);
    NOTES_NAME->set_feature(bar => $new_value);
    NOTES_NAME->write;  # Save changes
  
  
  =head1 DESCRIPTION
  
  This module holds the configuration data for the C<MODULE_NAME>
  module.  It also provides a programmatic interface for getting or
  setting that configuration data.  Note that in order to actually make
  changes, you'll have to have write access to the C<NOTES_NAME>
  module, and you should attempt to understand the repercussions of your
  actions.
  
  
  =head1 METHODS
  
  =over 4
  
  =item config($name)
  
  Given a string argument, returns the value of the configuration item
  by that name, or C<undef> if no such item exists.
  
  =item feature($name)
  
  Given a string argument, returns the value of the feature by that
  name, or C<undef> if no such feature exists.
  
  =item set_config($name, $value)
  
  Sets the configuration item with the given name to the given value.
  The value may be any Perl scalar that will serialize correctly using
  C<Data::Dumper>.  This includes references, objects (usually), and
  complex data structures.  It probably does not include transient
  things like filehandles or sockets.
  
  =item set_feature($name, $value)
  
  Sets the feature with the given name to the given boolean value.  The
  value will be converted to 0 or 1 automatically.
  
  =item config_names()
  
  Returns a list of all the names of config items currently defined in
  C<NOTES_NAME>, or in scalar context the number of items.
  
  =item feature_names()
  
  Returns a list of all the names of features currently defined in
  C<NOTES_NAME>, or in scalar context the number of features.
  
  =item auto_feature_names()
  
  Returns a list of all the names of features whose availability is
  dynamically determined, or in scalar context the number of such
  features.  Does not include such features that have later been set to
  a fixed value.
  
  =item write()
  
  Commits any changes from C<set_config()> and C<set_feature()> to disk.
  Requires write access to the C<NOTES_NAME> module.
  
  =back
  
  
  =head1 AUTHOR
  
  C<NOTES_NAME> was automatically created using C<Module::Build>.
  C<Module::Build> was written by Ken Williams, but he holds no
  authorship claim or copyright claim to the contents of C<NOTES_NAME>.
  
  =end private
  
MODULE_BUILD_NOTES

$fatpacked{"Module/Build/PPMMaker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PPMMAKER';
  package Module::Build::PPMMaker;use strict;use warnings;use Config;our$VERSION='0.4231';$VERSION=eval$VERSION;sub new {my$package=shift;return bless {@_},$package}sub make_ppd {my ($self,%args)=@_;my$build=delete$args{build};my@codebase;if (exists$args{codebase}){@codebase=ref$args{codebase}? @{$args{codebase}}: ($args{codebase})}else {my$distfile=$build->ppm_name .'.tar.gz';print "Using default codebase '$distfile'\n";@codebase=($distfile)}my%dist;for my$info (qw(name author abstract version)){my$method="dist_$info";$dist{$info}=$build->$method()or die "Can't determine distribution's $info\n"}$self->_simple_xml_escape($_)foreach$dist{abstract},@{$dist{author}};my$ppd=<<"PPD";for my$type (qw(requires)){my$prereq=$build->$type();for my$modname (sort keys %$prereq){next if$modname eq 'perl';my$min_version='0.0';for my$c ($build->_parse_conditions($prereq->{$modname})){my ($op,$version)=$c =~ /^\s*  (<=?|>=?|==|!=)  \s*  ([\w.]+)  \s*$/x;if ($op eq '>='){$min_version=$version;last}}$modname .= '::' unless$modname =~ /::/;$ppd .= qq!        <REQUIRE NAME="$modname" VERSION="$min_version" />\n!}}if (keys %{$build->find_xs_files}){my$perl_version=$self->_ppd_version($build->perl_version);$ppd .= sprintf(<<'EOF',$self->_varchname($build->config))}for my$codebase (@codebase){$self->_simple_xml_escape($codebase);$ppd .= sprintf(<<'EOF',$codebase)}$ppd .= <<'EOF';my$ppd_file="$dist{name}.ppd";open(my$fh,'>',$ppd_file)or die "Cannot write to $ppd_file: $!";binmode($fh,":utf8")if $] >= 5.008 && $Config{useperlio};print$fh $ppd;close$fh;return$ppd_file}sub _ppd_version {my ($self,$version)=@_;return join ',',(split(/\./,$version),(0)x4)[0..3]}sub _varchname {my ($self,$config)=@_;my$varchname=$config->{archname};if ($] >= 5.008){my$vstring=sprintf "%vd",$^V;$vstring =~ s/\.\d+$//;$varchname .= "-$vstring"}return$varchname}{my%escapes=("\n"=>"\\n",'"'=>'&quot;','&'=>'&amp;','>'=>'&gt;','<'=>'&lt;',);my$rx=join '|',keys%escapes;sub _simple_xml_escape {$_[1]=~ s/($rx)/$escapes{$1}/go}}1;
  <SOFTPKG NAME=\"$dist{name}\" VERSION=\"$dist{version}\">
      <ABSTRACT>$dist{abstract}</ABSTRACT>
  @{[ join "\n", map "    <AUTHOR>$_</AUTHOR>", @{$dist{author}} ]}
      <IMPLEMENTATION>
  PPD
          <ARCHITECTURE NAME="%s" />
  EOF
          <CODEBASE HREF="%s" />
  EOF
      </IMPLEMENTATION>
  </SOFTPKG>
  EOF
MODULE_BUILD_PPMMAKER

$fatpacked{"Module/Build/Platform/Default.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_DEFAULT';
  package Module::Build::Platform::Default;use strict;use warnings;our$VERSION='0.4231';$VERSION=eval$VERSION;use Module::Build::Base;our@ISA=qw(Module::Build::Base);1;
MODULE_BUILD_PLATFORM_DEFAULT

$fatpacked{"Module/Build/Platform/MacOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_MACOS';
  package Module::Build::Platform::MacOS;use strict;use warnings;our$VERSION='0.4231';$VERSION=eval$VERSION;use Module::Build::Base;our@ISA=qw(Module::Build::Base);use ExtUtils::Install;sub have_forkpipe {0}sub new {my$class=shift;my$self=$class->SUPER::new(@_);for ('sitelib','sitearch'){$self->config($_=>$self->config("install$_"))unless$self->config($_)}(my$sp=$self->config('startperl'))=~ s/.*Exit \{Status\}\s//;$self->config(startperl=>$sp);return$self}sub make_executable {my$self=shift;require MacPerl;for (@_){MacPerl::SetFileInfo('McPL','TEXT',$_)}}sub dispatch {my$self=shift;if(!@_ and!@ARGV){require MacPerl;my@action_list=qw(build test install);my%actions=map {+($_,1)}$self->known_actions;delete@actions{@action_list};push@action_list,sort {$a cmp $b}keys%actions;my%toolserver=map {+$_=>1}qw(test disttest diff testdb);for (@action_list){$_ .= ' *' if$toolserver{$_}}my$cmd=MacPerl::Pick("What build command? ('*' requires ToolServer)",@action_list);return unless defined$cmd;$cmd =~ s/ \*$//;$ARGV[0]=($cmd);my$args=MacPerl::Ask('Any extra arguments?  (ie. verbose=1)','');return unless defined$args;push@ARGV,$self->split_like_shell($args)}$self->SUPER::dispatch(@_)}sub ACTION_realclean {my$self=shift;chmod 0666,$self->{properties}{build_script};$self->SUPER::ACTION_realclean}sub ACTION_install {my$self=shift;return$self->SUPER::ACTION_install(@_)if eval {ExtUtils::Install->VERSION('1.30');1};local $^W=0;local*ExtUtils::Install::find=sub {my ($code,@dirs)=@_;@dirs=map {$_ eq '.' ? File::Spec->curdir : $_}@dirs;return File::Find::find($code,@dirs)};return$self->SUPER::ACTION_install(@_)}1;
MODULE_BUILD_PLATFORM_MACOS

$fatpacked{"Module/Build/Platform/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_UNIX';
  package Module::Build::Platform::Unix;use strict;use warnings;our$VERSION='0.4231';$VERSION=eval$VERSION;use Module::Build::Base;our@ISA=qw(Module::Build::Base);sub is_executable {my ($self,$file)=@_;return +(stat$file)[2]& 0100}sub _startperl {"#! " .shift()->perl}sub _construct {my$self=shift()->SUPER::_construct(@_);my$c=$self->{config};for (qw(siteman1 siteman3 vendorman1 vendorman3)){$c->{"install${_}dir"}||= $c->{"install${_}"}}return$self}sub _detildefy {my ($self,$value)=@_;$value =~ s[^~([^/]+)?(?=/|$)]   # tilde with optional username [$1 ? (eval{(getpwnam $1)[7]}|| "~$1"): ($ENV{HOME}|| eval{(getpwuid $>)[7]}|| glob("~"))]ex;return$value}1;
MODULE_BUILD_PLATFORM_UNIX

$fatpacked{"Module/Build/Platform/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_VMS';
  package Module::Build::Platform::VMS;use strict;use warnings;our$VERSION='0.4231';$VERSION=eval$VERSION;use Module::Build::Base;use Config;our@ISA=qw(Module::Build::Base);sub _set_defaults {my$self=shift;$self->SUPER::_set_defaults(@_);$self->{properties}{build_script}='Build.com'}sub cull_args {my$self=shift;my($action,$args)=$self->SUPER::cull_args(@_);my@possible_actions=grep {lc $_ eq lc$action}$self->known_actions;die "Ambiguous action '$action'.  Could be one of @possible_actions" if@possible_actions > 1;return ($possible_actions[0],$args)}sub manpage_separator {return '__'}sub _catprefix {my($self,$rprefix,$default)=@_;my($rvol,$rdirs)=File::Spec->splitpath($rprefix);if($rvol){return File::Spec->catpath($rvol,File::Spec->catdir($rdirs,$default),'')}else {return File::Spec->catdir($rdirs,$default)}}sub _prefixify {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;return '' unless defined$path;$self->log_verbose("  prefixify $path from $sprefix to $rprefix\n");$rprefix=VMS::Filespec::vmspath($rprefix)if$rprefix;$sprefix=VMS::Filespec::vmspath($sprefix)if$sprefix;$self->log_verbose("  rprefix translated to $rprefix\n"."  sprefix translated to $sprefix\n");if(length($path)==0){$self->log_verbose("  no path to prefixify.\n")}elsif(!File::Spec->file_name_is_absolute($path)){$self->log_verbose("    path is relative, not prefixifying.\n")}elsif($sprefix eq $rprefix){$self->log_verbose("  no new prefix.\n")}else {my($path_vol,$path_dirs)=File::Spec->splitpath($path);my$vms_prefix=$self->config('vms_prefix');if($path_vol eq $vms_prefix.':'){$self->log_verbose("  $vms_prefix: seen\n");$path_dirs =~ s{^\[}{\[.} unless$path_dirs =~ m{^\[\.};$path=$self->_catprefix($rprefix,$path_dirs)}else {$self->log_verbose("    cannot prefixify.\n");return$self->prefix_relpaths($self->installdirs,$type)}}$self->log_verbose("    now $path\n");return$path}sub _quote_args {my ($self,@args)=@_;my$got_arrayref=(scalar(@args)==1 && ref$args[0]eq 'ARRAY')? 1 : 0;map {if (!/^\//){$_ =~ s/\"/""/g;$_=q(").$_.q(")}}($got_arrayref ? @{$args[0]}: @args);return$got_arrayref ? $args[0]: join(' ',@args)}sub have_forkpipe {0}sub _backticks {my ($self,@cmd)=@_;my$cmd=shift@cmd;my$args=$self->_quote_args(@cmd);return `$cmd $args`}sub find_command {my ($self,$command)=@_;if ($^O eq 'VMS'){require VMS::DCLsym;my$syms=VMS::DCLsym->new;return$command if scalar$syms->getsym(uc$command)}$self->SUPER::find_command($command)}sub _maybe_command {my($self,$file)=@_;return$file if -x $file &&!-d _;my(@dirs)=('');my(@exts)=('',$Config{'exe_ext'},'.exe','.com');if ($file !~ m![/:>\]]!){for (my$i=0;defined$ENV{"DCL\$PATH;$i"};$i++){my$dir=$ENV{"DCL\$PATH;$i"};$dir .= ':' unless$dir =~ m%[\]:]$%;push(@dirs,$dir)}push(@dirs,'Sys$System:');for my$dir (@dirs){my$sysfile="$dir$file";for my$ext (@exts){return$file if -x "$sysfile$ext" &&!-d _}}}return}sub do_system {my ($self,@cmd)=@_;$self->log_verbose("@cmd\n");my$cmd=shift@cmd;my$args=$self->_quote_args(@cmd);return!system("$cmd $args")}sub oneliner {my$self=shift;my$oneliner=$self->SUPER::oneliner(@_);$oneliner =~ s/^\"\S+\"//;return "MCR $^X $oneliner"}sub rscan_dir {my ($self,$dir,$pattern)=@_;my$result=$self->SUPER::rscan_dir($dir,$pattern);for my$file (@$result){if (!_efs()&& ($file =~ m#/#)){$file =~ s/\.$//}}return$result}sub dist_dir {my$self=shift;my$dist_dir=$self->SUPER::dist_dir;$dist_dir =~ s/\./_/g unless _efs();return$dist_dir}sub man3page_name {my$self=shift;my$mpname=$self->SUPER::man3page_name(shift);my$sep=$self->manpage_separator;$mpname =~ s/^$sep//;return$mpname}sub expand_test_dir {my ($self,$dir)=@_;my@reldirs=$self->SUPER::expand_test_dir($dir);for my$eachdir (@reldirs){my ($v,$d,$f)=File::Spec->splitpath($eachdir);my$reldir=File::Spec->abs2rel(File::Spec->catpath($v,$d,''));$eachdir=File::Spec->catfile($reldir,$f)}return@reldirs}sub _detildefy {my ($self,$arg)=@_;return$arg if ($arg =~ /^~~/);return$arg if ($arg =~ /^~ /);if ($arg =~ /^~/){my$spec=$arg;$spec =~ s/^~//;$spec =~ s#^/##;my$home=VMS::Filespec::unixify($ENV{HOME});$home .= '/' unless$home =~ m#/$#;if ($spec eq ''){$home =~ s#/$##;return$home}my ($hvol,$hdir,$hfile)=File::Spec::Unix->splitpath($home);if ($hdir eq ''){$hdir=$hfile}my ($vol,$dir,$file)=File::Spec::Unix->splitpath($spec);my@hdirs=File::Spec::Unix->splitdir($hdir);my@dirs=File::Spec::Unix->splitdir($dir);unless ($arg =~ m#^~/#){shift@dirs}my$newdirs=File::Spec::Unix->catdir(@hdirs,@dirs);$arg=File::Spec::Unix->catpath($hvol,$newdirs,$file)}return$arg}sub find_perl_interpreter {return VMS::Filespec::vmsify($^X)}sub localize_file_path {my ($self,$path)=@_;$path=VMS::Filespec::vmsify($path);$path =~ s/\.\z//;return$path}sub localize_dir_path {my ($self,$path)=@_;return VMS::Filespec::vmspath($path)}sub ACTION_clean {my ($self)=@_;for my$item (map glob(VMS::Filespec::rmsexpand($_,'.;0')),$self->cleanup){$self->delete_filetree($item)}}my$use_feature;BEGIN {if (eval {local$SIG{__DIE__};require VMS::Feature}){$use_feature=1}}sub _unix_rpt {my$unix_rpt;if ($use_feature){$unix_rpt=VMS::Feature::current("filename_unix_report")}else {my$env_unix_rpt=$ENV{'DECC$FILENAME_UNIX_REPORT'}|| '';$unix_rpt=$env_unix_rpt =~ /^[ET1]/i}return$unix_rpt}sub _efs {my$efs;if ($use_feature){$efs=VMS::Feature::current("efs_charset")}else {my$env_efs=$ENV{'DECC$EFS_CHARSET'}|| '';$efs=$env_efs =~ /^[ET1]/i}return$efs}1;
MODULE_BUILD_PLATFORM_VMS

$fatpacked{"Module/Build/Platform/VOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_VOS';
  package Module::Build::Platform::VOS;use strict;use warnings;our$VERSION='0.4231';$VERSION=eval$VERSION;use Module::Build::Base;our@ISA=qw(Module::Build::Base);1;
MODULE_BUILD_PLATFORM_VOS

$fatpacked{"Module/Build/Platform/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_WINDOWS';
  package Module::Build::Platform::Windows;use strict;use warnings;our$VERSION='0.4231';$VERSION=eval$VERSION;use Config;use File::Basename;use File::Spec;use Module::Build::Base;our@ISA=qw(Module::Build::Base);sub manpage_separator {return '.'}sub have_forkpipe {0}sub _detildefy {my ($self,$value)=@_;$value =~ s,^~(?= [/\\] | $ ),$ENV{HOME},x if$ENV{HOME};return$value}sub ACTION_realclean {my ($self)=@_;$self->SUPER::ACTION_realclean();my$basename=basename($0);$basename =~ s/(?:\.bat)?$//i;if (lc$basename eq lc$self->build_script){if ($self->build_bat){$self->log_verbose("Deleting $basename.bat\n");my$full_progname=$0;$full_progname =~ s/(?:\.bat)?$/.bat/i;require Win32;my$null_arg=(Win32::IsWinNT())? '""' : '';my$cmd=qq(start $null_arg /min "\%comspec\%" /c del "$full_progname");open(my$fh,'>>',"$basename.bat")or die "Can't create $basename.bat: $!";print$fh $cmd;close$fh }else {$self->delete_filetree($self->build_script .'.bat')}}}sub make_executable {my$self=shift;$self->SUPER::make_executable(@_);for my$script (@_){if ($script =~ /\.(bat|cmd)$/){$self->SUPER::make_executable($script);next}else {my%opts=();if ($script eq $self->build_script){$opts{ntargs}=q(-x -S %0 --build_bat %*);$opts{otherargs}=q(-x -S "%0" --build_bat %1 %2 %3 %4 %5 %6 %7 %8 %9)}my$out=eval {$self->pl2bat(in=>$script,update=>1,%opts)};if ($@){$self->log_warn("WARNING: Unable to convert file '$script' to an executable script:\n$@")}else {$self->SUPER::make_executable($out)}}}}sub pl2bat {my$self=shift;my%opts=@_;require ExtUtils::PL2Bat;return ExtUtils::PL2Bat::pl2bat(%opts)}sub _quote_args {my ($self,@args)=@_;my@quoted;for (@args){if (/^[^\s*?!\$<>;|'"\[\]\{\}]+$/){push@quoted,$_}else {s/"/\\"/g;push@quoted,qq("$_")}}return join " ",@quoted}sub split_like_shell {(my$self,local $_)=@_;return @$_ if defined()&& ref()eq 'ARRAY';my@argv;return@argv unless defined()&& length();my$length=length;m/\G\s*/gc;ARGS: until (pos==$length){my$quote_mode;my$arg='';CHARS: until (pos==$length){if (m/\G((?:\\\\)+)(?=\\?(")?)/gc){if (defined $2){$arg .= '\\' x (length($1)/ 2)}else {$arg .= $1}}elsif (m/\G\\"/gc){$arg .= '"'}elsif (m/\G"/gc){if ($quote_mode && m/\G"/gc){$arg .= '"'}$quote_mode=!$quote_mode}elsif (!$quote_mode && m/\G\s+/gc){last}elsif (m/\G(.)/sgc){$arg .= $1}}push@argv,$arg}return@argv}sub do_system {my ($self,@cmd)=@_;my$cmd=$self->_quote_args(@cmd);my$status=system($cmd);if ($status and $! =~ /Argument list too long/i){my$env_entries='';for (sort keys%ENV){$env_entries .= "$_=>".length($ENV{$_})."; "}warn "'Argument list' was 'too long', env lengths are $env_entries"}return!$status}sub _maybe_command {my($self,$file)=@_;my@e=exists($ENV{'PATHEXT'})? split(/;/,$ENV{PATHEXT}): qw(.com .exe .bat .cmd);my$e='';for (@e){$e .= "\Q$_\E|"}chop$e;if ($file =~ /($e)$/i){return$file if -e $file}else {for (@e){return "$file$_" if -e "$file$_"}}return}1;
MODULE_BUILD_PLATFORM_WINDOWS

$fatpacked{"Module/Build/Platform/aix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_AIX';
  package Module::Build::Platform::aix;use strict;use warnings;our$VERSION='0.4231';$VERSION=eval$VERSION;use Module::Build::Platform::Unix;our@ISA=qw(Module::Build::Platform::Unix);1;
MODULE_BUILD_PLATFORM_AIX

$fatpacked{"Module/Build/Platform/cygwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_CYGWIN';
  package Module::Build::Platform::cygwin;use strict;use warnings;our$VERSION='0.4231';$VERSION=eval$VERSION;use Module::Build::Platform::Unix;our@ISA=qw(Module::Build::Platform::Unix);sub manpage_separator {'.'}sub _maybe_command {my ($self,$file)=@_;if ($file =~ m{^/cygdrive/}i){require Module::Build::Platform::Windows;return Module::Build::Platform::Windows->_maybe_command($file)}return$self->SUPER::_maybe_command($file)}1;
MODULE_BUILD_PLATFORM_CYGWIN

$fatpacked{"Module/Build/Platform/darwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_DARWIN';
  package Module::Build::Platform::darwin;use strict;use warnings;our$VERSION='0.4231';$VERSION=eval$VERSION;use Module::Build::Platform::Unix;our@ISA=qw(Module::Build::Platform::Unix);1;
MODULE_BUILD_PLATFORM_DARWIN

$fatpacked{"Module/Build/Platform/os2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_OS2';
  package Module::Build::Platform::os2;use strict;use warnings;our$VERSION='0.4231';$VERSION=eval$VERSION;use Module::Build::Platform::Unix;our@ISA=qw(Module::Build::Platform::Unix);sub manpage_separator {'.'}sub have_forkpipe {0}sub _maybe_command {my($self,$file)=@_;$file =~ s,[/\\]+,/,g;return$file if -x $file &&!-d _;return "$file.exe" if -x "$file.exe" &&!-d _;return "$file.cmd" if -x "$file.cmd" &&!-d _;return}1;
MODULE_BUILD_PLATFORM_OS2

$fatpacked{"Module/Build/PodParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PODPARSER';
  package Module::Build::PodParser;use strict;use warnings;our$VERSION='0.4231';$VERSION=eval$VERSION;sub new {my$package=shift;my$self;$self=bless {have_pod_parser=>0,@_},$package;unless ($self->{fh}){die "No 'file' or 'fh' parameter given" unless$self->{file};open($self->{fh},'<',$self->{file})or die "Couldn't open $self->{file}: $!"}return$self}sub parse_from_filehandle {my ($self,$fh)=@_;local $_;while (<$fh>){next unless /^=(?!cut)/ .. /^=cut/;last if ($self->{abstract})=/^ (?: [a-z_0-9:]+ | [BCIF] < [a-z_0-9:]+ > ) \s+ - \s+ (.*\S) /ix}my@author;while (<$fh>){next unless /^=head1\s+AUTHORS?/i ... /^=/;next if /^=/;push@author,$_ if /\@/}return unless@author;s/^\s+|\s+$//g foreach@author;$self->{author}=\@author;return}sub get_abstract {my$self=shift;return$self->{abstract}if defined$self->{abstract};$self->parse_from_filehandle($self->{fh});return$self->{abstract}}sub get_author {my$self=shift;return$self->{author}if defined$self->{author};$self->parse_from_filehandle($self->{fh});return$self->{author}|| []}
MODULE_BUILD_PODPARSER

$fatpacked{"Module/Build/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_TINY';
  package Module::Build::Tiny;$Module::Build::Tiny::VERSION='0.039';use strict;use warnings;use Exporter 5.57 'import';our@EXPORT=qw/Build Build_PL/;use CPAN::Meta;use ExtUtils::Config 0.003;use ExtUtils::Helpers 0.020 qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;use ExtUtils::Install qw/pm_to_blib install/;use ExtUtils::InstallPaths 0.002;use File::Basename qw/basename dirname/;use File::Find ();use File::Path qw/mkpath rmtree/;use File::Spec::Functions qw/catfile catdir rel2abs abs2rel splitdir curdir/;use Getopt::Long 2.36 qw/GetOptionsFromArray/;use JSON::PP 2 qw/encode_json decode_json/;sub write_file {my ($filename,$content)=@_;open my$fh,'>',$filename or die "Could not open $filename: $!\n";print$fh $content}sub read_file {my ($filename,$mode)=@_;open my$fh,'<',$filename or die "Could not open $filename: $!\n";return do {local $/;<$fh>}}sub get_meta {my ($metafile)=grep {-e $_}qw/META.json META.yml/ or die "No META information provided\n";return CPAN::Meta->load_file($metafile)}sub manify {my ($input_file,$output_file,$section,$opts)=@_;return if -e $output_file && -M $input_file <= -M $output_file;my$dirname=dirname($output_file);mkpath($dirname,$opts->{verbose})if not -d $dirname;require Pod::Man;Pod::Man->new(section=>$section)->parse_from_file($input_file,$output_file);print "Manifying $output_file\n" if$opts->{verbose}&& $opts->{verbose}> 0;return}sub process_xs {my ($source,$options)=@_;die "Can't build xs files under --pureperl-only\n" if$options->{'pureperl-only'};my (undef,@parts)=splitdir(dirname($source));push@parts,my$file_base=basename($source,'.xs');my$archdir=catdir(qw/blib arch auto/,@parts);my$tempdir='temp';my$c_file=catfile($tempdir,"$file_base.c");require ExtUtils::ParseXS;mkpath($tempdir,$options->{verbose},oct '755');ExtUtils::ParseXS::process_file(filename=>$source,prototypes=>0,output=>$c_file);my$version=$options->{meta}->version;require ExtUtils::CBuilder;my$builder=ExtUtils::CBuilder->new(config=>$options->{config}->values_set);my$ob_file=$builder->compile(source=>$c_file,defines=>{VERSION=>qq/"$version"/,XS_VERSION=>qq/"$version"/ },include_dirs=>[curdir,dirname($source)]);require DynaLoader;my$mod2fname=defined&DynaLoader::mod2fname ? \&DynaLoader::mod2fname : sub {return $_[0][-1]};mkpath($archdir,$options->{verbose},oct '755')unless -d $archdir;my$lib_file=catfile($archdir,$mod2fname->(\@parts).'.' .$options->{config}->get('dlext'));return$builder->link(objects=>$ob_file,lib_file=>$lib_file,module_name=>join '::',@parts)}sub find {my ($pattern,$dir)=@_;my@ret;File::Find::find(sub {push@ret,$File::Find::name if /$pattern/ && -f},$dir)if -d $dir;return@ret}my%actions=(build=>sub {my%opt=@_;for my$pl_file (find(qr/\.PL$/,'lib')){(my$pm=$pl_file)=~ s/\.PL$//;system $^X,$pl_file,$pm and die "$pl_file returned $?\n"}my%modules=map {$_=>catfile('blib',$_)}find(qr/\.p(?:m|od)$/,'lib');my%scripts=map {$_=>catfile('blib',$_)}find(qr//,'script');my%shared=map {$_=>catfile(qw/blib lib auto share dist/,$opt{meta}->name,abs2rel($_,'share'))}find(qr//,'share');pm_to_blib({%modules,%scripts,%shared },catdir(qw/blib lib auto/));make_executable($_)for values%scripts;mkpath(catdir(qw/blib arch/),$opt{verbose});process_xs($_,\%opt)for find(qr/.xs$/,'lib');if ($opt{install_paths}->install_destination('bindoc')&& $opt{install_paths}->is_default_installable('bindoc')){manify($_,catfile('blib','bindoc',man1_pagename($_)),$opt{config}->get('man1ext'),\%opt)for keys%scripts}if ($opt{install_paths}->install_destination('libdoc')&& $opt{install_paths}->is_default_installable('libdoc')){manify($_,catfile('blib','libdoc',man3_pagename($_)),$opt{config}->get('man3ext'),\%opt)for keys%modules}},test=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';require TAP::Harness::Env;my%test_args=((verbosity=>$opt{verbose})x!!exists$opt{verbose},(jobs=>$opt{jobs})x!!exists$opt{jobs},(color=>1)x!!-t STDOUT,lib=>[map {rel2abs(catdir(qw/blib/,$_))}qw/arch lib/ ],);my$tester=TAP::Harness::Env->create(\%test_args);$tester->runtests(sort +find(qr/\.t$/,'t'))->has_errors and exit 1},install=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';install($opt{install_paths}->install_map,@opt{qw/verbose dry_run uninst/})},clean=>sub {my%opt=@_;rmtree($_,$opt{verbose})for qw/blib temp/},realclean=>sub {my%opt=@_;rmtree($_,$opt{verbose})for qw/blib temp Build _build_params MYMETA.yml MYMETA.json/},);sub Build {my$action=@ARGV && $ARGV[0]=~ /\A\w+\z/ ? shift@ARGV : 'build';die "No such action '$action'\n" if not $actions{$action};my($env,$bargv)=@{decode_json(read_file('_build_params'))};my%opt;GetOptionsFromArray($_,\%opt,qw/install_base=s install_path=s% installdirs=s destdir=s prefix=s config=s% uninst:1 verbose:1 dry_run:1 pureperl-only:1 create_packlist=i jobs=i/)for ($env,$bargv,\@ARGV);$_=detildefy($_)for grep {defined}@opt{qw/install_base destdir prefix/},values %{$opt{install_path}};@opt{'config','meta' }=(ExtUtils::Config->new($opt{config}),get_meta());$actions{$action}->(%opt,install_paths=>ExtUtils::InstallPaths->new(%opt,dist_name=>$opt{meta}->name))}sub Build_PL {my$meta=get_meta();printf "Creating new 'Build' script for '%s' version '%s'\n",$meta->name,$meta->version;my$dir=$meta->name eq 'Module-Build-Tiny' ? "use lib 'lib';" : '';write_file('Build',"#!perl\n$dir\nuse Module::Build::Tiny;\nBuild();\n");make_executable('Build');my@env=defined$ENV{PERL_MB_OPT}? split_like_shell($ENV{PERL_MB_OPT}): ();write_file('_build_params',encode_json([\@env,\@ARGV ]));$meta->save(@$_)for ['MYMETA.json'],['MYMETA.yml'=>{version=>1.4 }]}1;
MODULE_BUILD_TINY

$fatpacked{"Net/OpenSSH.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH';
  package Net::OpenSSH;our$VERSION='0.82';use strict;use warnings;our$debug ||= 0;our$debug_fh ||= \*STDERR;our$FACTORY;use Carp qw(carp croak);use POSIX qw(:sys_wait_h);use Socket;use File::Spec;use Cwd ();use Scalar::Util ();use Errno ();use Net::OpenSSH::Constants qw(:error :_state);use Net::OpenSSH::ModuleLoader;use Net::OpenSSH::ShellQuoter;use Digest::MD5;my$thread_generation=0;sub CLONE {$thread_generation++};sub _debug {local ($!,$@);print {$debug_fh}'# ',(map {defined($_)? $_ : '<undef>'}@_),"\n"}sub _debug_dump {local ($!,$@);require Data::Dumper;local$Data::Dumper::Terse=1;local$Data::Dumper::Indent=0;my$head=shift;_debug("$head: ",Data::Dumper::Dumper(@_))}sub _hexdump {no warnings qw(uninitialized);my$data=shift;while ($data =~ /(.{1,32})/smg){my$line=$1;my@c=((map {sprintf "%02x",$_}unpack('C*',$line)),(("  ")x 32))[0..31];$line=~s/(.)/ my $c=$1; unpack("c",$c)>=32 ? $c : '.' /egms;print {$debug_fh}"#> ",join(" ",@c,'|',$line),"\n"}}{my%good;sub _sub_options {my$sub=shift;$good{__PACKAGE__ ."::$sub"}={map {$_=>1}@_ }}sub _croak_bad_options (\%) {my$opts=shift;if (%$opts){my$sub=(caller 1)[3];my$good=$good{$sub};my@keys=grep defined($opts->{$_}),($good ? grep!$good->{$_},keys %$opts : keys %$opts);if (@keys){croak "Invalid or bad combination of options ('" .CORE::join("', '",@keys)."')"}}}}sub _croak_scalar_context {my ($sub,$wantarray)=(caller 1)[3,5];unless ($wantarray){$sub =~ s/^.*:://;croak "method '$sub' called in scalar context"}}sub _tcroak {if (${^TAINT} > 0){push @_," while running with -T switch";goto&croak}if (${^TAINT} < 0){push @_," while running with -t switch";goto&carp}}sub _catch_tainted_args {my$i;for (@_){next unless$i++;if (Scalar::Util::tainted($_)){my (undef,undef,undef,$subn)=caller 1;my$msg=($subn =~ /::([a-z]\w*)$/ ? "Insecure argument '$_' on '$1' method call" : "Insecure argument '$_' on method call");_tcroak($msg)}elsif (ref($_)eq 'HASH'){for (grep Scalar::Util::tainted($_),values %$_){my (undef,undef,undef,$subn)=caller 1;my$msg=($subn =~ /::([a-z]\w*)$/ ? "Insecure argument on '$1' method call" : "Insecure argument on method call");_tcroak($msg)}}}}sub _set_error {my$self=shift;my$code=shift || 0;my@extra=grep defined,@_;my$err=$self->{_error}=($code ? Scalar::Util::dualvar($code,join(': ',@{$self->{_error_prefix}},(@extra ? @extra : "Unknown error $code"))): 0);$debug and $debug & 1 and _debug "set_error($code - $err)";return$err}my$check_eval_re=do {my$path=quotemeta$INC{"Net/OpenSSH.pm"};qr/at $path line \d+.$/};sub _check_eval_ok {my ($self,$code)=@_;if ($@){my$err=$@;$err =~ s/$check_eval_re//;$self->_set_error($code,$err);return}1}sub _or_set_error {my$self=shift;$self->{_error}or $self->_set_error(@_)}sub _first_defined {defined && return $_ for @_;return}my$obfuscate=sub {my$txt=shift;$txt =~ s/(.)/chr(ord($1) ^ 47)/ges if defined$txt;$txt};my$deobfuscate=$obfuscate;my$IPv6_re=qr((?-xism::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))));sub parse_connection_opts {my ($class,$opts)=@_;my ($user,$passwd,$ipv6,$host,$port,$host_squared);my$target=delete$opts->{host};defined$target or croak "mandatory host argument missing";($user,$passwd,$ipv6,$host,$port)=$target =~ m{^
                         \s*               # space
                         (?:
                           ([^:]+)         # username
                           (?::(.*))?      # : password
                           \@              # @
                         )?
                         (?:               # host
                            (              #   IPv6...
                              \[$IPv6_re(?:\%[^\[\]]*)\] #     [IPv6]
                              |            #     or
                              $IPv6_re     #     IPv6
                            )
                            |              #   or
                            ([^\[\]\@:]+)  #   hostname / ipv4
                         )
                         (?::([^\@:]+))?   # port
                         \s*               # space
                       $}ix or croak "bad host/target '$target' specification";if (defined$ipv6){($host)=$ipv6 =~ /^\[?(.*?)\]?$/;$host_squared="[$host]"}else {$host_squared=$host}$user=delete$opts->{user}unless defined$user;$port=delete$opts->{port}unless defined$port;$passwd=delete$opts->{passwd}unless defined$passwd;$passwd=delete$opts->{password}unless defined$passwd;wantarray and return ($host,$port,$user,$passwd,$host_squared);my%r=(user=>$user,password=>$passwd,host=>$host,host_squared=>$host_squared,port=>$port);$r{ipv6}=1 if defined$ipv6;return \%r}my$sizeof_sun_path=($^O eq 'linux' ? 108 : $^O =~ /bsd/i ? 104 : $^O eq 'hpux' ? 92 : undef);sub new {${^TAINT} and &_catch_tainted_args;my$class=shift;@_ & 1 and unshift @_,'host';return$FACTORY->($class,@_)if defined$FACTORY;my%opts=@_;my$external_master=delete$opts{external_master};$external_master=delete$opts{reuse_master}unless defined$external_master;if (not defined$opts{host}and defined$external_master){$opts{host}='0.0.0.0'}my ($host,$port,$user,$passwd,$host_squared)=$class->parse_connection_opts(\%opts);my ($passphrase,$key_path,$login_handler);unless (defined$passwd){$key_path=delete$opts{key_path};$passwd=delete$opts{passphrase};if (defined$passwd){$passphrase=1}else {$login_handler=delete$opts{login_handler}}}my$ssh_version=delete$opts{ssh_version};my$batch_mode=delete$opts{batch_mode};my$ctl_path=delete$opts{ctl_path};my$ctl_dir=delete$opts{ctl_dir};my$proxy_command=delete$opts{proxy_command};my$gateway=delete$opts{gateway}unless defined$proxy_command;my$ssh_cmd=_first_defined delete$opts{ssh_cmd},'ssh';my$rsync_cmd=_first_defined delete$opts{rsync_cmd},'rsync';my$scp_cmd=delete$opts{scp_cmd};my$sshfs_cmd=_first_defined delete$opts{sshfs_cmd},'sshfs';my$sftp_server_cmd=_first_defined delete$opts{sftp_server_cmd},'/usr/lib/openssh/sftp-server';my$timeout=delete$opts{timeout};my$kill_ssh_on_timeout=delete$opts{kill_ssh_on_timeout};my$strict_mode=_first_defined delete$opts{strict_mode},1;my$connect=_first_defined delete$opts{connect},1;my$async=delete$opts{async};my$remote_shell=_first_defined delete$opts{remote_shell},'POSIX';my$expand_vars=delete$opts{expand_vars};my$vars=_first_defined delete$opts{vars},{};my$default_encoding=delete$opts{default_encoding};my$default_stream_encoding=_first_defined delete$opts{default_stream_encoding},$default_encoding;my$default_argument_encoding=_first_defined delete$opts{default_argument_encoding},$default_encoding;my$forward_agent=delete$opts{forward_agent};$forward_agent and $passphrase and croak "agent forwarding can not be used when a passphrase has also been given";my$forward_X11=delete$opts{forward_X11};my$passwd_prompt=delete$opts{password_prompt};my$master_pty_force=delete$opts{master_pty_force};$passwd_prompt=delete$opts{passwd_prompt}unless defined$passwd_prompt;my ($master_opts,@master_opts,$master_stdout_fh,$master_stderr_fh,$master_stdout_discard,$master_stderr_discard,$master_setpgrp);unless ($external_master){($master_stdout_fh=delete$opts{master_stdout_fh}or $master_stdout_discard=delete$opts{master_stdout_discard});($master_stderr_fh=delete$opts{master_stderr_fh}or $master_stderr_discard=delete$opts{master_stderr_discard});$master_opts=delete$opts{master_opts};if (defined$master_opts){if (ref$master_opts){@master_opts=@$master_opts}else {carp "'master_opts' argument looks like if it should be splited first" if$master_opts =~ /^-\w\s+\S/;@master_opts=$master_opts}}$master_setpgrp=delete$opts{master_setpgrp};undef$master_setpgrp if$login_handler or defined$passwd}my$default_ssh_opts=delete$opts{default_ssh_opts};carp "'default_ssh_opts' argument looks like if it should be splited first" if defined$default_ssh_opts and not ref$default_ssh_opts and $default_ssh_opts =~ /^-\w\s+\S/;my ($default_stdout_fh,$default_stderr_fh,$default_stdin_fh,$default_stdout_file,$default_stderr_file,$default_stdin_file,$default_stdout_discard,$default_stderr_discard,$default_stdin_discard);$default_stdout_file=(delete$opts{default_stdout_discard}? '/dev/null' : delete$opts{default_stdout_file});$default_stdout_fh=delete$opts{default_stdout_fh}unless defined$default_stdout_file;$default_stderr_file=(delete$opts{default_stderr_discard}? '/dev/null' : delete$opts{default_stderr_file});$default_stderr_fh=delete$opts{default_stderr_fh}unless defined$default_stderr_file;$default_stdin_file=(delete$opts{default_stdin_discard}? '/dev/null' : delete$opts{default_stdin_file});$default_stdin_fh=delete$opts{default_stdin_fh}unless defined$default_stdin_file;_croak_bad_options%opts;my@ssh_opts;push@ssh_opts,-l=>$user if defined$user;push@ssh_opts,-p=>$port if defined$port;my$home=do {local ($@,$SIG{__DIE__});eval {Cwd::realpath((getpwuid $>)[7])}};if (${^TAINT}){($home)=$home =~ /^(.*)$/;Scalar::Util::tainted($ENV{PATH})and _tcroak('Insecure $ENV{PATH}')}my$self={_error=>0,_error_prefix=>[],_perl_pid=>$$,_thread_generation=>$thread_generation,_ssh_version=>$ssh_version,_ssh_cmd=>$ssh_cmd,_scp_cmd=>$scp_cmd,_rsync_cmd=>$rsync_cmd,_sshfs_cmd=>$sshfs_cmd,_sftp_server_cmd=>$sftp_server_cmd,_pid=>undef,_host=>$host,_host_squared=>$host_squared,_user=>$user,_port=>$port,_passwd=>$obfuscate->($passwd),_passwd_prompt=>$passwd_prompt,_passphrase=>$passphrase,_key_path=>$key_path,_login_handler=>$login_handler,_timeout=>$timeout,_proxy_command=>$proxy_command,_gateway_args=>$gateway,_kill_ssh_on_timeout=>$kill_ssh_on_timeout,_batch_mode=>$batch_mode,_home=>$home,_forward_agent=>$forward_agent,_forward_X11=>$forward_X11,_external_master=>$external_master,_default_ssh_opts=>$default_ssh_opts,_default_stdin_fh=>$default_stdin_fh,_default_stdout_fh=>$default_stdout_fh,_default_stderr_fh=>$default_stderr_fh,_master_stdout_fh=>$master_stdout_fh,_master_stderr_fh=>$master_stderr_fh,_master_stdout_discard=>$master_stdout_discard,_master_stderr_discard=>$master_stderr_discard,_master_setpgrp=>$master_setpgrp,_master_pty_force=>$master_pty_force,_remote_shell=>$remote_shell,_default_stream_encoding=>$default_stream_encoding,_default_argument_encoding=>$default_argument_encoding,_expand_vars=>$expand_vars,_vars=>$vars,_master_state=>_STATE_START,};bless$self,$class;$self->_detect_ssh_version;$self->{_default_stdout_fh}=$self->_open_file('>',$default_stdout_file)if defined$default_stdout_file;$self->{_default_stderr_fh}=$self->_open_file('>',$default_stderr_file)if defined$default_stderr_file;$self->{_default_stdin_fh}=$self->_open_file('<',$default_stdin_file)if defined$default_stdin_file;if ($self->{_error}==OSSH_SLAVE_PIPE_FAILED){$self->_master_fail($async,"Unable to create default slave stream",$self->{_error});return$self}$self->{_ssh_opts}=[$self->_expand_vars(@ssh_opts)];$self->{_master_opts}=[$self->_expand_vars(@master_opts)];$ctl_path=$self->_expand_vars($ctl_path);$ctl_dir=$self->_expand_vars($ctl_dir);if (defined$ctl_path){if ($external_master){unless (-S $ctl_path){$self->_master_fail($async,"ctl_path $ctl_path does not point to a socket");return$self}}else {if (-e $ctl_path){$self->_master_fail($async,"unable to use ctl_path $ctl_path, a file object already exists there");return$self}}}else {$external_master and croak "external_master is set but ctl_path is not defined";unless (defined$ctl_dir){unless (defined$self->{_home}){$self->_master_fail($async,"unable to determine home directory for uid $>");return$self}$ctl_dir=File::Spec->catdir($self->{_home},".libnet-openssh-perl")}mkdir$ctl_dir,0700;unless (-d $ctl_dir){$self->_master_fail($async,"unable to create ctl_dir $ctl_dir");return$self}my$target=join('-',grep defined,$user,$host,$port);for (1..10){my$ctl_file=Digest::MD5::md5_hex(sprintf "%s-%d-%d-%d",$target,$$,time,rand 1e6);$ctl_path=File::Spec->join($ctl_dir,$ctl_file);last unless -e $ctl_path}if (-e $ctl_path){$self->_master_fail($async,"unable to find unused name for ctl_path inside ctl_dir $ctl_dir");return$self}}if (defined$sizeof_sun_path and length$ctl_path > $sizeof_sun_path){$self->_master_fail($async,"ctl_path $ctl_path is too long (max permissible size for $^O is $sizeof_sun_path)");return$self}$ctl_dir=File::Spec->catpath((File::Spec->splitpath($ctl_path))[0,1],"");$debug and $debug & 2 and _debug "ctl_path: $ctl_path, ctl_dir: $ctl_dir";if ($strict_mode and!$self->_is_secure_path($ctl_dir)){$self->_master_fail($async,"ctl_dir $ctl_dir is not secure");return$self}$self->{_ctl_path}=$ctl_path;$self->_master_wait($async)if$connect;$self}sub get_user {shift->{_user}}sub get_host {shift->{_host}}sub get_port {shift->{_port}}sub get_master_pid {shift->{_pid}}sub get_ctl_path {shift->{_ctl_path}}sub get_expand_vars {shift->{_expand_vars}}sub get_master_pty_log {shift->{_master_pty_log}}sub set_expand_vars {my$self=shift;$self->{_expand_vars}=(shift(@_)? 1 : 0)}sub set_var {${^TAINT} and &_catch_tainted_args;my$self=shift;my$k=shift;$k =~ /^(?:USER|HOST|PORT)$/ and croak "internal variable %$k% can not be set";$self->{_vars}{$k}=shift}sub get_var {my ($self,$k)=@_;my$v=($k =~ /^(?:USER|HOST|PORT)$/ ? $self->{lc "_$k"}: $self->{_vars}{$k});(defined$v ? $v : '')}sub _expand_vars {my ($self,@str)=@_;if (ref$self and $self->{_expand_vars}){for (@str){s{%(\w*)%}{length ($1) ? $self->get_var($1) : '%'}ge if defined $_}}wantarray ? @str : $str[0]}sub error {shift->{_error}}sub die_on_error {my$ssh=shift;$ssh->{_error}and croak(@_ ? "@_: $ssh->{_error}" : $ssh->{_error})}sub _is_secure_path {my ($self,$path)=@_;my@parts=File::Spec->splitdir(Cwd::realpath($path));my$home=$self->{_home};for my$last (reverse 0..$#parts){my$dir=File::Spec->catdir(@parts[0..$last]);unless (-d $dir){$debug and $debug & 2 and _debug "$dir is not a directory";return undef}my ($mode,$uid)=(stat$dir)[2,4];$debug and $debug & 2 and _debug "_is_secure_path(dir: $dir, file mode: $mode, file uid: $uid, euid: $>";return undef unless(($uid==$> or $uid==0)and (($mode & 022)==0 or ($mode & 01000)));return 1 if (defined$home and $home eq $dir)}return 1}sub _detect_ssh_version {my$self=shift;if (defined$self->{_ssh_version}){$debug and $debug & 4 and _debug "ssh version given as $self->{_ssh_version}"}else {my (undef,$out,undef,$pid)=$self->open_ex({_cmd=>'raw',_no_master_required=>1,stdout_pipe=>1,stdin_discard=>1,stderr_to_stdout=>1 },$self->{_ssh_cmd},'-V');my ($txt)=$self->_io3($out,undef,undef,undef,10,'bytes');local$self->{_kill_ssh_on_timeout}=1;$self->_waitpid($pid,10);if (my ($full,$num)=$txt =~ /^OpenSSH_((\d+\.\d+)\S*)/mi){$debug and $debug & 4 and _debug "OpenSSH version is $full";$self->{_ssh_version}=$num}else {$self->{_ssh_version}=0;$debug and $debug & 4 and _debug "unable to determine version, '$self->{_ssh_cmd} -V', output:\n$txt"}}}sub _make_ssh_call {my$self=shift;my@before=@{shift || []};my@args=($self->{_ssh_cmd},@before,-S=>$self->{_ctl_path},@{$self->{_ssh_opts}},$self->{_host},'--',(@_ ? "@_" : ()));$debug and $debug & 8 and _debug_dump 'call args'=>\@args;@args}sub _scp_cmd {my$self=shift;$self->{_scp_cmd}||= do {my$scp=$self->{_ssh_cmd};$scp =~ s/ssh$/scp/i or croak "scp command name not set";$scp}}sub _make_scp_call {my$self=shift;my@before=@{shift || []};my@args=($self->_scp_cmd,@before,-o=>"ControlPath=$self->{_ctl_path}",-S=>$self->{_ssh_cmd},(defined$self->{_port}? (-P=>$self->{_port}): ()),'--',@_);$debug and $debug & 8 and _debug_dump 'scp call args'=>\@args;@args}sub _rsync_quote {my ($self,@args)=@_;for (@args){if (/['"\s]/){s/"/""/g;$_=qq|"$_"|}s/%/%%/}wantarray ? @args : join(' ',@args)}sub _make_rsync_call {my$self=shift;my$before=shift;my@transport=($self->{_ssh_cmd},@$before,-S=>$self->{_ctl_path});my$transport=$self->_rsync_quote(@transport);my@args=($self->{_rsync_cmd},-e=>$transport,@_);$debug and $debug & 8 and _debug_dump 'rsync call args'=>\@args;@args}sub _make_W_option {my$self=shift;if (@_==1){my$path=shift;$path="./$path" unless$path =~ m|/|;$path =~ s/([\\:])/\\$1/g;return "-W$path"}if (@_==2){return "-W" .join(':',@_)}croak "bad number of arguments for creating a tunnel"}sub _make_tunnel_call {my$self=shift;my@before=@{shift||[]};push@before,$self->_make_W_option(@_);my@args=$self->_make_ssh_call(\@before);$debug and $debug & 8 and _debug_dump 'tunnel call args'=>\@args;@args}sub master_exited {my$self=shift;$self->_master_gone(1)}sub _master_gone {my$self=shift;my$async=shift;delete$self->{_pid};$self->_master_fail($async,(@_ ? @_ : "master process exited unexpectedly"))}my@kill_signal=qw(0 0 TERM TERM TERM KILL);sub __has_sigchld_handle {my$h=$SIG{CHLD};defined$h and $h ne 'IGNORE' and $h ne 'DEFAULT'}sub _master_kill {my ($self,$async)=@_;if (my$pid=$self->_my_master_pid){$debug and $debug & 32 and _debug '_master_kill: ',$pid;my$now=time;my$start=$self->{_master_kill_start}||= $now;$self->{_master_kill_last}||= $now;$self->{_master_kill_count}||= 0;local$SIG{CHLD}=sub {}unless$async or __has_sigchld_handle;while (1){if ($self->{_master_kill_last}< $now){$self->{_master_kill_last}=$now;my$sig=$kill_signal[$self->{_master_kill_count}++];$sig='KILL' unless defined$sig;$debug and $debug & 32 and _debug "killing master $$ with signal $sig";kill$sig,$pid}my$deceased=waitpid($pid,WNOHANG);$debug and $debug & 32 and _debug "waitpid(master: $pid) => pid: $deceased, rc: $!";last if$deceased==$pid or ($deceased < 0 and $!==Errno::ECHILD());if ($self->{_master_kill_count}> 20){$debug and $debug & 32 and _debug "unable to kill SSH master process, giving up";last}return if$async;select(undef,undef,undef,0.2);$now=time}}else {$debug and $debug & 32 and _debug("not killing master SSH (",$self->{_pid},") started from " ."process ",$self->{_perl_pid},"/",$self->{_thread_generation},", current ",$$,"/",$thread_generation,")")}$self->_master_gone($async)}sub disconnect {my ($self,$async)=@_;@_ <= 2 or croak 'Usage: $self->disconnect([$async])';$self->_disconnect($async,1)}sub disown_master {my$self=shift;if (my$pid=$self->_my_master_pid){if ($self->wait_for_master){$self->{_external_master}=1;return$pid}}undef}sub restart {my ($self,$async)=@_;$self->{_external_master}and croak "Can restart SSH connection when using external master";$self->_disconnect($async,1)unless$async;if ($self->{_master_state}!=_STATE_GONE){croak "restart method called in wrong state (terminate the connection first!)" if$async;return$self->_master_fail($async,"Unable to restart SSH session from state $self->{_master_state}")}delete$self->{_master_kill_start};delete$self->{_master_kill_last};delete$self->{_master_kill_count};$self->_master_jump_state(_STATE_START,$async)}sub _my_master_pid {my$self=shift;unless ($self->{_external_master}){my$pid=$self->{_pid};return$pid if $pid and $self->{_perl_pid}==$$ and $self->{_thread_generation}==$thread_generation}()}sub _disconnect {my ($self,$async,$send_ctl)=@_;return if$self->{_master_state}==_STATE_GONE;if (!$async and $self->{_master_state}==_STATE_RUNNING and ($send_ctl or $self->_my_master_pid)){$debug and $debug & 32 and _debug("sending exit control to master");$self->_master_ctl('exit')}$self->_master_fail($async,'aborted')}sub _check_is_system_fh {my ($name,$fh)=@_;my$fn=fileno(defined$fh ? $fh : $name);defined$fn and $fn >= 0 and return;croak "child process $name is not a real system file handle"}sub _master_redirect {my$self=shift;my$uname=uc shift;my$name=lc$uname;no strict 'refs';if ($self->{"_master_${name}_discard"}){open *$uname,'>>','/dev/null'}else {my$fh=$self->{"_master_${name}_fh"};$fh=$self->{"_default_${name}_fh"}unless defined$fh;if (defined$fh){_check_is_system_fh$uname=>$fh;if (fileno$fh!=fileno *$uname){open *$uname,'>>&',$fh or POSIX::_exit(255)}}}}sub _waitpid {my ($self,$pid,$timeout)=@_;$?=0;if ($pid){$timeout=$self->{_timeout}unless defined$timeout;my$time_limit;if (defined$timeout and $self->{_kill_ssh_on_timeout}){$timeout=0 if$self->{_error}==OSSH_SLAVE_TIMEOUT;$time_limit=time + $timeout}local$SIG{CHLD}=sub {}unless __has_sigchld_handle;while (1){my$deceased;if (defined$time_limit){while (1){$deceased=waitpid($pid,WNOHANG)and last;my$remaining=$time_limit - time;if ($remaining <= 0){$debug and $debug & 16 and _debug "killing SSH slave, pid: $pid";kill TERM=>$pid;$self->_or_set_error(OSSH_SLAVE_TIMEOUT,"ssh slave failed","timed out")}my$sleep=($remaining < 0.1 ? 0.1 : 1);$debug and $debug & 16 and _debug "waiting for slave, timeout: $timeout, remaining: $remaining, sleep: $sleep";$deceased=waitpid($pid,WNOHANG)and last;select(undef,undef,undef,$sleep)}}else {$deceased=waitpid($pid,0)}$debug and $debug & 16 and _debug "_waitpid($pid) => pid: $deceased, rc: $?, err: $!";if ($deceased==$pid){if ($?){my$signal=($? & 255);my$errstr="child exited with code " .($? >> 8);$errstr .= ", signal $signal" if$signal;$self->_or_set_error(OSSH_SLAVE_CMD_FAILED,$errstr);return undef}return 1}elsif ($deceased < 0){next if $!==Errno::EINTR();if ($!==Errno::ECHILD()){$self->_or_set_error(OSSH_SLAVE_FAILED,"child process $pid does not exist",$!);return undef}warn "Internal error: unexpected error (".($!+0).": $!) from waitpid($pid) = $deceased. Report it, please!"}elsif ($deceased > 0){warn "Internal error: spurious process $deceased exited"}select(undef,undef,undef,0.1)}}else {$self->_or_set_error(OSSH_SLAVE_FAILED,"spawning of new process failed");return undef}}sub check_master {my$self=shift;@_ and croak 'Usage: $ssh->check_master()';$self->_master_check(0)}sub wait_for_master {my ($self,$async)=@_;@_ <= 2 or croak 'Usage: $ssh->wait_for_master([$async])';$self->{_error}=0 unless$self->{_error}==OSSH_MASTER_FAILED;$self->_master_wait($async)}sub _master_start {my ($self,$async)=@_;$self->_set_error;my$timeout=int((($self->{_timeout}|| 90)+ 2)/3);my$ssh_flags='-2MN';$ssh_flags .= ($self->{_forward_agent}? 'A' : 'a')if defined$self->{_forward_agent};$ssh_flags .= ($self->{_forward_X11}? 'X' : 'x');my@master_opts=(@{$self->{_master_opts}},-o=>"ServerAliveInterval=$timeout",($self->{_ssh_version}>= 5.6 ? (-o=>"ControlPersist=no"): ()),$ssh_flags);my ($mpty,$use_pty,$pref_auths);$use_pty=1 if ($self->{_master_pty_force}or defined$self->{_login_handler});if (defined$self->{_passwd}){$use_pty=1;$pref_auths=($self->{_passphrase}? 'publickey' : 'keyboard-interactive,password');push@master_opts,-o=>'NumberOfPasswordPrompts=1'}elsif ($self->{_batch_mode}){push@master_opts,-o=>'BatchMode=yes'}if (defined$self->{_key_path}){$pref_auths='publickey';push@master_opts,-i=>$self->{_key_path}}my$proxy_command=$self->{_proxy_command};my$gateway;if (my$gateway_args=$self->{_gateway_args}){if (ref$gateway_args eq 'HASH'){_load_module('Net::OpenSSH::Gateway');my$errors;unless ($gateway=Net::OpenSSH::Gateway->find_gateway(errors=>$errors,host=>$self->{_host},port=>$self->{_port},%$gateway_args)){return$self->_master_fail($async,'Unable to build gateway object',join(', ',@$errors))}}else {$gateway=$gateway_args}$self->{_gateway}=$gateway;$gateway->before_ssh_connect or return$self->_master_fail($async,'Gateway setup failed',join(', ',$gateway->errors));$proxy_command=$gateway->proxy_command}if (defined$proxy_command){push@master_opts,-o=>"ProxyCommand=$proxy_command"}if ($use_pty){_load_module('IO::Pty');$self->{_mpty}=$mpty=IO::Pty->new}push@master_opts,-o=>"PreferredAuthentications=$pref_auths" if defined$pref_auths;my@call=$self->_make_ssh_call(\@master_opts);my$pid=fork;unless ($pid){defined$pid or return$self->_master_fail($async,"unable to fork ssh master: $!");if ($debug and $debug & 512){require Net::OpenSSH::OSTracer;Net::OpenSSH::OSTracer->trace}$mpty->make_slave_controlling_terminal if$mpty;$self->_master_redirect('STDOUT');$self->_master_redirect('STDERR');delete$ENV{SSH_ASKPASS}if defined$self->{_passwd};delete$ENV{SSH_AUTH_SOCK}if defined$self->{_passphrase};setpgrp if$self->{_master_setpgrp};local$SIG{__DIE__};eval {exec@call};POSIX::_exit(255)}$self->{_pid}=$pid;1}sub _master_check {my ($self,$async)=@_;my$error;if ($async){if (-S $self->{_ctl_path}){delete$self->{_master_pty_log};return 1}$error="master SSH connection broken"}else {my$out=$self->_master_ctl('check');$error=$self->{_error};unless ($error){my$pid=$self->{_pid};if ($out =~ /pid=(\d+)/){if (!$pid or $1==$pid){delete$self->{_master_pty_log};return 1}$error="bad ssh master at $self->{_ctl_path} socket owned by pid $1 (pid $pid expected)"}else {$error=($out =~ /illegal option/i ? 'OpenSSH 4.1 or later required' : 'unknown error')}}}$self->_master_fail($async,$error)}sub _master_fail {my$self=shift;my$async=shift;if ($self->{_error}!=OSSH_MASTER_FAILED){$self->_set_error(OSSH_MASTER_FAILED,@_)}$self->_master_jump_state($self->{_pid}? _STATE_KILLING : _STATE_GONE,$async)}sub _master_jump_state {my ($self,$state,$async)=@_;$debug and $debug & 4 and _debug "master state jumping from $self->{_master_state} to $state";if ($state==$self->{_master_state}and $state!=_STATE_KILLING and $state!=_STATE_GONE){croak "internal error: state jump to itself ($state)!"}$self->{_master_state}=$state;return$self->_master_wait($async)}sub _master_wait {my ($self,$async)=@_;my$pid=$self->_my_master_pid;if ($pid){my$deceased=waitpid($pid,WNOHANG);if ($deceased==$pid or ($deceased < 0 and $!==Errno::ECHILD())){$debug and $debug & 4 and _debug "master $pid exited, rc:",$?,", err: ",$!;return$self->_master_gone($async)}}if ($self->{_master_state}==_STATE_RUNNING){return 1 if -S $self->{_ctl_path};return$self->_master_fail($async,"master SSH connection broken")}if ($self->{_master_state}==_STATE_KILLING){$debug and $debug & 4 and _debug "killing master";return$self->_master_kill($async)}if ($self->{_master_state}==_STATE_START){if ($self->{_external_master}){return ($self->_master_jump_state(_STATE_RUNNING,$async)and $self->_master_check($async))}$self->_master_start($async)or return;if ($self->{_mpty}){$self->{_wfm_bout}='';$self->{_master_pty_log}='';if (defined$self->{_passwd}or $self->{_login_handler}){return$self->_master_jump_state(_STATE_LOGIN,$async)}}return$self->_master_jump_state(_STATE_AWAITING_MUX,$async)}if ($self->{_master_state}==_STATE_GONE){if (my$mpty=delete$self->{_mpty}){close($mpty)}return 0}if ($self->{_master_state}==_STATE_STOPPED){return 0}local$self->{_error_prefix}=[@{$self->{_error_prefix}},"unable to establish master SSH connection"];$pid or return$self->_master_gone($async,"perl process was forked or threaded before SSH connection had been established");my$old_tcpgrp;if ($self->{_master_setpgrp}and not $async and not $self->{_batch_mode}and not $self->{_external_master}){$old_tcpgrp=POSIX::tcgetpgrp(0);if ($old_tcpgrp > 0){POSIX::tcsetpgrp(0,$pid)}else {undef$old_tcpgrp}}my$mpty=$self->{_mpty};my$fnopty;my$rv='';if ($mpty and ($self->{_master_state}==_STATE_LOGIN or $self->{_master_state}==_STATE_AWAITING_MUX)){$fnopty=fileno$mpty;vec($rv,$fnopty,1)=1}my$timeout=$self->{_timeout};my$dt=($async ? 0 : 0.02);my$start_time=time;my$error;while (1){$dt *= 1.10 if$dt < 0.2;if (-e $self->{_ctl_path}){$debug and $debug & 4 and _debug "file object found at $self->{_ctl_path}";last}$debug and $debug & 4 and _debug "file object not yet found at $self->{_ctl_path}, state:",$self->{_master_state};if (defined$timeout and (time - $start_time)> $timeout){$error="login timeout";last}my$deceased=waitpid($pid,WNOHANG);if ($deceased==$pid or ($deceased < 0 and $!==Errno::ECHILD())){$error="master process exited unexpectedly";$error="bad pass" .($self->{_passphrase}? 'phrase' : 'word')." or $error" if defined$self->{_passwd};delete$self->{_pid};last}if ($self->{_login_handler}and $self->{_master_state}==_STATE_LOGIN){local ($@,$SIG{__DIE__});if (eval {$self->{_login_handler}->($self,$mpty,\$self->{_wfm_bout})}){$self->{_master_state}=_STATE_AWAITING_MUX;next}if ($@){$error="custom login handler failed: $@";last}}else {my$rv1=$rv;my$n=select($rv1,undef,undef,$dt);if ($n > 0){vec($rv1,$fnopty,1)or die "internal error";my$read=sysread($mpty,$self->{_wfm_bout},4096,length$self->{_wfm_bout});if ($read){$self->{_master_pty_log}.= substr($self->{_wfm_bout},-$read);if ((my$remove=length($self->{_master_pty_log})- 4096)> 0){substr($self->{_master_pty_log},0,$remove)=''}if ($self->{_wfm_bout}=~ /The authenticity of host.*can't be established/si){$error="the authenticity of the target host can't be established; the remote host " ."public key is probably not present in the '~/.ssh/known_hosts' file";last}if ($self->{_wfm_bout}=~ /WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED/si){$error="the authenticity of the target host can't be established; the remote host " ."public key doesn't match the one stored locally";last}my$passwd_prompt=_first_defined$self->{_passwd_prompt},qr/[:?]/;$passwd_prompt=quotemeta$passwd_prompt unless ref$passwd_prompt;if ($self->{_master_state}==_STATE_LOGIN){if ($self->{_wfm_bout}=~ /^(.*$passwd_prompt)/s){$debug and $debug & 4 and _debug "passwd/passphrase requested ($1)";print$mpty $deobfuscate->($self->{_passwd})."\n";$self->{_wfm_bout}='';$self->{_master_state}=_STATE_AWAITING_MUX}}elsif (length($passwd_prompt)and $self->{_wfm_bout}=~ /^(.*$passwd_prompt)\s*$/s){$debug and $debug & 4 and _debug "passwd/passphrase requested again ($1)";$error="password authentication failed";last}next}}}return if$async;select(undef,undef,undef,$dt)}if (defined$old_tcpgrp){$debug and $debug & 4 and _debug("ssh pid: $pid, pgrp: ",getpgrp($pid),", \$\$: ",$$,", tcpgrp: ",POSIX::tcgetpgrp(0),", old_tcppgrp: ",$old_tcpgrp);local$SIG{TTOU}='IGNORE';POSIX::tcsetpgrp(0,$old_tcpgrp)}if ($error){return$self->_master_fail($async,$error)}$self->_master_jump_state(_STATE_RUNNING,$async)and $self->_master_check($async)}sub _master_ctl {my$self=shift;my%opts=(ref $_[0]eq 'HASH' ? %{shift()}: ());my$cmd=shift;local $?;local$self->{_error_prefix}=[@{$self->{_error_prefix}},"control command failed"];$self->capture({%opts,encoding=>'bytes',stdin_discard=>1,tty=>0,stderr_to_stdout=>1,ssh_opts=>[-O=>$cmd]})}sub stop {my ($self,$timeout)=@_;my$pid=$self->{_pid};local$self->{_kill_ssh_on_timeout}=1;$self->_master_ctl({timeout=>$timeout},'stop');unless ($self->{_error}){$self->_set_error(OSSH_MASTER_FAILED,"master stopped");$self->_master_jump_state(_STATE_STOPPED,1)}}sub _make_pipe {my$self=shift;my ($r,$w);if (pipe$r,$w){my$old=select;select$r;$ |= 1;select$w;$ |= 1;select$old;return ($r,$w)}$self->_set_error(OSSH_SLAVE_PIPE_FAILED,"unable to create pipe: $!");return}sub _remote_quoter {my ($self,$remote_shell)=@_;if (ref$self and (!defined$remote_shell or $remote_shell eq $self->{_remote_shell})){return$self->{remote_quoter}||= Net::OpenSSH::ShellQuoter->quoter($self->{_remote_shell})}Net::OpenSSH::ShellQuoter->quoter($remote_shell)}sub _quote_args {my$self=shift;my$opts=shift;ref$opts eq 'HASH' or die "internal error";my$quote=delete$opts->{quote_args};my$quote_extended=delete$opts->{quote_args_extended};my$glob_quoting=delete$opts->{glob_quoting};$quote=(@_ > 1)unless defined$quote;if ($quote){my$remote_shell=delete$opts->{remote_shell};my$quoter=$self->_remote_quoter($remote_shell);my$quote_method=($glob_quoting ? 'quote_glob' : 'quote');my@quoted;for (@_){if (ref $_){if (ref $_ eq 'SCALAR'){push@quoted,$quoter->quote_glob($self->_expand_vars($$_))}elsif (ref $_ eq 'REF' and ref $$_ eq 'SCALAR'){push@quoted,$self->_expand_vars($$$_);undef$quote_extended}else {croak "invalid reference in remote command argument list"}}else {push@quoted,$quoter->$quote_method($self->_expand_vars($_))}}if ($quote_extended){my@fragments;if ($opts->{stdout_discard}and ($opts->{stderr_discard}or $opts->{stderr_to_stdout})){@fragments=('stdout_and_stderr_discard');push@fragments,'stdin_discard' if$opts->{stdin_discard}}else {@fragments=grep$opts->{$_},qw(stdin_discard stdout_discard stderr_discard stderr_to_stdout)}push@quoted,$quoter->shell_fragments(@fragments)}wantarray ? @quoted : join(" ",@quoted)}else {croak "reference found in argument list when argument quoting is disabled" if (grep ref,@_);my@args=$self->_expand_vars(@_);wantarray ? @args : join(" ",@args)}}sub shell_quote {shift->_quote_args({quote_args=>1},@_)}sub shell_quote_glob {shift->_quote_args({quote_args=>1,glob_quoting=>1},@_)}sub _array_or_scalar_to_list {map {defined($_)? (ref $_ eq 'ARRAY' ? @$_ : $_): ()}@_}sub make_remote_command {my$self=shift;$self->wait_for_master or return;my%opts=(ref $_[0]eq 'HASH' ? %{shift()}: ());my@ssh_opts=_array_or_scalar_to_list delete$opts{ssh_opts};my$tty=delete$opts{tty};my$ssh_flags='';$ssh_flags .= ($tty ? 'qtt' : 'T')if defined$tty;if ($self->{_forward_agent}){my$forward_always=(($self->{_forward_agent}eq 'always')? 1 : undef);my$forward_agent=_first_defined(delete($opts{forward_agent}),$forward_always);$ssh_flags .= ($forward_agent ? 'A' : 'a')if defined$forward_agent}if ($self->{_forward_X11}){my$forward_X11=delete$opts{forward_X11};$ssh_flags .= ($forward_X11 ? 'X' : 'x')}my$tunnel=delete$opts{tunnel};my (@args);if ($tunnel){push@ssh_opts,$self->_make_W_option(@_)}else {my$subsystem=delete$opts{subsystem};if ($subsystem){push@ssh_opts,'-s';@_==1 or croak "wrong number of arguments for subsystem command"}@args=$self->_quote_args(\%opts,@_)}_croak_bad_options%opts;push@ssh_opts,"-$ssh_flags" if length$ssh_flags;my@call=$self->_make_ssh_call(\@ssh_opts,@args);if (wantarray){$debug and $debug & 16 and _debug_dump make_remote_command=>\@call;return@call}else {my$call=join ' ',$self->shell_quote(@call);$debug and $debug & 16 and _debug_dump 'make_remote_command (quoted)'=>$call;return$call}}sub _open_file {my ($self,$default_mode,$name_or_args)=@_;my ($mode,@args)=(ref$name_or_args ? @$name_or_args : ($default_mode,$name_or_args));@args=$self->_expand_vars(@args);if (open my$fh,$mode,@args){return$fh}else {$self->_set_error(OSSH_SLAVE_PIPE_FAILED,"Unable to open file '$args[0]': $!");return undef}}sub _fileno_dup_over {my ($good_fn,$fh)=@_;if (defined$fh){my$fn=fileno$fh;for (1..5){$fn >= $good_fn and return$fn;$fn=POSIX::dup($fn)}POSIX::_exit(255)}undef}sub _exec_dpipe {my ($self,$cmd,$io,$err)=@_;my$io_fd=_fileno_dup_over(3=>$io);my$err_fd=_fileno_dup_over(3=>$err);POSIX::dup2($io_fd,0);POSIX::dup2($io_fd,1);POSIX::dup2($err_fd,2)if defined$err_fd;if (ref$cmd){exec @$cmd}else {exec$cmd}}sub _delete_stream_encoding {my ($self,$opts)=@_;_first_defined(delete$opts->{stream_encoding},$opts->{encoding},$self->{_default_stream_encoding})}sub _delete_argument_encoding {my ($self,$opts)=@_;_first_defined(delete$opts->{argument_encoding},delete$opts->{encoding},$self->{_default_argument_encoding})}sub open_ex {${^TAINT} and &_catch_tainted_args;my$self=shift;my%opts=(ref $_[0]eq 'HASH' ? %{shift()}: ());unless (delete$opts{_no_master_required}){$self->wait_for_master or return}my$ssh_flags='';my$tunnel=delete$opts{tunnel};my ($cmd,$close_slave_pty,@args);if ($tunnel){@args=@_}else {my$argument_encoding=$self->_delete_argument_encoding(\%opts);my$tty=delete$opts{tty};$ssh_flags .= ($tty ? 'qtt' : 'T')if defined$tty;$cmd=delete$opts{_cmd}|| 'ssh';$opts{quote_args_extended}=1 if (not defined$opts{quote_args_extended}and $cmd eq 'ssh');@args=$self->_quote_args(\%opts,@_);$self->_encode_args($argument_encoding,@args)or return}my ($stdinout_socket,$stdinout_dpipe_make_parent);my$stdinout_dpipe=delete$opts{stdinout_dpipe};if ($stdinout_dpipe){$stdinout_dpipe_make_parent=delete$opts{stdinout_dpipe_make_parent};$stdinout_socket=1}else {$stdinout_socket=delete$opts{stdinout_socket}}my ($stdin_discard,$stdin_pipe,$stdin_fh,$stdin_file,$stdin_pty,$stdout_discard,$stdout_pipe,$stdout_fh,$stdout_file,$stdout_pty,$stderr_discard,$stderr_pipe,$stderr_fh,$stderr_file,$stderr_to_stdout);unless ($stdinout_socket){unless ($stdin_discard=delete$opts{stdin_discard}or $stdin_pipe=delete$opts{stdin_pipe}or $stdin_fh=delete$opts{stdin_fh}or $stdin_file=delete$opts{stdin_file}){unless ($tunnel){if ($stdin_pty=delete$opts{stdin_pty}){$close_slave_pty=_first_defined delete$opts{close_slave_pty},1}}}($stdout_discard=delete$opts{stdout_discard}or $stdout_pipe=delete$opts{stdout_pipe}or $stdout_fh=delete$opts{stdout_fh}or $stdout_file=delete$opts{stdout_file}or (not $tunnel and $stdout_pty=delete$opts{stdout_pty}));$stdout_pty and!$stdin_pty and croak "option stdout_pty requires stdin_pty set"}($stderr_discard=delete$opts{stderr_discard}or $stderr_pipe=delete$opts{stderr_pipe}or $stderr_fh=delete$opts{stderr_fh}or $stderr_to_stdout=delete$opts{stderr_to_stdout}or $stderr_file=delete$opts{stderr_file});my$ssh_opts=delete$opts{ssh_opts};$ssh_opts=$self->{_default_ssh_opts}unless defined$ssh_opts;my@ssh_opts=$self->_expand_vars(_array_or_scalar_to_list$ssh_opts);if ($self->{_forward_agent}){my$forward_always=(($self->{_forward_agent}eq 'always')? 1 : undef);my$forward_agent=_first_defined(delete($opts{forward_agent}),$forward_always);$ssh_flags .= ($forward_agent ? 'A' : 'a')if defined$forward_agent}if ($self->{_forward_X11}){my$forward_X11=delete$opts{forward_X11};$ssh_flags .= ($forward_X11 ? 'X' : 'x')}if (delete$opts{subsystem}){$ssh_flags .= 's'}my$setpgrp=delete$opts{setpgrp};undef$setpgrp if defined$stdin_pty;_croak_bad_options%opts;if (defined$stdin_file){$stdin_fh=$self->_open_file('<',$stdin_file)or return}if (defined$stdout_file){$stdout_fh=$self->_open_file('>',$stdout_file)or return}if (defined$stderr_file){$stderr_fh=$self->_open_file('>',$stderr_file)or return}my ($rin,$win,$rout,$wout,$rerr,$werr);if ($stdinout_socket){unless(socketpair$rin,$win,AF_UNIX,SOCK_STREAM,PF_UNSPEC){$self->_set_error(OSSH_SLAVE_PIPE_FAILED,"socketpair failed: $!");return}$wout=$rin}else {if ($stdin_pipe){($rin,$win)=$self->_make_pipe or return}elsif ($stdin_pty){_load_module('IO::Pty');$win=IO::Pty->new;unless ($win){$self->_set_error(OSSH_SLAVE_PIPE_FAILED,"unable to allocate pseudo-tty: $!");return}$rin=$win->slave}elsif (defined$stdin_fh){$rin=$stdin_fh}else {$rin=$self->{_default_stdin_fh}}_check_is_system_fh STDIN=>$rin;if ($stdout_pipe){($rout,$wout)=$self->_make_pipe or return}elsif ($stdout_pty){$wout=$rin}elsif (defined$stdout_fh){$wout=$stdout_fh}else {$wout=$self->{_default_stdout_fh}}_check_is_system_fh STDOUT=>$wout}unless ($stderr_to_stdout){if ($stderr_pipe){($rerr,$werr)=$self->_make_pipe or return}elsif (defined$stderr_fh){$werr=$stderr_fh}else {$werr=$self->{_default_stderr_fh}}_check_is_system_fh STDERR=>$werr}push@ssh_opts,"-$ssh_flags" if length$ssh_flags;my@call=($tunnel ? $self->_make_tunnel_call(\@ssh_opts,@args): $cmd eq 'ssh' ? $self->_make_ssh_call(\@ssh_opts,@args): $cmd eq 'scp' ? $self->_make_scp_call(\@ssh_opts,@args): $cmd eq 'rsync' ? $self->_make_rsync_call(\@ssh_opts,@args): $cmd eq 'raw' ? @args : die "Internal error: bad _cmd protocol");$debug and $debug & 16 and _debug_dump open_ex=>\@call;my$pid=fork;unless ($pid){unless (defined$pid){$self->_set_error(OSSH_SLAVE_FAILED,"unable to fork new ssh slave: $!");return}setpgrp if$setpgrp;$stdin_discard and (open$rin,'<','/dev/null' or POSIX::_exit(255));$stdout_discard and (open$wout,'>','/dev/null' or POSIX::_exit(255));$stderr_discard and (open$werr,'>','/dev/null' or POSIX::_exit(255));if ($stdinout_dpipe){my$pid1=fork;defined$pid1 or POSIX::_exit(255);unless ($pid1 xor $stdinout_dpipe_make_parent){eval {$self->_exec_dpipe($stdinout_dpipe,$win,$werr)};POSIX::_exit(255)}}my$rin_fd=_fileno_dup_over(0=>$rin);my$wout_fd=_fileno_dup_over(1=>$wout);my$werr_fd=_fileno_dup_over(2=>$werr);if (defined$rin_fd){$win->make_slave_controlling_terminal if$stdin_pty;$rin_fd==0 or POSIX::dup2($rin_fd,0)or POSIX::_exit(255)}if (defined$wout_fd){$wout_fd==1 or POSIX::dup2($wout_fd,1)or POSIX::_exit(255)}if (defined$werr_fd){$werr_fd==2 or POSIX::dup2($werr_fd,2)or POSIX::_exit(255)}elsif ($stderr_to_stdout){POSIX::dup2(1,2)or POSIX::_exit(255)}do {exec@call};POSIX::_exit(255)}$win->close_slave()if$close_slave_pty;undef$win if defined$stdinout_dpipe;wantarray ? ($win,$rout,$rerr,$pid): $pid}sub pipe_in {${^TAINT} and &_catch_tainted_args;my$self=shift;$self->wait_for_master or return;my%opts=(ref $_[0]eq 'HASH' ? %{shift()}: ());my$argument_encoding=$self->_delete_argument_encoding(\%opts);my@args=$self->_quote_args(\%opts,@_);_croak_bad_options%opts;$self->_encode_args($argument_encoding,@args)or return;my@call=$self->_make_ssh_call([],@args);$debug and $debug & 16 and _debug_dump pipe_in=>@call;my$pid=open my$rin,'|-',@call;unless ($pid){$self->_set_error(OSSH_SLAVE_FAILED,"unable to fork new ssh slave: $!");return}wantarray ? ($rin,$pid): $rin}sub pipe_out {${^TAINT} and &_catch_tainted_args;my$self=shift;$self->wait_for_master or return;my%opts=(ref $_[0]eq 'HASH' ? %{shift()}: ());my$argument_encoding=$self->_delete_argument_encoding(\%opts);my@args=$self->_quote_args(\%opts,@_);_croak_bad_options%opts;$self->_encode_args($argument_encoding,@args)or return;my@call=$self->_make_ssh_call([],@args);$debug and $debug & 16 and _debug_dump pipe_out=>@call;my$pid=open my$rout,'-|',@call;unless ($pid){$self->_set_error(OSSH_SLAVE_FAILED,"unable to fork new ssh slave: $!");return}wantarray ? ($rout,$pid): $rout}sub _find_encoding {my ($self,$encoding,$data)=@_;if (defined$encoding and $encoding ne 'bytes'){_load_module('Encode');my$enc=Encode::find_encoding($encoding);unless (defined$enc){$self->_set_error(OSSH_ENCODING_ERROR,"bad encoding '$encoding'");return}return$enc}return undef}sub _encode {my$self=shift;my$enc=shift;if (defined$enc and @_){local ($@,$SIG{__DIE__});eval {for (@_){defined or next;$_=$enc->encode($_,Encode::FB_CROAK())}};$self->_check_eval_ok(OSSH_ENCODING_ERROR)or return undef}1}sub _encode_args {if (@_ > 2){my$self=shift;my$encoding=shift;my$enc=$self->_find_encoding($encoding);if ($enc){local$self->{_error_prefix}=[@{$self->{_error_prefix}},"argument encoding failed"];$self->_encode($enc,@_)}return!$self->{_error}}1}sub _decode {my$self=shift;my$enc=shift;local ($@,$SIG{__DIE__});eval {for (@_){defined or next;$_=$enc->decode($_,Encode::FB_CROAK())}};$self->_check_eval_ok(OSSH_ENCODING_ERROR)}my@retriable=(Errno::EINTR(),Errno::EAGAIN());push@retriable,Errno::EWOULDBLOCK()if Errno::EWOULDBLOCK()!=Errno::EAGAIN();sub _io3 {my ($self,$out,$err,$in,$stdin_data,$timeout,$encoding,$keep_in_open)=@_;my@data=_array_or_scalar_to_list$stdin_data;my ($cout,$cerr,$cin)=(defined($out),defined($err),defined($in));$timeout=$self->{_timeout}unless defined$timeout;my$has_input=grep {defined and length}@data;if ($cin and!$has_input){close$in unless$keep_in_open;undef$cin}elsif (!$cin and $has_input){croak "remote input channel is not defined but data is available for sending"}my$enc=$self->_find_encoding($encoding);if ($enc and @data){local$self->{_error_prefix}=[@{$self->{_error_prefix}},"stdin data encoding failed"];$self->_encode($enc,@data)if$has_input;return if$self->{_error}}my$bout='';my$berr='';my ($fnoout,$fnoerr,$fnoin);local$SIG{PIPE}='IGNORE';MLOOP: while ($cout or $cerr or $cin){$debug and $debug & 64 and _debug "io3 mloop, cin: " .($cin || 0).", cout: " .($cout || 0).", cerr: " .($cerr || 0);my ($rv,$wv);if ($cout or $cerr){$rv='';if ($cout){$fnoout=fileno$out;vec($rv,$fnoout,1)=1}if ($cerr){$fnoerr=fileno$err;vec($rv,$fnoerr,1)=1}}if ($cin){$fnoin=fileno$in;$wv='';vec($wv,$fnoin,1)=1}my$recalc_vecs;FAST: until ($recalc_vecs){$debug and $debug & 64 and _debug "io3 fast, cin: " .($cin || 0).", cout: " .($cout || 0).", cerr: " .($cerr || 0);my ($rv1,$wv1)=($rv,$wv);my$n=select ($rv1,$wv1,undef,$timeout);if ($n > 0){if ($cout and vec($rv1,$fnoout,1)){my$offset=length$bout;my$read=sysread($out,$bout,20480,$offset);if ($debug and $debug & 64){_debug "stdout, bytes read: ",$read," at offset $offset";$read and $debug & 128 and _hexdump substr$bout,$offset}unless ($read or grep $!==$_,@retriable){close$out;undef$cout;$recalc_vecs=1}}if ($cerr and vec($rv1,$fnoerr,1)){my$read=sysread($err,$berr,20480,length($berr));$debug and $debug & 64 and _debug "stderr, bytes read: ",$read;unless ($read or grep $!==$_,@retriable){close$err;undef$cerr;$recalc_vecs=1}}if ($cin and vec($wv1,$fnoin,1)){my$written=syswrite($in,$data[0],20480);if ($debug and $debug & 64){_debug "stdin, bytes written: ",$written;$written and $debug & 128 and _hexdump substr$data[0],0,$written}if ($written){substr($data[0],0,$written,'');while (@data){next FAST if (defined$data[0]and length$data[0]);shift@data}}elsif (grep $!==$_,@retriable){next FAST}close$in unless$keep_in_open;undef$cin;$recalc_vecs=1}}else {next if$n < 0 and grep $!==$_,@retriable;$self->_set_error(OSSH_SLAVE_TIMEOUT,'ssh slave failed','timed out');last MLOOP}}}close$out if$cout;close$err if$cerr;close$in if$cin and not $keep_in_open;if ($enc){local$self->{_error_prefix}=[@{$self->{_error_prefix}},'output decoding failed'];unless ($self->_decode($enc,$bout,$berr)){undef$bout;undef$berr}}$debug and $debug & 64 and _debug "leaving _io3()";return ($bout,$berr)}_sub_options spawn=>qw(stderr_to_stdout stdin_discard stdin_fh stdin_file stdout_discard stdout_fh stdout_file stderr_discard stderr_fh stderr_file stdinout_dpipe stdinout_dpipe_make_parent quote_args quote_args_extended remote_shell glob_quoting tty ssh_opts tunnel encoding argument_encoding forward_agent forward_X11 setpgrp subsystem);sub spawn {${^TAINT} and &_catch_tainted_args;my$self=shift;my%opts=(ref $_[0]eq 'HASH' ? %{shift()}: ());_croak_bad_options%opts;return scalar$self->open_ex(\%opts,@_)}_sub_options open2=>qw(stderr_to_stdout stderr_discard stderr_fh stderr_file quote_args quote_args_extended remote_shell glob_quoting tty ssh_opts tunnel encoding argument_encoding forward_agent forward_X11 setpgrp subsystem);sub open2 {${^TAINT} and &_catch_tainted_args;my$self=shift;my%opts=(ref $_[0]eq 'HASH' ? %{shift()}: ());_croak_bad_options%opts;_croak_scalar_context;my ($in,$out,undef,$pid)=$self->open_ex({stdout_pipe=>1,stdin_pipe=>1,%opts },@_)or return ();return ($in,$out,$pid)}_sub_options open2pty=>qw(stderr_to_stdout stderr_discard stderr_fh stderr_file quote_args quote_args_extended remote_shell glob_quoting tty close_slave_pty ssh_opts encoding argument_encoding forward_agent forward_X11 setpgrp subsystem);sub open2pty {${^TAINT} and &_catch_tainted_args;my$self=shift;my%opts=(ref $_[0]eq 'HASH' ? %{shift()}: ());_croak_bad_options%opts;my ($pty,undef,undef,$pid)=$self->open_ex({stdout_pty=>1,stdin_pty=>1,tty=>1,%opts },@_)or return ();wantarray ? ($pty,$pid): $pty}_sub_options open2socket=>qw(stderr_to_stdout stderr_discard stderr_fh stderr_file quote_args quote_args_extended remote_shell glob_quoting tty ssh_opts tunnel encoding argument_encoding forward_agent forward_X11 setpgrp subsystem);sub open2socket {${^TAINT} and &_catch_tainted_args;my$self=shift;my%opts=(ref $_[0]eq 'HASH' ? %{shift()}: ());_croak_bad_options%opts;my ($socket,undef,undef,$pid)=$self->open_ex({stdinout_socket=>1,%opts },@_)or return ();wantarray ? ($socket,$pid): $socket}_sub_options open3=>qw(quote_args quote_args_extended remote_shell glob_quoting tty ssh_opts encoding argument_encoding forward_agent forward_X11 setpgrp subsystem);sub open3 {${^TAINT} and &_catch_tainted_args;my$self=shift;my%opts=(ref $_[0]eq 'HASH' ? %{shift()}: ());_croak_bad_options%opts;_croak_scalar_context;my ($in,$out,$err,$pid)=$self->open_ex({stdout_pipe=>1,stdin_pipe=>1,stderr_pipe=>1,%opts },@_)or return ();return ($in,$out,$err,$pid)}_sub_options open3pty=>qw(quote_args quote_args_extended remote_shell glob_quoting tty close_slave_pty ssh_opts encoding argument_encoding forward_agent forward_X11 setpgrp subsystem);sub open3pty {${^TAINT} and &_catch_tainted_args;my$self=shift;my%opts=(ref $_[0]eq 'HASH' ? %{shift()}: ());_croak_bad_options%opts;_croak_scalar_context;my ($pty,undef,$err,$pid)=$self->open_ex({stdout_pty=>1,stdin_pty=>1,tty=>1,stderr_pipe=>1,%opts },@_)or return ();return ($pty,$err,$pid)}_sub_options open3socket=>qw(quote_args quote_args_extended remote_shell glob_quoting tty ssh_opts encoding argument_encoding forward_agent forward_X11 setpgrp subsystem);sub open3socket {${^TAINT} and &_catch_tainted_args;my$self=shift;my%opts=(ref $_[0]eq 'HASH' ? %{shift()}: ());_croak_bad_options%opts;_croak_scalar_context;my ($socket,undef,$err,$pid)=$self->open_ex({stdinout_socket=>1,stderr_pipe=>1,%opts },@_)or return ();return ($socket,$err,$pid)}_sub_options system=>qw(stdout_discard stdout_fh stdin_discard stdout_file stdin_fh stdin_file quote_args quote_args_extended remote_shell glob_quoting stderr_to_stdout stderr_discard stderr_fh stderr_file stdinout_dpipe stdinout_dpipe_make_parent tty ssh_opts tunnel encoding argument_encoding forward_agent forward_X11 setpgrp subsystem);sub system {${^TAINT} and &_catch_tainted_args;my$self=shift;my%opts=(ref $_[0]eq 'HASH' ? %{shift()}: ());my$stdin_data=delete$opts{stdin_data};my$timeout=delete$opts{timeout};my$async=delete$opts{async};my$stdin_keep_open=($async ? undef : delete$opts{stdin_keep_open});_croak_bad_options%opts;$stdin_data='' if$stdin_keep_open and not defined$stdin_data;my$stream_encoding;if (defined$stdin_data){$opts{stdin_pipe}=1;$stream_encoding=$self->_delete_stream_encoding(\%opts)}local$SIG{INT}='IGNORE';local$SIG{QUIT}='IGNORE';local$SIG{CHLD};my ($in,undef,undef,$pid)=$self->open_ex(\%opts,@_)or return undef;$self->_io3(undef,undef,$in,$stdin_data,$timeout,$stream_encoding,$stdin_keep_open)if defined$stdin_data;return$pid if$async;$self->_waitpid($pid,$timeout)}_sub_options test=>qw(stdout_discard stdout_fh stdin_discard stdout_file stdin_fh stdin_file quote_args quote_args_extended remote_shell glob_quoting stderr_to_stdout stderr_discard stderr_fh stderr_file stdinout_dpipe stdinout_dpipe_make_parent tty ssh_opts timeout stdin_data stdin_keep_open encoding stream_encoding argument_encoding forward_agent forward_X11 setpgrp subsystem);sub test {${^TAINT} and &_catch_tainted_args;my$self=shift;my%opts=(ref $_[0]eq 'HASH' ? %{shift()}: ());$opts{stdout_discard}=1 unless grep defined($opts{$_}),qw(stdout_discard stdout_fh stdout_file stdinout_dpipe);$opts{stderr_discard}=1 unless grep defined($opts{$_}),qw(stderr_discard stderr_fh stderr_file stderr_to_stdout);_croak_bad_options%opts;$self->system(\%opts,@_);my$error=$self->{_error};unless ($error){return 1}if ($error==OSSH_SLAVE_CMD_FAILED){$self->_set_error(0);return 0}return undef}_sub_options capture=>qw(stderr_to_stdout stderr_discard stderr_fh stderr_file stdin_discard stdin_fh stdin_file quote_args quote_args_extended remote_shell glob_quoting tty ssh_opts tunnel encoding argument_encoding forward_agent forward_X11 setpgrp subsystem);sub capture {${^TAINT} and &_catch_tainted_args;my$self=shift;my%opts=(ref $_[0]eq 'HASH' ? %{shift()}: ());my$stdin_data=delete$opts{stdin_data};my$stdin_keep_open=delete$opts{stdin_keep_open};my$timeout=delete$opts{timeout};_croak_bad_options%opts;$stdin_data='' if$stdin_keep_open and not defined$stdin_data;my$stream_encoding=$self->_delete_stream_encoding(\%opts);$opts{stdout_pipe}=1;$opts{stdin_pipe}=1 if defined$stdin_data;local$SIG{INT}='IGNORE';local$SIG{QUIT}='IGNORE';local$SIG{CHLD};my ($in,$out,undef,$pid)=$self->open_ex(\%opts,@_)or return ();my ($output)=$self->_io3($out,undef,$in,$stdin_data,$timeout,$stream_encoding,$stdin_keep_open);$self->_waitpid($pid,$timeout);if (wantarray){my$pattern=quotemeta $/;return split /(?<=$pattern)/,$output}$output}_sub_options capture2=>qw(stdin_discard stdin_fh stdin_file quote_args quote_args_extended remote_shell glob_quoting tty ssh_opts encoding stream_encoding argument_encoding forward_agent forward_X11 setpgrp subsystem);sub capture2 {${^TAINT} and &_catch_tainted_args;my$self=shift;my%opts=(ref $_[0]eq 'HASH' ? %{shift()}: ());my$stdin_data=delete$opts{stdin_data};my$stdin_keep_open=delete$opts{stdin_keep_open};my$timeout=delete$opts{timeout};_croak_bad_options%opts;$stdin_data='' if$stdin_keep_open and not defined$stdin_data;my$stream_encoding=$self->_delete_stream_encoding(\%opts);$opts{stdout_pipe}=1;$opts{stderr_pipe}=1;$opts{stdin_pipe}=1 if defined$stdin_data;local$SIG{INT}='IGNORE';local$SIG{QUIT}='IGNORE';local$SIG{CHLD};my ($in,$out,$err,$pid)=$self->open_ex(\%opts,@_)or return ();my@capture=$self->_io3($out,$err,$in,$stdin_data,$timeout,$stream_encoding,$stdin_keep_open);$self->_waitpid($pid,$timeout);wantarray ? @capture : $capture[0]}_sub_options open_tunnel=>qw(ssh_opts stderr_discard stderr_fh stderr_file encoding argument_encoding forward_agent setpgrp);sub open_tunnel {${^TAINT} and &_catch_tainted_args;my$self=shift;my%opts=(ref $_[0]eq 'HASH' ? %{shift()}: ());$opts{stderr_discard}=1 unless grep defined$opts{$_},qw(stderr_discard stderr_fh stderr_file);_croak_bad_options%opts;@_==2 or croak 'Usage: $ssh->open_tunnel(\%opts, $host, $port)';$opts{tunnel}=1;$self->open2socket(\%opts,@_)}_sub_options capture_tunnel=>qw(ssh_opts stderr_discard stderr_fh stderr_file stdin_discard stdin_fh stdin_file stdin_data timeout encoding stream_encoding argument_encoding forward_agent setpgrp);sub capture_tunnel {${^TAINT} and &_catch_tainted_args;my$self=shift;my%opts=(ref $_[0]eq 'HASH' ? %{shift()}: ());$opts{stderr_discard}=1 unless grep defined$opts{$_},qw(stderr_discard stderr_fh stderr_file);_croak_bad_options%opts;@_==2 or croak 'Usage: $ssh->capture_tunnel(\%opts, $host, $port)';$opts{tunnel}=1;$self->capture(\%opts,@_)}sub _calling_method {my$method=(caller 2)[3];$method =~ s/.*:://;$method}sub _scp_get_args {my$self=shift;my%opts=(ref $_[0]eq 'HASH' ? %{shift()}: ());@_ > 0 or croak 'Usage: $ssh->' ._calling_method .'(\%opts, $remote_fn1, $remote_fn2, ..., $local_fn_or_dir)';my$glob=delete$opts{glob};my$target=(@_ > 1 ? pop @_ : '.');$target =~ m|^[^/]*:| and $target="./$target";my$prefix=$self->{_host_squared};$prefix="$self->{_user}\@$prefix" if defined$self->{_user};my$src="$prefix:".join(" ",$self->_quote_args({quote_args=>1,glob_quoting=>$glob},@_));($self,\%opts,$target,$src)}sub scp_get {${^TAINT} and &_catch_tainted_args;my ($self,$opts,$target,@src)=_scp_get_args @_;$self->_scp($opts,@src,$target)}sub rsync_get {${^TAINT} and &_catch_tainted_args;my ($self,$opts,$target,@src)=_scp_get_args @_;$self->_rsync($opts,@src,$target)}sub _scp_put_args {my$self=shift;my%opts=(ref $_[0]eq 'HASH' ? %{shift()}: ());@_ > 0 or croak 'Usage: $ssh->' ._calling_method .'(\%opts, $local_fn1, $local_fn2, ..., $remote_dir_or_fn)';my$glob=delete$opts{glob};my$glob_flags=($glob ? delete$opts{glob_flags}|| 0 : undef);my$prefix=$self->{_host_squared};$prefix="$self->{_user}\@$prefix" if defined$self->{_user};my$remote_shell=delete$opts{remote_shell};my$target=$prefix .':' .(@_ > 1 ? $self->_quote_args({quote_args=>1,remote_shell=>$remote_shell},pop(@_)): '');my@src=@_;if ($glob){require File::Glob;@src=map File::Glob::bsd_glob($_,$glob_flags),@src;unless (@src){$self->_set_error(OSSH_SLAVE_FAILED,"given file name patterns did not match any file");return undef}}$_="./$_" for grep m|^[^/]*:|,@src;($self,\%opts,$target,@src)}sub scp_put {${^TAINT} and &_catch_tainted_args;my ($self,$opts,$target,@src)=_scp_put_args @_;return unless$self;$self->_scp($opts,@src,$target)}sub rsync_put {${^TAINT} and &_catch_tainted_args;my ($self,$opts,$target,@src)=_scp_put_args @_;return unless$self;$self->_rsync($opts,@src,$target)}_sub_options _scp=>qw(stderr_to_stdout stderr_discard stderr_fh stderr_file stdout_discard stdout_fh stdout_file encoding argument_encoding forward_agent setpgrp);sub _scp {my$self=shift;my%opts=(ref $_[0]eq 'HASH' ? %{shift()}: ());my$quiet=delete$opts{quiet};$quiet=1 unless defined$quiet;my$recursive=delete$opts{recursive};my$copy_attrs=delete$opts{copy_attrs};my$bwlimit=delete$opts{bwlimit};my$async=delete$opts{async};my$ssh_opts=delete$opts{ssh_opts};my$timeout=delete$opts{timeout};my$verbose=delete$opts{verbose};_croak_bad_options%opts;my@opts;@opts=@$ssh_opts if$ssh_opts;push@opts,'-q' if$quiet;push@opts,'-v' if$verbose;push@opts,'-r' if$recursive;push@opts,'-p' if$copy_attrs;push@opts,'-l',$bwlimit if$bwlimit;local$self->{_error_prefix}=[@{$self->{_error_prefix}},'scp failed'];my$pid=$self->open_ex({%opts,_cmd=>'scp',ssh_opts=>\@opts,quote_args=>0 },@_);return$pid if$async;$self->_waitpid($pid,$timeout)}my%rsync_opt_with_arg=map {$_=>1}qw(chmod suffix backup-dir rsync-path max-delete max-size min-size partial-dir timeout modify-window temp-dir compare-dest copy-dest link-dest compress-level skip-compress filter exclude exclude-from include include-from out-format log-file log-file-format bwlimit protocol iconv checksum-seed files-from);my%rsync_opt_forbidden=map {$_=>1}qw(rsh address port sockopts password-file write-batch only-write-batch read-batch ipv4 ipv6 version help daemon config detach protect-args list-only);$rsync_opt_forbidden{"no-$_"}=1 for (keys%rsync_opt_with_arg,keys%rsync_opt_forbidden);my%rsync_error=(1,'syntax or usage error',2,'protocol incompatibility',3,'errors selecting input/output files, dirs',4,'requested action not supported: an attempt was made to manipulate 64-bit files on a platform '.'that  cannot  support them; or an option was specified that is supported by the client and not '.'by the server.',5,'error starting client-server protocol',6,'daemon unable to append to log-file',10,'error in socket I/O',11,'error in file I/O',12,'error in rsync protocol data stream',13,'errors with program diagnostics',14,'error in IPC code',20,'received SIGUSR1 or SIGINT',21,'some error returned by waitpid()',22,'error allocating core memory buffers',23,'partial transfer due to error',24,'partial transfer due to vanished source files',25,'the --max-delete limit stopped deletions',30,'timeout in data send/receive',35,'timeout waiting for daemon connection');my%rsync_opt_open_ex=map {$_=>1}qw(stderr_to_stdout stderr_discard stderr_fh stderr_file stdout_discard stdout_fh stdout_file encoding argument_encoding);sub _rsync {my$self=shift;my%opts=(ref $_[0]eq 'HASH' ? %{shift()}: ());my$async=delete$opts{async};my$verbose=delete$opts{verbose};my$quiet=delete$opts{quiet};my$copy_attrs=delete$opts{copy_attrs};my$timeout=delete$opts{timeout};$quiet=1 unless (defined$quiet or $verbose);my@opts;push@opts,'-q' if$quiet;push@opts,'-pt' if$copy_attrs;push@opts,'-' .($verbose =~ /^\d+$/ ? 'v' x $verbose : 'v')if$verbose;my%opts_open_ex=(_cmd=>'rsync',quote_args=>0);for my$opt (keys%opts){my$value=$opts{$opt};if (defined$value){if ($rsync_opt_open_ex{$opt}){$opts_open_ex{$opt}=$value}else {my$opt1=$opt;$opt1 =~ tr/_/-/;$rsync_opt_forbidden{$opt1}and croak "forbidden rsync option '$opt' used";if ($rsync_opt_with_arg{$opt1}){push@opts,"--$opt1=$_" for _array_or_scalar_to_list($value)}else {$value=!$value if$opt1 =~ s/^no-//;push@opts,($value ? "--$opt1" : "--no-$opt1")}}}}local$self->{_error_prefix}=[@{$self->{_error_prefix}},'rsync failed'];my$pid=$self->open_ex(\%opts_open_ex,@opts,'--',@_);return$pid if$async;$self->_waitpid($pid,$timeout)and return 1;if ($self->{_error}==OSSH_SLAVE_CMD_FAILED and $?){my$err=($? >> 8);my$errstr=$rsync_error{$err};$errstr='Unknown rsync error' unless defined$errstr;my$signal=$? & 255;my$signalstr=($signal ? " (signal $signal)" : '');$self->_set_error(OSSH_SLAVE_CMD_FAILED,"command exited with code $err$signalstr: $errstr")}return undef}_sub_options sftp=>qw(autoflush timeout argument_encoding encoding block_size queue_size autodie late_set_perm forward_agent setpgrp min_block_size read_ahead write_delay dirty_cleanup remote_has_volumes autodisconnect more);sub sftp {${^TAINT} and &_catch_tainted_args;@_ & 1 or croak 'Usage: $ssh->sftp(%sftp_opts)';_load_module('Net::SFTP::Foreign','1.47');my ($self,%opts)=@_;my$stderr_fh=delete$opts{stderr_fh};my$stderr_discard=delete$opts{stderr_discard};my$fs_encoding=_first_defined(delete$opts{fs_encoding},$opts{argument_encoding},$opts{encoding},$self->{_default_argument_encoding});undef$fs_encoding if (defined$fs_encoding and $fs_encoding eq 'bytes');_croak_bad_options%opts;$opts{timeout}=$self->{_timeout}unless defined$opts{timeout};$self->wait_for_master or return undef;my ($in,$out,$pid)=$self->open2({subsystem=>1,stderr_fh=>$stderr_fh,stderr_discard=>$stderr_discard },'sftp')or return undef;my$sftp=Net::SFTP::Foreign->new(transport=>[$out,$in,$pid],dirty_cleanup=>0,fs_encoding=>$fs_encoding,%opts);if ($sftp->error){$self->_or_set_error(OSSH_SLAVE_SFTP_FAILED,"unable to create SFTP client",$sftp->error);return undef}$sftp}_sub_options sshfs_import=>qw(stderr_discard stderr_fh stderr_file ssh_opts argument_encoding sshfs_opts setpgrp);sub sshfs_import {${^TAINT} and &_catch_tainted_args;my$self=shift;my%opts=(ref $_[0]eq 'HASH' ? %{shift()}: ());@_==2 or croak 'Usage: $ssh->sshfs_import(\%opts, $remote, $local)';my ($from,$to)=@_;my@sshfs_opts=(-o=>'slave',_array_or_scalar_to_list delete$opts{sshfs_opts});_croak_bad_options%opts;$opts{ssh_opts}=['-s',_array_or_scalar_to_list delete$opts{ssh_opts}];$opts{stdinout_dpipe}=[$self->{_sshfs_cmd},"$self->{_host_squared}:$from",$to,@sshfs_opts];$opts{stdinout_dpipe_make_parent}=1;$self->spawn(\%opts,'sftp')}_sub_options sshfs_export=>qw(stderr_discard stderr_fh stderr_file ssh_opts argument_encoding sshfs_opts setpgrp);sub sshfs_export {${^TAINT} and &_catch_tainted_args;my$self=shift;my%opts=(ref $_[0]eq 'HASH' ? %{shift()}: ());@_==2 or croak 'Usage: $ssh->sshfs_export(\%opts, $local, $remote)';my ($from,$to)=@_;my@sshfs_opts=(-o=>'slave',_array_or_scalar_to_list delete$opts{sshfs_opts});_croak_bad_options%opts;$opts{stdinout_dpipe}=$self->{_sftp_server_cmd};my$hostname=do {local ($@,$SIG{__DIE__});eval {require Sys::Hostname;Sys::Hostname::hostname()}};$hostname='remote' if (not defined$hostname or not length$hostname or $hostname=~/^localhost\b/);$self->spawn(\%opts,$self->{_sshfs_cmd},"$hostname:$from",$to,@sshfs_opts)}sub object_remote {my$self=shift;_load_module('Object::Remote')or return;_load_module('Net::OpenSSH::ObjectRemote')or return;my$connector=Net::OpenSSH::ObjectRemote->new(net_openssh=>$self);$connector->connect(@_)}sub any {my$self=shift;_load_module('Net::SSH::Any');Net::SSH::Any->new($self->{_host},user=>$self->{_user},port=>$self->{_port},backend=>'Net_OpenSSH',backend_opts=>{Net_OpenSSH=>{instance=>$self }})}sub DESTROY {my$self=shift;$debug and $debug & 2 and _debug("DESTROY($self, pid: ",$self->{_pid},")");local ($SIG{__DIE__},$@,$?,$!);$self->_disconnect}1;
NET_OPENSSH

$fatpacked{"Net/OpenSSH/ConnectionCache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_CONNECTIONCACHE';
  package Net::OpenSSH::ConnectionCache;use strict;use warnings;use Net::OpenSSH;use Net::OpenSSH::Constants qw(:error);use Data::Dumper;use Scalar::Util qw(weaken);our$MAX_SIZE=20;our%cache;sub _factory {my$class=shift;my%opts=@_;my$dump=Data::Dumper->new([\%opts],['s']);$dump->Indent(0);$dump->Sortkeys(1);$dump->Deepcopy(1);my$signature=$dump->Dump;my$ssh=$cache{$signature};if ($ssh and $ssh->error!=OSSH_MASTER_FAILED){if ($opts{async}or $ssh->wait_for_master){return$cache{$signature}=$ssh}}if ($MAX_SIZE <= keys%cache){for (keys%cache){$ssh=$cache{$_};$ssh or $ssh->error!=OSSH_MASTER_FAILED or delete$cache{$_}}for (keys%cache){last if ($MAX_SIZE <= keys%cache);weaken$cache{$_};if (defined$cache{$_}){$cache{$_}=$cache{$_}}else {delete$cache{$_}}}}local$Net::OpenSSH::FACTORY;$cache{$signature}=$class->new(@_)}$Net::OpenSSH::FACTORY=\&_factory;sub clean_cache {%cache=()}END {%cache=()}1;
NET_OPENSSH_CONNECTIONCACHE

$fatpacked{"Net/OpenSSH/Constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_CONSTANTS';
  package Net::OpenSSH::Constants;our$VERSION='0.51_07';use strict;use warnings;use Carp;use Scalar::Util ();require Exporter;our@ISA=qw(Exporter);our%EXPORT_TAGS=(error=>[],_state=>[]);my%error=(OSSH_MASTER_FAILED=>1,OSSH_SLAVE_FAILED=>2,OSSH_SLAVE_PIPE_FAILED=>3,OSSH_SLAVE_TIMEOUT=>4,OSSH_SLAVE_CMD_FAILED=>5,OSSH_SLAVE_SFTP_FAILED=>6,OSSH_ENCODING_ERROR=>7);for my$key (keys%error){no strict 'refs';my$value=$error{$key};*{$key}=sub () {$value};push @{$EXPORT_TAGS{error}},$key}my@states=qw(_STATE_START _STATE_LOGIN _STATE_AWAITING_MUX _STATE_RUNNING _STATE_KILLING _STATE_GONE _STATE_STOPPED);my$last_value;for my$state (@states){no strict 'refs';my$value=Scalar::Util::dualvar(++$last_value,$state);*{$state}=sub () {$value};push @{$EXPORT_TAGS{_state}},$state}our@EXPORT_OK=map {@{$EXPORT_TAGS{$_}}}keys%EXPORT_TAGS;$EXPORT_TAGS{all}=[@EXPORT_OK];1;
NET_OPENSSH_CONSTANTS

$fatpacked{"Net/OpenSSH/ModuleLoader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_MODULELOADER';
  package Net::OpenSSH::ModuleLoader;use strict;use warnings;use Carp;our%loaded_module;use Exporter qw(import);our@EXPORT=qw(_load_module);sub _load_module {my ($module,$version)=@_;$loaded_module{$module}||= do {my$err;do {local ($@,$SIG{__DIE__});my$ok=eval "require $module; 1";$err=$@;$ok}or croak "unable to load Perl module $module: $err"};if (defined$version){my$mv=do {local ($@,$SIG{__DIE__});eval "\$${module}::VERSION"}|| 0;(my$mv1=$mv)=~ s/_\d*$//;croak "$module version $version required, $mv is available" if$mv1 < $version}1}1;
NET_OPENSSH_MODULELOADER

$fatpacked{"Net/OpenSSH/OSTracer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_OSTRACER';
  package Net::OpenSSH::OSTracer;our$VERSION='0.65_06';use strict;use warnings;use POSIX;our$cmd;our$type;our$output;our$sudo;our$delay;our@EXTRA_ARGS;my%type_by_os=(linux=>'strace',openbsd=>'ktrace',freebsd=>'ktrace',netbsd=>'ktrace',bsd=>'ktrace','hp-ux'=>'tusc',aix=>'truss',solaris=>'truss');sub trace {my$class=shift;my ($cmd,$type)=($cmd,$type);if (not defined$type){my$os=lc $^O;if (defined$cmd and $cmd =~ /([sk]trace|k?truss|tusc)$/){$type=$1}elsif ($os =~ /(linux|openbsd|freebsd|netbsd|bsd|hp-ux|aix|solaris)/){$type=$type_by_os{$1}}else {Net::OpenSSH::_debug("unable to determine tracer type for OS $os");return}}my$output1=(defined$output ? $output : "/tmp/net_openssh_master").".$$";my$file="$output1.$type";my$err="$output1.txt";$cmd=$type unless defined$cmd;my@args;if ($type eq 'strace'){@args=(-o=>$file,-p=>$$,-s=>1024,'-fx')}elsif ($type eq 'ktruss'){@args=(-o=>$file,-p=>$$,-m=>1024,'-d')}elsif ($type eq 'ktrace'){@args=(-f=>$file,-p=>$$,'-id')}elsif ($type eq 'tusc'){@args=(-o=>$file,-b=>1024,'-fa',$$)}elsif ($type eq 'truss'){@args=(-o=>$file,-faep=>$$)}else {Net::OpenSSH::_debug("tracer type $type not supported");return}my@cmd=(defined$sudo ? ($sudo,'-A',$cmd): $cmd);my$pid=fork;unless ($pid){unless (defined$pid){Net::OpenSSH::_debug("unable to launch tracer, fork failed: $!");return}my ($in,$out);if (open$in,'</dev/null' and open$out,'>',$err and POSIX::dup2(fileno$in,0)and POSIX::dup2(fileno$out,1)and POSIX::dup2(fileno$out,2)){exec (@cmd,@EXTRA_ARGS,@args)}else {eval {Net::OpenSSH::_debug("Unable to redirect tracer IO: $!")}}POSIX::_exit(1)}sleep (defined$delay ? $delay : 1);Net::OpenSSH::_debug("tracer attached, ssh pid: $$, tracer pid: $pid");1}1;
NET_OPENSSH_OSTRACER

$fatpacked{"Net/OpenSSH/ObjectRemote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_OBJECTREMOTE';
  package Net::OpenSSH::ObjectRemote;use strict;use warnings;use Moo;with 'Object::Remote::Role::Connector::PerlInterpreter';has net_openssh=>(is=>'ro',required=>1);sub final_perl_command {my$self=shift;my$perl_command=$self->perl_command;[$self->net_openssh->make_remote_command(@$perl_command)]}1;
NET_OPENSSH_OBJECTREMOTE

$fatpacked{"Net/OpenSSH/SSH.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_SSH';
  package Net::OpenSSH::SSH;1;
NET_OPENSSH_SSH

$fatpacked{"Net/OpenSSH/ShellQuoter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_SHELLQUOTER';
  package Net::OpenSSH::ShellQuoter;use strict;use warnings;use Carp;use Net::OpenSSH::ModuleLoader;my%alias=(bash=>'POSIX',sh=>'POSIX',ksh=>'POSIX',ash=>'POSIX',dash=>'POSIX',pdksh=>'POSIX',mksh=>'POSIX',lksh=>'POSIX',zsh=>'POSIX',fizsh=>'POSIX',posh=>'POSIX',fish=>'fish',tcsh=>'csh');sub quoter {my ($class,$shell)=@_;$shell='POSIX' unless defined$shell;return$shell if ref$shell;if ($shell =~ /,/){require Net::OpenSSH::ShellQuoter::Chain;return Net::OpenSSH::ShellQuoter::Chain->chain(split /\s*,\s*/,$shell)}else {$shell=$alias{$shell}if defined$alias{$shell};$shell =~ /^\w+$/ or croak "bad quoting style $shell";my$impl="Net::OpenSSH::ShellQuoter::$shell";_load_module($impl);return$impl->new}}1;
NET_OPENSSH_SHELLQUOTER

$fatpacked{"Net/OpenSSH/ShellQuoter/Chain.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_SHELLQUOTER_CHAIN';
  package Net::OpenSSH::ShellQuoter::Chain;use strict;use warnings;use Net::OpenSSH::ShellQuoter;sub chain {my$class=shift;my@quoters=map Net::OpenSSH::ShellQuoter->quoter($_),reverse @_;my$self=\@quoters;bless$self,$class;$self}sub quote {my ($self,$arg)=@_;$arg=$_->quote($arg)for @$self;$arg}sub quote_glob {my ($self,$arg)=@_;if (@$self){$arg=$self->[0]->quote_glob($arg);$arg=$self->[$_]->quote($arg)for 1..$#$self}$arg}sub shell_fragments {my$self=shift;@$self or return (wantarray ? (): '');$self->[-1]->shell_fragments(@_)}1;
NET_OPENSSH_SHELLQUOTER_CHAIN

$fatpacked{"Net/OpenSSH/ShellQuoter/MSCmd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_SHELLQUOTER_MSCMD';
  package Net::OpenSSH::ShellQuoter::MSCmd;use strict;use warnings;use Carp;sub new {shift()}sub quote {shift;my$arg=shift;if ($arg =~ /[\r\n\0]/){croak "can't quote newlines to pass through MS cmd.exe"}$arg =~ s/([()%!^"<>&|])/^$1/g;$arg}*quote_glob=\&quote;my%fragments=(stdin_discard=>'<NUL:',stdout_discard=>'>NUL:',stderr_discard=>'2>NUL:',stdout_and_stderr_discard=>'>NUL: 2>&1',stderr_to_stdout=>'2>&1');sub shell_fragments {shift;my@f=grep defined,@fragments{@_};wantarray ? @f : join(' ',@f)}1;
NET_OPENSSH_SHELLQUOTER_MSCMD

$fatpacked{"Net/OpenSSH/ShellQuoter/MSWin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_SHELLQUOTER_MSWIN';
  package Net::OpenSSH::ShellQuoter::MSWin;use strict;use warnings;use Carp;sub new {shift()}sub quote {shift;my$arg=shift;if ($arg eq ''){return '""'}if ($arg =~ /[ \t\n\x0b"]/){$arg =~ s{(\\+)(?="|\z)}{$1$1}g;$arg =~ s{"}{\\"}g;return qq("$arg")}return$arg}*quote_glob=\&quote;sub shell_fragments {wantarray ? (): ''}1;
NET_OPENSSH_SHELLQUOTER_MSWIN

$fatpacked{"Net/OpenSSH/ShellQuoter/POSIX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_SHELLQUOTER_POSIX';
  package Net::OpenSSH::ShellQuoter::POSIX;use strict;use warnings;use Carp;sub new {__PACKAGE__}my$noquote_class='.\\w/\\-@,:';my$glob_class='*?\\[\\],\\{\\}:!^~';sub quote {shift;my$quoted=join '',map {(m|\A'\z| ? "\\'" : m|\A'| ? "\"$_\"" : m|\A[$noquote_class]+\z|o ? $_ : "'$_'")}split /('+)/,$_[0];length$quoted ? $quoted : "''"}sub quote_glob {shift;my$arg=shift;my@parts;while ((pos$arg ||0)< length$arg){if ($arg =~ m|\G('+)|gc){push@parts,(length($1)> 1 ? "\"$1\"" : "\\'")}elsif ($arg =~ m|\G([$noquote_class$glob_class]+)|gco){push@parts,$1}elsif ($arg =~ m|\G(\\[$glob_class\\])|gco){push@parts,$1}elsif ($arg =~ m|\G\\|gc){push@parts,'\\\\'}elsif ($arg =~ m|\G([^$glob_class\\']+)|gco){push@parts,"'$1'"}else {require Data::Dumper;$arg =~ m|\G(.+)|gc;die "Internal error: unquotable string:\n".Data::Dumper::Dumper($1)."\n"}}my$quoted=join('',@parts);length$quoted ? $quoted : "''"}my%fragments=(stdin_discard=>'</dev/null',stdout_discard=>'>/dev/null',stderr_discard=>'2>/dev/null',stdout_and_stderr_discard=>'>/dev/null 2>&1',stderr_to_stdout=>'2>&1');sub shell_fragments {shift;my@f=grep defined,@fragments{@_};wantarray ? @f : join(' ',@f)}1;
NET_OPENSSH_SHELLQUOTER_POSIX

$fatpacked{"Net/OpenSSH/ShellQuoter/csh.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_SHELLQUOTER_CSH';
  package Net::OpenSSH::ShellQuoter::csh;use strict;use warnings;use Carp;sub new {__PACKAGE__}my$noquote_class=q(.\\w/\\-@,:);my$glob_class=q(*?\\[\\],{}:!^~);my$escape_inside_single_quotes_class=q(\!\n);sub _single_quote {my$arg=shift;$arg =~ s/([$escape_inside_single_quotes_class])/\\$1/go;"'$arg'"}sub quote {shift;my$quoted=join '',map {(m|\A'\z| ? "\\'" : m|\A'| ? "\"$_\"" : m|\A[$noquote_class]*\z|o ? $_ : _single_quote($_))}split /(')/o,$_[0];length$quoted ? $quoted : "''"}sub quote_glob {shift;my$arg=shift;my@parts;while ((pos$arg ||0)< length$arg){if ($arg =~ m|\G('+)|gc){push@parts,(length($1)> 1 ? "\"$1\"" : "\\'")}elsif ($arg =~ m|\G([$noquote_class$glob_class]+)|gco){push@parts,$1}elsif ($arg =~ m|\G(\\[$glob_class\\])|gco){push@parts,$1}elsif ($arg =~ m|\G([^$glob_class\\']+)|gco){push@parts,_single_quote($1)}else {require Data::Dumper;$arg =~ m|\G(.+)|gc;die "Internal error: unquotable string:\n".Data::Dumper::Dumper($1)."\n"}}my$quoted=join('',@parts);length$quoted ? $quoted : "''"}my%fragments=(stdin_discard=>'</dev/null',stdout_discard=>'>/dev/null',stdout_and_stderr_discard=>'>&/dev/null');sub shell_fragments {shift;my@f=grep defined,@fragments{@_};wantarray ? @f : join(' ',@f)}1;
NET_OPENSSH_SHELLQUOTER_CSH

$fatpacked{"Net/OpenSSH/ShellQuoter/fish.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_OPENSSH_SHELLQUOTER_FISH';
  package Net::OpenSSH::ShellQuoter::fish;use strict;use warnings;use Carp;sub new {__PACKAGE__}my$noquote_class='.\\w/\\-@,:';my$glob_class='*?\\[\\],\\{\\}:!^~';sub quote {my$quoted=$_[1];return$quoted if$quoted =~ /\A[$noquote_class]+\z/o;$quoted =~ s/([\'\\])/\\$1/g;"'$quoted'"}sub quote_glob {shift;my$arg=shift;my@parts;while ((pos$arg || 0)< length$arg){if ($arg =~ m|\G('+)|gc){push@parts,(length($1)> 1 ? "\"$1\"" : "\\'")}elsif ($arg =~ m|\G([$noquote_class$glob_class]+)|gco){push@parts,$1}elsif ($arg =~ m|\G(\\[$glob_class\\])|gco){push@parts,$1}elsif ($arg =~ m|\G\\|gc){push@parts,'\\\\'}elsif ($arg =~ m|\G([^$glob_class\\']+)|gco){push@parts,"'$1'"}else {require Data::Dumper;$arg =~ m|\G(.+)|gc;die "Internal error: unquotable string:\n".Data::Dumper::Dumper($1)."\n"}}my$quoted=join('',@parts);length$quoted ? $quoted : "''"}my%fragments=(stdin_discard=>'</dev/null',stdout_discard=>'>/dev/null',stderr_discard=>'2>/dev/null',stdout_and_stderr_discard=>'>/dev/null 2>&1',stderr_to_stdout=>'2>&1');sub shell_fragments {shift;my@f=grep defined,@fragments{@_};wantarray ? @f : join(' ',@f)}1;
NET_OPENSSH_SHELLQUOTER_FISH

$fatpacked{"PPI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI';
  package PPI;use 5.006;use strict;our$VERSION='1.274';our ($XS_COMPATIBLE,@XS_EXCLUDE)=('0.845');use PPI::Util ();use PPI::Exception ();use PPI::Element ();use PPI::Token ();use PPI::Statement ();use PPI::Structure ();use PPI::Document ();use PPI::Document::File ();use PPI::Document::Fragment ();use PPI::Document::Normalized ();use PPI::Normal ();use PPI::Tokenizer ();use PPI::Lexer ();die if!$PPI::XS_DISABLE and!eval {require PPI::XS;1}and $@ !~ /^Can't locate .*? at /;1;
PPI

$fatpacked{"PPI/Cache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_CACHE';
  package PPI::Cache;use strict;use Carp ();use File::Spec ();use File::Path ();use Storable 2.17 ();use Digest::MD5 2.35 ();use Params::Util qw{_INSTANCE _SCALAR};use PPI::Document ();our$VERSION='1.274';use constant VMS=>!!($^O eq 'VMS');sub import {my$class=ref $_[0]? ref shift : shift;return 1 unless @_;my$cache=$class->new(@_);unless (PPI::Document->set_cache($cache)){Carp::croak("Failed to set cache in PPI::Document")}1}sub new {my$class=shift;my%params=@_;my$path=$params{path}or Carp::croak("Cannot create PPI::Cache, no path provided");unless (-d $path){Carp::croak("Cannot create PPI::Cache, path does not exist")}unless (-r $path and -x $path){Carp::croak("Cannot create PPI::Cache, no read permissions for path")}if (!$params{readonly}and!-w $path){Carp::croak("Cannot create PPI::Cache, no write permissions for path")}my$self=bless {path=>$path,readonly=>!!$params{readonly},},$class;$self}sub path {$_[0]->{path}}sub readonly {$_[0]->{readonly}}sub get_document {my$self=ref $_[0]? shift : Carp::croak('PPI::Cache::get_document called as static method');my$md5hex=$self->_md5hex(shift)or return undef;$self->_load($md5hex)}sub store_document {my$self=shift;my$Document=_INSTANCE(shift,'PPI::Document')or return undef;return 1 if$self->readonly;my$md5hex=$Document->hex_id or return undef;$self->_store($md5hex,$Document)}sub _store {my ($self,$md5hex,$object)=@_;my ($dir,$file)=$self->_paths($md5hex);File::Path::mkpath($dir,0,0755)unless -d $dir;if (VMS){Storable::lock_nstore($object,$file)}else {Storable::nstore($object,$file)}}sub _load {my ($self,$md5hex)=@_;my (undef,$file)=$self->_paths($md5hex);return '' unless -f $file;my$object=VMS ? Storable::retrieve($file): Storable::lock_retrieve($file);unless (_INSTANCE($object,'PPI::Document')){Carp::croak("Security Violation: Object in '$file' is not a PPI::Document")}$object}sub _paths {my$self=shift;my$md5hex=lc shift;my$dir=File::Spec->catdir($self->path,substr($md5hex,0,1),substr($md5hex,0,2));my$file=File::Spec->catfile($dir,$md5hex .'.ppi');return ($dir,$file)}sub _md5hex {my$either=shift;my$it=_SCALAR($_[0])? PPI::Util::md5hex(${$_[0]}): $_[0];return (defined$it and!ref$it and $it =~ /^[[:xdigit:]]{32}\z/s)? lc$it : undef}1;
PPI_CACHE

$fatpacked{"PPI/Document.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DOCUMENT';
  package PPI::Document;use strict;use Carp ();use List::Util 1.33 ();use Params::Util 1.00 qw{_SCALAR0 _ARRAY0 _INSTANCE};use Digest::MD5 ();use PPI::Util ();use PPI ();use PPI::Node ();use overload 'bool'=>\&PPI::Util::TRUE;use overload '""'=>'content';our$VERSION='1.274';our ($errstr,@ISA)=("","PPI::Node");use PPI::Document::Fragment ();my$CACHE;use constant LOCATION_LINE=>0;use constant LOCATION_CHARACTER=>1;use constant LOCATION_COLUMN=>2;use constant LOCATION_LOGICAL_LINE=>3;use constant LOCATION_LOGICAL_FILE=>4;sub new {local $_;my$class=ref $_[0]? ref shift : shift;unless (@_){my$self=$class->SUPER::new;$self->{readonly}=!1;$self->{tab_width}=1;return$self}my$source=shift;my%attr=@_;if (!defined$source){$class->_error("An undefined value was passed to PPI::Document::new")}elsif (!ref$source){if ($source =~ /(?:\012|\015)/){Carp::croak("API CHANGE: Source code should only be passed to PPI::Document->new as a SCALAR reference")}$attr{filename}||= $source;if ($CACHE){my$file_contents=PPI::Util::_slurp($source);return$class->_error($file_contents)if!ref$file_contents;my$document=$CACHE->get_document($file_contents);return$class->_setattr($document,%attr)if$document;$document=PPI::Lexer->lex_source($$file_contents);if ($document){$CACHE->store_document($document);return$class->_setattr($document,%attr)}}else {my$document=PPI::Lexer->lex_file($source);return$class->_setattr($document,%attr)if$document}}elsif (_SCALAR0($source)){my$document=PPI::Lexer->lex_source($$source);return$class->_setattr($document,%attr)if$document}elsif (_ARRAY0($source)){$source=join '',map {"$_\n"}@$source;my$document=PPI::Lexer->lex_source($source);return$class->_setattr($document,%attr)if$document}else {$class->_error("Unknown object or reference was passed to PPI::Document::new")}my$errstr;if (_INSTANCE($@,'PPI::Exception')){$errstr=$@->message}elsif ($@){$errstr=$@;$errstr =~ s/\sat line\s.+$//}elsif (PPI::Lexer->errstr){$errstr=PPI::Lexer->errstr}else {$errstr="Unknown error parsing Perl document"}PPI::Lexer->_clear;$class->_error($errstr)}sub load {Carp::croak("API CHANGE: File names should now be passed to PPI::Document->new to load a file")}sub _setattr {my ($class,$document,%attr)=@_;$document->{readonly}=!!$attr{readonly};$document->{filename}=$attr{filename};return$document}sub set_cache {my$class=ref $_[0]? ref shift : shift;if (defined $_[0]){my$object=_INSTANCE(shift,'PPI::Cache')or return undef;$CACHE=$object}else {$CACHE=undef}1}sub get_cache {$CACHE}sub filename {$_[0]->{filename}}sub readonly {$_[0]->{readonly}}sub tab_width {my$self=shift;return$self->{tab_width}unless @_;$self->{tab_width}=shift}sub save {my$self=shift;local*FILE;open(FILE,'>',$_[0])or return undef;binmode FILE;print FILE$self->serialize or return undef;close FILE or return undef;return 1}sub serialize {my$self=shift;my@tokens=$self->tokens;my$heredoc='';my$output='';for my$i (0 .. $#tokens){my$Token=$tokens[$i];unless ($Token->isa('PPI::Token::HereDoc')){my$content=$Token->content;unless ($heredoc ne '' and $content =~ /\n/){$output .= $content;next}if ($content eq "\n"){$output .= $content .$heredoc}else {$content =~ s/\n/\n$heredoc/;$output .= $content}$heredoc='';next}$output .= $Token->content;my$indentation=$Token->indentation || '';for my$line ($Token->heredoc){$heredoc .= "\n" eq $line ? $line : $indentation .$line}if ($Token->{_damaged}){my$last_index=$#tokens;if ($tokens[$last_index]->{content}=~ /^[^\n]*\n$/){$last_index--}my$last_line=List::Util::none {$tokens[$_]and $tokens[$_]->{content}=~ /\n/}(($i + 1).. $last_index);if (!defined$last_line){$last_line=1}my$any_after=List::Util::any {$tokens[$_]->isa('PPI::Token::HereDoc')and (scalar(@{$tokens[$_]->{_heredoc}})or defined$tokens[$_]->{_terminator_line})}(($i + 1).. $#tokens);if (!defined$any_after){$any_after=''}unless ($last_line and!$any_after){unless (defined$Token->{_terminator_line}){$Token->{_terminator_line}=$Token->{_terminator}}unless ($Token->{_terminator_line}=~ /\n$/){$Token->{_terminator_line}.= "\n"}}}if (defined$Token->{_terminator_line}){$heredoc .= $indentation .$Token->{_terminator_line}}}if ($heredoc ne ''){unless ($output =~ /\n$/){$output .= "\n"}$output .= $heredoc}$output}sub hex_id {PPI::Util::md5hex($_[0]->serialize)}sub index_locations {my$self=shift;my@tokens=$self->tokens;my$heredoc=0;my ($first,$location)=();for (0 .. $#tokens){my$Token=$tokens[$_];next if$Token->{_location};if ($_){$location=$self->_add_location($location,$tokens[$_ - 1],\$heredoc)}else {my$logical_file=$self->can('filename')? $self->filename : undef;$location=[1,1,1,1,$logical_file ]}$first=$_;last}if (defined$first){for ($first .. $#tokens){my$Token=$tokens[$_];$Token->{_location}=$location;$location=$self->_add_location($location,$Token,\$heredoc);if ($Token->isa('PPI::Token::HereDoc')){$heredoc += $Token->heredoc + 1}}}1}sub _add_location {my ($self,$start,$Token,$heredoc)=@_;my$content=$Token->{content};my$newlines=()=$content =~ /\n/g;my ($logical_line,$logical_file)=$self->_logical_line_and_file($start,$Token,$newlines);unless ($newlines){return [$start->[LOCATION_LINE],$start->[LOCATION_CHARACTER]+ length($content),$start->[LOCATION_COLUMN]+ $self->_visual_length($content,$start->[LOCATION_COLUMN]),$logical_line,$logical_file,]}my$physical_line=$start->[LOCATION_LINE]+ $newlines;my$location=[$physical_line,1,1,$logical_line,$logical_file ];if ($heredoc and $$heredoc){$location->[LOCATION_LINE]+= $$heredoc;$location->[LOCATION_LOGICAL_LINE]+= $$heredoc;$$heredoc=0}if ($content =~ /\n([^\n]+?)\z/){$location->[LOCATION_CHARACTER]+= length($1);$location->[LOCATION_COLUMN]+= $self->_visual_length($1,$location->[LOCATION_COLUMN],)}$location}sub _logical_line_and_file {my ($self,$start,$Token,$newlines)=@_;if ($start->[LOCATION_CHARACTER]==1){if ($Token->isa('PPI::Token::Comment')){if ($Token->content =~ m<
  					\A
  					\#      \s*
  					line    \s+
  					(\d+)   \s*
  					(?: (\"?) ([^\"]* [^\s\"]) \2 )?
  					\s*
  					\z
  				>xms){return $1,($3 || $start->[LOCATION_LOGICAL_FILE])}}elsif ($Token->isa('PPI::Token::Pod')){my$content=$Token->content;my$line;my$file=$start->[LOCATION_LOGICAL_FILE];my$end_of_directive;while ($content =~ m<
  					^
  					\#      \s*?
  					line    \s+?
  					(\d+)   (?: (?! \n) \s)*
  					(?: (\"?) ([^\"]*? [^\s\"]) \2 )??
  					\s*?
  					$
  				>xmsg){($line,$file)=($1,($3 || $file));$end_of_directive=pos$content}if (defined$line){pos$content=$end_of_directive;my$post_directive_newlines=()=$content =~ m< \G [^\n]* \n >xmsg;return$line + $post_directive_newlines - 1,$file}}}return $start->[LOCATION_LOGICAL_LINE]+ $newlines,$start->[LOCATION_LOGICAL_FILE]}sub _visual_length {my ($self,$content,$pos)=@_;my$tab_width=$self->tab_width;my ($length,$vis_inc);return length$content if$content !~ /\t/;for my$part (split(/(\t)/,$content)){if ($part eq "\t"){$vis_inc=$tab_width - ($pos-1)% $tab_width}else {$vis_inc=length$part}$length += $vis_inc;$pos += $vis_inc}$length}sub flush_locations {shift->_flush_locations(@_)}sub normalized {PPI::Normal->process($_[0]->clone)}sub complete {my$self=shift;$self->find_any(sub {$_[1]->isa('PPI::Structure')and !$_[1]->complete})and return '';my@child=$self->children;while (@child and not $child[-1]->isa('PPI::Statement')){pop@child}return '' unless@child;return$child[-1]->_complete}sub scope() {1}sub insert_before {return undef}sub insert_after {return undef}sub replace {return undef}sub _error {$errstr=$_[1];undef}sub _clear {$errstr='';$_[0]}sub errstr {$errstr}sub STORABLE_freeze {my$self=shift;my$class=ref$self;my%hash=%$self;return ($class,\%hash)}sub STORABLE_thaw {my ($self,undef,$class,$hash)=@_;bless$self,$class;for (keys %$hash){$self->{$_}=delete$hash->{$_}}$self->__link_children}1;
PPI_DOCUMENT

$fatpacked{"PPI/Document/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DOCUMENT_FILE';
  package PPI::Document::File;use strict;use Carp ();use Params::Util qw{_STRING _INSTANCE};use PPI::Document ();our$VERSION='1.274';our@ISA='PPI::Document';sub new {my$class=shift;my$filename=_STRING(shift);unless (defined$filename){return$class->_error("Did not provide a file name to load")}my$self=$class->SUPER::new($filename,@_)or return undef;if (_INSTANCE($self,'PPI::Document')){bless$self,'PPI::Document::File'}else {die "PPI::Document::File SUPER call returned an object of the wrong type"}$self}sub save {my$self=shift;my$filename=shift;unless (defined$filename){$filename=$self->filename}$self->SUPER::save($filename,@_)}1;
PPI_DOCUMENT_FILE

$fatpacked{"PPI/Document/Fragment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DOCUMENT_FRAGMENT';
  package PPI::Document::Fragment;use strict;use PPI::Document ();our$VERSION='1.274';our@ISA='PPI::Document';sub index_locations {warn "Useless attempt to index the locations of a document fragment";undef}sub scope() {''}1;
PPI_DOCUMENT_FRAGMENT

$fatpacked{"PPI/Document/Normalized.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DOCUMENT_NORMALIZED';
  package PPI::Document::Normalized;use strict;use Scalar::Util qw{refaddr reftype blessed};use Params::Util qw{_INSTANCE _ARRAY};use PPI::Util ();our$VERSION='1.274';use overload 'bool'=>\&PPI::Util::TRUE;use overload '=='=>'equal';sub new {my$class=shift;my%args=@_;my$Document=_INSTANCE($args{Document},'PPI::Document')or return undef;my$version=$args{version};my$functions=_ARRAY($args{functions})or return undef;my$self=bless {Document=>$Document,version=>$version,functions=>$functions,},$class;$self}sub _Document {$_[0]->{Document}}sub version {$_[0]->{version}}sub functions {$_[0]->{functions}}sub equal {my$self=shift;my$other=_INSTANCE(shift,'PPI::Document::Normalized')or return undef;return undef if$self->{processing};my$v1=$self->version || "undef";my$v2=$other->version || "undef";return '' if$v1 ne $v2;$self->_equal_ARRAY($self->functions,$other->functions)or return '';$self->{seen}={};my$rv=$self->_equal_blessed($self->_Document,$other->_Document);delete$self->{seen};$rv}sub _equal_blessed {my ($self,$this,$that)=@_;my ($bthis,$bthat)=(blessed$this,blessed$that);$bthis and $bthat and $bthis eq $bthat or return '';$self->_equal_reference($this,$that)}sub _equal_reference {my ($self,$this,$that)=@_;my ($rthis,$rthat)=(refaddr$this,refaddr$that);$rthis and $rthat or return undef;my$seen=$self->{seen}->{$rthis};if ($seen and $seen ne $rthat){return ''}my ($tthis,$tthat)=(reftype$this,reftype$that);$tthis and $tthat and $tthis eq $tthat or return undef;$self->{seen}->{$rthis}=$rthat;my$method="_equal_$tthat";my$rv=$self->$method($this,$that);delete$self->{seen}->{$rthis};$rv}sub _equal_SCALAR {my ($self,$this,$that)=@_;my ($cthis,$cthat)=($$this,$$that);return$self->_equal_blessed($cthis,$cthat)if blessed$cthis;return$self->_equal_reference($cthis,$cthat)if ref$cthis;return (defined$cthat and $cthis eq $cthat)if defined$cthis;!defined$cthat}sub _equal_REF {shift->_equal_SCALAR(@_)}sub _equal_ARRAY {my ($self,$this,$that)=@_;scalar(@$this)==scalar(@$that)or return '';for my$i (0 .. scalar(@$this)){my ($cthis,$cthat)=($this->[$i],$that->[$i]);if (blessed$cthis){return '' unless$self->_equal_blessed($cthis,$cthat)}elsif (ref$cthis){return '' unless$self->_equal_reference($cthis,$cthat)}elsif (defined$cthis){return '' unless (defined$cthat and $cthis eq $cthat)}else {return '' if defined$cthat}}1}sub _equal_HASH {my ($self,$this,$that)=@_;return '' unless scalar(keys %$this)==scalar(keys %$that);for my$k (keys %$this){return '' unless exists$that->{$k};my ($cthis,$cthat)=($this->{$k},$that->{$k});if (blessed$cthis){return '' unless$self->_equal_blessed($cthis,$cthat)}elsif (ref$cthis){return '' unless$self->_equal_reference($cthis,$cthat)}elsif (defined$cthis){return '' unless (defined$cthat and $cthis eq $cthat)}else {return '' if defined$cthat}}1}sub _equal_GLOB {my ($self,$this,$that)=@_;warn('GLOB comparisons are not supported');''}sub _equal_CODE {my ($self,$this,$that)=@_;refaddr$this==refaddr$that}sub _equal_IO {my ($self,$this,$that)=@_;warn('IO comparisons are not supported');''}sub DESTROY {if ($_[0]->{Document}){$_[0]->{Document}->DESTROY;delete $_[0]->{Document}}}1;
PPI_DOCUMENT_NORMALIZED

$fatpacked{"PPI/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DUMPER';
  package PPI::Dumper;use strict;use Params::Util qw{_INSTANCE};our$VERSION='1.274';sub new {my$class=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;my$self=bless {root=>$Element,display=>{memaddr=>'',indent=>2,class=>1,content=>1,whitespace=>1,comments=>1,locations=>0,},},$class;my@options=map {lc $_}@_;my%options=@options;for (keys %{$self->{display}}){if (exists$options{$_}){if ($_ eq 'indent'){$self->{display}->{indent}=$options{$_}}else {$self->{display}->{$_}=!!$options{$_}}}}$self->{indent_string}=join '',(' ' x $self->{display}->{indent});$self}sub print {CORE::print(shift->string)}sub string {my$array_ref=shift->_dump or return undef;join '',map {"$_\n"}@$array_ref}sub list {my$array_ref=shift->_dump or return ();@$array_ref}sub _dump {my$self=ref $_[0]? shift : shift->new(shift);my$Element=_INSTANCE($_[0],'PPI::Element')? shift : $self->{root};my$indent=shift || '';my$output=shift || [];my$show=1;if ($Element->isa('PPI::Token::Whitespace')){$show=0 unless$self->{display}->{whitespace}}elsif ($Element->isa('PPI::Token::Comment')){$show=0 unless$self->{display}->{comments}}push @$output,$self->_element_string($Element,$indent)if$show;if ($Element->isa('PPI::Node')){my$child_indent=$indent .$self->{indent_string};for my$child (@{$Element->{children}}){$self->_dump($child,$child_indent,$output)}}$output}sub _element_string {my$self=ref $_[0]? shift : shift->new(shift);my$Element=_INSTANCE($_[0],'PPI::Element')? shift : $self->{root};my$indent=shift || '';my$string='';if ($self->{display}->{memaddr}){$string .= $Element->refaddr .'  '}if ($self->{display}->{locations}){my$loc_string;if ($Element->isa('PPI::Token')){my$location=$Element->location;if ($location){$loc_string=sprintf("[ % 4d, % 3d, % 3d ] ",@$location)}}$string .= $loc_string || " " x 20}if ($self->{display}->{indent}){$string .= $indent}if ($self->{display}->{class}){$string .= ref$Element}if ($Element->isa('PPI::Token')){if ($self->{display}->{content}){my$content=$Element->content;$content =~ s/\n/\\n/g;$content =~ s/\t/\\t/g;$content =~ s/\f/\\f/g;$string .= "  \t'$content'"}}elsif ($Element->isa('PPI::Structure')){if ($self->{display}->{content}){my$start=$Element->start ? $Element->start->content : '???';my$finish=$Element->finish ? $Element->finish->content : '???';$string .= "  \t$start ... $finish"}}$string}1;
PPI_DUMPER

$fatpacked{"PPI/Element.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_ELEMENT';
  package PPI::Element;use strict;use Clone 0.30 ();use Scalar::Util qw{refaddr};use Params::Util qw{_INSTANCE _ARRAY};use List::Util ();use PPI::Util ();use PPI::Node ();use PPI::Singletons '%_PARENT';our$VERSION='1.274';our$errstr="";use overload 'bool'=>\&PPI::Util::TRUE;use overload '""'=>'content';use overload '=='=>'__equals';use overload '!='=>'__nequals';use overload 'eq'=>'__eq';use overload 'ne'=>'__ne';sub significant() {1}sub class {ref($_[0])}sub tokens {$_[0]}sub content() {''}sub parent {$_PARENT{refaddr $_[0]}}sub descendant_of {my$cursor=shift;my$parent=shift or return undef;while (refaddr$cursor!=refaddr$parent){$cursor=$_PARENT{refaddr$cursor}or return ''}return 1}sub ancestor_of {my$self=shift;my$cursor=shift or return undef;while (refaddr$cursor!=refaddr$self){$cursor=$_PARENT{refaddr$cursor}or return ''}return 1}sub statement {my$cursor=shift;while (!_INSTANCE($cursor,'PPI::Statement')){$cursor=$_PARENT{refaddr$cursor}or return ''}$cursor}sub top {my$cursor=shift;while (my$parent=$_PARENT{refaddr$cursor}){$cursor=$parent}$cursor}sub document {my$top=shift->top;_INSTANCE($top,'PPI::Document')and $top}sub next_sibling {my$self=shift;my$parent=$_PARENT{refaddr$self}or return '';my$key=refaddr$self;my$elements=$parent->{children};my$position=List::Util::first {refaddr$elements->[$_]==$key}0..$#$elements;$elements->[$position + 1]|| ''}sub snext_sibling {my$self=shift;my$parent=$_PARENT{refaddr$self}or return '';my$key=refaddr$self;my$elements=$parent->{children};my$position=List::Util::first {refaddr$elements->[$_]==$key}0..$#$elements;while (defined(my$it=$elements->[++$position])){return$it if$it->significant}''}sub previous_sibling {my$self=shift;my$parent=$_PARENT{refaddr$self}or return '';my$key=refaddr$self;my$elements=$parent->{children};my$position=List::Util::first {refaddr$elements->[$_]==$key}0..$#$elements;$position and $elements->[$position - 1]or ''}sub sprevious_sibling {my$self=shift;my$parent=$_PARENT{refaddr$self}or return '';my$key=refaddr$self;my$elements=$parent->{children};my$position=List::Util::first {refaddr$elements->[$_]==$key}0..$#$elements;while ($position-- and defined(my$it=$elements->[$position])){return$it if$it->significant}''}sub first_token {my$cursor=shift;while ($cursor->isa('PPI::Node')){$cursor=$cursor->first_element or die "Found empty PPI::Node while getting first token"}$cursor}sub last_token {my$cursor=shift;while ($cursor->isa('PPI::Node')){$cursor=$cursor->last_element or die "Found empty PPI::Node while getting first token"}$cursor}sub next_token {my$cursor=shift;while (1){my$element=$cursor->next_sibling;if ($element){return$element if$element->isa('PPI::Token');return$element->first_token}$cursor=$cursor->parent or return '';if ($cursor->isa('PPI::Structure')and $cursor->finish){return$cursor->finish}}}sub previous_token {my$cursor=shift;while (1){my$element=$cursor->previous_sibling;if ($element){return$element if$element->isa('PPI::Token');return$element->last_token}$cursor=$cursor->parent or return '';if ($cursor->isa('PPI::Structure')and $cursor->start){return$cursor->start}}}sub clone {Clone::clone(shift)}sub __insert_before {my$self=shift;$self->parent->__insert_before_child($self,@_)}sub __insert_after {my$self=shift;$self->parent->__insert_after_child($self,@_)}sub remove {my$self=shift;my$parent=$self->parent or return$self;$parent->remove_child($self)}sub delete {$_[0]->remove or return undef;$_[0]->DESTROY;1}sub replace {my$self=ref $_[0]? shift : return undef;_INSTANCE(shift,ref$self)or return undef;die "The ->replace method has not yet been implemented"}sub location {my$self=shift;$self->_ensure_location_present or return undef;return [@{$self->{_location}}]}sub line_number {my$self=shift;my$location=$self->location()or return undef;return$location->[0]}sub column_number {my$self=shift;my$location=$self->location()or return undef;return$location->[1]}sub visual_column_number {my$self=shift;my$location=$self->location()or return undef;return$location->[2]}sub logical_line_number {my$self=shift;return$self->location()->[3]}sub logical_filename {my$self=shift;my$location=$self->location()or return undef;return$location->[4]}sub _ensure_location_present {my$self=shift;unless (exists$self->{_location}){my$Document=$self->document or return undef;if ($Document->isa('PPI::Document::Fragment')){return undef}$Document->index_locations or return undef;unless (exists$self->{_location}){return undef}}return 1}sub _flush_locations {my$self=shift;unless ($self==$self->top){return$self->top->_flush_locations($self)}my@Tokens=$self->tokens;if (_INSTANCE($_[0],'PPI::Element')){my$start=shift->first_token;while (my$Token=shift@Tokens){return 1 unless$Token->{_location};next unless refaddr($Token)==refaddr($start);delete $$Token->{_location};last}}for my$Token (@Tokens){delete$Token->{_location}}1}sub _xml_name {my$class=ref $_[0]|| $_[0];my$name=lc join('_',split /::/,$class);substr($name,4)}sub _xml_attr {return {}}sub _xml_content {defined $_[0]->{content}? $_[0]->{content}: ''}sub _error {$errstr=$_[1];undef}sub _clear {$errstr='';$_[0]}sub DESTROY {delete$_PARENT{refaddr $_[0]}}sub __equals {ref $_[1]and refaddr($_[0])==refaddr($_[1])}sub __nequals {!__equals(@_)}sub __eq {my$self=_INSTANCE($_[0],'PPI::Element')? $_[0]->content : $_[0];my$other=_INSTANCE($_[1],'PPI::Element')? $_[1]->content : $_[1];$self eq $other}sub __ne {!__eq(@_)}1;
PPI_ELEMENT

$fatpacked{"PPI/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_EXCEPTION';
  package PPI::Exception;use strict;use Params::Util qw{_INSTANCE};our$VERSION='1.274';sub new {my$class=shift;return bless {@_ },$class if @_ > 1;return bless {message=>$_[0]},$class if @_;return bless {message=>'Unknown Exception' },$class}sub throw {my$it=shift;if (_INSTANCE($it,'PPI::Exception')){if ($it->{callers}){push @{$it->{callers}},[caller(0)]}else {$it->{callers}||= []}}else {my$message=$_[0]|| 'Unknown Exception';$it=$it->new(message=>$message,callers=>[[caller(0)],],)}die$it}sub message {$_[0]->{message}}sub callers {@{$_[0]->{callers}|| []}}1;
PPI_EXCEPTION

$fatpacked{"PPI/Exception/ParserRejection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_EXCEPTION_PARSERREJECTION';
  package PPI::Exception::ParserRejection;use strict;use PPI::Exception ();our$VERSION='1.274';our@ISA='PPI::Exception';1;
PPI_EXCEPTION_PARSERREJECTION

$fatpacked{"PPI/Find.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_FIND';
  package PPI::Find;use strict;use Params::Util qw{_INSTANCE};our$VERSION='1.274';sub new {my$class=ref $_[0]? ref shift : shift;my$wanted=ref $_[0]eq 'CODE' ? shift : return undef;my$self=bless {wanted=>$wanted,},$class;$self}sub clone {my$self=ref $_[0]? shift : die "->clone can only be called as an object method";my$class=ref$self;my$clone=bless {wanted=>$self->{wanted},},$class;$clone}sub in {my$self=shift;my$Element=shift;my%params=@_;delete$self->{errstr};if ($self->{in}){return$self->_error('->in called while another search is in progress',%params)}unless (_INSTANCE($Element,'PPI::Element')){return$self->_error('->in was not passed a PPI::Element object',%params)}$self->{in}=$Element;$self->{matches}=[];if (!eval {$self->_execute;1}){my$errstr=$@;$errstr =~ s/\s+at\s+line\s+.+$//;return$self->_error("Error while searching: $errstr",%params)}delete$self->{in};if ($params{array_ref}){if (@{$self->{matches}}){return delete$self->{matches}}delete$self->{matches};return ''}my$matches=delete$self->{matches};@$matches}sub start {my$self=shift;my$Element=shift;delete$self->{errstr};if ($self->{in}){return$self->_error('->in called while another search is in progress')}unless (_INSTANCE($Element,'PPI::Element')){return$self->_error('->in was not passed a PPI::Element object')}$self->{in}=$Element;$self->{matches}=[];if (!eval {$self->_execute;1}){my$errstr=$@;$errstr =~ s/\s+at\s+line\s+.+$//;$self->_error("Error while searching: $errstr");return undef}1}sub match {my$self=shift;return undef unless$self->{matches};my$match=shift @{$self->{matches}};return$match if$match;$self->finish;undef}sub finish {my$self=shift;delete$self->{in};delete$self->{matches};delete$self->{errstr};1}sub _execute {my$self=shift;my$wanted=$self->{wanted};my@queue=($self->{in});while (my$Element=shift@queue){my$rv=&$wanted($Element,$self->{in});push @{$self->{matches}},$Element if$rv;next unless defined$rv;next unless$Element->isa('PPI::Node');if ($Element->isa('PPI::Structure')){unshift@queue,$Element->finish if$Element->finish;unshift@queue,$Element->children;unshift@queue,$Element->start if$Element->start}else {unshift@queue,$Element->children}}1}sub errstr {shift->{errstr}}sub _error {my$self=shift;$self->{errstr}=shift;my%params=@_;$params{array_ref}? undef : ()}1;
PPI_FIND

$fatpacked{"PPI/Lexer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_LEXER';
  package PPI::Lexer;use strict;use Scalar::Util ();use Params::Util qw{_STRING _INSTANCE};use PPI ();use PPI::Exception ();use PPI::Singletons '%_PARENT';our$VERSION='1.274';our$errstr="";my%ROUND=('if'=>'PPI::Structure::Condition','elsif'=>'PPI::Structure::Condition','unless'=>'PPI::Structure::Condition','while'=>'PPI::Structure::Condition','until'=>'PPI::Structure::Condition','for'=>'PPI::Structure::For','foreach'=>'PPI::Structure::For',);my%RESOLVE=('('=>'_round','['=>'_square','{'=>'_curly',);our$X_TOKENIZER="PPI::Tokenizer";sub X_TOKENIZER {$X_TOKENIZER}sub new {my$class=shift->_clear;bless {Tokenizer=>undef,buffer=>[],delayed=>[],},$class}sub lex_file {my$self=ref $_[0]? shift : shift->new;my$file=_STRING(shift);unless (defined$file){return$self->_error("Did not pass a filename to PPI::Lexer::lex_file")}my$Tokenizer=eval {X_TOKENIZER->new($file)};if (_INSTANCE($@,'PPI::Exception')){return$self->_error($@->message)}elsif ($@){return$self->_error($errstr)}$self->lex_tokenizer($Tokenizer)}sub lex_source {my$self=ref $_[0]? shift : shift->new;my$source=shift;unless (defined$source and not ref$source){return$self->_error("Did not pass a string to PPI::Lexer::lex_source")}my$Tokenizer=eval {X_TOKENIZER->new(\$source)};if (_INSTANCE($@,'PPI::Exception')){return$self->_error($@->message)}elsif ($@){return$self->_error($errstr)}$self->lex_tokenizer($Tokenizer)}sub lex_tokenizer {my$self=ref $_[0]? shift : shift->new;my$Tokenizer=_INSTANCE(shift,'PPI::Tokenizer');return$self->_error("Did not pass a PPI::Tokenizer object to PPI::Lexer::lex_tokenizer")unless$Tokenizer;my$Document=PPI::Document->new;$self->{Tokenizer}=$Tokenizer;if (!eval {$self->_lex_document($Document);1}){undef$Document;if (_INSTANCE($@,'PPI::Exception')){return$self->_error($@->message)}else {return$self->_error($errstr)}}return$Document}sub _lex_document {my ($self,$Document)=@_;my$Token;while (ref($Token=$self->_get_token)){unless ($Token->significant){$self->_add_element($Document,$Token);next}if ($Token->content eq ';'){$self->_add_element($Document,PPI::Statement::Null->new($Token),);next}unless (ref$Token eq 'PPI::Token::Structure'){my$Statement=$self->_statement($Document,$Token)->new($Token);$self->_add_delayed($Document);$self->_add_element($Document,$Statement);$self->_lex_statement($Statement);next}if ($Token->__LEXER__opens){$self->_rollback($Token);my$Statement=PPI::Statement->new;$self->_add_element($Document,$Statement);$self->_lex_statement($Statement);next}if ($Token->__LEXER__closes){$self->_add_element($Document,PPI::Statement::UnmatchedBrace->new($Token));next}PPI::Exception->throw('Lexer reached an illegal state')}unless (defined$Token){my$errstr=$self->{Tokenizer}? $self->{Tokenizer}->errstr : '';$errstr ||= 'Unknown Tokenizer Error';PPI::Exception->throw($errstr)}$self->_add_delayed($Document);my$perl6=$self->{Tokenizer}->{'perl6'};if (@$perl6){my$includes=$Document->find('PPI::Statement::Include::Perl6');for my$include (@$includes){unless (@$perl6){PPI::Exception->throw('Failed to find a perl6 section')}$include->{perl6}=shift @$perl6}}return 1}my%STATEMENT_CLASSES=('BEGIN'=>'PPI::Statement::Scheduled','CHECK'=>'PPI::Statement::Scheduled','UNITCHECK'=>'PPI::Statement::Scheduled','INIT'=>'PPI::Statement::Scheduled','END'=>'PPI::Statement::Scheduled','AUTOLOAD'=>'PPI::Statement::Sub','DESTROY'=>'PPI::Statement::Sub','package'=>'PPI::Statement::Package','no'=>'PPI::Statement::Include','require'=>'PPI::Statement::Include','my'=>'PPI::Statement::Variable','local'=>'PPI::Statement::Variable','our'=>'PPI::Statement::Variable','state'=>'PPI::Statement::Variable','if'=>'PPI::Statement::Compound','unless'=>'PPI::Statement::Compound','for'=>'PPI::Statement::Compound','foreach'=>'PPI::Statement::Compound','while'=>'PPI::Statement::Compound','until'=>'PPI::Statement::Compound','given'=>'PPI::Statement::Given','when'=>'PPI::Statement::When','default'=>'PPI::Statement::When','redo'=>'PPI::Statement::Break','next'=>'PPI::Statement::Break','last'=>'PPI::Statement::Break','return'=>'PPI::Statement::Break','goto'=>'PPI::Statement::Break','__DATA__'=>'PPI::Statement::Data','__END__'=>'PPI::Statement::End',);sub _statement {my ($self,$Parent,$Token)=@_;if ($Parent->isa('PPI::Structure::List')or $Parent->isa('PPI::Structure::Constructor')){if ($Token->isa('PPI::Token::Word')){my$Next;while ($Next=$self->_get_token){unless ($Next->significant){push @{$self->{delayed}},$Next;next}if ($Next->isa('PPI::Token::Operator')and $Next->content eq '=>'){$self->_rollback($Next);return 'PPI::Statement::Expression'}else {last}}$self->_rollback($Next)}}my$is_lexsub=0;my$class=$STATEMENT_CLASSES{$Token->content};if ($class){my$Next;while ($Next=$self->_get_token){if (!$Next->significant){push @{$self->{delayed}},$Next;next}if ($Token->content =~ /^(?:my|our|state)$/ and $Next->isa('PPI::Token::Word')and $Next->content eq 'sub'){$class=undef;$is_lexsub=1;last}last if !$Next->isa('PPI::Token::Operator')or $Next->content ne '=>';$self->_rollback($Next);return 'PPI::Statement'}$self->_rollback($Next)}if ($Parent->isa('PPI::Structure::Subscript')){unless ($class and $class->isa('PPI::Statement::Expression')){return 'PPI::Statement::Expression'}my$Next;while ($Next=$self->_get_token){unless ($Next->significant){push @{$self->{delayed}},$Next;next}if ($Next->content eq '}'){$self->_rollback($Next);return 'PPI::Statement::Expression'}else {$self->_rollback($Next);return$class}}$self->_rollback($Next);return 'PPI::Statement::Expression'}return$class if$class;if ($is_lexsub || $Token->content eq 'sub'){my$Next;while ($Next=$self->_get_token){unless ($Next->significant){push @{$self->{delayed}},$Next;next}my$sclass=$STATEMENT_CLASSES{$Next->content};if ($sclass and $sclass eq 'PPI::Statement::Scheduled'){$self->_rollback($Next);return 'PPI::Statement::Scheduled'}if ($Next->isa('PPI::Token::Word')){$self->_rollback($Next);return 'PPI::Statement::Sub'}$self->_rollback($Next);return 'PPI::Statement'}$self->_rollback($Next);return 'PPI::Statement::Sub'}if ($Token->content eq 'use'){my$Next;while ($Next=$self->_get_token){unless ($Next->significant){push @{$self->{delayed}},$Next;next}if ($Next->isa('PPI::Token::Operator')and $Next->content eq '=>'){$self->_rollback($Next);return 'PPI::Statement'}elsif ($Next->content eq 'v6'){$self->_rollback($Next);return 'PPI::Statement::Include::Perl6'}else {$self->_rollback($Next);return 'PPI::Statement::Include'}}$self->_rollback($Next);return 'PPI::Statement::Include'}if ($Parent->isa('PPI::Structure::Condition')){return 'PPI::Statement::Expression'}if ($Parent->isa('PPI::Structure::List')){return 'PPI::Statement::Expression'}if ($Parent->isa('PPI::Structure::Given')or $Parent->isa('PPI::Structure::When')){return 'PPI::Statement::Expression'}if (_INSTANCE($Token,'PPI::Token::Label')){return 'PPI::Statement::Compound'}return 'PPI::Statement'}sub _lex_statement {my ($self,$Statement)=@_;if ($Statement->isa('PPI::Statement::End')){return$self->_lex_end($Statement)}my$Token;while (ref($Token=$self->_get_token)){unless ($Token->significant){push @{$self->{delayed}},$Token;next}if ($Token->__LEXER__closes or $Token->isa('PPI::Token::Separator')){return$self->_rollback($Token)}unless ($Statement->__LEXER__normal){unless ($self->_continues($Statement,$Token)){return$self->_rollback($Token)}}unless ($Token->isa('PPI::Token::Structure')){$self->_add_element($Statement,$Token);next}if ($Token->content eq ';'){$self->_add_element($Statement,$Token);return 1}my$method=$RESOLVE{$Token->content};my$Structure=$self->$method($Statement)->new($Token);$self->_add_delayed($Statement);$self->_add_element($Statement,$Structure);$self->_lex_structure($Structure)}unless (defined$Token){PPI::Exception->throw}$self->_rollback}sub _lex_end {my ($self,$Statement)=@_;my$Token;while ($Token=$self->_get_token){Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$Token}=$Statement);push @{$Statement->{children}},$Token}unless (defined$Token){PPI::Exception->throw}$self->_rollback}sub _continues {my ($self,$Statement,$Token)=@_;if ($Statement->schildren==1 and $Statement->schild(0)->isa('PPI::Structure::Block')){return ''}return 1 if ref$Statement !~ /\b(?:Scheduled|Sub|Compound|Given|When|Package)$/;my@part=$Statement->schildren;my$LastChild=$part[-1];return!$LastChild->isa('PPI::Structure::Block')if!$Statement->isa('PPI::Statement::Compound');my$type=$Statement->type;if ($type eq 'if'){unless ($LastChild->isa('PPI::Structure::Block')){return 1}my$NextLast=$Statement->schild(-2);if ($NextLast and $NextLast->isa('PPI::Token')and $NextLast->isa('PPI::Token::Word')and $NextLast->content eq 'else'){return ''}if ($Token->isa('PPI::Token::Word')and ($Token->content eq 'else' or $Token->content eq 'elsif')){return 1}return ''}if ($type eq 'label'){if ($Token->isa('PPI::Token::Word')and $Token->content =~ /^(?:while|until|for|foreach)$/){return 1}if ($Token->isa('PPI::Token::Structure')&& $Token->content eq '{'){return 1}return ''}if ($LastChild->isa('PPI::Structure')and $LastChild->braces eq '()'){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '{'}if ($type eq 'for'){if ($LastChild->isa('PPI::Token::Word')and $LastChild->content =~ /^for(?:each)?\z/){if (($Token->isa('PPI::Token::Structure')and $Token->content eq '(')or $Token->isa('PPI::Token::QuoteLike::Words')){return 1}if ($LastChild->isa('PPI::Token::QuoteLike::Words')){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '{'}$type='foreach'}elsif ($LastChild->isa('PPI::Structure::Block')){return ''}elsif ($LastChild->isa('PPI::Token::QuoteLike::Words')){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '{'}}if ($LastChild->isa('PPI::Token::Word')and $LastChild->content eq 'continue'){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '{'}if ($LastChild->isa('PPI::Structure::Block')){if (_INSTANCE($part[-2],'PPI::Token::Word')and $part[-2]->content eq 'continue'){return ''}return$Token->isa('PPI::Token::Word')&& $Token->content eq 'continue'}if ($type eq 'block'){}if ($type eq 'while'){if ($LastChild->isa('PPI::Token::Word')and ($LastChild->content eq 'while' or $LastChild->content eq 'until')){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '('}}if ($type eq 'foreach'){if ($LastChild->isa('PPI::Token::Symbol')){return 1 if$Token->isa('PPI::Token::Structure')&& $Token->content eq '(';return 1 if$Token->isa('PPI::Token::QuoteLike::Words');return ''}if ($LastChild->content eq 'foreach' or $LastChild->content eq 'for'){if ($Token->isa('PPI::Token::Word')and (($STATEMENT_CLASSES{$Token->content }|| '')eq 'PPI::Statement::Variable')){return 1}elsif ($Token->content =~ /^\$/){return 1}elsif ($Token->isa('PPI::Token::Structure')and $Token->content eq '('){return 1}elsif ($Token->isa('PPI::Token::QuoteLike::Words')){return 1}else {return ''}}if (($STATEMENT_CLASSES{$LastChild->content }|| '')eq 'PPI::Statement::Variable'){return$Token->content =~ /^\$/}if ($LastChild->isa('PPI::Token::QuoteLike::Words')){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '{'}}PPI::Exception->throw("Illegal state in '$type' compound statement")}sub _round {my ($self,$Parent)=@_;my$Element=$Parent->schild(-1);if (_INSTANCE($Element,'PPI::Token::Word')){my$rclass=$ROUND{$Element->content};return$rclass if$rclass}if ($Parent->isa('PPI::Statement::Compound')){if ($Parent->type =~ /^for(?:each)?$/){return 'PPI::Structure::For'}}elsif ($Parent->isa('PPI::Statement::Given')){return 'PPI::Structure::Given'}elsif ($Parent->isa('PPI::Statement::When')){return 'PPI::Structure::When'}if (_INSTANCE($Element,'PPI::Token::Operator')and $Element->content eq '->'){$Element->{_dereference}=1}'PPI::Structure::List'}sub _square {my ($self,$Parent)=@_;my$Element=$Parent->schild(-1);if ($Element){if ($Element->isa('PPI::Token::Operator')and $Element->content eq '->'){$Element->{_dereference}=1;return 'PPI::Structure::Subscript'}if ($Element->isa('PPI::Structure::Subscript')){return 'PPI::Structure::Subscript'}if ($Element->isa('PPI::Token::Symbol')and $Element->content =~ /^(?:\$|\@)/){return 'PPI::Structure::Subscript'}if ($Element->isa('PPI::Token::Cast')and $Element->content =~ /^(?:\@|\%)/){my$prior=$Parent->schild(-2);if ($prior and $prior->isa('PPI::Token::Operator')and $prior->content eq '->'){return 'PPI::Structure::Subscript'}}}'PPI::Structure::Constructor'}my%CURLY_CLASSES=('sub'=>'PPI::Structure::Block','grep'=>'PPI::Structure::Block','map'=>'PPI::Structure::Block','sort'=>'PPI::Structure::Block','do'=>'PPI::Structure::Block','scalar'=>'PPI::Structure::Constructor','='=>'PPI::Structure::Constructor','||='=>'PPI::Structure::Constructor','&&='=>'PPI::Structure::Constructor','//='=>'PPI::Structure::Constructor','||'=>'PPI::Structure::Constructor','&&'=>'PPI::Structure::Constructor','//'=>'PPI::Structure::Constructor','?'=>'PPI::Structure::Constructor',':'=>'PPI::Structure::Constructor',','=>'PPI::Structure::Constructor','=>'=>'PPI::Structure::Constructor','+'=>'PPI::Structure::Constructor','return'=>'PPI::Structure::Constructor','bless'=>'PPI::Structure::Constructor',);my@CURLY_LOOKAHEAD_CLASSES=({},{';'=>'PPI::Structure::Block','}'=>'PPI::Structure::Constructor',},{'=>'=>'PPI::Structure::Constructor',},);sub _curly {my ($self,$Parent)=@_;my$Element=$Parent->schild(-1);my$content=$Element ? $Element->content : '';if ($Element){if ($content eq '->' and $Element->isa('PPI::Token::Operator')){$Element->{_dereference}=1;return 'PPI::Structure::Subscript'}if ($Element->isa('PPI::Structure::Subscript')){return 'PPI::Structure::Subscript'}if ($content =~ /^(?:\$|\@)/ and $Element->isa('PPI::Token::Symbol')){return 'PPI::Structure::Subscript'}if ($Element->isa('PPI::Token::Cast')and $Element->content =~ /^(?:\@|\%|\*)/){my$prior=$Parent->schild(-2);if ($prior and $prior->isa('PPI::Token::Operator')and $prior->content eq '->'){return 'PPI::Structure::Subscript'}}if ($Element->isa('PPI::Structure::Block')){if (my$prior=$Parent->schild(-2)){my$prior_content=$prior->content();$prior->isa('PPI::Token::Cast')and ($prior_content eq '@' || $prior_content eq '$')and return 'PPI::Structure::Subscript'}}return 'PPI::Structure::Block' if$Parent->isa('PPI::Statement::Sub');return 'PPI::Structure::Block' if$Parent->isa('PPI::Statement::Package');if ($CURLY_CLASSES{$content}){return$CURLY_CLASSES{$content}}}if ($Parent->isa('PPI::Statement::Compound')){return 'PPI::Structure::Block'}if ($Parent->isa('PPI::Statement::Include')){if ($Parent->schildren==2 || $Parent->schildren==3 && $Parent->schild(2)->isa('PPI::Token::Number')){return 'PPI::Structure::Constructor'}}return 'PPI::Structure::Block' if$Element;if ($Parent->isa('PPI::Statement')and _INSTANCE($Parent->parent,'PPI::Structure::List')){my$function=$Parent->parent->parent->schild(-2);return 'PPI::Structure::Block' if$function and $function->content =~ /^(?:map|grep|sort|eval|do)$/;return 'PPI::Structure::Constructor' if not $function or $function->content !~ /^(?:print|say)$/}my$Next;my$position=0;my@delayed;while ($Next=$self->_get_token){unless ($Next->significant){push@delayed,$Next;next}if (++$position >= @CURLY_LOOKAHEAD_CLASSES){$self->_buffer(splice(@delayed),$Next);last}elsif (my$class=$CURLY_LOOKAHEAD_CLASSES[$position]{$Next->content}){$self->_buffer(splice(@delayed),$Next);return$class}push@delayed,$Next}$self->_buffer(splice(@delayed));if (ref$Parent eq 'PPI::Statement'){bless$Parent,'PPI::Statement::Compound'}return 'PPI::Structure::Block'}sub _lex_structure {my ($self,$Structure)=@_;my$Token;while (ref($Token=$self->_get_token)){unless ($Token->significant){push @{$self->{delayed}},$Token;next}unless ($Token->isa('PPI::Token::Structure')){$self->_add_delayed($Structure);my$Statement=$self->_statement($Structure,$Token)->new($Token);$self->_add_element($Structure,$Statement);$self->_lex_statement($Statement);next}if ($Token->__LEXER__opens){$self->_rollback($Token);my$Statement=PPI::Statement->new;$self->_add_element($Structure,$Statement);$self->_lex_statement($Statement);next}if ($Token->__LEXER__closes){if ($Token->content eq $Structure->start->__LEXER__opposite){$self->_add_delayed($Structure);$Structure->{finish}=$Token;Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$Token}=$Structure);if ($Structure->isa('PPI::Structure::For')){if (2 > scalar grep {$_->isa('PPI::Statement')}$Structure->children){bless($Structure,'PPI::Structure::List')}}return 1}return$self->_rollback($Token)}$self->_add_element($Structure,PPI::Statement::Null->new($Token),)}unless (defined$Token){PPI::Exception->throw}$self->_add_delayed($Structure)}sub _get_token {shift(@{$_[0]->{buffer}})or $_[0]->{Tokenizer}->get_token}sub _add_element {my ($self,$Parent,$Element)=@_;if (ref$Parent eq 'PPI::Statement' and my$first=$Parent->schild(0)){if ($first->isa('PPI::Token::Label')and!(my$second=$Parent->schild(1))){my$new_class=$STATEMENT_CLASSES{$second->content};bless$Parent,$new_class if$new_class}}for my$el (@{$self->{delayed}}){Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$el}=$Parent)}Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$Element}=$Parent);push @{$Parent->{children}},@{$self->{delayed}},$Element;$self->{delayed}=[]}sub _add_delayed {my ($self,$Parent)=@_;for my$el (@{$self->{delayed}}){Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$el}=$Parent)}push @{$Parent->{children}},@{$self->{delayed}};$self->{delayed}=[]}sub _rollback {my$self=shift;if (@_){unshift @{$self->{buffer}},splice @_}if (@{$self->{delayed}}){unshift @{$self->{buffer}},splice @{$self->{delayed}}}1}sub _buffer {my$self=shift;if (@_){unshift @{$self->{buffer}},splice @_}1}sub _error {$errstr=$_[1];undef}sub _clear {$errstr='';$_[0]}sub errstr {$errstr}1;
PPI_LEXER

$fatpacked{"PPI/Node.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_NODE';
  package PPI::Node;use strict;use Carp ();use Scalar::Util qw{refaddr};use List::Util ();use Params::Util qw{_INSTANCE _CLASS _CODELIKE _NUMBER};use PPI::Element ();use PPI::Singletons '%_PARENT';our$VERSION='1.274';our@ISA="PPI::Element";sub new {my$class=ref $_[0]|| $_[0];bless {children=>[]},$class}sub scope() {''}sub add_element {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;$_PARENT{refaddr$Element}and return undef;push @{$self->{children}},$Element;Scalar::Util::weaken($_PARENT{refaddr$Element}=$self);1}sub __add_element {Scalar::Util::weaken($_PARENT{refaddr $_[1]}=$_[0]);push @{$_[0]->{children}},$_[1]}sub elements {if (wantarray){return @{$_[0]->{children}}}else {return scalar @{$_[0]->{children}}}}sub first_element {$_[0]->{children}->[0]}sub last_element {$_[0]->{children}->[-1]}sub children {wantarray ? @{$_[0]->{children}}: scalar @{$_[0]->{children}}}sub schildren {return grep {$_->significant}@{$_[0]->{children}}if wantarray;my$count=0;for (@{$_[0]->{children}}){$count++ if $_->significant}return$count}sub child {my ($self,$index)=@_;PPI::Exception->throw("method child() needs an index")if not defined _NUMBER$index;$self->{children}->[$index]}sub schild {my$self=shift;my$idx=0 + shift;my$el=$self->{children};if ($idx < 0){my$cursor=0;while (exists$el->[--$cursor]){return$el->[$cursor]if$el->[$cursor]->significant and ++$idx >= 0}}else {my$cursor=-1;while (exists$el->[++$cursor]){return$el->[$cursor]if$el->[$cursor]->significant and --$idx < 0}}undef}sub contains {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;while ($Element=$Element->parent){return 1 if refaddr($self)==refaddr($Element)}''}sub find {my$self=shift;my$wanted=$self->_wanted(shift)or return undef;my@found;my@queue=@{$self->{children}};my$ok=eval {while (@queue){my$Element=shift@queue;my$rv=&$wanted($self,$Element);push@found,$Element if$rv;next unless defined$rv;next unless$Element->isa('PPI::Node');if ($Element->isa('PPI::Structure')){unshift@queue,$Element->finish if$Element->finish;unshift@queue,@{$Element->{children}};unshift@queue,$Element->start if$Element->start}else {unshift@queue,@{$Element->{children}}}}1};if (!$ok){return undef}@found ? \@found : ''}sub find_first {my$self=shift;my$wanted=$self->_wanted(shift)or return undef;my@queue=@{$self->{children}};my$rv;my$ok=eval {while (@queue){my$Element=shift@queue;my$element_rv=$wanted->($self,$Element);if ($element_rv){$rv=$Element;last}next if!defined$element_rv;next if!$Element->isa('PPI::Node');if ($Element->isa('PPI::Structure')){unshift@queue,$Element->finish if defined($Element->finish);unshift@queue,@{$Element->{children}};unshift@queue,$Element->start if defined($Element->start)}else {unshift@queue,@{$Element->{children}}}}1};if (!$ok){return undef}$rv or ''}sub find_any {my$self=shift;my$rv=$self->find_first(@_);$rv ? 1 : $rv}sub remove_child {my$self=shift;my$child=_INSTANCE(shift,'PPI::Element')or return undef;my$key=refaddr$child;my$p=List::Util::first {refaddr$self->{children}[$_]==$key}0..$#{$self->{children}};return undef unless defined$p;splice(@{$self->{children}},$p,1);delete$_PARENT{refaddr$child};$child}sub prune {my$self=shift;my$wanted=$self->_wanted(shift)or return undef;my$pruned=0;my@queue=$self->children;my$ok=eval {while (my$element=shift@queue){my$rv=&$wanted($self,$element);if ($rv){$element->delete or return undef;$pruned++;next}next unless defined$rv;if (_INSTANCE($element,'PPI::Node')){unshift@queue,$element->children}}1};if (!$ok){return undef}$pruned}sub _wanted {my$either=shift;my$it=defined($_[0])? shift : do {Carp::carp('Undefined value passed as search condition')if $^W;return undef};return$it if _CODELIKE($it);if (ref$it){Carp::carp('Illegal non-CODE reference passed as search condition')if $^W;return undef}$it="PPI::$it" unless substr($it,0,5)eq 'PPI::';unless (_CLASS($it)and $it->isa('PPI::Element')){Carp::carp("Cannot create search condition for '$it': Not a PPI::Element")if $^W;return undef}my$wanted_class="\n\treturn '' unless \$_[1]->isa('$it');";my$wanted_content='';if (defined $_[0]){my$content=shift;if (ref$content eq 'Regexp'){$content="$content"}elsif (ref$content){Carp::carp("Cannot create search condition for '$it': Not a PPI::Element")if $^W;return undef}else {$content=quotemeta$content}$wanted_content .= "\n\treturn '' unless defined \$_[1]->{content};";$wanted_content .= "\n\treturn '' unless \$_[1]->{content} =~ /$content/;"}my$code="sub {" .$wanted_class .$wanted_content ."\n\t1;" ."\n}";$code=eval$code;(ref$code eq 'CODE')? $code : undef}sub tokens {map {$_->tokens}@{$_[0]->{children}}}sub content {join '',map {$_->content}@{$_[0]->{children}}}sub clone {my$self=shift;my$clone=$self->SUPER::clone;$clone->__link_children;$clone}sub location {my$self=shift;my$first=$self->{children}->[0]or return undef;$first->location}sub DESTROY {local $_;if ($_[0]->{children}){my@queue=$_[0];while (defined($_=shift@queue)){unshift@queue,@{delete $_->{children}}if $_->{children};%$_=()}}delete$_PARENT{refaddr $_[0]}}sub __position {my$key=refaddr $_[1];List::Util::first {refaddr $_[0]{children}[$_]==$key}0..$#{$_[0]{children}}}sub __insert_before_child {my$self=shift;my$key=refaddr shift;my$p=List::Util::first {refaddr$self->{children}[$_]==$key}0..$#{$self->{children}};for (@_){Scalar::Util::weaken($_PARENT{refaddr $_}=$self)}splice(@{$self->{children}},$p,0,@_);1}sub __insert_after_child {my$self=shift;my$key=refaddr shift;my$p=List::Util::first {refaddr$self->{children}[$_]==$key}0..$#{$self->{children}};for (@_){Scalar::Util::weaken($_PARENT{refaddr $_}=$self)}splice(@{$self->{children}},$p + 1,0,@_);1}sub __replace_child {my$self=shift;my$key=refaddr shift;my$p=List::Util::first {refaddr$self->{children}[$_]==$key}0..$#{$self->{children}};for (@_){Scalar::Util::weaken($_PARENT{refaddr $_}=$self)}splice(@{$self->{children}},$p,1,@_);1}sub __link_children {my$self=shift;my@queue=($self);while (my$Node=shift@queue){for my$Element (@{$Node->{children}}){Scalar::Util::weaken($_PARENT{refaddr($Element)}=$Node);unshift@queue,$Element if$Element->isa('PPI::Node')}next unless$Node->isa('PPI::Structure');Scalar::Util::weaken($_PARENT{refaddr($Node->start)}=$Node)if$Node->start;Scalar::Util::weaken($_PARENT{refaddr($Node->finish)}=$Node)if$Node->finish}1}1;
PPI_NODE

$fatpacked{"PPI/Normal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_NORMAL';
  package PPI::Normal;use strict;use Carp ();use List::Util 1.33 ();use PPI::Util '_Document';use PPI::Document::Normalized ();use PPI::Normal::Standard ();use PPI::Singletons '%LAYER';our$VERSION='1.274';PPI::Normal::Standard->import;sub register {my$class=shift;while (@_){my$function=shift;SCOPE: {no strict 'refs';defined$function and defined &{"$function"}or Carp::croak("Bad function name provided to PPI::Normal")}if (List::Util::any {$_ eq $function}map @{$_},values%LAYER){return 1}my$layer=shift;defined$layer and $layer =~ /^(?:1|2)$/ or Carp::croak("Bad layer provided to PPI::Normal");push @{$LAYER{$layer}},$function}1}sub new {my$class=shift;my$layer=@_ ? (defined $_[0]and!ref $_[0]and $_[0]=~ /^[12]$/)? shift : return undef : 1;my$object=bless {layer=>$layer,},$class;$object}sub layer {$_[0]->{layer}}sub process {my$self=ref $_[0]? shift : shift->new;return undef if$self->{Document};$self->{Document}=_Document(shift)or return undef;my@functions=map {@{$LAYER{$_}}}(1 .. $self->layer);for my$function (@functions){no strict 'refs';&{"$function"}($self->{Document})}my$Normalized=PPI::Document::Normalized->new(Document=>$self->{Document},version=>__PACKAGE__->VERSION,functions=>\@functions,)or return undef;delete$self->{Document};return$Normalized}1;
PPI_NORMAL

$fatpacked{"PPI/Normal/Standard.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_NORMAL_STANDARD';
  package PPI::Normal::Standard;use strict;our$VERSION='1.274';my@METHODS=(remove_insignificant_elements=>1,remove_useless_attributes=>1,remove_useless_pragma=>2,remove_statement_separator=>2,remove_useless_return=>2,);sub import {PPI::Normal->register(map {/\D/ ? "PPI::Normal::Standard::$_" : $_}@METHODS)or die "Failed to register PPI::Normal::Standard transforms"}sub remove_insignificant_elements {my$Document=shift;$Document->prune(sub {!$_[1]->significant})}sub remove_useless_attributes {my$Document=shift;delete$Document->{tab_width}}my$remove_pragma=map {$_=>1}qw{strict warnings diagnostics less};sub remove_useless_pragma {my$Document=shift;$Document->prune(sub {return '' unless $_[1]->isa('PPI::Statement::Include');return 1 if $_[1]->version;return 1 if$remove_pragma->{$_[1]->pragma};''})}sub remove_statement_separator {my$Document=shift;$Document->prune(sub {$_[1]->isa('PPI::Token::Structure')or return '';$_[1]->content eq ';' or return '';my$stmt=$_[1]->parent or return '';$stmt->isa('PPI::Statement')or return '';$_[1]->next_sibling and return '';1})}sub remove_useless_return {my$Document=shift;$Document->prune(sub {$_[1]->isa('PPI::Token::Word')or return '';$_[1]->content eq 'return' or return '';my$stmt=$_[1]->parent or return '';$stmt->isa('PPI::Statement::Break')or return '';$stmt->children==2 or return '';$stmt->next_sibling and return '';my$block=$stmt->parent or return '';$block->isa('PPI::Structure::Block')or return '';1})}1;
PPI_NORMAL_STANDARD

$fatpacked{"PPI/Singletons.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_SINGLETONS';
  package PPI::Singletons;use strict;use Exporter ();our$VERSION='1.274';our@ISA='Exporter';our@EXPORT_OK=qw{%_PARENT %OPERATOR %MAGIC %LAYER $CURLY_SYMBOL %QUOTELIKE %KEYWORDS};our%_PARENT;our%OPERATOR=map {$_=>1}(qw{-> ++ -- ** ! ~ + - =~ !~ * / % x . << >> < > <= >= lt gt le ge == != <=> eq ne cmp ~~ & | ^ && || // .. ... ? : = **= += -= .= *= /= %= x= &= |= ^= <<= >>= &&= ||= //= => <> <<>> and or xor not},',');our%MAGIC=map {$_=>1}qw{$1 $2 $3 $4 $5 $6 $7 $8 $9 $_ $& $` $' $+ @+ %+ $* $. $/ $| $\\ $" $; $% $= $- @- %- $) $~ $^ $: $? $! %! $@ $$ $< $> $( $0 $[ $] @_ @* $^L $^A $^E $^C $^D $^F $^H $^I $^M $^N $^O $^P $^R $^S $^T $^V $^W $^X %^H $::|},'$}','$,','$#','$#+','$#-';our%LAYER=(1=>[],2=>[]);our$CURLY_SYMBOL=qr{\G\^[[:upper:]_]\w+\}};our%QUOTELIKE=('q'=>'Quote::Literal','qq'=>'Quote::Interpolate','qx'=>'QuoteLike::Command','qw'=>'QuoteLike::Words','qr'=>'QuoteLike::Regexp','m'=>'Regexp::Match','s'=>'Regexp::Substitute','tr'=>'Regexp::Transliterate','y'=>'Regexp::Transliterate',);our%KEYWORDS=map {$_=>1}qw{abs accept alarm and atan2 bind binmode bless break caller chdir chmod chomp chop chown chr chroot close closedir cmp connect continue cos crypt dbmclose dbmopen default defined delete die do dump each else elsif endgrent endhostent endnetent endprotoent endpwent endservent eof eq eval evalbytes exec exists exit exp fc fcntl fileno flock for foreach fork format formline ge getc getgrent getgrgid getgrnam gethostbyaddr gethostbyname gethostent getlogin getnetbyaddr getnetbyname getnetent getpeername getpgrp getppid getpriority getprotobyname getprotobynumber getprotoent getpwent getpwnam getpwuid getservbyname getservbyport getservent getsockname getsockopt given glob gmtime goto grep gt hex if index int ioctl join keys kill last lc lcfirst le length link listen local localtime lock log lstat lt m map mkdir msgctl msgget msgrcv msgsnd my ne next no not oct open opendir or ord our pack package pipe pop pos print printf prototype push q qq qr quotemeta qw qx rand read readdir readline readlink readpipe recv redo ref rename require reset return reverse rewinddir rindex rmdir s say scalar seek seekdir select semctl semget semop send setgrent sethostent setnetent setpgrp setpriority setprotoent setpwent setservent setsockopt shift shmctl shmget shmread shmwrite shutdown sin sleep socket socketpair sort splice split sprintf sqrt srand stat state study sub substr symlink syscall sysopen sysread sysseek system syswrite tell telldir tie tied time times tr truncate uc ucfirst umask undef unless unlink unpack unshift untie until use utime values vec wait waitpid wantarray warn when while write x xor y};1;
PPI_SINGLETONS

$fatpacked{"PPI/Statement.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT';
  package PPI::Statement;use strict;use Scalar::Util ();use Params::Util qw{_INSTANCE};use PPI::Node ();use PPI::Exception ();use PPI::Singletons '%_PARENT';our$VERSION='1.274';our@ISA="PPI::Node";use PPI::Statement::Break ();use PPI::Statement::Compound ();use PPI::Statement::Data ();use PPI::Statement::End ();use PPI::Statement::Expression ();use PPI::Statement::Include ();use PPI::Statement::Null ();use PPI::Statement::Package ();use PPI::Statement::Scheduled ();use PPI::Statement::Sub ();use PPI::Statement::Given ();use PPI::Statement::UnmatchedBrace ();use PPI::Statement::Unknown ();use PPI::Statement::Variable ();use PPI::Statement::When ();sub __LEXER__normal() {1}sub new {my$class=shift;if (ref$class){PPI::Exception->throw}my$self=bless {children=>[],},$class;my$token=shift;if (_INSTANCE($token,'PPI::Token')){Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$token}=$self);push @{$self->{children}},$token}$self}sub label {my$first=shift->schild(1)or return '';$first->isa('PPI::Token::Label')? substr($first,0,length($first)- 1): ''}sub specialized {__PACKAGE__ ne ref $_[0]}sub stable {die "The ->stable method has not yet been implemented"}sub _complete {my$self=shift;my$semi=$self->schild(-1);return!!(defined$semi and $semi->isa('PPI::Token::Structure')and $semi->content eq ';')}sub insert_before {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Statement')){return$self->__insert_before($Element)}elsif ($Element->isa('PPI::Token')and!$Element->significant){return$self->__insert_before($Element)}''}sub insert_after {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Statement')){return$self->__insert_after($Element)}elsif ($Element->isa('PPI::Token')and!$Element->significant){return$self->__insert_after($Element)}''}1;
PPI_STATEMENT

$fatpacked{"PPI/Statement/Break.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_BREAK';
  package PPI::Statement::Break;use strict;use PPI::Statement ();our$VERSION='1.274';our@ISA="PPI::Statement";1;
PPI_STATEMENT_BREAK

$fatpacked{"PPI/Statement/Compound.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_COMPOUND';
  package PPI::Statement::Compound;use strict;use PPI::Statement ();our$VERSION='1.274';our@ISA="PPI::Statement";my%TYPES=('if'=>'if','unless'=>'if','while'=>'while','until'=>'while','for'=>'for','foreach'=>'foreach',);sub __LEXER__normal() {''}sub type {my$self=shift;my$p=0;my$Element=$self->schild($p)or return undef;if ($Element->isa('PPI::Token::Label')){$Element=$self->schild(++$p)or return 'label'}my$content=$Element->content;if ($content =~ /^for(?:each)?\z/){$Element=$self->schild(++$p)or return$content;if ($Element->isa('PPI::Token')){return 'foreach' if$Element->content =~ /^my|our|state\z/;return 'foreach' if$Element->isa('PPI::Token::Symbol');return 'foreach' if$Element->isa('PPI::Token::QuoteLike::Words')}if ($Element->isa('PPI::Structure::List')){return 'foreach'}return 'for'}return$TYPES{$content}if$Element->isa('PPI::Token::Word');return 'continue' if$Element->isa('PPI::Structure::Block');undef}sub scope() {1}sub _complete {my$self=shift;my$type=$self->type or die "Illegal compound statement type";if ($type eq 'if'){my$child=$self->schild(-1)or return '';$child->isa('PPI::Structure')or return '';$child->braces eq '{}' or return '';$child->_complete or return ''}elsif ($type eq 'while'){die "CODE INCOMPLETE"}else {die "CODE INCOMPLETE"}}1;
PPI_STATEMENT_COMPOUND

$fatpacked{"PPI/Statement/Data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_DATA';
  package PPI::Statement::Data;use strict;use PPI::Statement ();our$VERSION='1.274';our@ISA="PPI::Statement";sub _complete () {''}1;
PPI_STATEMENT_DATA

$fatpacked{"PPI/Statement/End.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_END';
  package PPI::Statement::End;use strict;use PPI::Statement ();our$VERSION='1.274';our@ISA="PPI::Statement";sub _complete () {1}1;
PPI_STATEMENT_END

$fatpacked{"PPI/Statement/Expression.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_EXPRESSION';
  package PPI::Statement::Expression;use strict;use PPI::Statement ();our$VERSION='1.274';our@ISA="PPI::Statement";1;
PPI_STATEMENT_EXPRESSION

$fatpacked{"PPI/Statement/Given.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_GIVEN';
  package PPI::Statement::Given;use strict;use PPI::Statement ();our$VERSION='1.274';our@ISA="PPI::Statement";sub __LEXER__normal() {''}sub _complete {my$child=$_[0]->schild(-1);return!!(defined$child and $child->isa('PPI::Structure::Block')and $child->complete)}sub scope() {1}1;
PPI_STATEMENT_GIVEN

$fatpacked{"PPI/Statement/Include.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_INCLUDE';
  package PPI::Statement::Include;use strict;use PPI::Statement ();use PPI::Statement::Include::Perl6 ();our$VERSION='1.274';our@ISA="PPI::Statement";sub type {my$self=shift;my$keyword=$self->schild(0)or return undef;$keyword->isa('PPI::Token::Word')and $keyword->content}sub module {my$self=shift;my$module=$self->schild(1)or return undef;$module->isa('PPI::Token::Word')and $module->content}sub module_version {my$self=shift;my$argument=$self->schild(3);if ($argument and $argument->isa('PPI::Token::Operator')){return undef}my$version=$self->schild(2)or return undef;return undef unless$version->isa('PPI::Token::Number');return$version}sub pragma {my$self=shift;my$module=$self->module or return '';$module =~ /^[a-z][a-z\d]*$/ ? $module : ''}sub version {my$self=shift;my$version=$self->schild(1)or return undef;$version->isa('PPI::Token::Number')? $version->content : ''}sub version_literal {my$self=shift;my$version=$self->schild(1)or return undef;$version->isa('PPI::Token::Number')? $version->literal : ''}sub arguments {my$self=shift;my@args=$self->schildren;shift@args;if ($args[-1]->isa('PPI::Token::Structure')and $args[-1]->content eq ';'){pop@args}shift@args;return unless@args;if ($args[0]->isa('PPI::Token::Number')){my$after=$args[1]or return;$after->isa('PPI::Token::Operator')or shift@args}return@args}1;
PPI_STATEMENT_INCLUDE

$fatpacked{"PPI/Statement/Include/Perl6.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_INCLUDE_PERL6';
  package PPI::Statement::Include::Perl6;use strict;use PPI::Statement::Include ();our$VERSION='1.274';our@ISA="PPI::Statement::Include";sub perl6 {$_[0]->{perl6}}1;
PPI_STATEMENT_INCLUDE_PERL6

$fatpacked{"PPI/Statement/Null.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_NULL';
  package PPI::Statement::Null;use strict;use PPI::Statement ();our$VERSION='1.274';our@ISA="PPI::Statement";sub significant() {''}1;
PPI_STATEMENT_NULL

$fatpacked{"PPI/Statement/Package.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_PACKAGE';
  package PPI::Statement::Package;use strict;use PPI::Statement ();our$VERSION='1.274';our@ISA="PPI::Statement";sub __LEXER__normal() {''}sub namespace {my$self=shift;my$namespace=$self->schild(1)or return '';$namespace->isa('PPI::Token::Word')? $namespace->content : ''}sub version {my$self=shift;my$version=$self->schild(2)or return '';$version->isa('PPI::Token::Structure')? '' : $version->content}sub file_scoped {my$self=shift;my ($Parent,$Document)=($self->parent,$self->top);$Parent and $Document and $Parent==$Document and $Document->isa('PPI::Document')and!$Document->isa('PPI::Document::Fragment')}1;
PPI_STATEMENT_PACKAGE

$fatpacked{"PPI/Statement/Scheduled.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_SCHEDULED';
  package PPI::Statement::Scheduled;use strict;use PPI::Statement::Sub ();our$VERSION='1.274';our@ISA="PPI::Statement::Sub";sub __LEXER__normal() {''}sub _complete {my$child=$_[0]->schild(-1);return!!(defined$child and $child->isa('PPI::Structure::Block')and $child->complete)}sub type {my$self=shift;my@children=$self->schildren or return undef;$children[0]->content eq 'sub' ? $children[1]->content : $children[0]->content}sub name {shift->type(@_)}1;
PPI_STATEMENT_SCHEDULED

$fatpacked{"PPI/Statement/Sub.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_SUB';
  package PPI::Statement::Sub;use strict;use List::Util ();use Params::Util qw{_INSTANCE};use PPI::Statement ();our$VERSION='1.274';our@ISA="PPI::Statement";sub __LEXER__normal() {''}sub _complete {my$child=$_[0]->schild(-1);return!!(defined$child and $child->isa('PPI::Structure::Block')and $child->complete)}sub name {my ($self)=@_;my$token=$self->schild(defined$self->type ? 2 : 1);return$token->content if defined$token and $token->isa('PPI::Token::Word');$token=$self->schild(0);return$token->content if defined$token and $token->isa('PPI::Token::Word');return ''}sub prototype {my$self=shift;my$Prototype=List::Util::first {_INSTANCE($_,'PPI::Token::Prototype')}$self->children;defined($Prototype)? $Prototype->prototype : undef}sub block {my$self=shift;my$lastchild=$self->schild(-1)or return '';$lastchild->isa('PPI::Structure::Block')and $lastchild}sub forward {!shift->block}sub reserved {my$self=shift;my$name=$self->name or return '';$name eq uc$name}sub type {my$self=shift;my@schild=grep {$_->significant}$self->children;shift@schild if _INSTANCE($schild[0],'PPI::Token::Label');(_INSTANCE($schild[0],'PPI::Token::Word')and $schild[0]->content =~ /^(my|our|state)$/)? $schild[0]->content : undef}1;
PPI_STATEMENT_SUB

$fatpacked{"PPI/Statement/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_UNKNOWN';
  package PPI::Statement::Unknown;use strict;use PPI::Statement ();our$VERSION='1.274';our@ISA="PPI::Statement";sub _complete () {1}1;
PPI_STATEMENT_UNKNOWN

$fatpacked{"PPI/Statement/UnmatchedBrace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_UNMATCHEDBRACE';
  package PPI::Statement::UnmatchedBrace;use strict;use PPI::Statement ();our$VERSION='1.274';our@ISA="PPI::Statement";sub _complete () {1}1;
PPI_STATEMENT_UNMATCHEDBRACE

$fatpacked{"PPI/Statement/Variable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_VARIABLE';
  package PPI::Statement::Variable;use strict;use Params::Util qw{_INSTANCE};use PPI::Statement::Expression ();our$VERSION='1.274';our@ISA="PPI::Statement::Expression";sub type {my$self=shift;my@schild=grep {$_->significant}$self->children;shift@schild if _INSTANCE($schild[0],'PPI::Token::Label');(_INSTANCE($schild[0],'PPI::Token::Word')and $schild[0]->content =~ /^(my|local|our|state)$/)? $schild[0]->content : undef}sub variables {map {$_->canonical}$_[0]->symbols}sub symbols {my$self=shift;my@schild=grep {$_->significant}$self->children;shift@schild if _INSTANCE($schild[0],'PPI::Token::Label');if (_INSTANCE($schild[1],'PPI::Token::Symbol')){return$schild[1]}if (_INSTANCE($schild[1],'PPI::Structure::List')){my$Expression=$schild[1]->schild(0);$Expression and $Expression->isa('PPI::Statement::Expression')or return ();if ($self->type eq 'my' or $self->type eq 'our' or $self->type eq 'state'){return grep {$_->isa('PPI::Token::Symbol')}$Expression->schildren}return grep {$self->_local_variable($_)}grep {$_->isa('PPI::Token::Symbol')}$Expression->schildren}()}sub _local_variable {my ($self,$el)=@_;my$n=$el->snext_sibling or return 1;my$p=$el->sprevious_sibling;if (!$p or $p eq ','){return 1 if$n eq ',';return 1 if$n eq '='}return ''}1;
PPI_STATEMENT_VARIABLE

$fatpacked{"PPI/Statement/When.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_WHEN';
  package PPI::Statement::When;use strict;use PPI::Statement ();our$VERSION='1.274';our@ISA="PPI::Statement";sub __LEXER__normal() {''}sub _complete {my$child=$_[0]->schild(-1);return!!(defined$child and $child->isa('PPI::Structure::Block')and $child->complete)}sub scope() {1}1;
PPI_STATEMENT_WHEN

$fatpacked{"PPI/Structure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE';
  package PPI::Structure;use strict;use Scalar::Util ();use Params::Util qw{_INSTANCE};use PPI::Node ();use PPI::Exception ();use PPI::Singletons '%_PARENT';our$VERSION='1.274';our@ISA="PPI::Node";use PPI::Structure::Block ();use PPI::Structure::Condition ();use PPI::Structure::Constructor ();use PPI::Structure::For ();use PPI::Structure::Given ();use PPI::Structure::List ();use PPI::Structure::Subscript ();use PPI::Structure::Unknown ();use PPI::Structure::When ();sub new {my$class=shift;my$Token=PPI::Token::__LEXER__opens($_[0])? shift : return undef;my$self=bless {children=>[],start=>$Token,},$class;Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$Token}=$self);$self}sub start {$_[0]->{start}}sub finish {$_[0]->{finish}}sub braces {my$self=$_[0]->{start}? shift : return undef;return {'['=>'[]','('=>'()','{'=>'{}',}->{$self->{start}->{content}}}sub complete {!!($_[0]->{start}and $_[0]->{finish})}sub elements {my$self=shift;if (wantarray){return ($self->{start}|| (),@{$self->{children}},$self->{finish}|| ())}else {return scalar(@{$self->{children}})+ ($self->{start}? 1 : 0)+ ($self->{finish}? 1 : 0)}}sub first_element {$_[0]->{start}or $_[0]->{children}->[0]or $_[0]->{finish}}sub last_element {$_[0]->{finish}or $_[0]->{children}->[-1]or $_[0]->{start}}sub location {my$self=shift;my$first=$self->first_element or return undef;$first->location}sub tokens {my$self=shift;my@tokens=($self->{start}|| (),$self->SUPER::tokens(@_),$self->{finish}|| (),);@tokens}sub content {my$self=shift;my$content=$self->{start}? $self->{start}->content : '';for my$child (@{$self->{children}}){$content .= $child->content}$content .= $self->{finish}->content if$self->{finish};$content}sub _complete {!!(defined $_[0]->{finish})}sub insert_before {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Structure')){return$self->__insert_before($Element)}elsif ($Element->isa('PPI::Token')){return$self->__insert_before($Element)}''}sub insert_after {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Structure')){return$self->__insert_after($Element)}elsif ($Element->isa('PPI::Token')){return$self->__insert_after($Element)}''}1;
PPI_STRUCTURE

$fatpacked{"PPI/Structure/Block.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_BLOCK';
  package PPI::Structure::Block;use strict;use PPI::Structure ();our$VERSION='1.274';our@ISA="PPI::Structure";sub scope() {1}1;
PPI_STRUCTURE_BLOCK

$fatpacked{"PPI/Structure/Condition.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_CONDITION';
  package PPI::Structure::Condition;use strict;use PPI::Structure ();our$VERSION='1.274';our@ISA="PPI::Structure";1;
PPI_STRUCTURE_CONDITION

$fatpacked{"PPI/Structure/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_CONSTRUCTOR';
  package PPI::Structure::Constructor;use strict;use PPI::Structure ();our$VERSION='1.274';our@ISA="PPI::Structure";1;
PPI_STRUCTURE_CONSTRUCTOR

$fatpacked{"PPI/Structure/For.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_FOR';
  package PPI::Structure::For;use strict;use PPI::Structure ();our$VERSION='1.274';our@ISA="PPI::Structure";my$has_warned=0;sub isa {if ($_[1]and $_[1]eq 'PPI::Structure::ForLoop'){unless ($has_warned){warn("PPI::Structure::ForLoop has been deprecated");$has_warned=1}return 1}return shift->SUPER::isa(@_)}1;
PPI_STRUCTURE_FOR

$fatpacked{"PPI/Structure/Given.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_GIVEN';
  package PPI::Structure::Given;use strict;use PPI::Structure ();our$VERSION='1.274';our@ISA="PPI::Structure";1;
PPI_STRUCTURE_GIVEN

$fatpacked{"PPI/Structure/List.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_LIST';
  package PPI::Structure::List;use strict;use Carp ();use PPI::Structure ();our$VERSION='1.274';our@ISA="PPI::Structure";my$has_warned=0;sub isa {if ($_[1]and $_[1]eq 'PPI::Structure::ForLoop'){if ($_[0]->parent->isa('PPI::Statement::Compound')and $_[0]->parent->type =~ /^for/){unless ($has_warned){local$Carp::CarpLevel=$Carp::CarpLevel + 1;Carp::carp("PPI::Structure::ForLoop has been deprecated");$has_warned=1}return 1}}return shift->SUPER::isa(@_)}1;
PPI_STRUCTURE_LIST

$fatpacked{"PPI/Structure/Subscript.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_SUBSCRIPT';
  package PPI::Structure::Subscript;use strict;use PPI::Structure ();our$VERSION='1.274';our@ISA="PPI::Structure";1;
PPI_STRUCTURE_SUBSCRIPT

$fatpacked{"PPI/Structure/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_UNKNOWN';
  package PPI::Structure::Unknown;use strict;use PPI::Structure ();our$VERSION='1.274';our@ISA="PPI::Structure";1;
PPI_STRUCTURE_UNKNOWN

$fatpacked{"PPI/Structure/When.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_WHEN';
  package PPI::Structure::When;use strict;use PPI::Structure ();our$VERSION='1.274';our@ISA="PPI::Structure";1;
PPI_STRUCTURE_WHEN

$fatpacked{"PPI/Token.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN';
  package PPI::Token;use strict;use Params::Util qw{_INSTANCE};use PPI::Element ();use PPI::Exception ();our$VERSION='1.274';our@ISA='PPI::Element';use PPI::Token::BOM ();use PPI::Token::Whitespace ();use PPI::Token::Comment ();use PPI::Token::Pod ();use PPI::Token::Number ();use PPI::Token::Number::Binary ();use PPI::Token::Number::Octal ();use PPI::Token::Number::Hex ();use PPI::Token::Number::Float ();use PPI::Token::Number::Exp ();use PPI::Token::Number::Version ();use PPI::Token::Word ();use PPI::Token::DashedWord ();use PPI::Token::Symbol ();use PPI::Token::ArrayIndex ();use PPI::Token::Magic ();use PPI::Token::Quote::Single ();use PPI::Token::Quote::Double ();use PPI::Token::Quote::Literal ();use PPI::Token::Quote::Interpolate ();use PPI::Token::QuoteLike::Backtick ();use PPI::Token::QuoteLike::Command ();use PPI::Token::QuoteLike::Regexp ();use PPI::Token::QuoteLike::Words ();use PPI::Token::QuoteLike::Readline ();use PPI::Token::Regexp::Match ();use PPI::Token::Regexp::Substitute ();use PPI::Token::Regexp::Transliterate ();use PPI::Token::Operator ();use PPI::Token::Cast ();use PPI::Token::Structure ();use PPI::Token::Label ();use PPI::Token::HereDoc ();use PPI::Token::Separator ();use PPI::Token::Data ();use PPI::Token::End ();use PPI::Token::Prototype ();use PPI::Token::Attribute ();use PPI::Token::Unknown ();sub new {bless {content=>(defined $_[1]? "$_[1]" : '')},$_[0]}sub set_class {my$self=shift;my$class=substr($_[0],0,12)eq 'PPI::Token::' ? shift : 'PPI::Token::' .shift;my$old_quote=(ref($self)=~ /\b(?:Quote|Regex)\b/o)? 1 : 0;my$new_quote=($class =~ /\b(?:Quote|Regex)\b/o)? 1 : 0;bless$self,$class;return$class if ($old_quote - $new_quote)==0;my$token=$class->new($self->{content});%$self=%$token;return$class}sub set_content {$_[0]->{content}=$_[1]}sub add_content {$_[0]->{content}.= $_[1]}sub length {CORE::length($_[0]->{content})}sub content {$_[0]->{content}}sub insert_before {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Structure')){return$self->__insert_before($Element)}elsif ($Element->isa('PPI::Token')){return$self->__insert_before($Element)}''}sub insert_after {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Structure')){return$self->__insert_after($Element)}elsif ($Element->isa('PPI::Token')){return$self->__insert_after($Element)}''}sub __TOKENIZER__on_line_start() {1}sub __TOKENIZER__on_line_end() {1}sub __TOKENIZER__on_char() {'Unknown'}sub __LEXER__opens {ref($_[0])eq 'PPI::Token::Structure' and $_[0]->{content}=~ /(?:\(|\[|\{)/}sub __LEXER__closes {ref($_[0])eq 'PPI::Token::Structure' and $_[0]->{content}=~ /(?:\)|\]|\})/}1;
PPI_TOKEN

$fatpacked{"PPI/Token/ArrayIndex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_ARRAYINDEX';
  package PPI::Token::ArrayIndex;use strict;use PPI::Token ();our$VERSION='1.274';our@ISA="PPI::Token";sub __TOKENIZER__on_char {my$t=$_[1];pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G([\w:']+)/gc){$t->{token}->{content}.= $1;$t->{line_cursor}+= length $1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_ARRAYINDEX

$fatpacked{"PPI/Token/Attribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_ATTRIBUTE';
  package PPI::Token::Attribute;use strict;use PPI::Token ();our$VERSION='1.274';our@ISA="PPI::Token";sub identifier {my$self=shift;$self->{content}=~ /^(.+?)\(/ ? $1 : $self->{content}}sub parameters {my$self=shift;$self->{content}=~ /\((.*)\)$/ ? $1 : undef}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);unless ($char eq '('){return$t->_finalize_token->__TOKENIZER__on_char($t)}my$string=$class->__TOKENIZER__scan_for_end($t);if (ref$string){$t->{token}->{content}.= $$string;$t->_finalize_token;return 0}$t->{token}->{content}.= $string;$t->_finalize_token->__TOKENIZER__on_char($t)}sub __TOKENIZER__scan_for_end {my$t=$_[1];my$string='';my$depth=0;while (exists$t->{line}){pos$t->{line}=$t->{line_cursor};unless ($t->{line}=~ /\G((?:\\.|[^()])*?[()])/gc){$string .= substr($t->{line},$t->{line_cursor});$t->_fill_line(1)or return \$string;$t->{line_cursor}=0;next}$string .= $1;$t->{line_cursor}+= length $1;$depth += ($1 =~ /\($/)? 1 : -1 and next;return$string}\$string}1;
PPI_TOKEN_ATTRIBUTE

$fatpacked{"PPI/Token/BOM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_BOM';
  package PPI::Token::BOM;use strict;use PPI::Token ();our$VERSION='1.274';our@ISA="PPI::Token";sub significant() {''}my%bom_types=("\x00\x00\xfe\xff"=>'UTF-32',"\xff\xfe\x00\x00"=>'UTF-32',"\xfe\xff"=>'UTF-16',"\xff\xfe"=>'UTF-16',"\xef\xbb\xbf"=>'UTF-8',);sub __TOKENIZER__on_line_start {my$t=$_[1];$_=$t->{line};if (m/^(\x00\x00\xfe\xff |  # UTF-32, big-endian
  		\xff\xfe\x00\x00 |  # UTF-32, little-endian
  		\xfe\xff         |  # UTF-16, big-endian
  		\xff\xfe         |  # UTF-16, little-endian
  		\xef\xbb\xbf)       # UTF-8
  	    /xs){my$bom=$1;if ($bom_types{$bom}ne 'UTF-8'){return$t->_error("$bom_types{$bom} is not supported")}$t->_new_token('BOM',$bom)or return undef;$t->{line_cursor}+= length$bom}$t->{class}='PPI::Token::Whitespace';return$t->{class}->__TOKENIZER__on_line_start($t)}1;
PPI_TOKEN_BOM

$fatpacked{"PPI/Token/Cast.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_CAST';
  package PPI::Token::Cast;use strict;use PPI::Token ();our$VERSION='1.274';our@ISA="PPI::Token";our%POSTFIX=map {$_=>1}(qw{%* @* $*},'$#*');sub __TOKENIZER__on_char {my$t=$_[1];my$char=substr($t->{line},$t->{line_cursor},1);my$content=$t->{token}->{content};return 1 if$POSTFIX{$content .$char };$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_CAST

$fatpacked{"PPI/Token/Comment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_COMMENT';
  package PPI::Token::Comment;use strict;use PPI::Token ();our$VERSION='1.274';our@ISA="PPI::Token";sub significant() {''}sub __TOKENIZER__on_char {my$t=$_[1];if (substr($t->{line},$t->{line_cursor},1)eq "\n"){return$t->_finalize_token->__TOKENIZER__on_char($t)}1}sub __TOKENIZER__commit {my$t=$_[1];my$rest=substr($t->{line},$t->{line_cursor});if (chomp$rest){$t->_new_token('Comment',$rest);$t->_new_token('Whitespace',"\n")}else {$t->_new_token('Comment',$rest)}$t->{line_cursor}=$t->{line_length}- 1;0}sub __TOKENIZER__on_line_end {$_[1]->_finalize_token if $_[1]->{token};1}sub line {$_[0]->{content}=~ /\n$/ ? 1 : 0}1;
PPI_TOKEN_COMMENT

$fatpacked{"PPI/Token/DashedWord.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_DASHEDWORD';
  package PPI::Token::DashedWord;use strict;use PPI::Token ();our$VERSION='1.274';our@ISA="PPI::Token";*literal=*PPI::Token::Word::literal;sub __TOKENIZER__on_char {my$t=$_[1];pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G(\w+)/gc){$t->{token}->{content}.= $1;$t->{line_cursor}+= length $1}if ($t->{token}->{content}=~ /^\-[rwxoRWXOezsfdlpSbctugkTBMAC]$/){$t->{class}=$t->{token}->set_class('Operator')}else {$t->{class}=$t->{token}->set_class('Word')}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_DASHEDWORD

$fatpacked{"PPI/Token/Data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_DATA';
  package PPI::Token::Data;use strict;use PPI::Token ();use constant USE_IO_STRING=>$] < '5.008000';use if USE_IO_STRING,'IO::String';use if!USE_IO_STRING,'IO::File';our$VERSION='1.274';our@ISA="PPI::Token";sub handle {my$self=shift;if (USE_IO_STRING){return IO::String->new(\$self->{content})}else {open my$fh,'+<',\$self->{content};return$fh}}sub __TOKENIZER__on_line_start {my ($self,$t)=@_;if (defined$t->{token}){$t->{token}->{content}.= $t->{line}}else {defined($t->{token}=$t->{class}->new($t->{line}))or return undef}return 0}1;
PPI_TOKEN_DATA

$fatpacked{"PPI/Token/End.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_END';
  package PPI::Token::End;use strict;use PPI::Token ();our$VERSION='1.274';our@ISA="PPI::Token";sub significant() {''}sub __TOKENIZER__on_char() {1}sub __TOKENIZER__on_line_start {my$t=$_[1];if ($t->{line}=~ /^=(\w+)/){$t->_new_token('Pod',$t->{line});unless ($1 eq 'cut'){$t->{class}='PPI::Token::Pod'}}else {if (defined$t->{token}){$t->{token}->{content}.= $t->{line}}else {$t->_new_token('End',$t->{line})}}0}1;
PPI_TOKEN_END

$fatpacked{"PPI/Token/HereDoc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_HEREDOC';
  package PPI::Token::HereDoc;use strict;our$VERSION='1.274';our@ISA="PPI::Token";sub heredoc {@{shift->{_heredoc}}}sub indentation {shift->{_indentation}}sub terminator {shift->{_terminator}}sub _is_terminator {my ($self,$terminator,$line,$indented)=@_;if ($indented){return$line =~ /^\s*\Q$terminator\E$/}else {return$line eq $terminator}}sub _indent {my ($self,$token)=@_;my ($indent)=$token->{_terminator_line}=~ /^(\s*)/;return$indent}sub _is_match_indent {my ($self,$token,$indent)=@_;return (grep {/^$indent/ || $_ eq "\n"}@{$token->{_heredoc}})==@{$token->{_heredoc}}}sub __TOKENIZER__on_char {my ($self,$t)=@_;pos$t->{line}=$t->{line_cursor};if ($t->{line}!~ m/\G( ~? \s* (?: "[^"]*" | '[^']*' | `[^`]*` | \\?\w+ ) )/gcx){$t->{token}->set_class('Operator');return$t->_finalize_token->__TOKENIZER__on_char($t)}my$token=$t->{token};$token->{content}.= $1;$t->{line_cursor}+= length $1;my$content=$token->{content};if ($content =~ /^\<\<(~?)(\w+)$/){$token->{_mode}='interpolate';$token->{_indented}=1 if $1 eq '~';$token->{_terminator}=$2}elsif ($content =~ /^\<\<(~?)\s*\'(.*)\'$/){$token->{_mode}='literal';$token->{_indented}=1 if $1 eq '~';$token->{_terminator}=$2;$token->{_terminator}=~ s/\\'/'/g}elsif ($content =~ /^\<\<(~?)\s*\"(.*)\"$/){$token->{_mode}='interpolate';$token->{_indented}=1 if $1 eq '~';$token->{_terminator}=$2;$token->{_terminator}=~ s/\\"/"/g}elsif ($content =~ /^\<\<(~?)\s*\`(.*)\`$/){$token->{_mode}='command';$token->{_indented}=1 if $1 eq '~';$token->{_terminator}=$2;$token->{_terminator}=~ s/\\`/`/g}elsif ($content =~ /^\<\<(~?)\\(\w+)$/){$token->{_mode}='literal';$token->{_indented}=1 if $1 eq '~';$token->{_terminator}=$2}else {return undef}$token->{_heredoc}=\my@heredoc;my$terminator=$token->{_terminator}."\n";while (defined(my$line=$t->_get_line)){if ($self->_is_terminator($terminator,$line,$token->{_indented})){$token->{_terminator_line}=$line;if ($token->{_indented}){my$indent=$self->_indent($token);$token->{_indentation}=$indent;unless ($self->_is_match_indent($token,$indent)){push@heredoc,$line;last}s/^$indent// for@heredoc,$token->{_terminator_line}}return$t->_finalize_token->__TOKENIZER__on_char($t)}push@heredoc,$line}$token->{_terminator_line}=undef;if (@heredoc and defined$heredoc[-1]){if ($t->{source_eof_chop}){chop$heredoc[-1];$t->{source_eof_chop}=''}$token->{_terminator_line}=pop@heredoc if$self->_is_terminator($token->{_terminator},$heredoc[-1],$token->{_indented})}if ($token->{_indented}&& $token->{_terminator_line}){my$indent=$self->_indent($token);$token->{_indentation}=$indent;if ($self->_is_match_indent($token,$indent)){s/^$indent// for@heredoc}s/^$indent// for$token->{_terminator_line}}$token->{_damaged}=1;$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_HEREDOC

$fatpacked{"PPI/Token/Label.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_LABEL';
  package PPI::Token::Label;use strict;use PPI::Token ();our$VERSION='1.274';our@ISA="PPI::Token";1;
PPI_TOKEN_LABEL

$fatpacked{"PPI/Token/Magic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_MAGIC';
  package PPI::Token::Magic;use strict;use PPI::Token::Symbol ();use PPI::Token::Unknown ();use PPI::Singletons qw'%MAGIC $CURLY_SYMBOL';our$VERSION='1.274';our@ISA="PPI::Token::Symbol";sub __TOKENIZER__on_char {my$t=$_[1];my$c=$t->{token}->{content}.substr($t->{line},$t->{line_cursor},1);if ($c =~ /^  \$  .*  [  \w  :  \$  \{  ]  $/x){if ($c =~ /^(\$(?:\_[\w:]|::))/ or $c =~ /^\$\'[\w]/){if ($c =~ /^\$\'\d$/){return$t->_finalize_token->__TOKENIZER__on_char($t)}$t->{class}=$t->{token}->set_class('Symbol');return PPI::Token::Symbol->__TOKENIZER__on_char($t)}if ($c =~ /^\$\$\w/){$t->{token}=PPI::Token::Cast->new('$');$t->_finalize_token;return$t->_new_token('Symbol','$')}if ($c eq '$${'){pos$t->{line}=$t->{line_cursor}+ 1;if ($t->{line}=~ m/$CURLY_SYMBOL/gc){$t->{token}=PPI::Token::Cast->new('$');$t->_finalize_token;return$t->_new_token('Magic','$')}}if ($c eq '$#$' or $c eq '$#{'){$t->{class}=$t->{token}->set_class('Cast');return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($c =~ /^(\$\#)\w/){$t->{token}=PPI::Token::ArrayIndex->new("$1");return PPI::Token::ArrayIndex->__TOKENIZER__on_char($t)}if ($c =~ /^\$\^\w+$/o){my$next=substr($t->{line},$t->{line_cursor}+1,1);if ($MAGIC{$c}&& (!$next || $next !~ /\w/)){$t->{token}->{content}=$c;$t->{line_cursor}++}else {return 1}}if ($c =~ /^\$\#\{/){$t->{token}=PPI::Token::Cast->new('$#');$t->_finalize_token;return$t->_new_token('Structure','{')}}elsif ($c =~ /^%\^/){return 1 if$c eq '%^';if ($MAGIC{$c}){$t->{token}->{content}=$c;$t->{line_cursor}++}else {chop$t->{token}->{content};bless$t->{token},$t->{class}='PPI::Token::Operator';$t->{line_cursor}--}}if ($MAGIC{$c}){$t->{line_cursor}+= length($c)- length($t->{token}->{content});$t->{token}->{content}=$c}else {pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/($CURLY_SYMBOL)/gc){$t->{token}->{content}.= $1;$t->{line_cursor}+= length $1}elsif ($c =~ /^\$\d+$/ and $t->{line}=~ /\G(\d+)/gc){$t->{token}{content}.= $1;$t->{line_cursor}+= length $1}}$t->_finalize_token->__TOKENIZER__on_char($t)}sub canonical {$_[0]->content}1;
PPI_TOKEN_MAGIC

$fatpacked{"PPI/Token/Number.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER';
  package PPI::Token::Number;use strict;use PPI::Token ();our$VERSION='1.274';our@ISA="PPI::Token";sub base() {10}sub literal {return 0 + $_[0]->_literal}sub _literal {my$self=shift;my$string=$self->content;$string =~ s/^\+//;$string =~ s/_//g;return$string}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';my$token=$t->{token};if ($token->{content}=~ /^-?0_*$/){if ($char eq 'x' || $char eq 'X'){$t->{class}=$t->{token}->set_class('Number::Hex');return 1}elsif ($char eq 'b' || $char eq 'B'){$t->{class}=$t->{token}->set_class('Number::Binary');return 1}elsif ($char =~ /\d/){if ($char eq '8' or $char eq '9'){$token->{_error}="Illegal character in octal number '$char'"}$t->{class}=$t->{token}->set_class('Number::Octal');return 1}}return 1 if$char =~ /\d/o;if ($char eq '.'){$t->{class}=$t->{token}->set_class('Number::Float');return 1}if ($char eq 'e' || $char eq 'E'){$t->{class}=$t->{token}->set_class('Number::Exp');return 1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER

$fatpacked{"PPI/Token/Number/Binary.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_BINARY';
  package PPI::Token::Number::Binary;use strict;use PPI::Token::Number ();our$VERSION='1.274';our@ISA="PPI::Token::Number";sub base() {2}sub literal {my$self=shift;return if$self->{_error};my$str=$self->_literal;my$neg=$str =~ s/^\-//;$str =~ s/^0[bB]//;my$val=0;for my$bit ($str =~ m/(.)/g){$val=$val * 2 + $bit}return$neg ? -$val : $val}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';if ($char =~ /[\w\d]/){unless ($char eq '1' or $char eq '0'){$t->{token}->{_error}="Illegal character in binary number '$char'"}return 1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_BINARY

$fatpacked{"PPI/Token/Number/Exp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_EXP';
  package PPI::Token::Number::Exp;use strict;use PPI::Token::Number::Float ();our$VERSION='1.274';our@ISA="PPI::Token::Number::Float";sub literal {my$self=shift;return if$self->{_error};my ($mantissa,$exponent)=split m/e/i,$self->_literal;my$neg=$mantissa =~ s/^\-//;$mantissa =~ s/^\./0./;$exponent =~ s/^\+//;$exponent += 0;my$negpow=0;if ($exponent < 0){$negpow=1;$exponent *= -1}my$result=1;my$power=10;for (my$bit=1;$exponent;$bit=$bit << 1){if ($exponent & $bit){$exponent=$exponent ^ $bit;$result *= $power}$power *= $power}my$val=$neg ? 0 - $mantissa : $mantissa;return$negpow ? $val / $result : $val * $result}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';return 1 if$char =~ /\d/o;if ($t->{token}->{content}=~ /e$/i){return 1 if$char eq '-' || $char eq '+';if ($t->{token}->{content}=~ s/\.(e)$//i){my$word=$1;$t->{class}=$t->{token}->set_class('Number');$t->_new_token('Operator','.');$t->_new_token('Word',$word);return$t->{class}->__TOKENIZER__on_char($t)}else {$t->{token}->{_error}="Illegal character in exponent '$char'"}}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_EXP

$fatpacked{"PPI/Token/Number/Float.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_FLOAT';
  package PPI::Token::Number::Float;use strict;use PPI::Token::Number ();our$VERSION='1.274';our@ISA="PPI::Token::Number";sub base() {10}sub literal {my$self=shift;my$str=$self->_literal;my$neg=$str =~ s/^\-//;$str =~ s/^\./0./;my$val=0+$str;return$neg ? -$val : $val}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';return 1 if$char =~ /\d/o;if ($char eq '.'){if ($t->{token}{content}=~ /\.$/){chop$t->{token}{content};$t->{class}=$t->{token}->set_class('Number');$t->_new_token('Operator','..');return 0}elsif ($t->{token}{content}=~ /\._/){($t->{token}{content},my$bareword)=split /\./,$t->{token}{content};$t->{class}=$t->{token}->set_class('Number');$t->_new_token('Operator','.');$t->_new_token('Word',$bareword);$t->_new_token('Operator','.');return 0}else {$t->{class}=$t->{token}->set_class('Number::Version');return 1}}my$char2=substr$t->{line},$t->{line_cursor}+1,1;if ("$char$char2" =~ /[eE][0-9+-]/){$t->{class}=$t->{token}->set_class('Number::Exp');return 1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_FLOAT

$fatpacked{"PPI/Token/Number/Hex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_HEX';
  package PPI::Token::Number::Hex;use strict;use PPI::Token::Number ();our$VERSION='1.274';our@ISA="PPI::Token::Number";sub base() {16}sub literal {my$self=shift;my$str=$self->_literal;my$neg=$str =~ s/^\-//;my$val=hex lc($str);return$neg ? -$val : $val}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';if ($char =~ /[[:xdigit:]]/){return 1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_HEX

$fatpacked{"PPI/Token/Number/Octal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_OCTAL';
  package PPI::Token::Number::Octal;use strict;use PPI::Token::Number ();our$VERSION='1.274';our@ISA="PPI::Token::Number";sub base() {8}sub literal {my$self=shift;return if$self->{_error};my$str=$self->_literal;my$neg=$str =~ s/^\-//;my$val=oct$str;return$neg ? -$val : $val}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';if ($char =~ /\d/){if ($char eq '8' or $char eq '9'){$t->{token}->{_error}="Illegal character in octal number '$char'"}return 1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_OCTAL

$fatpacked{"PPI/Token/Number/Version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_VERSION';
  package PPI::Token::Number::Version;use strict;use PPI::Token::Number ();our$VERSION='1.274';our@ISA="PPI::Token::Number";sub base() {256}sub literal {my$self=shift;my$content=$self->{content};$content =~ s/^v//;return join '',map {chr $_}(split /\./,$content)}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char =~ /\d/o;if($char eq '_'){return 1 if$t->{token}{content}!~ /\.$/;chop$t->{token}->{content};$t->{class}=$t->{token}->set_class('Number::Float')if$t->{token}{content}!~ /\..+\./;$t->_new_token('Operator','.');$t->_new_token('Word','_');return 0}if ($char eq '.'){if ($t->{token}->{content}=~ /\.$/){chop$t->{token}->{content};$t->{class}=$t->{token}->set_class('Number::Float')if$t->{token}{content}!~ /\..+\./;$t->_new_token('Operator','..');return 0}else {return 1}}$t->_finalize_token->__TOKENIZER__on_char($t)}sub __TOKENIZER__commit {my$t=$_[1];pos$t->{line}=$t->{line_cursor};return PPI::Token::Word->__TOKENIZER__commit($t)if$t->{line}!~ m/\G(v\d[_\d]*(?:\.\d[_\d]*)+|v\d[_\d]*\b)/gc;my$content=$1;return PPI::Token::Word->__TOKENIZER__commit($t)if$content !~ /\./ and $t->__current_token_is_forced_word($content);$t->{line_cursor}+= length$content;$t->_new_token('Number::Version',$content);$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_VERSION

$fatpacked{"PPI/Token/Operator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_OPERATOR';
  package PPI::Token::Operator;use strict;use PPI::Token ();use PPI::Singletons '%OPERATOR';our$VERSION='1.274';our@ISA="PPI::Token";sub __TOKENIZER__on_char {my$t=$_[1];my$char=substr($t->{line},$t->{line_cursor},1);my$content=$t->{token}->{content};if(length($content)< 4 && $content .substr($t->{line},$t->{line_cursor},4 - length($content))eq '<<>>'){return 1}return 1 if$OPERATOR{$content .$char };if ($content eq '.'){if ($char =~ /^[0-9]$/){$t->{class}=$t->{token}->set_class('Number::Float');return$t->{class}->__TOKENIZER__on_char($t)}}if ($content eq '<<'){pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G ~? (?: (?!\d)\w | \s*['"`] | \\\w ) /gcx){$t->{class}=$t->{token}->set_class('HereDoc');return$t->{class}->__TOKENIZER__on_char($t)}}$t->{class}=$t->{token}->set_class('QuoteLike::Readline')if$content eq '<>' or $content eq '<<>>';$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_OPERATOR

$fatpacked{"PPI/Token/Pod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_POD';
  package PPI::Token::Pod;use strict;use Params::Util qw{_INSTANCE};use PPI::Token ();our$VERSION='1.274';our@ISA="PPI::Token";sub merge {my$class=(!ref $_[0])? shift : return undef;if (grep {!_INSTANCE($_,'PPI::Token::Pod')}@_){return undef}my@content=(map {[$_->lines ]}@_)or return undef;for my$pod (@content){if (@$pod and $pod->[0]=~ /^=pod\b/o){shift @$pod}if (@$pod and $pod->[-1]=~ /^=cut\b/o){pop @$pod}while (@$pod and $pod->[0]eq ''){shift @$pod}while (@$pod and $pod->[-1]eq ''){pop @$pod}}@content=(['=pod' ],grep {@$_}@content,['=cut' ]);$class->new(join "\n",map {join("\n",@$_)."\n"}@content)}sub lines {split /(?:\015{1,2}\012|\015|\012)/,$_[0]->{content}}sub significant() {''}sub __TOKENIZER__on_line_start {my$t=$_[1];$t->{token}->{content}.= $t->{line};if ($t->{line}=~ /^=(\w+)/){$t->_finalize_token if $1 eq 'cut'}0}1;
PPI_TOKEN_POD

$fatpacked{"PPI/Token/Prototype.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_PROTOTYPE';
  package PPI::Token::Prototype;use strict;use PPI::Token ();our$VERSION='1.274';our@ISA="PPI::Token";sub __TOKENIZER__on_char {my$class=shift;my$t=shift;pos$t->{line}=$t->{line_cursor};die "regex should always match" if$t->{line}!~ m/\G(.*?\n?(?:\)|$))/gc;$t->{token}->{content}.= $1;$t->{line_cursor}+= length $1;return 0 unless $1 =~ /\)$/;$t->_finalize_token->__TOKENIZER__on_char($t)}sub prototype {my$self=shift;my$proto=$self->content;$proto =~ s/(^\(|\)$|\s+)//g;$proto}1;
PPI_TOKEN_PROTOTYPE

$fatpacked{"PPI/Token/Quote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE';
  package PPI::Token::Quote;use strict;use PPI::Token ();our$VERSION='1.274';our@ISA="PPI::Token";1;
PPI_TOKEN_QUOTE

$fatpacked{"PPI/Token/Quote/Double.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE_DOUBLE';
  package PPI::Token::Quote::Double;use strict;use Params::Util qw{_INSTANCE};use PPI::Token::Quote ();use PPI::Token::_QuoteEngine::Simple ();our$VERSION='1.274';our@ISA=qw{PPI::Token::_QuoteEngine::Simple PPI::Token::Quote};sub interpolations {!!($_[0]->content =~ /(?<!\\)(?:\\\\)*[\$\@]/)}sub simplify {my$self=_INSTANCE(shift,'PPI::Token::Quote::Double')or return undef;my$content=$self->content;my$value=substr($content,1,length($content)- 2);return$self if$value =~ /[\\\$@\'\"]/;$self->{content}="'$value'";bless$self,'PPI::Token::Quote::Single'}sub string {my$str=$_[0]->{content};substr($str,1,length($str)- 2)}1;
PPI_TOKEN_QUOTE_DOUBLE

$fatpacked{"PPI/Token/Quote/Interpolate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE_INTERPOLATE';
  package PPI::Token::Quote::Interpolate;use strict;use PPI::Token::Quote ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.274';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::Quote};sub string {my$self=shift;my@sections=$self->_sections;my$str=$sections[0];substr($self->{content},$str->{position},$str->{size})}1;
PPI_TOKEN_QUOTE_INTERPOLATE

$fatpacked{"PPI/Token/Quote/Literal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE_LITERAL';
  package PPI::Token::Quote::Literal;use strict;use PPI::Token::Quote ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.274';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::Quote};sub string {my$self=shift;my@sections=$self->_sections;my$str=$sections[0];substr($self->{content},$str->{position},$str->{size})}*literal=*PPI::Token::Quote::Single::literal;1;
PPI_TOKEN_QUOTE_LITERAL

$fatpacked{"PPI/Token/Quote/Single.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE_SINGLE';
  package PPI::Token::Quote::Single;use strict;use PPI::Token::Quote ();use PPI::Token::_QuoteEngine::Simple ();our$VERSION='1.274';our@ISA=qw{PPI::Token::_QuoteEngine::Simple PPI::Token::Quote};sub string {my$str=$_[0]->{content};substr($str,1,length($str)- 2)}my%UNESCAPE=("\\'"=>"'","\\\\"=>"\\",);sub literal {my$str=$_[0]->string;$str =~ s/(\\.)/$UNESCAPE{$1} || $1/ge;return$str}1;
PPI_TOKEN_QUOTE_SINGLE

$fatpacked{"PPI/Token/QuoteLike.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE';
  package PPI::Token::QuoteLike;use strict;use PPI::Token ();our$VERSION='1.274';our@ISA="PPI::Token";1;
PPI_TOKEN_QUOTELIKE

$fatpacked{"PPI/Token/QuoteLike/Backtick.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_BACKTICK';
  package PPI::Token::QuoteLike::Backtick;use strict;use PPI::Token::QuoteLike ();use PPI::Token::_QuoteEngine::Simple ();our$VERSION='1.274';our@ISA=qw{PPI::Token::_QuoteEngine::Simple PPI::Token::QuoteLike};1;
PPI_TOKEN_QUOTELIKE_BACKTICK

$fatpacked{"PPI/Token/QuoteLike/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_COMMAND';
  package PPI::Token::QuoteLike::Command;use strict;use PPI::Token::QuoteLike ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.274';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::QuoteLike};1;
PPI_TOKEN_QUOTELIKE_COMMAND

$fatpacked{"PPI/Token/QuoteLike/Readline.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_READLINE';
  package PPI::Token::QuoteLike::Readline;use strict;use PPI::Token::QuoteLike ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.274';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::QuoteLike};1;
PPI_TOKEN_QUOTELIKE_READLINE

$fatpacked{"PPI/Token/QuoteLike/Regexp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_REGEXP';
  package PPI::Token::QuoteLike::Regexp;use strict;use PPI::Token::QuoteLike ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.274';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::QuoteLike};sub get_match_string {return $_[0]->_section_content(0)}sub get_substitute_string {return undef}sub get_modifiers {return $_[0]->_modifiers()}sub get_delimiters {return $_[0]->_delimiters()}1;
PPI_TOKEN_QUOTELIKE_REGEXP

$fatpacked{"PPI/Token/QuoteLike/Words.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_WORDS';
  package PPI::Token::QuoteLike::Words;use strict;use PPI::Token::QuoteLike ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.274';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::QuoteLike};sub literal {my ($self)=@_;my$content=$self->_section_content(0);return if!defined$content;my ($left,$right)=($self->_delimiters,'','');$content =~ s/\\([\Q$left$right\\\E])/$1/g;my@words=split ' ',$content;return@words}1;
PPI_TOKEN_QUOTELIKE_WORDS

$fatpacked{"PPI/Token/Regexp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_REGEXP';
  package PPI::Token::Regexp;use strict;use PPI::Token ();our$VERSION='1.274';our@ISA="PPI::Token";sub get_match_string {return $_[0]->_section_content(0)}sub get_substitute_string {return $_[0]->_section_content(1)}sub get_modifiers {return $_[0]->_modifiers()}sub get_delimiters {return $_[0]->_delimiters()}1;
PPI_TOKEN_REGEXP

$fatpacked{"PPI/Token/Regexp/Match.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_REGEXP_MATCH';
  package PPI::Token::Regexp::Match;use strict;use PPI::Token::Regexp ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.274';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::Regexp};1;
PPI_TOKEN_REGEXP_MATCH

$fatpacked{"PPI/Token/Regexp/Substitute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_REGEXP_SUBSTITUTE';
  package PPI::Token::Regexp::Substitute;use strict;use PPI::Token::Regexp ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.274';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::Regexp};1;
PPI_TOKEN_REGEXP_SUBSTITUTE

$fatpacked{"PPI/Token/Regexp/Transliterate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_REGEXP_TRANSLITERATE';
  package PPI::Token::Regexp::Transliterate;use strict;use PPI::Token::Regexp ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.274';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::Regexp};1;
PPI_TOKEN_REGEXP_TRANSLITERATE

$fatpacked{"PPI/Token/Separator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_SEPARATOR';
  package PPI::Token::Separator;use strict;use PPI::Token::Word ();our$VERSION='1.274';our@ISA="PPI::Token::Word";1;
PPI_TOKEN_SEPARATOR

$fatpacked{"PPI/Token/Structure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_STRUCTURE';
  package PPI::Token::Structure;use strict;use PPI::Token ();our$VERSION='1.274';our@ISA="PPI::Token";my%MATCH=(ord '{'=>'}',ord '}'=>'{',ord '['=>']',ord ']'=>'[',ord '('=>')',ord ')'=>'(',);my%OPENS=(ord '{'=>1,ord '['=>1,ord '('=>1,);my%CLOSES=(ord '}'=>1,ord ']'=>1,ord ')'=>1,);sub __TOKENIZER__on_char {$_[1]->_finalize_token->__TOKENIZER__on_char($_[1])}sub __TOKENIZER__commit {my$t=$_[1];$t->_new_token('Structure',substr($t->{line},$t->{line_cursor},1));$t->_finalize_token;0}sub __LEXER__opposite {$MATCH{ord $_[0]->{content}}}sub next_sibling {return $_[0]->SUPER::next_sibling if $_[0]->{content}eq ';';return ''}sub snext_sibling {return $_[0]->SUPER::snext_sibling if $_[0]->{content}eq ';';return ''}sub previous_sibling {return $_[0]->SUPER::previous_sibling if $_[0]->{content}eq ';';return ''}sub sprevious_sibling {return $_[0]->SUPER::sprevious_sibling if $_[0]->{content}eq ';';return ''}sub next_token {my$self=shift;return$self->SUPER::next_token if$self->{content}eq ';';my$structure=$self->parent or return '';if ($OPENS{ord$self->{content}}){my$child=$structure->child(0);if ($child){return$child->isa('PPI::Token')? $child : $child->first_token}elsif ($structure->finish){return$structure->finish}}$structure->next_token}sub previous_token {my$self=shift;return$self->SUPER::previous_token if$self->{content}eq ';';my$structure=$self->parent or return '';if ($CLOSES{ord$self->{content}}){my$child=$structure->child(-1);if ($child){return$child->isa('PPI::Token')? $child : $child->last_token}elsif ($structure->start){return$structure->start}}$structure->previous_token}1;
PPI_TOKEN_STRUCTURE

$fatpacked{"PPI/Token/Symbol.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_SYMBOL';
  package PPI::Token::Symbol;use strict;use Params::Util qw{_INSTANCE};use PPI::Token ();our$VERSION='1.274';our@ISA="PPI::Token";sub canonical {my$symbol=shift->content;$symbol =~ s/\s+//;$symbol =~ s/\'/::/g;$symbol =~ s/(?<=[\$\@\%\&\*])::/main::/;$symbol}my%cast_which_trumps_braces=map {$_=>1}qw{$ @ %};sub symbol {my$self=shift;my$symbol=$self->canonical;my$type=substr($symbol,0,1);return$symbol if$type eq '&';my$after=$self->snext_sibling;return$symbol unless _INSTANCE($after,'PPI::Structure');my$braces=$after->braces;return$symbol unless defined$braces;if ($type eq '$'){my$before=$self->sprevious_sibling;return$symbol if$before && $before->isa('PPI::Token::Cast')&& $cast_which_trumps_braces{$before->content };substr($symbol,0,1,'@')if$braces eq '[]';substr($symbol,0,1,'%')if$braces eq '{}'}elsif ($type eq '@'){substr($symbol,0,1,'%')if$braces eq '{}'}elsif ($type eq '%'){substr($symbol,0,1,'@')if$braces eq '[]'}$symbol}sub raw_type {substr($_[0]->content,0,1)}sub symbol_type {substr($_[0]->symbol,0,1)}sub __TOKENIZER__on_char {my$t=$_[1];pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G([\w:\']+)/gc){$t->{token}->{content}.= $1;$t->{line_cursor}+= length $1}my$content=$t->{token}->{content};if ($content eq '@_' or $content eq '$_'){$t->{class}=$t->{token}->set_class('Magic');return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($content eq '$::'){my$nextchar=substr($t->{line},$t->{line_cursor},1);if ($nextchar eq '|'){$t->{token}->{content}.= $nextchar;$t->{line_cursor}++;$t->{class}=$t->{token}->set_class('Magic')}return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($content =~ /^[\$%*@&]::(?:[^\w]|$)/){my$current=substr($content,0,3,'');$t->{token}->{content}=$current;$t->{line_cursor}-= length($content);return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($content =~ /^(?:\$|\@)\d+/){$t->{class}=$t->{token}->set_class('Magic');return$t->_finalize_token->__TOKENIZER__on_char($t)}$content =~ /^(
  		[\$@%&*]
  		(?: : (?!:) | # Allow single-colon non-magic variables
  			(?: \w+ | \' (?!\d) \w+ | \:: \w+ )
  			(?:
  				# Allow both :: and ' in namespace separators
  				(?: \' (?!\d) \w+ | \:: \w+ )
  			)*
  			(?: :: )? # Technically a compiler-magic hash, but keep it here
  		)
  	)/x or return undef;unless (length $1 eq length$content){$t->{line_cursor}+= length($1)- length($content);$t->{token}->{content}=$1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_SYMBOL

$fatpacked{"PPI/Token/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_UNKNOWN';
  package PPI::Token::Unknown;use strict;use PPI::Token ();use PPI::Exception ();use PPI::Singletons qw'%MAGIC $CURLY_SYMBOL';our$VERSION='1.274';our@ISA="PPI::Token";sub __TOKENIZER__on_char {my ($self,$t)=@_;my$c=$t->{token}->{content};my$char=substr($t->{line},$t->{line_cursor},1);if ($c eq '*'){if ($char =~ /\d/){$t->{class}=$t->{token}->set_class('Operator');return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($char =~ /[\w:]/){my ($prev)=$t->_previous_significant_tokens(1);if (not $prev or not $prev->isa('PPI::Token::Number')){$t->{class}=$t->{token}->set_class('Symbol');return 1}}if ($char eq '{'){pos$t->{line}=$t->{line_cursor}+ 1;if ($t->{line}=~ m/$CURLY_SYMBOL/gc){$t->{class}=$t->{token}->set_class('Magic');return 1}}if ($char eq '*'){my ($prev)=$t->_previous_significant_tokens(1);if ($prev and $prev->isa('PPI::Token::Operator')and $prev->content eq '->'){$t->{class}=$t->{token}->set_class('Cast');return 1}}if ($char eq '*' || $char eq '='){$t->{class}=$t->{token}->set_class('Operator');return 1}return$self->_as_cast_or_op($t)if$self->_is_cast_or_op($char);$t->{class}=$t->{token}->set_class('Operator');return$t->_finalize_token->__TOKENIZER__on_char($t)}elsif ($c eq '$'){if ($char eq '*' || $char eq '#'){my ($prev)=$t->_previous_significant_tokens(1);if ($prev and $prev->isa('PPI::Token::Operator')and $prev->content eq '->'){$t->{class}=$t->{token}->set_class('Cast');return 1}}if ($char =~ /[a-z_]/i){$t->{class}=$t->{token}->set_class('Symbol');return 1}if ($MAGIC{$c .$char }){$t->{class}=$t->{token}->set_class('Magic');return 1}if ($char eq '{'){pos$t->{line}=$t->{line_cursor}+ 1;if ($t->{line}=~ m/$CURLY_SYMBOL/gc){$t->{class}=$t->{token}->set_class('Magic');return 1}}$t->{class}=$t->{token}->set_class('Cast');return$t->_finalize_token->__TOKENIZER__on_char($t)}elsif ($c eq '@'){if ($char eq '*'){my ($prev)=$t->_previous_significant_tokens(1);if ($prev and $prev->isa('PPI::Token::Operator')and $prev->content eq '->'){$t->{class}=$t->{token}->set_class('Cast');return 1}}if ($char =~ /[\w:]/){$t->{class}=$t->{token}->set_class('Symbol');return 1}if ($MAGIC{$c .$char }){$t->{class}=$t->{token}->set_class('Magic');return 1}if ($char eq '{'){pos$t->{line}=$t->{line_cursor}+ 1;if ($t->{line}=~ m/$CURLY_SYMBOL/gc){$t->{class}=$t->{token}->set_class('Magic');return 1}}$t->{class}=$t->{token}->set_class('Cast');return$t->_finalize_token->__TOKENIZER__on_char($t)}elsif ($c eq '%'){if ($char eq '*' || $char eq '['){my ($prev)=$t->_previous_significant_tokens(1);if ($prev and $prev->isa('PPI::Token::Operator')and $prev->content eq '->'){if ($char eq '*'){$t->{class}=$t->{token}->set_class('Cast');return 1}if ($char eq '['){$t->{class}=$t->{token}->set_class('Cast');return$t->_finalize_token->__TOKENIZER__on_char($t)}}}if ($char =~ /\d/){$t->{class}=$t->{token}->set_class('Operator');return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($char eq '^' || $MAGIC{$c .$char }){$t->{class}=$t->{token}->set_class('Magic');return 1}if ($char =~ /[\w:]/){my ($prev)=$t->_previous_significant_tokens(1);if (not $prev or not $prev->isa('PPI::Token::Number')){$t->{class}=$t->{token}->set_class('Symbol');return 1}}if ($char eq '{'){pos$t->{line}=$t->{line_cursor}+ 1;if ($t->{line}=~ m/$CURLY_SYMBOL/gc){$t->{class}=$t->{token}->set_class('Magic');return 1}}return$self->_as_cast_or_op($t)if$self->_is_cast_or_op($char);$t->{class}=$t->{token}->set_class('Operator');return$t->{class}->__TOKENIZER__on_char($t)}elsif ($c eq '&'){if ($char eq '*'){my ($prev)=$t->_previous_significant_tokens(1);if ($prev and $prev->isa('PPI::Token::Operator')and $prev->content eq '->'){$t->{class}=$t->{token}->set_class('Cast');return 1}}if ($char =~ /\d/){$t->{class}=$t->{token}->set_class('Operator');return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($char =~ /[\w:]/){my ($prev)=$t->_previous_significant_tokens(1);if (not $prev or not $prev->isa('PPI::Token::Number')){$t->{class}=$t->{token}->set_class('Symbol');return 1}}return$self->_as_cast_or_op($t)if$self->_is_cast_or_op($char);$t->{class}=$t->{token}->set_class('Operator');return$t->{class}->__TOKENIZER__on_char($t)}elsif ($c eq '-'){if ($char =~ /\d/o){$t->{class}=$t->{token}->set_class('Number');return 1}if ($char eq '.'){$t->{class}=$t->{token}->set_class('Number::Float');return 1}if ($char =~ /[a-zA-Z]/){$t->{class}=$t->{token}->set_class('DashedWord');return 1}$t->{class}=$t->{token}->set_class('Operator');return$t->{class}->__TOKENIZER__on_char($t)}elsif ($c eq ':'){if ($char eq ':'){$t->{class}=$t->{token}->set_class('Word');return 1}if ($self->__TOKENIZER__is_an_attribute($t)){$t->{class}=$t->{token}->set_class('Operator');$t->{token}->{_attribute}=1;return$t->_finalize_token->__TOKENIZER__on_char($t)}$t->{class}=$t->{token}->set_class('Operator');return$t->{class}->__TOKENIZER__on_char($t)}PPI::Exception->throw('Unknown value in PPI::Token::Unknown token')}sub _is_cast_or_op {my ($self,$char)=@_;return 1 if$char eq '$';return 1 if$char eq '@';return 1 if$char eq '%';return 1 if$char eq '*';return 1 if$char eq '{';return}sub _as_cast_or_op {my ($self,$t)=@_;my$class=_cast_or_op($t);$t->{class}=$t->{token}->set_class($class);return$t->_finalize_token->__TOKENIZER__on_char($t)}sub _prev_significant_w_cursor {my ($tokens,$cursor,$extra_check)=@_;while ($cursor >= 0){my$token=$tokens->[$cursor-- ];next if!$token->significant;next if$extra_check and!$extra_check->($token);return ($token,$cursor)}return (undef,$cursor)}sub _cast_or_op {my ($t)=@_;my$tokens=$t->{tokens};my$cursor=scalar(@$tokens)- 1;my$token;($token,$cursor)=_prev_significant_w_cursor($tokens,$cursor);return 'Cast' if!$token;if ($token->isa('PPI::Token::Structure')and $token->content eq '}'){my$structure_depth=1;($token,$cursor)=_prev_significant_w_cursor($tokens,$cursor,sub {my ($token)=@_;return if!$token->isa('PPI::Token::Structure');if ($token eq '}'){$structure_depth++;return}if ($token eq '{'){$structure_depth--;return if$structure_depth}return 1});return 'Operator' if!$token;($token,$cursor)=_prev_significant_w_cursor($tokens,$cursor);return 'Operator' if!$token;return 'Operator' if$token->isa('PPI::Token::Symbol');my%meth_or_subscript_end=map {$_=>1}qw@-> } ]@;return 'Operator' if$meth_or_subscript_end{$token->content };my$content=$token->content;my$produces_or_wants_value=($token->isa('PPI::Token::Word')and ($content eq 'do' or $content eq 'eval'));return$produces_or_wants_value ? 'Operator' : 'Cast'}my%list_start_or_term_end=map {$_=>1}qw@; ( { [@;return 'Cast' if$token->isa('PPI::Token::Structure')and $list_start_or_term_end{$token->content }or $token->isa('PPI::Token::Cast')or $token->isa('PPI::Token::Operator')or $token->isa('PPI::Token::Label');return 'Operator' if!$token->isa('PPI::Token::Word');($token,$cursor)=_prev_significant_w_cursor($tokens,$cursor);return 'Cast' if!$token || $token->content ne '->';return 'Operator'}sub __TOKENIZER__is_an_attribute {my$t=$_[1];my@tokens=$t->_previous_significant_tokens(3);my$p0=$tokens[0];return '' if not $p0;return 1 if$p0->isa('PPI::Token::Attribute');return 1 if$p0->isa('PPI::Token::Prototype');return '' unless$p0->isa('PPI::Token::Word');if ($p0->isa('PPI::Token::Word')and $p0->content eq 'sub'){return 1}my$p1=$tokens[1];my$p2=$tokens[2];if ($p1 and $p1->isa('PPI::Token::Word')and $p1->content eq 'sub' and (not $p2 or $p2->isa('PPI::Token::Structure')or ($p2->isa('PPI::Token::Whitespace')and $p2->content eq ''))){return 1}''}1;
PPI_TOKEN_UNKNOWN

$fatpacked{"PPI/Token/Whitespace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_WHITESPACE';
  package PPI::Token::Whitespace;use strict;use Clone ();use PPI::Token ();our$VERSION='1.274';our@ISA="PPI::Token";my$null;sub null {$null ||= $_[0]->new('');Clone::clone($null)}sub significant() {''}sub tidy {$_[0]->{content}=~ s/^\s+?(?>\n)//;1}my%COMMITMAP=(map({ord $_=>'PPI::Token::Word'}'a' .. 'u','A' .. 'Z',qw"w y z _"),map({ord $_=>'PPI::Token::Structure'}qw"; [ ] { } )"),ord '#'=>'PPI::Token::Comment',ord 'v'=>'PPI::Token::Number::Version',);my%CLASSMAP=(map({ord $_=>'Number'}0 .. 9),map({ord $_=>'Operator'}qw"= ? | + > . ! ~ ^"),map({ord $_=>'Unknown'}qw"* $ @ & : %"),ord ','=>'PPI::Token::Operator',ord "'"=>'Quote::Single',ord '"'=>'Quote::Double',ord '`'=>'QuoteLike::Backtick',ord '\\'=>'Cast',ord '_'=>'Word',9=>'Whitespace',10=>'Whitespace',12=>'Whitespace',13=>'Whitespace',32=>'Whitespace',);my%MATCHWORD=map {$_=>1}qw{return split if unless grep map};sub __TOKENIZER__on_line_start {my$t=$_[1];my$line=$t->{line};if ($line =~ /^\s*$/){$t->_new_token('Whitespace',$line);return 0}elsif ($line =~ /^\s*#/){$t->_new_token('Comment',$line);$t->_finalize_token;return 0}elsif ($line =~ /^=(\w+)/){$t->_new_token('Pod',$line);if ($1 eq 'cut'){}else {$t->{class}='PPI::Token::Pod'}return 0}elsif ($line =~ /^use v6\-alpha\;/){my@perl6;while (1){my$line6=$t->_get_line;last unless defined$line6;push@perl6,$line6}push @{$t->{perl6}},join '',@perl6;return 1}1}sub __TOKENIZER__on_char {my$t=$_[1];my$c=substr$t->{line},$t->{line_cursor},1;my$char=ord$c;return$COMMITMAP{$char}->__TOKENIZER__commit($t)if$COMMITMAP{$char};return$CLASSMAP{$char}if$CLASSMAP{$char};if ($char==40){$t->_finalize_token if$t->{token};my@tokens=$t->_previous_significant_tokens(3);my$p1=$tokens[1];my$p2=$tokens[2];if ($tokens[0]and $tokens[0]->isa('PPI::Token::Word')and $p1 and $p1->isa('PPI::Token::Word')and $p1->content eq 'sub' and (not $p2 or $p2->isa('PPI::Token::Structure')or ($p2->isa('PPI::Token::Whitespace')and $p2->content eq '')or ($p2->isa('PPI::Token::Word')and $p2->content =~ /^(?:my|our|state)$/))){return 'Prototype'}my$p0=$tokens[0];if ($p0 and $p0->isa('PPI::Token::Word')and $p0->content eq 'sub' and not ($p1 and $p1->isa('PPI::Token::Operator')and $p1->content eq '->')){return 'Prototype'}return 'Structure'}elsif ($char==60){$t->_finalize_token if$t->{token};my$prev=$t->_last_significant_token;return 'Operator' if$prev and $prev->isa('PPI::Token::Symbol');return 'Operator' if$prev and $prev->isa('PPI::Token::Magic');return 'Operator' if$prev and $prev->isa('PPI::Token::Number');return 'Operator' if$prev and $prev->isa('PPI::Token::ArrayIndex');my$next_char=substr($t->{line},$t->{line_cursor}+ 1,2);return 'Operator' if$next_char =~ /<[^>]/;return 'Operator' if not $prev;my$prec=$prev->content;return 'QuoteLike::Readline' if ($prev->isa('PPI::Token::Structure')and $prec eq '(')or ($prev->isa('PPI::Token::Structure')and $prec eq ';')or ($prev->isa('PPI::Token::Word')and $prec eq 'while')or ($prev->isa('PPI::Token::Operator')and $prec eq '=')or ($prev->isa('PPI::Token::Operator')and $prec eq ',');if ($prev->isa('PPI::Token::Structure')and $prec eq '}'){pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G<(?!\d)\w+>/gc){return 'QuoteLike::Readline'}}return 'Operator'}elsif ($char==47){$t->_finalize_token if$t->{token};my$prev=$t->_last_significant_token;return 'Regexp::Match' if not $prev;my$prec=$prev->content;return 'Regexp::Match' if$prev->isa('PPI::Token::Operator');return 'Operator' if$prev->isa('PPI::Token::Symbol');if ($prec eq ']' and $prev->isa('PPI::Token::Structure')){return 'Operator'}return 'Operator' if$prev->isa('PPI::Token::Number');if ($prev->isa('PPI::Token::Structure')and ($prec eq '(' or $prec eq '{' or $prec eq ';')){return 'Regexp::Match'}if ($MATCHWORD{$prec}and $prev->isa('PPI::Token::Word')){return 'Regexp::Match'}my$next_char=substr$t->{line},$t->{line_cursor}+ 1,1;if (defined$next_char and length$next_char){if ($next_char =~ /(?:\^|\[|\\)/){return 'Regexp::Match'}}return 'Operator'}elsif ($char==120){if ($t->_current_x_is_operator){pos$t->{line}=$t->{line_cursor}+ 1;return 'Operator' if$t->{line}=~ m/\G(?:
  				\d  # x op with no whitespace e.g. 'x3'
  				|
  				(?!(  # negative lookahead
  					=>  # not on left of fat comma
  					|
  					\w  # not a word like "xyzzy"
  					|
  					\s  # not x op plus whitespace
  				))
  			)/gcx}return PPI::Token::Word->__TOKENIZER__commit($t)}elsif ($char==45){my$context=$t->_opcontext;if ($context eq 'operator'){return 'Operator'}else {return 'Unknown'}}elsif ($char >= 128){return 'PPI::Token::Word'->__TOKENIZER__commit($t)if$c =~ /\w/;return 'Whitespace' if$c =~ /\s/}PPI::Exception->throw("Encountered unexpected character '$char'")}sub __TOKENIZER__on_line_end {$_[1]->_finalize_token if $_[1]->{token}}1;
PPI_TOKEN_WHITESPACE

$fatpacked{"PPI/Token/Word.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_WORD';
  package PPI::Token::Word;use strict;use PPI::Token ();use PPI::Singletons qw'%OPERATOR %QUOTELIKE %KEYWORDS';our$VERSION='1.274';our@ISA="PPI::Token";sub literal {my$self=shift;my$word=$self->content;$word =~ s/\'/::/g;return$word}sub method_call {my$self=shift;my$previous=$self->sprevious_sibling;if ($previous and $previous->isa('PPI::Token::Operator')and $previous->content eq '->'){return 1}my$snext=$self->snext_sibling;return 0 unless$snext;if ($snext->isa('PPI::Structure::List')or $snext->isa('PPI::Token::Structure')or $snext->isa('PPI::Token::Operator')and ($snext->content eq ',' or $snext->content eq '=>')){return 0}if ($snext->isa('PPI::Token::Word')and $snext->content =~ m< \w :: \z >xms){return 1}return}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G(\w+(?:(?:\'|::)\w+)*(?:::)?)/gc){my$word=$1;if ($word =~ /^(\w+)'/ && $KEYWORDS{$1}){$word=$1}$t->{token}->{content}.= $word;$t->{line_cursor}+= length$word}if (__current_token_is_attribute($t)){$t->{class}=$t->{token}->set_class('Attribute');return$t->{class}->__TOKENIZER__commit($t)}my$word=$t->{token}->{content};if ($KEYWORDS{$word}){if ($t->__current_token_is_forced_word){$t->{class}=$t->{token}->set_class('Word');return$t->{class}->__TOKENIZER__on_char($t)}if ($QUOTELIKE{$word}){$t->{class}=$t->{token}->set_class($QUOTELIKE{$word});return$t->{class}->__TOKENIZER__on_char($t)}if ($OPERATOR{$word}){$t->{class}=$t->{token}->set_class('Operator');return$t->_finalize_token->__TOKENIZER__on_char($t)}}if ($word =~ /\:/){return$t->_finalize_token->__TOKENIZER__on_char($t)}my$char=substr($t->{line},$t->{line_cursor},1);if ($char eq ':'){$t->{token}->{content}.= ':';$t->{line_cursor}++;$t->{class}=$t->{token}->set_class('Label')}elsif ($word eq '_'){$t->{class}=$t->{token}->set_class('Magic')}$t->_finalize_token->__TOKENIZER__on_char($t)}sub __TOKENIZER__commit {my ($class,$t)=@_;pos$t->{line}=$t->{line_cursor};unless ($t->{line}=~ m/\G((?!\d)\w+(?:(?:\'|::)\w+)*(?:::)?)/gc){die sprintf "Fatal error... regex failed to match in '%s' when expected",substr$t->{line},$t->{line_cursor}}my$word=$1;if ($word =~ /^(\w+)'/ && $KEYWORDS{$1}){$word=$1}$t->{line_cursor}+= length$word;if (__current_token_is_attribute($t)){$t->_new_token('Attribute',$word);return ($t->{line_cursor}>= $t->{line_length})? 0 : $t->{class}->__TOKENIZER__on_char($t)}if ($word eq '__END__'){$t->_new_token('Separator',$1);$t->_finalize_token;$t->{zone}='PPI::Token::End';my$end_rest=substr($t->{line},$t->{line_cursor});$t->{line_cursor}=length$t->{line};if ($end_rest =~ /\n$/){chomp$end_rest;$t->_new_token('Comment',$end_rest)if length$end_rest;$t->_new_token('Whitespace',"\n")}else {$t->_new_token('Comment',$end_rest)if length$end_rest}$t->_finalize_token;return 0}if ($word eq '__DATA__'){$t->_new_token('Separator',"$1");$t->_finalize_token;$t->{zone}='PPI::Token::Data';my$data_rest=substr($t->{line},$t->{line_cursor});$t->{line_cursor}=length$t->{line};if ($data_rest =~ /\n$/){chomp$data_rest;$t->_new_token('Comment',$data_rest)if length$data_rest;$t->_new_token('Whitespace',"\n")}else {$t->_new_token('Comment',$data_rest)if length$data_rest}$t->_finalize_token;return 0}my$token_class;if ($word =~ /\:/){$token_class='Word'}elsif ($KEYWORDS{$word}and $t->__current_token_is_forced_word){$token_class='Word'}elsif ($QUOTELIKE{$word}){$t->_new_token($QUOTELIKE{$word},$word);return ($t->{line_cursor}>= $t->{line_length})? 0 : $t->{class}->__TOKENIZER__on_char($t)}elsif ($OPERATOR{$word}&& ($word ne 'x' || $t->_current_x_is_operator)){$token_class='Operator'}else {my@tokens=$t->_previous_significant_tokens(1);pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G(\s*:)(?!:)/gc){if ($tokens[0]and $tokens[0]->{content}eq 'sub'){$token_class='Word'}else {$word .= $1;$t->{line_cursor}+= length($1);$token_class='Label'}}elsif ($word eq '_'){$token_class='Magic'}else {$token_class='Word'}}$t->_new_token($token_class,$word);if ($t->{line_cursor}>= $t->{line_length}){$t->_finalize_token;return 0}$t->_finalize_token->__TOKENIZER__on_char($t)}sub __current_token_is_attribute {my ($t)=@_;my@tokens=$t->_previous_significant_tokens(1);return ($tokens[0]and ($tokens[0]->{_attribute}or $tokens[0]->isa('PPI::Token::Attribute')))}1;
PPI_TOKEN_WORD

$fatpacked{"PPI/Token/_QuoteEngine.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN__QUOTEENGINE';
  package PPI::Token::_QuoteEngine;use strict;use Carp ();our$VERSION='1.274';sub __TOKENIZER__on_char {my$class=shift;my$t=$_[0]->{token}? shift : return undef;my$rv=$t->{token}->_fill($t);return undef unless defined$rv;$t->_finalize_token;0}sub _scan_for_unescaped_character {my$class=shift;my$t=shift;my$char=(length $_[0]==1)? quotemeta shift : return undef;my$search=qr/(.*?(?<!\\)(?:\\\\)*$char)/;my$string='';while (exists$t->{line}){pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G$search/gc){$t->{line_cursor}+= length($1)- 1;return$string .$1}$string .= substr$t->{line},$t->{line_cursor};my$rv=$t->_fill_line('inscan');if ($rv){$t->{line_cursor}=0}elsif (defined$rv){return \$string}else {return undef}}return undef}sub _scan_for_brace_character {my$class=shift;my$t=shift;my$close_brace=$_[0]=~ /^(?:\>|\)|\}|\])$/ ? shift : Carp::confess('');my$open_brace=$close_brace;$open_brace =~ tr/\>\)\}\]/\<\(\{\[/;$close_brace=quotemeta$close_brace;$open_brace=quotemeta$open_brace;my$search=qr/\G(.*?(?<!\\)(?:\\\\)*(?:$open_brace|$close_brace))/;my$string='';my$depth=1;while (exists$t->{line}){pos$t->{line}=$t->{line_cursor};unless ($t->{line}=~ /$search/gc){$string .= substr($t->{line},$t->{line_cursor});my$rv=$t->_fill_line('inscan');if ($rv){$t->{line_cursor}=0;next}if (defined$rv){return \$string}return undef}$string .= $1;$t->{line_cursor}+= length $1;$depth += ($1 =~ /$open_brace$/)? 1 : -1 and next;$t->{line_cursor}-= 1;return$string}\$string}sub _scan_quote_like_operator_gap {my$t=$_[1];my$string='';while (exists$t->{line}){pos$t->{line}=$t->{line_cursor};$t->{line}=~ /\G(\s*(?:\#.*)?)/gc or return undef;$string .= $1;unless ($t->{line_cursor}+ length $1==length$t->{line}){$t->{line_cursor}+= length $1;return$string}my$rv=$t->_fill_line('inscan');if ($rv){$t->{line_cursor}=0}elsif (defined$rv){return \$string}else {return undef}}return undef}1;
PPI_TOKEN__QUOTEENGINE

$fatpacked{"PPI/Token/_QuoteEngine/Full.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN__QUOTEENGINE_FULL';
  package PPI::Token::_QuoteEngine::Full;use strict;use Clone ();use Carp ();use PPI::Token::_QuoteEngine ();our$VERSION='1.274';our@ISA='PPI::Token::_QuoteEngine';my%SECTIONS=('('=>{type=>'()',_close=>')' },'<'=>{type=>'<>',_close=>'>' },'['=>{type=>'[]',_close=>']' },'{'=>{type=>'{}',_close=>'}' },);my%QUOTES=('q'=>{operator=>'q',braced=>undef,separator=>undef,_sections=>1 },'qq'=>{operator=>'qq',braced=>undef,separator=>undef,_sections=>1 },'qx'=>{operator=>'qx',braced=>undef,separator=>undef,_sections=>1 },'qw'=>{operator=>'qw',braced=>undef,separator=>undef,_sections=>1 },'qr'=>{operator=>'qr',braced=>undef,separator=>undef,_sections=>1,modifiers=>1 },'m'=>{operator=>'m',braced=>undef,separator=>undef,_sections=>1,modifiers=>1 },'s'=>{operator=>'s',braced=>undef,separator=>undef,_sections=>2,modifiers=>1 },'tr'=>{operator=>'tr',braced=>undef,separator=>undef,_sections=>2,modifiers=>1 },'y'=>{operator=>'y',braced=>undef,separator=>undef,_sections=>2,modifiers=>1 },'/'=>{operator=>undef,braced=>0,separator=>'/',_sections=>1,modifiers=>1 },'<'=>{operator=>undef,braced=>1,separator=>undef,_sections=>1,},'?'=>{operator=>undef,braced=>0,separator=>'?',_sections=>1,modifiers=>1 },);sub new {my$class=shift;my$init=defined $_[0]? shift : Carp::croak("::Full->new called without init string");my$self=PPI::Token::new($class,$init)or return undef;my$options=$QUOTES{$init}or return$self->_error("Unknown quote type '$init'");for (keys %$options){$self->{$_}=$options->{$_}}$self->{modifiers}={}if$self->{modifiers};if ($init eq '<'){$self->{sections}->[0]=Clone::clone($SECTIONS{'<'})}$self}sub _fill {my$class=shift;my$t=shift;my$self=$t->{token}or Carp::croak("::Full->_fill called without current token");if ($self->{operator}){if (substr($t->{line},$t->{line_cursor},1)=~ /\s/){my$gap=$self->_scan_quote_like_operator_gap($t);return undef unless defined$gap;if (ref$gap){$self->{content}.= $$gap;return 0}$self->{content}.= $gap}my$sep=substr($t->{line},$t->{line_cursor}++,1);$self->{content}.= $sep;if (my$section=$SECTIONS{$sep}){$self->{braced}=1;$self->{sections}->[0]=Clone::clone($section)}else {$self->{braced}=0;$self->{separator}=$sep}}my$rv=$self->{braced}? $self->_fill_braced($t): $self->_fill_normal($t);return$rv if!$rv;return 1 unless$self->{modifiers};my$char;my$len=0;while (($char=substr($t->{line},$t->{line_cursor}+ 1,1))=~ /[^\W\d_]/){$len++;$self->{content}.= $char;$self->{modifiers}->{lc$char}=1;$t->{line_cursor}++}}sub _fill_normal {my$self=shift;my$t=shift;my$string=$self->_scan_for_unescaped_character($t,$self->{separator});return undef unless defined$string;if (ref$string){if (length($$string)> 1){my$str=$$string;chop$str;$self->{sections}->[0]={position=>length($self->{content}),size=>length($$string)- 1,type=>"$self->{separator}$self->{separator}",};$self->{_sections}=1}else {$self->{sections}=[];$self->{_sections}=0}$self->{content}.= $$string;return 0}$self->{sections}->[0]={position=>length$self->{content},size=>length($string)- 1,type=>"$self->{separator}$self->{separator}",};$self->{content}.= $string;return 1 if$self->{_sections}==1;$t->{line_cursor}++;$string=$self->_scan_for_unescaped_character($t,$self->{separator});return undef unless defined$string;if (ref$string){if (length($$string)> 1){my$str=$$string;chop$str;$self->{sections}->[1]={position=>length($self->{content}),size=>length($$string)- 1,type=>"$self->{separator}$self->{separator}",}}else {$self->{_sections}=1}$self->{content}.= $$string;return 0}$self->{sections}->[1]={position=>length($self->{content}),size=>length($string)- 1 };$self->{content}.= $string;1}sub _fill_braced {my$self=shift;my$t=shift;my$section=$self->{sections}->[0];my$brace_str=$self->_scan_for_brace_character($t,$section->{_close});return undef unless defined$brace_str;if (ref$brace_str){if (length($$brace_str)> 1){my$str=$$brace_str;chop$str;$self->{sections}->[0]={position=>length($self->{content}),size=>length($$brace_str)- 1,type=>$section->{type},};$self->{_sections}=1}else {$self->{sections}=[];$self->{_sections}=0}$self->{content}.= $$brace_str;return 0}$section->{position}=length$self->{content};$section->{size}=length($brace_str)- 1;$self->{content}.= $brace_str;delete$section->{_close};return 1 if$self->{_sections}==1;my$char=substr($t->{line},++$t->{line_cursor},1);if ($char =~ /\s/){my$gap_str=$self->_scan_quote_like_operator_gap($t);return undef unless defined$gap_str;if (ref$gap_str){$self->{content}.= $$gap_str;return 0}$self->{content}.= $gap_str;$char=substr($t->{line},$t->{line_cursor},1)}$section=$SECTIONS{$char};if ($section){$self->{content}.= $char;$section={%$section };$t->{line_cursor}++;$brace_str=$self->_scan_for_brace_character($t,$section->{_close});return undef unless defined$brace_str;if (ref$brace_str){if (length($$brace_str)> 1){my$str=$$brace_str;chop$str;$self->{sections}->[1]={position=>length($self->{content}),size=>length($$brace_str)- 1,type=>$section->{type},};$self->{_sections}=2}else {$self->{_sections}=1}$self->{content}.= $$brace_str;return 0}else {$self->{sections}->[1]={position=>length($self->{content}),size=>length($brace_str)- 1,type=>$section->{type},};$self->{content}.= $brace_str}}elsif ($char =~ m/ \A [^\w\s] \z /smx){$self->{content}.= $char;$t->{line_cursor}++;my$string=$self->_scan_for_unescaped_character($t,$char);return undef unless defined$string;if (ref$string){if (length($$string)> 1){my$str=$$string;chop$str;$self->{sections}->[1]={position=>length($self->{content}),size=>length($$string)- 1,type=>"$char$char",}}else {$self->{_sections}=1}$self->{content}.= $$string;return 0}$self->{sections}->[1]={position=>length($self->{content}),size=>length($string)- 1,type=>"$char$char",};$self->{content}.= $string}else {$self->{sections}->[1]={position=>length($self->{content}),size=>0,type=>'',};$self->{_error}="No second section of regexp, or does not start with a balanced character";$t->{line_cursor}--;return 0}1}sub _sections {wantarray ? @{$_[0]->{sections}}: scalar @{$_[0]->{sections}}}sub _section_content {my$self=shift;my$i=shift;$self->{sections}or return;my$section=$self->{sections}->[$i]or return;return substr($self->content,$section->{position},$section->{size})}sub _modifiers {my$self=shift;$self->{modifiers}or return;wantarray and return %{$self->{modifiers}};return +{%{$self->{modifiers}}}}sub _delimiters {my$self=shift;$self->{sections}or return;my@delims;for my$sect (@{$self->{sections}}){if (exists$sect->{type}){push@delims,$sect->{type}}else {my$content=$self->content;push@delims,substr($content,$sect->{position}- 1,1).substr($content,$sect->{position}+ $sect->{size},1)}}return@delims}1;
PPI_TOKEN__QUOTEENGINE_FULL

$fatpacked{"PPI/Token/_QuoteEngine/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN__QUOTEENGINE_SIMPLE';
  package PPI::Token::_QuoteEngine::Simple;use strict;use PPI::Token::_QuoteEngine ();our$VERSION='1.274';our@ISA='PPI::Token::_QuoteEngine';sub new {my$class=shift;my$separator=shift or return undef;my$self=PPI::Token::new($class,$separator)or return undef;$self->{separator}=$separator;$self}sub _fill {my$class=shift;my$t=shift;my$self=$t->{token}or return undef;my$string=$self->_scan_for_unescaped_character($t,$self->{separator});return undef unless defined$string;if (ref$string){$self->{content}.= $$string;return 0}else {$self->{content}.= $string;return$self}}1;
PPI_TOKEN__QUOTEENGINE_SIMPLE

$fatpacked{"PPI/Tokenizer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKENIZER';
  package PPI::Tokenizer;use strict;use Params::Util qw{_INSTANCE _SCALAR0 _ARRAY0};use List::Util 1.33 ();use PPI::Util ();use PPI::Element ();use PPI::Token ();use PPI::Exception ();use PPI::Exception::ParserRejection ();our$VERSION='1.274';my%X_CAN_FOLLOW_OPERATOR=map {$_=>1}qw(-- ++);my%X_CAN_FOLLOW_STRUCTURE=map {$_=>1}qw(} ] \));my%X_CAN_FOLLOW_WORD=map {$_=>1}qw(endgrent endhostent endnetent endprotoent endpwent endservent fork getgrent gethostent getlogin getnetent getppid getprotoent getpwent getservent setgrent setpwent time times wait wantarray __SUB__);sub new {my$class=ref($_[0])|| $_[0];my$self=bless {source=>undef,source_bytes=>undef,line=>undef,line_length=>undef,line_cursor=>undef,line_count=>0,token=>undef,class=>'PPI::Token::BOM',zone=>'PPI::Token::Whitespace',tokens=>[],token_cursor=>0,token_eof=>0,perl6=>[],},$class;if (!defined $_[1]){PPI::Exception->throw("No source provided to Tokenizer")}elsif (!ref $_[1]){my$source=PPI::Util::_slurp($_[1]);if (ref$source){$self->{source}=$$source}else {return($source)}}elsif (_SCALAR0($_[1])){$self->{source}=${$_[1]}}elsif (_ARRAY0($_[1])){$self->{source}=join '',map {"\n"}@{$_[1]}}else {PPI::Exception->throw(ref($_[1])." is not supported as a source provider")}$self->{source_bytes}=length$self->{source};if ($self->{source_bytes}){$self->{source}=~ s/(?:\015{1,2}\012|\015|\012)/\n/g;$self->{source}=[split /(?<=\n)/,$self->{source}]}else {$self->{source}=[]}if (List::Util::any {/^__(?:DATA|END)__\s*$/}@{$self->{source}}){$self->{source_eof_chop}=''}elsif (!defined$self->{source}->[0]){$self->{source_eof_chop}=''}elsif ($self->{source}->[-1]=~ /\s$/){$self->{source_eof_chop}=''}else {$self->{source_eof_chop}=1;$self->{source}->[-1].= ' '}$self}sub get_token {my$self=shift;if ($self->{token_eof}and $self->{token_cursor}> scalar @{$self->{tokens}}){return 0}if (my$token=$self->{tokens}->[$self->{token_cursor}]){$self->{token_cursor}++;return$token}my$line_rv;my$rv=eval {while ($line_rv=$self->_process_next_line){if (defined(my$token=$self->{tokens}->[$self->{token_cursor}])){$self->{token_cursor}++;return$token}}return undef};if ($@){if (_INSTANCE($@,'PPI::Exception')){$@->throw}else {my$errstr=$@;$errstr =~ s/^(.*) at line .+$/$1/;PPI::Exception->throw($errstr)}}elsif ($rv){return$rv}if (defined$line_rv){if (my$token=$self->{tokens}->[$self->{token_cursor}]){$self->{token_cursor}++;return$token}$self->{token_eof}=1;return 0}undef}sub all_tokens {my$self=shift;my$ok=eval {unless ($self->{token_eof}){my$rv;while ($rv=$self->_process_next_line){}unless (defined$rv){PPI::Exception->throw("Error while processing source")}$self->_clean_eof}1};if (!$ok){my$errstr=$@;$errstr =~ s/^(.*) at line .+$/$1/;PPI::Exception->throw($errstr)}return [@{$self->{tokens}}]}sub increment_cursor {$_[0]->get_token and 1}sub decrement_cursor {my$self=shift;return 0 unless$self->{token_cursor};$self->{token_eof}=0;--$self->{token_cursor}}sub _get_line {my$self=shift;return undef unless$self->{source};my$line=shift @{$self->{source}};$self->{source}=undef unless defined$line;return$line}sub _fill_line {my$self=shift;my$inscan=shift;my$line=$self->_get_line;unless (defined$line){unless ($inscan){delete$self->{line};delete$self->{line_cursor};delete$self->{line_length};return 0}$self->{line_cursor}=$self->{line_length};return 0}$self->{line}=$line;$self->{line_cursor}=-1;$self->{line_length}=length$line;$self->{line_count}++;1}sub _char {my$self=shift;substr($self->{line},$self->{line_cursor},1)}sub _process_next_line {my$self=shift;my$rv;unless ($rv=$self->_fill_line){return undef unless defined$rv;$self->_finalize_token;return 0}$rv=$self->{class}->__TOKENIZER__on_line_start($self);unless ($rv){if (ref$self->{source}eq 'ARRAY' and!@{$self->{source}}){$self->_clean_eof}return 1 if defined$rv;PPI::Exception->throw("Error at line $self->{line_count}")}while ($rv=$self->_process_next_char){}unless (defined$rv){PPI::Exception->throw("Error at line $self->{line_count}, character $self->{line_cursor}")}$self->{class}->__TOKENIZER__on_line_end($self);unless (ref($self->{source})eq 'ARRAY' and @{$self->{source}}){return$self->_clean_eof}return 1}sub _process_next_char {my$self=shift;if (!defined$self->{line_cursor}or!defined$self->{line_length}){return undef}return 0 if ++$self->{line_cursor}>= $self->{line_length};my$result;unless ($result=$self->{class}->__TOKENIZER__on_char($self)){return defined$result ? 1 : undef}my$char=substr($self->{line},$self->{line_cursor},1);if ($result eq '1'){if (defined$self->{token}){$self->{token}->{content}.= $char}else {defined($self->{token}=$self->{class}->new($char))or return undef}return 1}if ($self->{class}ne "PPI::Token::$result"){$self->_new_token($result,$char)}elsif (defined$self->{token}){$self->{token}->{content}.= $char}else {defined($self->{token}=$self->{class}->new($char))or return undef}1}sub _finalize_token {my$self=shift;return$self->{class}unless defined$self->{token};push @{$self->{tokens}},$self->{token};$self->{token}=undef;$self->{class}=$self->{zone}}sub _new_token {my$self=shift;my$class=substr($_[0],0,12)eq 'PPI::Token::' ? shift : 'PPI::Token::' .shift;$self->_finalize_token if defined$self->{token};defined($self->{token}=$class->new($_[0]))or PPI::Exception->throw;$self->{class}=$class;1}sub _clean_eof {my$self=shift;$self->_finalize_token if$self->{token};my$last_token=$self->{tokens}->[-1 ];unless (length$last_token->{content}){pop @{$self->{tokens}}}if ($self->{source_eof_chop}){$last_token=$self->{tokens}->[-1 ];$last_token->{content}=~ s/ $//;unless (length$last_token->{content}){pop @{$self->{tokens}}}$self->{source_eof_chop}=''}1}sub _last_token {$_[0]->{tokens}->[-1]}sub _last_significant_token {my$self=shift;my$cursor=$#{$self->{tokens}};while ($cursor >= 0){my$token=$self->{tokens}->[$cursor--];return$token if$token->significant}return}sub _previous_significant_tokens {my$self=shift;my$count=shift || 1;my$cursor=$#{$self->{tokens}};my@tokens;while ($cursor >= 0){my$token=$self->{tokens}->[$cursor--];next if not $token->significant;push@tokens,$token;last if@tokens >= $count}return@tokens}my%OBVIOUS_CLASS=('PPI::Token::Symbol'=>'operator','PPI::Token::Magic'=>'operator','PPI::Token::Number'=>'operator','PPI::Token::ArrayIndex'=>'operator','PPI::Token::Quote::Double'=>'operator','PPI::Token::Quote::Interpolate'=>'operator','PPI::Token::Quote::Literal'=>'operator','PPI::Token::Quote::Single'=>'operator','PPI::Token::QuoteLike::Backtick'=>'operator','PPI::Token::QuoteLike::Command'=>'operator','PPI::Token::QuoteLike::Readline'=>'operator','PPI::Token::QuoteLike::Regexp'=>'operator','PPI::Token::QuoteLike::Words'=>'operator',);my%OBVIOUS_CONTENT=('('=>'operand','{'=>'operand','['=>'operand',';'=>'operand','}'=>'operator',);my%USUALLY_FORCES=map {$_=>1}qw(sub package use no);sub _opcontext {my$self=shift;my@tokens=$self->_previous_significant_tokens(1);my$p0=$tokens[0];return '' if not $p0;my$c0=ref$p0;return$OBVIOUS_CLASS{$c0}if defined$OBVIOUS_CLASS{$c0};return$OBVIOUS_CONTENT{$p0}if defined$OBVIOUS_CONTENT{$p0};return 'operand' if$p0->isa('PPI::Token::Operator');return 'operand' if$p0->content eq '';return ''}sub _current_x_is_operator {my ($self)=@_;return if!@{$self->{tokens}};my ($prev,$prevprev)=$self->_previous_significant_tokens(2);return if!$prev;return!$self->__current_token_is_forced_word if$prev->isa('PPI::Token::Word');return (!$prev->isa('PPI::Token::Operator')|| $X_CAN_FOLLOW_OPERATOR{$prev})&& (!$prev->isa('PPI::Token::Structure')|| $X_CAN_FOLLOW_STRUCTURE{$prev})&&!$prev->isa('PPI::Token::Label')}sub __current_token_is_forced_word {my ($t,$word)=@_;my ($prev,$prevprev)=$t->_previous_significant_tokens(2);if (!$prev){pos$t->{line}=$t->{line_cursor}}else {my$content=$prev->{content};return 1 if$content eq '->';pos$t->{line}=$t->{line_cursor};return 1 if$content eq '{' and $t->{line}=~ /\G\s*\}/gc;if($USUALLY_FORCES{$content}){return if defined$word and $word =~ /^v[0-9]+$/ and ($content eq "use" or $content eq "no");return 1 if not $prevprev;return 1 if not $USUALLY_FORCES{$prevprev->content}and $prevprev->content ne '->';return}}return 1 if$t->{line}=~ /\G\s*=>/gc;return ''}1;
PPI_TOKENIZER

$fatpacked{"PPI/Transform.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TRANSFORM';
  package PPI::Transform;use strict;use Carp ();use List::Util ();use PPI::Document ();use Params::Util qw{_INSTANCE _CLASS _CODE _SCALAR0};our$VERSION='1.274';my%HANDLER;my@ORDER;sub register_apply_handler {my$class=shift;my$handler=_CLASS(shift)or Carp::croak("Invalid PPI::Transform->register_apply_handler param");my$get=_CODE(shift)or Carp::croak("Invalid PPI::Transform->register_apply_handler param");my$set=_CODE(shift)or Carp::croak("Invalid PPI::Transform->register_apply_handler param");if ($HANDLER{$handler}){Carp::croak("PPI::Transform->apply handler '$handler' already exists")}$HANDLER{$handler}=[$get,$set ];unshift@ORDER,$handler}__PACKAGE__->register_apply_handler('SCALAR',\&_SCALAR_get,\&_SCALAR_set);__PACKAGE__->register_apply_handler('PPI::Document',sub {$_[0]},sub() {1});sub new {my$class=shift;bless {@_ },$class}sub document {my$class=shift;die "$class does not implement the required ->document method"}sub apply {my$self=_SELF(shift);my$it=defined $_[0]? shift : return undef;my$class=_SCALAR0($it)? 'SCALAR' : List::Util::first {_INSTANCE($it,$_)}@ORDER or return undef;my$handler=$HANDLER{$class}or die("->apply handler for $class missing! Panic");my$Document=_INSTANCE($handler->[0]->($it),'PPI::Document')or Carp::croak("->apply handler for $class failed to get a PPI::Document");$self->document($Document)or return undef;$handler->[1]->($it,$Document)or Carp::croak("->apply handler for $class failed to save the changed document");1}sub file {my$self=_SELF(shift);my$input=defined $_[0]? shift : return undef;my$output=@_ ? defined $_[0]? "$_[0]" : undef : $input or return undef;my$Document=PPI::Document->new("$input")or return undef;$self->document($Document)or return undef;$Document->save($output)}sub _SCALAR_get {PPI::Document->new($_[0])}sub _SCALAR_set {my$it=shift;$$it=$_[0]->serialize;1}sub _SELF {return shift if ref $_[0];my$self=$_[0]->new or Carp::croak("Failed to auto-instantiate new $_[0] object");$self}1;
PPI_TRANSFORM

$fatpacked{"PPI/Transform/UpdateCopyright.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TRANSFORM_UPDATECOPYRIGHT';
  package PPI::Transform::UpdateCopyright;use strict;use Params::Util qw{_STRING};use PPI::Transform ();our$VERSION='1.274';sub new {my$self=shift->SUPER::new(@_);unless (defined _STRING($self->name)){PPI::Exception->throw("Did not provide a valid name param")}return$self}sub name {$_[0]->{name}}sub document {my$self=shift;my$document=_INSTANCE(shift,'PPI::Document')or return undef;my$name=quotemeta$self->name;my$regexp=qr/\bcopyright\b.*$name/m;my$elements=$document->find(sub {$_[1]->isa('PPI::Token::Pod')or return '';$_[1]->content =~ $regexp or return '';return 1});return undef unless defined$elements;return 0 unless$elements;my$changes=0;my$change=sub {my$copyright=shift;my$thisyear=(localtime time)[5]+ 1900;my@year=$copyright =~ m/(\d{4})/g;if (@year==1){if ($year[0]==$thisyear){return$copyright}else {$changes++;$copyright =~ s/(\d{4})/$1 - $thisyear/;return$copyright}}if (@year==2){if ($year[1]==$thisyear){return$copyright}else {$changes++;$copyright =~ s/$year[1]/$thisyear/;return$copyright}}die "Invalid or unknown copyright line '$copyright'"};my$pattern=qr/\b(copyright.*\d)({4}(?:\s*-\s*\d{4})?)(.*$name)/mi;for my$element (@$elements){$element =~ s/$pattern/$1 . $change->($2) . $2/eg}return$changes}1;
PPI_TRANSFORM_UPDATECOPYRIGHT

$fatpacked{"PPI/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_UTIL';
  package PPI::Util;use strict;use Exporter ();use Digest::MD5 ();use Params::Util qw{_INSTANCE _SCALAR0 _ARRAY0};our$VERSION='1.274';our@ISA='Exporter';our@EXPORT_OK=qw{_Document _slurp};use constant HAVE_UNICODE=>!!($] >= 5.008007);sub TRUE () {1}sub FALSE () {''}sub _Document {shift if @_ > 1;return undef unless defined $_[0];require PPI::Document;return PPI::Document->new(shift)unless ref $_[0];return PPI::Document->new(shift)if _SCALAR0($_[0]);return PPI::Document->new(shift)if _ARRAY0($_[0]);return shift if _INSTANCE($_[0],'PPI::Document');return undef}sub _slurp {my$file=shift;local $/=undef;local*FILE;open(FILE,'<',$file)or return "open($file) failed: $!";my$source=<FILE>;close(FILE)or return "close($file) failed: $!";return \$source}sub md5hex {my$string=shift;$string =~ s/(?:\015{1,2}\012|\015|\012)/\015/gs;Digest::MD5::md5_hex($string)}sub md5hex_file {my$file=shift;my$content=_slurp($file);return undef unless ref$content;$$content =~ s/(?:\015{1,2}\012|\015|\012)/\n/gs;md5hex($$content)}1;
PPI_UTIL

$fatpacked{"PPI/XSAccessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_XSACCESSOR';
  package PPI::XSAccessor;use 5.006;use strict;use PPI ();our$VERSION='1.274';package PPI::Document;use Class::XSAccessor replace=>1,getters=>{readonly=>'readonly',},true=>['scope' ];package PPI::Document::File;use Class::XSAccessor replace=>1,getters=>{filename=>'filename',};package PPI::Document::Fragment;use Class::XSAccessor replace=>1,false=>['scope',];package PPI::Document::Normalized;use Class::XSAccessor replace=>1,getters=>{'_Document'=>'Document','version'=>'version','functions'=>'functions',};package PPI::Element;use Class::XSAccessor replace=>1,true=>['significant',];package PPI::Exception;use Class::XSAccessor replace=>1,getters=>{message=>'message',};package PPI::Node;use Class::XSAccessor replace=>1,false=>['scope',];package PPI::Normal;use Class::XSAccessor replace=>1,getters=>{'layer'=>'layer',};package PPI::Statement;use Class::XSAccessor replace=>1,true=>['__LEXER__normal',];package PPI::Statement::Compound;use Class::XSAccessor replace=>1,true=>['scope',],false=>['__LEXER__normal',];package PPI::Statement::Data;use Class::XSAccessor replace=>1,false=>['_complete',];package PPI::Statement::End;use Class::XSAccessor replace=>1,true=>['_complete',];package PPI::Statement::Given;use Class::XSAccessor replace=>1,true=>['scope',],false=>['__LEXER__normal',];package PPI::Token;use Class::XSAccessor replace=>1,getters=>{content=>'content',},setters=>{set_content=>'content',},true=>['__TOKENIZER__on_line_start','__TOKENIZER__on_line_end',];1;
PPI_XSACCESSOR

$fatpacked{"Params/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARAMS_UTIL';
  package Params::Util;use 5.00503;use strict;use warnings;use parent qw{Exporter XSLoader};use Params::Util::PP qw();our$VERSION='1.102';local$ENV{PERL_DL_NONLAZY}=0 if$ENV{PERL_DL_NONLAZY};XSLoader::load("Params::Util",$VERSION)unless$ENV{PERL_PARAMS_UTIL_PP};our@EXPORT_OK=qw{_STRING _IDENTIFIER _CLASS _CLASSISA _SUBCLASS _DRIVER _CLASSDOES _NUMBER _POSINT _NONNEGINT _SCALAR _SCALAR0 _ARRAY _ARRAY0 _ARRAYLIKE _HASH _HASH0 _HASHLIKE _CODE _CODELIKE _INVOCANT _REGEX _INSTANCE _INSTANCEDOES _SET _SET0 _HANDLE};our%EXPORT_TAGS=(ALL=>\@EXPORT_OK);no strict "refs";Params::Util->can($_)or *$_=Params::Util::PP->can($_)for (@EXPORT_OK);use strict "refs";1;
PARAMS_UTIL

$fatpacked{"Params/Util/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARAMS_UTIL_PP';
  package Params::Util::PP;use strict;use warnings;our$VERSION='1.102';use Scalar::Util ();use overload ();Scalar::Util->can("looks_like_number")and Scalar::Util->import("looks_like_number");Params::Util::PP->can("looks_like_number")or *looks_like_number=sub {local $_=shift;return 0 if!defined($_);if (ref($_)){return overload::Overloaded($_)? defined(0 + $_): 0}return 1 if (/^[+-]?[0-9]+$/);return 1 if (/^(?:[+-]?)(?=[0-9]|\.[0-9])[0-9]*(?:\.[0-9]*)?(?:[Ee](?:[+-]?[0-9]+))?$/);return 1 if ($] >= 5.008 and /^(?:Inf(?:inity)?|NaN)$/i)or ($] >= 5.006001 and /^Inf$/i);0};sub _XScompiled {return 0}sub _STRING ($) {my$arg=$_[0];return (defined$arg and not ref$arg and length($arg))? $arg : undef}sub _IDENTIFIER ($) {my$arg=$_[0];return (defined$arg and not ref$arg and $arg =~ m/^[^\W\d]\w*\z/s)? $arg : undef}sub _CLASS ($) {my$arg=$_[0];return (defined$arg and not ref$arg and $arg =~ m/^[^\W\d]\w*(?:::\w+)*\z/s)? $arg : undef}sub _CLASSISA ($$) {return (defined $_[0]and not ref $_[0]and $_[0]=~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->isa($_[1]))? $_[0]: undef}sub _CLASSDOES ($$) {return (defined $_[0]and not ref $_[0]and $_[0]=~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->DOES($_[1]))? $_[0]: undef}sub _SUBCLASS ($$) {return (defined $_[0]and not ref $_[0]and $_[0]=~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]ne $_[1]and $_[0]->isa($_[1]))? $_[0]: undef}sub _NUMBER ($) {my$arg=$_[0];return (defined$arg and not ref$arg and looks_like_number($arg))? $arg : undef}sub _POSINT ($) {my$arg=$_[0];return (defined$arg and not ref$arg and $arg =~ m/^[1-9]\d*$/)? $arg : undef}sub _NONNEGINT ($) {my$arg=$_[0];return (defined$arg and not ref$arg and $arg =~ m/^(?:0|[1-9]\d*)$/)? $arg : undef}sub _SCALAR ($) {return (ref $_[0]eq 'SCALAR' and defined ${$_[0]}and ${$_[0]}ne '')? $_[0]: undef}sub _SCALAR0 ($) {return ref $_[0]eq 'SCALAR' ? $_[0]: undef}sub _ARRAY ($) {return (ref $_[0]eq 'ARRAY' and @{$_[0]})? $_[0]: undef}sub _ARRAY0 ($) {return ref $_[0]eq 'ARRAY' ? $_[0]: undef}sub _ARRAYLIKE {return (defined $_[0]and ref $_[0]and ((Scalar::Util::reftype($_[0])eq 'ARRAY')or overload::Method($_[0],'@{}')))? $_[0]: undef}sub _HASH ($) {return (ref $_[0]eq 'HASH' and scalar %{$_[0]})? $_[0]: undef}sub _HASH0 ($) {return ref $_[0]eq 'HASH' ? $_[0]: undef}sub _HASHLIKE {return (defined $_[0]and ref $_[0]and ((Scalar::Util::reftype($_[0])eq 'HASH')or overload::Method($_[0],'%{}')))? $_[0]: undef}sub _CODE ($) {return ref $_[0]eq 'CODE' ? $_[0]: undef}sub _CODELIKE($) {return ((Scalar::Util::reftype($_[0])|| '')eq 'CODE' or Scalar::Util::blessed($_[0])and overload::Method($_[0],'&{}'))? $_[0]: undef}sub _INVOCANT($) {return (defined $_[0]and (defined Scalar::Util::blessed($_[0])or _CLASS($_[0])))? $_[0]: undef}sub _INSTANCE ($$) {return (Scalar::Util::blessed($_[0])and $_[0]->isa($_[1]))? $_[0]: undef}sub _INSTANCEDOES ($$) {return (Scalar::Util::blessed($_[0])and $_[0]->DOES($_[1]))? $_[0]: undef}sub _REGEX ($) {return (defined $_[0]and 'Regexp' eq ref($_[0]))? $_[0]: undef}sub _SET ($$) {my$set_param=shift;_ARRAY($set_param)or return undef;for my$item (@$set_param){_INSTANCE($item,$_[0])or return undef}return$set_param}sub _SET0 ($$) {my$set_param=shift;_ARRAY0($set_param)or return undef;for my$item (@$set_param){_INSTANCE($item,$_[0])or return undef}return$set_param}sub _HANDLE {my$it=shift;unless (defined$it){return undef}if (ref$it eq 'GLOB'){return$it}if (tied($it)and tied($it)->can('TIEHANDLE')){return$it}unless (Scalar::Util::blessed($it)){return undef}if ($it->isa('IO::Handle')){return$it}if ($it->isa('Tie::Handle')){return$it}if ($it->isa('IO::Scalar')){return$it}if ($it->isa('IO::String')){return$it}return undef}sub _DRIVER ($$) {return (defined _CLASS($_[0])and eval "require $_[0];" and not $@ and $_[0]->isa($_[1])and $_[0]ne $_[1])? $_[0]: undef}1;
PARAMS_UTIL_PP

$fatpacked{"Parse/CPAN/Meta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARSE_CPAN_META';
  use 5.008001;use strict;use warnings;package Parse::CPAN::Meta;our$VERSION='2.150010';use Exporter;use Carp 'croak';our@ISA=qw/Exporter/;our@EXPORT_OK=qw/Load LoadFile/;sub load_file {my ($class,$filename)=@_;my$meta=_slurp($filename);if ($filename =~ /\.ya?ml$/){return$class->load_yaml_string($meta)}elsif ($filename =~ /\.json$/){return$class->load_json_string($meta)}else {$class->load_string($meta)}}sub load_string {my ($class,$string)=@_;if ($string =~ /^---/){return$class->load_yaml_string($string)}elsif ($string =~ /^\s*\{/){return$class->load_json_string($string)}else {return$class->load_yaml_string($string)}}sub load_yaml_string {my ($class,$string)=@_;my$backend=$class->yaml_backend();my$data=eval {no strict 'refs';&{"$backend\::Load"}($string)};croak $@ if $@;return$data || {}}sub load_json_string {my ($class,$string)=@_;require Encode;my$encoded=Encode::encode('UTF-8',$string,Encode::PERLQQ());my$data=eval {$class->json_decoder()->can('decode_json')->($encoded)};croak $@ if $@;return$data || {}}sub yaml_backend {if ($ENV{PERL_CORE}or not defined$ENV{PERL_YAML_BACKEND}){_can_load('CPAN::Meta::YAML',0.011)or croak "CPAN::Meta::YAML 0.011 is not available\n";return "CPAN::Meta::YAML"}else {my$backend=$ENV{PERL_YAML_BACKEND};_can_load($backend)or croak "Could not load PERL_YAML_BACKEND '$backend'\n";$backend->can("Load")or croak "PERL_YAML_BACKEND '$backend' does not implement Load()\n";return$backend}}sub json_decoder {if ($ENV{PERL_CORE}){_can_load('JSON::PP'=>2.27300)or croak "JSON::PP 2.27300 is not available\n";return 'JSON::PP'}if (my$decoder=$ENV{CPAN_META_JSON_DECODER}){_can_load($decoder)or croak "Could not load CPAN_META_JSON_DECODER '$decoder'\n";$decoder->can('decode_json')or croak "No decode_json sub provided by CPAN_META_JSON_DECODER '$decoder'\n";return$decoder}return $_[0]->json_backend}sub json_backend {if ($ENV{PERL_CORE}){_can_load('JSON::PP'=>2.27300)or croak "JSON::PP 2.27300 is not available\n";return 'JSON::PP'}if (my$backend=$ENV{CPAN_META_JSON_BACKEND}){_can_load($backend)or croak "Could not load CPAN_META_JSON_BACKEND '$backend'\n";$backend->can('new')or croak "No constructor provided by CPAN_META_JSON_BACKEND '$backend'\n";return$backend}if (!$ENV{PERL_JSON_BACKEND}or $ENV{PERL_JSON_BACKEND}eq 'JSON::PP'){_can_load('JSON::PP'=>2.27300)or croak "JSON::PP 2.27300 is not available\n";return 'JSON::PP'}else {_can_load('JSON'=>2.5)or croak "JSON 2.5 is required for " ."\$ENV{PERL_JSON_BACKEND} = '$ENV{PERL_JSON_BACKEND}'\n";return "JSON"}}sub _slurp {require Encode;open my$fh,"<:raw","$_[0]" or die "can't open $_[0] for reading: $!";my$content=do {local $/;<$fh>};$content=Encode::decode('UTF-8',$content,Encode::PERLQQ());return$content}sub _can_load {my ($module,$version)=@_;(my$file=$module)=~ s{::}{/}g;$file .= ".pm";return 1 if$INC{$file};return 0 if exists$INC{$file};eval {require$file;1}or return 0;if (defined$version){eval {$module->VERSION($version);1}or return 0}return 1}sub LoadFile ($) {return Load(_slurp(shift))}sub Load ($) {require CPAN::Meta::YAML;my$object=eval {CPAN::Meta::YAML::Load(shift)};croak $@ if $@;return$object}1;
PARSE_CPAN_META

$fatpacked{"Parser/MGC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARSER_MGC';
  package Parser::MGC 0.19;use v5.14;use warnings;use Carp;use Feature::Compat::Try;use File::Slurp::Tiny qw(read_file);use Scalar::Util qw(blessed);my@patterns=qw(ws comment int float ident string_delim);use constant pattern_ws=>qr/[\s\n\t]+/;use constant pattern_comment=>undef;use constant pattern_int=>qr/-?(?:0x[[:xdigit:]]+|[[:digit:]]+)/;use constant pattern_float=>qr/-?(?:\d*\.\d+|\d+\.)(?:e-?\d+)?|-?\d+e-?\d+/i;use constant pattern_ident=>qr/[[:alpha:]_]\w*/;use constant pattern_string_delim=>qr/["']/;sub new {my$class=shift;my%args=@_;my$toplevel=$args{toplevel}|| "parse";$class->can($toplevel)or croak "Expected to be a subclass that can ->$toplevel";my$self=bless {toplevel=>$toplevel,patterns=>{},scope_level=>0,},$class;$self->{patterns}{$_}=$args{patterns}{$_}|| $self->${\"pattern_$_"}for@patterns;if($args{accept_0o_oct}){$self->{patterns}{int}=qr/0o[0-7]+|$self->{patterns}{int}/}if(defined$self->{patterns}{comment}){$self->{patterns}{_skip}=qr/$self->{patterns}{ws}|$self->{patterns}{comment}/}else {$self->{patterns}{_skip}=$self->{patterns}{ws}}return$self}sub from_string {my$self=shift;my ($str)=@_;$self->{str}=$str;pos$self->{str}=0;my$toplevel=$self->{toplevel};my$result=$self->$toplevel;$self->at_eos or $self->fail("Expected end of input");return$result}sub from_file {my$self=shift;my ($file,%opts)=@_;defined$file or croak "Expected a filename to ->from_file";$self->{filename}=$file;$self->from_string(ref$file ? do {local $/;binmode$file,$opts{binmode}if$opts{binmode};<$file>}: (read_file$file,binmode=>$opts{binmode}))}sub from_reader {my$self=shift;my ($reader)=@_;local$self->{reader}=$reader;$self->{str}="";pos$self->{str}=0;my$result=$self->parse;$self->at_eos or $self->fail("Expected end of input");return$result}sub pos {my$self=shift;return pos$self->{str}}sub take {my$self=shift;my ($len)=@_;my$start=pos($self->{str});pos($self->{str})+= $len;return substr($self->{str},$start,$len)}sub where {my$self=shift;my ($pos)=@_;defined$pos or $pos=pos$self->{str};my$str=$self->{str};my$sol=$pos;$sol-- if$sol > 0 and substr($str,$sol,1)=~ m/^[\r\n]$/;$sol-- while$sol > 0 and substr($str,$sol-1,1)!~ m/^[\r\n]$/;my$eol=$pos;$eol++ while$eol < length($str)and substr($str,$eol,1)!~ m/^[\r\n]$/;my$line=substr($str,$sol,$eol - $sol);my$col=$pos - $sol;my$lineno=(()=substr($str,0,$pos)=~ m/\n/g)+ 1;return ($lineno,$col,$line)}sub fail {my$self=shift;my ($message)=@_;$self->fail_from($self->pos,$message)}sub fail_from {my$self=shift;my ($pos,$message)=@_;die Parser::MGC::Failure->new($message,$self,$pos)}sub _isa_failure {blessed $_[0]and $_[0]->isa("Parser::MGC::Failure")}sub at_eos {my$self=shift;my$pos=pos$self->{str};$self->skip_ws;my$at_eos;if(pos($self->{str})>= length$self->{str}){$at_eos=1}elsif(defined$self->{endofscope}){$at_eos=$self->{str}=~ m/\G$self->{endofscope}/}else {$at_eos=0}pos($self->{str})=$pos;return$at_eos}sub scope_level {my$self=shift;return$self->{scope_level}}sub maybe {my$self=shift;my ($code)=@_;my$pos=pos$self->{str};my$committed=0;local$self->{committer}=sub {$committed++};try {return$self->$code}catch ($e){pos($self->{str})=$pos;die$e if$committed or not _isa_failure($e);return undef}}sub scope_of {my$self=shift;$self->_scope_of(0,@_)}sub _scope_of {my$self=shift;my ($commit_if_started,$start,$code,$stop)=@_;ref$stop or $stop=qr/\Q$stop/;$self->expect($start)if defined$start;$self->commit if$commit_if_started;local$self->{endofscope}=$stop;local$self->{scope_level}=$self->{scope_level}+ 1;my$ret=$self->$code;$self->expect($stop);return$ret}sub committed_scope_of {my$self=shift;$self->_scope_of(1,@_)}sub list_of {my$self=shift;my ($sep,$code)=@_;ref$sep or $sep=qr/\Q$sep/ if defined$sep;my$committed;local$self->{committer}=sub {$committed++};my@ret;while(!$self->at_eos){$committed=0;my$pos=pos$self->{str};try {push@ret,$self->$code;next}catch ($e){pos($self->{str})=$pos;die$e if$committed or not _isa_failure($e);last}}continue {if(defined$sep){$self->skip_ws;$self->{str}=~ m/\G$sep/gc or last}}return \@ret}sub sequence_of {my$self=shift;my ($code)=@_;$self->list_of(undef,$code)}sub any_of {my$self=shift;while(@_){my$code=shift;my$pos=pos$self->{str};my$committed=0;local$self->{committer}=sub {$committed++};try {return$self->$code}catch ($e){pos($self->{str})=$pos;die$e if$committed or not _isa_failure($e)}}$self->fail("Found nothing parseable")}sub one_of {croak "Parser::MGC->one_of is deprecated; use ->any_of instead"}sub commit {my$self=shift;if($self->{committer}){$self->{committer}->()}else {croak "Cannot commit except within a backtrack-able structure"}}sub skip_ws {my$self=shift;my$pattern=$self->{patterns}{_skip};{1 while$self->{str}=~ m/\G$pattern/gc;return if pos($self->{str})< length$self->{str};return unless$self->{reader};my$more=$self->{reader}->($self);if(defined$more){my$pos=pos($self->{str});$self->{str}.= $more;pos($self->{str})=$pos;redo}undef$self->{reader};return}}sub maybe_expect {my$self=shift;my ($expect)=@_;ref$expect or $expect=qr/\Q$expect/;$self->skip_ws;$self->{str}=~ m/\G$expect/gc or return;return substr($self->{str},$-[0],$+[0]-$-[0])if!wantarray;return map {defined $-[$_]? substr($self->{str},$-[$_],$+[$_]-$-[$_]): undef}0 .. $#+}sub expect {my$self=shift;my ($expect)=@_;ref$expect or $expect=qr/\Q$expect/;if(wantarray){my@ret=$self->maybe_expect($expect)or $self->fail("Expected $expect");return@ret}else {defined(my$ret=$self->maybe_expect($expect))or $self->fail("Expected $expect");return$ret}}sub substring_before {my$self=shift;my ($expect)=@_;ref$expect or $expect=qr/\Q$expect/;my$endre=(defined$self->{endofscope})? qr/$expect|$self->{endofscope}/ : $expect;my$start=pos$self->{str};my$end;if($self->{str}=~ m/\G(?s:.*?)($endre)/){$end=$-[1]}else {$end=length$self->{str}}return$self->take($end - $start)}sub generic_token {my$self=shift;my ($name,$re,$convert)=@_;$self->fail("Expected $name")if$self->at_eos;$self->skip_ws;$self->{str}=~ m/\G$re/gc or $self->fail("Expected $name");my$match=substr($self->{str},$-[0],$+[0]- $-[0]);return$convert ? $convert->($self,$match): $match}sub _token_generic {my$self=shift;my%args=@_;my$name=$args{name};my$re=$args{pattern}? $self->{patterns}{$args{pattern}}: $args{re};my$convert=$args{convert};$self->generic_token($name,$re,$convert)}sub token_int {my$self=shift;$self->_token_generic(name=>"int",pattern=>"int",convert=>sub {my$int=$_[1];my$sign=($int =~ s/^-//)? -1 : 1;$int =~ s/^0o/0/;return$sign * oct$int if$int =~ m/^0/;return$sign * $int},)}sub token_float {my$self=shift;$self->_token_generic(name=>"float",pattern=>"float",convert=>sub {$_[1]+ 0},)}sub token_number {my$self=shift;$self->any_of(\&token_float,\&token_int)}my%escapes=(a=>"\a",b=>"\b",e=>"\e",f=>"\f",n=>"\n",r=>"\r",t=>"\t",);sub token_string {my$self=shift;$self->fail("Expected string")if$self->at_eos;my$pos=pos$self->{str};$self->skip_ws;$self->{str}=~ m/\G($self->{patterns}{string_delim})/gc or $self->fail("Expected string delimiter");my$delim=$1;$self->{str}=~ m/
        \G(
           (?:
              \\[0-7]{1,3}     # octal escape
             |\\x[0-9A-F]{2}   # 2-digit hex escape
             |\\x\{[0-9A-F]+\} # {}-delimited hex escape
             |\\.              # symbolic escape
             |[^\\$delim]+     # plain chunk
           )*?
        )$delim/gcix or pos($self->{str})=$pos,$self->fail("Expected contents of string");my$string=$1;$string =~ s<\\(?:([0-7]{1,3})|x([0-9A-F]{2})|x\{([0-9A-F]+)\}|(.))>
                 [defined $1 ? chr oct $1 :
                  defined $2 ? chr hex $2 :
                  defined $3 ? chr hex $3 :
                               exists $escapes{$4} ? $escapes{$4} : $4]egi;return$string}sub token_ident {my$self=shift;$self->_token_generic(name=>"ident",pattern=>"ident",)}sub token_kw {my$self=shift;my@acceptable=@_;$self->skip_ws;my$pos=pos$self->{str};defined(my$kw=$self->token_ident)or return undef;grep {$_ eq $kw}@acceptable or pos($self->{str})=$pos,$self->fail("Expected any of ".join(", ",@acceptable));return$kw}package Parser::MGC::Failure;sub new {my$class=shift;my$self=bless {},$class;@{$self}{qw(message parser pos)}=@_;return$self}use overload '""'=>"STRING";sub STRING {my$self=shift;my$parser=$self->{parser};my ($linenum,$col,$text)=$parser->where($self->{pos});my$indent=substr($text,0,$col);$indent =~ s/[^ \t]/ /g;my$filename=$parser->{filename};my$in_file=(defined$filename and!ref$filename)? "in $filename " : "";return "$self->{message} ${in_file}on line $linenum at:\n" ."$text\n" ."$indent^\n"}use overload fallback=>1;0x55AA;
PARSER_MGC

$fatpacked{"Parser/MGC/Examples/EvaluateExpression.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARSER_MGC_EXAMPLES_EVALUATEEXPRESSION';
  package Parser::MGC::Examples::EvaluateExpression;
PARSER_MGC_EXAMPLES_EVALUATEEXPRESSION

$fatpacked{"Perl/Strip.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_STRIP';
  package Perl::Strip;our$VERSION='1.1';our$CACHE_VERSION=2;use common::sense;use PPI;use base PPI::Transform::;sub document {my ($self,$doc)=@_;$self->{optimise_size}=1;if (eval {$doc->child (1)->content =~ /^# .* (build by mktables|machine-generated .*mktables) /}){for my$heredoc (@{$doc->find (PPI::Token::HereDoc::)}){my$src=join "",$heredoc->heredoc;for ($src){s/^(?:0*([0-9a-fA-F]+))?\t(?:0*([0-9a-fA-F]+))?\t(?:0*([0-9a-fA-F]+))?/$1\t$2\t$3/gm if$self->{optimise_size};s/#.*\n/\n/mg;s/\s+\n/\n/mg}$heredoc->{_heredoc}=[split /$/,$src]}}$doc->prune (PPI::Token::Comment::);$doc->prune (PPI::Token::Pod::);for (my$last=$doc->last_element;$last;){my$prev=$last->previous_token;if ($last->isa (PPI::Token::Whitespace::)){$last->delete}elsif ($last->isa (PPI::Statement::End::)){$last->delete;last}elsif ($last->isa (PPI::Token::Pod::)){$last->delete}else {last}$last=$prev}for my$ws (@{$doc->find (PPI::Token::Whitespace::)}){my$prev=$ws->previous_token;my$next=$ws->next_token;if (!$prev ||!$next){$ws->delete}else {if ($next->isa (PPI::Token::Operator::)&& $next->{content}=~ /^(?:,|=|!|!=|==|=>)$/ or $prev->isa (PPI::Token::Operator::)&& $prev->{content}=~ /^(?:,|=|\.|!|!=|==|=>)$/ or $prev->isa (PPI::Token::Structure::)or ($self->{optimise_size}&& ($prev->isa (PPI::Token::Word::)&& (PPI::Token::Symbol:: eq ref$next || $next->isa (PPI::Structure::Block::)|| $next->isa (PPI::Structure::List::)|| $next->isa (PPI::Structure::Condition::))))){$ws->delete}elsif ($prev->isa (PPI::Token::Whitespace::)){$ws->{content}=' ';$prev->delete}else {$ws->{content}=' '}}}if ($self->{optimise_size}){for my$struct (PPI::Structure::Block::,PPI::Structure::Condition::,PPI::Structure::List::){for my$node (@{$doc->find ($struct)}){my$n1=$node->first_token;my$n3=$n1->next_token;$n1->delete if$n1->isa (PPI::Token::Whitespace::);$n3->delete if$n3 && $n3->isa (PPI::Token::Whitespace::);my$n1=$node->last_token;my$n2=$n1->next_token;my$n3=$n1->previous_token;$n1->delete if$n1->isa (PPI::Token::Whitespace::);$n2->delete if$n2 && $n2->isa (PPI::Token::Whitespace::);$n3->{content}="" if$n3 && ($n3->isa (PPI::Token::Whitespace::)|| ($n3->isa (PPI::Token::Structure::)&& $n3->content eq ";"))}}}for my$node (@{$doc->find (PPI::Statement::Compound::)}){if (my$n=$node->first_token){$n->{content}="for" if$n->{content}eq "foreach" && $n->isa (PPI::Token::Word::)}}for my$node (@{$doc->find (PPI::Token::QuoteLike::Words::)}){if ($node->{content}=~ /^qw(.)(.*)(.)$/s){my ($a,$qw,$b)=($1,$2,$3);$qw =~ s/^\s+//;$qw =~ s/\s+$//;$qw =~ s/\s+/ /g;$node->{content}="qw$a$qw$b"}}1}sub strip {my ($self,$src)=@_;my$filter=sub {my$ppi=new PPI::Document \$src or return;$self->document ($ppi)or return;$src=$ppi->serialize};if (exists$self->{cache}&& (2048 <= length$src)){my$file="$self->{cache}/" .Digest::MD5::md5_hex "$CACHE_VERSION \n" .(!!$self->{optimise_size})."\n\x00$src";if (open my$fh,"<:perlio",$file){if (-s $fh){local $/;$src=<$fh>}}else {my$oldsrc=$src;$filter->();mkdir$self->{cache};if (open my$fh,">:perlio","$file~"){if ($oldsrc eq $src or (syswrite$fh,$src)==length$src){close$fh;rename "$file~",$file}}}}else {$filter->()}$src}1;
PERL_STRIP

$fatpacked{"Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SCALAR_UTIL';
  package Scalar::Util;use strict;use warnings;require Exporter;our@ISA=qw(Exporter);our@EXPORT_OK=qw(blessed refaddr reftype weaken unweaken isweak dualvar isdual isvstring looks_like_number openhandle readonly set_prototype tainted);our$VERSION="1.62";$VERSION =~ tr/_//d;require List::Util;List::Util->VERSION($VERSION);sub export_fail {if (grep {/^isvstring$/}@_){require Carp;Carp::croak("Vstrings are not implemented in this version of perl")}@_}sub set_prototype(&$) {my ($code,$proto)=@_;return Sub::Util::set_prototype($proto,$code)}1;
SCALAR_UTIL

$fatpacked{"Schedule/Cron.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SCHEDULE_CRON';
  package Schedule::Cron;use Time::ParseDate;use Data::Dumper;use strict;use vars qw($VERSION $DEBUG);use subs qw(dbg);my$HAS_POSIX;BEGIN {eval {require POSIX;import POSIX ":sys_wait_h"};$HAS_POSIX=$@ ? 0 : 1}$VERSION="1.01";our$DEBUG=0;my%STARTEDCHILD=();my@WDAYS=qw(Sunday Monday Tuesday Wednesday Thursday Friday Saturday Sunday);my@ALPHACONV=({},{},{},{qw(jan 1 feb 2 mar 3 apr 4 may 5 jun 6 jul 7 aug 8 sep 9 oct 10 nov 11 dec 12) },{qw(sun 0 mon 1 tue 2 wed 3 thu 4 fri 5 sat 6)},{});my@RANGES=([0,59 ],[0,23 ],[0,31 ],[0,12 ],[0,7 ],[0,59 ]);my@LOWMAP=({},{},{0=>1},{0=>1},{7=>0},{},);sub REAPER {&_reaper_all()}sub _reaper_specific {local ($!,%!);if ($HAS_POSIX){for my$pid (keys%STARTEDCHILD){if ($STARTEDCHILD{$pid}){my$res=$HAS_POSIX ? waitpid($pid,WNOHANG): waitpid($pid,0);if ($res > 0){$STARTEDCHILD{$pid}=0;dbg "Reaped child $res" if$DEBUG}}}}else {my$waitedpid=0;while($waitedpid!=-1){$waitedpid=wait}}}sub _reaper_all {local ($!,%!);my$kid;do {$kid=$HAS_POSIX ? waitpid(-1,WNOHANG): wait;print "Kid: $kid\n";if ($kid!=0 && $kid!=-1 && defined$STARTEDCHILD{$kid}){$STARTEDCHILD{$kid}=0;dbg "Reaped child $kid" if$DEBUG}}while ($kid!=0 && $kid!=-1)}sub _cleanup_process_list {my ($self,$cfg)=@_;&REAPER()if$HAS_POSIX &&!$cfg->{nofork};for my$k (keys%STARTEDCHILD){delete$STARTEDCHILD{$k}unless$STARTEDCHILD{$k}}}sub new {my$class=shift;my$dispatcher=shift || die "No dispatching sub provided";die "Dispatcher not a ref to a subroutine" unless ref($dispatcher)eq "CODE";my$cfg=ref($_[0])eq "HASH" ? $_[0]: {@_ };$cfg->{processprefix}="Schedule::Cron" unless$cfg->{processprefix};my$self={cfg=>$cfg,dispatcher=>$dispatcher,queue=>[],map=>{}};bless$self,(ref($class)|| $class);$self->load_crontab if$cfg->{file};$self}sub load_crontab {my$self=shift;my$cfg=shift;if ($cfg){if (@_){$cfg=ref($cfg)eq "HASH" ? $cfg : {$cfg,@_ }}elsif (!ref($cfg)){my$new_cfg={};$new_cfg->{file}=$cfg;$cfg=$new_cfg}}my$file=$cfg->{file}|| $self->{cfg}->{file}|| die "No filename provided";my$eval=$cfg->{eval}|| $self->{cfg}->{eval};open(F,$file)|| die "Cannot open schedule $file : $!";my$line=0;while (<F>){$line++;s/#.*$//;next if /^$/;next if /^$/;next if /^\s*#/;chomp;s/\s*(.*)\s*$/$1/;my ($min,$hour,$dmon,$month,$dweek,$rest)=split (/\s+/,$_,6);my$time=[$min,$hour,$dmon,$month,$dweek ];my$args;if ($rest){my ($col6,$more_args)=split(/\s+/,$rest,2);if ($col6 =~ /^[\d\-\*\,\/]+$/){push @$time,$col6;dbg "M: $more_args";$args=$more_args}else {$args=$rest}}$self->add_entry($time,{'args'=>$args,'eval'=>$eval})}close F}sub add_entry {my$self=shift;my$time=shift;my$args=shift || [];my$dispatch;if (ref($args)eq "HASH"){my$cfg=$args;$args=undef;$dispatch=$cfg->{subroutine}|| $cfg->{sub};$args=$cfg->{arguments}|| $cfg->{args}|| [];if ($cfg->{eval}&& $cfg){die "You have to provide a simple scalar if using eval" if (ref($args));my$orig_args=$args;dbg "Evaled args ",Dumper($args)if$DEBUG;$args=[eval$args ];die "Cannot evaluate args (\"$orig_args\")" if $@}}elsif (ref($args)eq "CODE"){$dispatch=$args;$args=shift || []}if (ref($args)ne "ARRAY"){$args=[$args,@_ ]}$dispatch ||= $self->{dispatcher};my$time_array=ref($time)? $time : [split(/\s+/,$time)];die "Invalid number of columns in time entry (5 or 6)\n" if ($#$time_array!=4 && $#$time_array!=5);$time=join ' ',@$time_array;push @{$self->{time_table}},{time=>$time,dispatcher=>$dispatch,args=>$args };$self->{entries_changed}=1;my$index=$#{$self->{time_table}};my$id=$args->[0];$self->{map}->{$id}=$index if$id;return $#{$self->{time_table}}}sub list_entries {my ($self)=shift;my@ret;for my$entry (@{$self->{time_table}}){push@ret,$self->_deep_copy_entry($entry)}return@ret}sub get_entry {my ($self,$idx)=@_;my$entry=$self->{time_table}->[$idx];if ($entry){return$self->_deep_copy_entry($entry)}else {return undef}}sub delete_entry {my ($self,$idx)=@_;if ($idx <= $#{$self->{time_table}}){$self->{entries_changed}=1;my$map=$self->{map};for my$key (keys %{$map}){if ($map->{$key}> $idx){$map->{$key}--}elsif ($map->{$key}==$idx){delete$map->{$key}}}return splice @{$self->{time_table}},$idx,1}else {return undef}}sub update_entry {my ($self,$idx,$entry)=@_;die "No update entry given" unless$entry;die "No time specification given" unless$entry->{time};if ($idx <= $#{$self->{time_table}}){my$new_entry=$self->_deep_copy_entry($entry);$new_entry->{dispatcher}=$self->{dispatcher}unless$new_entry->{dispatcher};$new_entry->{args}=[]unless$new_entry->{args};return splice @{$self->{time_table}},$idx,1,$new_entry}else {return undef}}sub run {my$self=shift;my$cfg=ref($_[0])eq "HASH" ? $_[0]: {@_ };$cfg={%{$self->{cfg}},%$cfg };my$log=$cfg->{log};my$loglevel=$cfg->{loglevel};$loglevel=0 unless defined$loglevel;my$sleeper=$cfg->{sleep};$self->_rebuild_queue;delete$self->{entries_changed};die "Nothing in schedule queue" unless @{$self->{queue}};unless ($cfg->{nofork}){my$old_child_handler=$SIG{'CHLD'};$SIG{'CHLD'}=sub {&REAPER();if ($old_child_handler && ref$old_child_handler eq 'CODE'){&$old_child_handler()}}}my$mainloop=sub {MAIN: while (42){unless (@{$self->{queue}}){die "No more jobs to run\n"}my ($index,$time)=@{shift @{$self->{queue}}};my$now=time;my$sleep=0;if ($time < $now){if ($cfg->{skip}){$log->(0,"Schedule::Cron - Skipping job $index")if$log && $loglevel <= 0;$self->_update_queue($index);next}$sleep=1}else {$sleep=$time - $now}$0=$self->_get_process_prefix()." MainLoop - next: ".scalar(localtime($time))unless$cfg->{nostatus};if (!$time){die "Internal: No time found, self: ",$self->{queue},"\n" unless$time}dbg "R: sleep = $sleep | ",scalar(localtime($time))," (",scalar(localtime($now)),")" if$DEBUG;while ($sleep > 0){if ($sleeper){$sleeper->($sleep,$self);if ($self->{entries_changed}){$self->_rebuild_queue;delete$self->{entries_changed};redo MAIN}}else {sleep($sleep)}$sleep=$time - time}$self->_execute($index,$cfg);$self->_cleanup_process_list($cfg);if ($self->{entries_changed}){dbg "rebuilding queue" if$DEBUG;$self->_rebuild_queue;delete$self->{entries_changed}}else {$self->_update_queue($index)}}};if ($cfg->{detach}){defined(my$pid=fork)or die "Can't fork: $!";if ($pid){if ($cfg->{pid_file}){if (open(P,">".$cfg->{pid_file})){print P$pid,"\n";close P}else {warn "Warning: Cannot open ",$cfg->{pid_file}," : $!\n"}}return$pid}else {chdir '/';open STDIN,'/dev/null' or die "Can't read /dev/null: $!";open STDOUT,'>/dev/null' or die "Can't write to /dev/null: $!";eval {require POSIX};if ($@){if (open(T,"/dev/tty")){dbg "No setsid found, trying ioctl() (Error: $@)";eval {require 'ioctl.ph'};if ($@){eval {require 'sys/ioctl.ph'};if ($@){die "No 'ioctl.ph'. Probably you have to run h2ph (Error: $@)"}}my$notty=&TIOCNOTTY;die "No TIOCNOTTY !" if $@ ||!$notty;ioctl(T,$notty,0)|| die "Cannot issue ioctl(..,TIOCNOTTY) : $!";close(T)}}else {&POSIX::setsid()|| die "Can't start a new session: $!"}open STDERR,'>&STDOUT' or die "Can't dup stdout: $!";$0=$self->_get_process_prefix()." MainLoop" unless$cfg->{nostatus};&$mainloop()}}else {&$mainloop()}}sub clean_timetable {my$self=shift;$self->{entries_changed}=1;$self->{time_table}=[]}sub check_entry {my$self=shift;my$id=shift;return$self->{map}->{$id}}sub get_next_execution_time {my$self=shift;my$cron_entry=shift;my$time=shift;$cron_entry=[split /\s+/,$cron_entry ]unless ref($cron_entry);die "Exactly 5 or 6 columns has to be specified for a crontab entry ! (not ",scalar(@$cron_entry),")" if ($#$cron_entry!=4 && $#$cron_entry!=5);my@expanded;my$w;for my$i (0..$#$cron_entry){my@e=split /,/,$cron_entry->[$i];my@res;my$t;while (defined($t=shift@e)){$t =~ s|^\*(/.+)$|$RANGES[$i][0]."-".$RANGES[$i][1].$1|e;if ($t =~ m|^([^-]+)-([^-/]+)(/(.*))?$|){my ($low,$high,$step)=($1,$2,$4);$step=1 unless$step;if ($low !~ /^(\d+)/){$low=$ALPHACONV[$i]{lc$low}}if ($high !~ /^(\d+)/){$high=$ALPHACONV[$i]{lc$high}}if (!defined($low)||!defined($high)|| $low > $high || $step !~ /^\d+$/){die "Invalid cronentry '",$cron_entry->[$i],"'"}my$j;for ($j=$low;$j <= $high;$j += $step){push@e,$j}}else {$t=$ALPHACONV[$i]{lc$t}if$t !~ /^(\d+|\*)$/;$t=$LOWMAP[$i]{$t}if exists($LOWMAP[$i]{$t});die "Invalid cronentry '",$cron_entry->[$i],"'" if (!defined($t)|| ($t ne '*' && ($t < $RANGES[$i][0]|| $t > $RANGES[$i][1])));push@res,$t}}push@expanded,($#res==0 && $res[0]eq '*')? ["*" ]: [sort {$a <=> $b}@res]}$self->_verify_expanded_cron_entry($cron_entry,\@expanded);my$now=$time || time;if ($expanded[2]->[0]ne '*' && $expanded[4]->[0]ne '*'){my@bak=@{$expanded[4]};$expanded[4]=['*' ];my$t1=$self->_calc_time($now,\@expanded);$expanded[4]=\@bak;$expanded[2]=['*' ];my$t2=$self->_calc_time($now,\@expanded);dbg "MDay : ",scalar(localtime($t1))," -- WDay : ",scalar(localtime($t2))if$DEBUG;return$t1 < $t2 ? $t1 : $t2}else {return$self->_calc_time($now,\@expanded)}}sub _rebuild_queue {my$self=shift;$self->{queue}=[];for my$id (0..$#{$self->{time_table}}){$self->_update_queue($id)}}sub _deep_copy_entry {my ($self,$entry)=@_;my$args=[@{$entry->{args}}];my$copied_entry={%$entry };$copied_entry->{args}=$args;return$copied_entry}sub _execute {my$self=shift;my$index=shift;my$cfg=shift || $self->{cfg};my$entry=$self->get_entry($index)|| die "Internal: No entry with index $index found in ",Dumper([$self->list_entries()]);my$pid;my$log=$cfg->{log};my$loglevel=$cfg->{loglevel}|| 0;unless ($cfg->{nofork}){if ($pid=fork){$log->(0,"Schedule::Cron - Forking child PID $pid")if$log && $loglevel <= 0;$STARTEDCHILD{$pid}=1;return}}my$dispatch=$entry->{dispatcher};die "No subroutine provided with $dispatch" unless ref($dispatch)eq "CODE";my$args=$entry->{args};my@args=();if (defined($args)&& defined($args->[0])){push@args,@$args}if ($log && $loglevel <= 0 ||!$cfg->{nofork}&&!$cfg->{nostatus}){my$args_label=(@args && $loglevel <= -1)? " with (".join(",",$self->_format_args(@args)).")" : "";$0=$self->_get_process_prefix()." Dispatched job $index$args_label" unless$cfg->{nofork}|| $cfg->{nostatus};$log->(0,"Schedule::Cron - Starting job $index$args_label")if$log && $loglevel <= 0}my$dispatch_result;if ($cfg->{catch}){eval {$dispatch_result=&$dispatch(@args)};if ($@){$log->(2,"Schedule::Cron - Error within job $index: $@")if$log && $loglevel <= 2}}else {$dispatch_result=&$dispatch(@args)}if($cfg->{after_job}){my$job=$cfg->{after_job};if (ref($job)eq "CODE"){eval {&$job($dispatch_result,@args)};if ($@){$log->(2,"Schedule::Cron - Error while calling after_job callback with retval = $dispatch_result: $@")if$log && $loglevel <= 2}}else {$log->(2,"Schedule::Cron - Invalid after_job callback, it's not a code ref (but ",$job,")")if$log && $loglevel <= 2}}$log->(0,"Schedule::Cron - Finished job $index")if$log && $loglevel <= 0;exit unless$cfg->{nofork}}sub _update_queue {my$self=shift;my$index=shift;my$entry=$self->get_entry($index);my$new_time=$self->get_next_execution_time($entry->{time});my$now=time;if ($new_time <= $now){dbg "Adjusting time calculation because of DST back flip (new_time - now = ",$new_time - $now,")" if$DEBUG;while ($new_time <= $now){$new_time += 3600}}dbg "Updating Queue: ",scalar(localtime($new_time))if$DEBUG;$self->{queue}=[sort {$a->[1]<=> $b->[1]}@{$self->{queue}},[$index,$new_time]]}sub _calc_time {my$self=shift;my$now=shift;my$expanded=shift;my$offset=($expanded->[5]? 1 : 60);my ($now_sec,$now_min,$now_hour,$now_mday,$now_mon,$now_wday,$now_year)=(localtime($now+$offset))[0,1,2,3,4,6,5];$now_mon++;$now_year += 1900;my ($dest_mon,$dest_mday,$dest_wday,$dest_hour,$dest_min,$dest_sec,$dest_year)=($now_mon,$now_mday,$now_wday,$now_hour,$now_min,$now_sec,$now_year);while ($dest_year <= $now_year + 1){dbg "Parsing $dest_hour:$dest_min:$dest_sec $dest_year/$dest_mon/$dest_mday" if$DEBUG;if ($expanded->[3]->[0]ne '*'){unless (defined ($dest_mon=$self->_get_nearest($dest_mon,$expanded->[3]))){$dest_mon=$expanded->[3]->[0];$dest_year++}}if ($expanded->[2]->[0]ne '*'){if ($dest_mon!=$now_mon){$dest_mday=$expanded->[2]->[0]}else {unless (defined ($dest_mday=$self->_get_nearest($dest_mday,$expanded->[2]))){$dest_mday=$expanded->[2]->[0];$dest_mon++;if ($dest_mon > 12){$dest_mon=1;$dest_year++}dbg "Backtrack mday: $dest_mday/$dest_mon/$dest_year" if$DEBUG;next}}}else {$dest_mday=($dest_mon==$now_mon ? $dest_mday : 1)}if ($expanded->[4]->[0]ne '*'){$dest_wday=$self->_get_nearest($dest_wday,$expanded->[4]);$dest_wday=$expanded->[4]->[0]unless$dest_wday;my ($mon,$mday,$year);$dest_mday=1 if$dest_mon!=$now_mon;my$t=parsedate(sprintf("%4.4d/%2.2d/%2.2d",$dest_year,$dest_mon,$dest_mday));($mon,$mday,$year)=(localtime(parsedate("$WDAYS[$dest_wday]",PREFER_FUTURE=>1,NOW=>$t-1)))[4,3,5];$mon++;$year += 1900;dbg "Calculated $mday/$mon/$year for weekday ",$WDAYS[$dest_wday]if$DEBUG;if ($mon!=$dest_mon || $year!=$dest_year){dbg "backtracking" if$DEBUG;$dest_mon=$mon;$dest_year=$year;$dest_mday=1;$dest_wday=(localtime(parsedate(sprintf("%4.4d/%2.2d/%2.2d",$dest_year,$dest_mon,$dest_mday))))[6];next}$dest_mday=$mday}else {unless ($dest_mday){$dest_mday=($dest_mon==$now_mon ? $dest_mday : 1)}}if ($expanded->[1]->[0]ne '*'){if ($dest_mday!=$now_mday || $dest_mon!=$now_mon || $dest_year!=$now_year){$dest_hour=$expanded->[1]->[0]}else {unless (defined ($dest_hour=$self->_get_nearest($dest_hour,$expanded->[1]))){$dest_hour=$expanded->[1]->[0];my$t=parsedate(sprintf("%2.2d:%2.2d:%2.2d %4.4d/%2.2d/%2.2d",$dest_hour,$dest_min,$dest_sec,$dest_year,$dest_mon,$dest_mday));($dest_mday,$dest_mon,$dest_year,$dest_wday)=(localtime(parsedate("+ 1 day",NOW=>$t)))[3,4,5,6];$dest_mon++;$dest_year += 1900;next}}}else {$dest_hour=($dest_mday==$now_mday ? $dest_hour : 0)}if ($expanded->[0]->[0]ne '*'){if ($dest_hour!=$now_hour || $dest_mday!=$now_mday || $dest_mon!=$dest_mon || $dest_year!=$now_year){$dest_min=$expanded->[0]->[0]}else {unless (defined ($dest_min=$self->_get_nearest($dest_min,$expanded->[0]))){$dest_min=$expanded->[0]->[0];my$t=parsedate(sprintf("%2.2d:%2.2d:%2.2d %4.4d/%2.2d/%2.2d",$dest_hour,$dest_min,$dest_sec,$dest_year,$dest_mon,$dest_mday));($dest_hour,$dest_mday,$dest_mon,$dest_year,$dest_wday)=(localtime(parsedate(" + 1 hour",NOW=>$t)))[2,3,4,5,6];$dest_mon++;$dest_year += 1900;next}}}else {if ($dest_hour!=$now_hour || $dest_mday!=$now_mday || $dest_year!=$now_year){$dest_min=0}}if ($expanded->[5]){if ($expanded->[5]->[0]ne '*'){if ($dest_min!=$now_min){$dest_sec=$expanded->[5]->[0]}else {unless (defined ($dest_sec=$self->_get_nearest($dest_sec,$expanded->[5]))){$dest_sec=$expanded->[5]->[0];my$t=parsedate(sprintf("%2.2d:%2.2d:%2.2d %4.4d/%2.2d/%2.2d",$dest_hour,$dest_min,$dest_sec,$dest_year,$dest_mon,$dest_mday));($dest_min,$dest_hour,$dest_mday,$dest_mon,$dest_year,$dest_wday)=(localtime(parsedate(" + 1 minute",NOW=>$t)))[1,2,3,4,5,6];$dest_mon++;$dest_year += 1900;next}}}else {$dest_sec=($dest_min==$now_min ? $dest_sec : 0)}}else {$dest_sec=0}my$date=sprintf("%2.2d:%2.2d:%2.2d %4.4d/%2.2d/%2.2d",$dest_hour,$dest_min,$dest_sec,$dest_year,$dest_mon,$dest_mday);dbg "Next execution time: $date ",$WDAYS[$dest_wday]if$DEBUG;my$result=parsedate($date,VALIDATE=>1);if ($result){return$result}else {my$t=parsedate($date);($dest_hour,$dest_mday,$dest_mon,$dest_year,$dest_wday)=(localtime(parsedate(" + 1 second",NOW=>$t)))[2,3,4,5,6];$dest_mon++;$dest_year += 1900;next}}my$dumper=new Data::Dumper($expanded);$dumper->Terse(1);$dumper->Indent(0);die "No suitable next execution time found for ",$dumper->Dump(),", now == ",scalar(localtime($now)),"\n"}sub _get_nearest {my$self=shift;my$x=shift;my$to_check=shift;for my$i (0 .. $#$to_check){if ($$to_check[$i]>= $x){return $$to_check[$i]}}return undef}sub _format_args {my$self=shift;my@args=@_;my$dumper=new Data::Dumper(\@args);$dumper->Terse(1);$dumper->Maxdepth(2);$dumper->Indent(0);return$dumper->Dump()}sub _get_process_prefix {my$self=shift;my$prefix=$self->{cfg}->{processprefix}|| "Schedule::Cron";return$prefix}sub dbg {if ($DEBUG){my$args=join('',@_)|| "";my$caller=(caller(1))[0];my$line=(caller(0))[2];$caller ||= $0;if (length$caller > 22){$caller=substr($caller,0,10)."..".substr($caller,-10,10)}print STDERR sprintf ("%02d:%02d:%02d [%22.22s %4.4s]  %s\n",(localtime)[2,1,0],$caller,$line,$args)}}*bug=\&report_exectime_bug;sub report_exectime_bug {my$self=shift;my$endless=shift;my$time=time;my$inp;my$now=$self->_time_as_string($time);my$email;do {while (1){$inp=$self->_get_input("Reference time\n(default: $now)  : ");if ($inp){parsedate($inp)|| (print "Couldn't parse \"$inp\"\n",next);$now=$inp}last}my$now_time=parsedate($now);my ($next_time,$next);my@entries;while (1){$inp=$self->_get_input("Crontab time (5 columns)            : ");@entries=split (/\s+/,$inp);if (@entries!=5){print "Invalid crontab entry \"$inp\"\n";next}eval {local$SIG{ALRM}=sub {die "TIMEOUT"};alarm(60);$next_time=Schedule::Cron->get_next_execution_time(\@entries,$now_time);alarm(0)};if ($@){alarm(0);if ($@ eq "TIMEOUT"){$next_time=-1}else {print "Invalid crontab entry \"$inp\" ($@)\n";next}}if ($next_time > 0){$next=$self->_time_as_string($next_time)}else {$next="Run into infinite loop !!"}last}my ($expected,$expected_time);while (1){$inp=$self->_get_input("Expected time                       : ");unless ($expected_time=parsedate($inp)){print "Couldn't parse \"$inp\"\n";next}$expected=$self->_time_as_string($expected_time);last}if ($expected eq $next){print "\nHmm, seems that everything's ok, or ?\n\n";print "Calculated time: ",$next,"\n";print "Expected time  : ",$expected,"\n"}else {print <<EOT;$email=$self->_get_input("Your E-Mail Address (if available)  : ")unless defined($email);$email="" unless defined($email);print "\n","=" x 80,"\n";print <<EOT;print "# ","-" x 78,"\n";print "Reftime: ",$now,"\n";print "# Reported by : ",$email,"\n" if$email;printf "%8s %8s %8s %8s %8s         %s\n",@entries,$expected;print "# Calculated  : \n";printf "# %8s %8s %8s %8s %8s         %s\n",@entries,$next;unless ($endless){require Config;my$vers=`uname -r 2>/dev/null` || $Config::Config{'osvers'};chomp$vers;my$osname=`uname -s 2>/dev/null` || $Config::Config{'osname'};chomp$osname;print "# OS: $osname ($vers)\n";print "# Perl-Version: $]\n";print "# Time::ParseDate-Version: ",$Time::ParseDate::VERSION,"\n"}print "# ","-" x 78,"\n"}print "\n","=" x 80,"\n"}while ($endless)}my ($input_initialized,$term);sub _get_input {my$self=shift;my$prompt=shift;use vars qw($term);unless (defined($input_initialized)){eval {require Term::ReadLine};$input_initialized=$@ ? 0 : 1;if ($input_initialized){$term=new Term::ReadLine;$term->ornaments(0)}}unless ($input_initialized){print$prompt;my$inp=<STDIN>;chomp$inp;return$inp}else {chomp$prompt;my@prompt=split /\n/s,$prompt;if ($#prompt > 0){print join "\n",@prompt[0..$#prompt-1],"\n"}my$inp=$term->readline($prompt[$#prompt]);return$inp}}sub _time_as_string {my$self=shift;my$time=shift;my ($min,$hour,$mday,$month,$year,$wday)=(localtime($time))[1..6];$month++;$year += 1900;$wday=$WDAYS[$wday];return sprintf("%2.2d:%2.2d %2.2d/%2.2d/%4.4d %s",$hour,$min,$mday,$month,$year,$wday)}sub _verify_expanded_cron_entry {my$self=shift;my$original=shift;my$entry=shift;die "Internal: Not an array ref. Orig: ",Dumper($original),", expanded: ",Dumper($entry)," (self = ",Dumper($self),")" unless ref($entry)eq "ARRAY";for my$i (0 .. $#{$entry}){die "Internal: Part $i of entry is not an array ref. Original: ",Dumper($original),", expanded: ",Dumper($entry)," (self=",Dumper($self),")",unless ref($entry->[$i])eq "ARRAY"}}1;
  Congratulation, you hit a bug. 
  
  EOT
  Please report the following lines
  to roland\@cpan.org
  
  EOT
SCHEDULE_CRON

$fatpacked{"Sub/Uplevel.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_UPLEVEL';
  package Sub::Uplevel;use 5.006;use strict;our$VERSION='0.2800';our$CHECK_FRAMES;BEGIN {$CHECK_FRAMES=!!$CHECK_FRAMES}use constant CHECK_FRAMES=>$CHECK_FRAMES;if (not defined*CORE::GLOBAL::caller{CODE}){*CORE::GLOBAL::caller=\&_normal_caller}my@reload_list=qw/Exporter Exporter::Heavy/;sub import {no strict 'refs';my ($class,@args)=@_;for my$tag (@args,'uplevel'){if ($tag eq 'uplevel'){my$caller=caller(0);*{"$caller\::uplevel"}=\&uplevel}elsif($tag eq ':aggressive'){_force_reload(@reload_list)}else {die qq{"$tag" is not exported by the $class module\n}}}return}sub _force_reload {no warnings 'redefine';local $^W=0;for my$m (@_){$m =~ s{::}{/}g;$m .= ".pm";require$m if delete$INC{$m}}}our (@Up_Frames,$Caller_Proxy);sub _apparent_stack_height {my$height=1;while (1){last if!defined scalar$Caller_Proxy->($height);$height++}return$height - 1}sub uplevel {my$old_W=$^W;$^W=0;local$Caller_Proxy=*CORE::GLOBAL::caller{CODE}if*CORE::GLOBAL::caller{CODE}!=\&_uplevel_caller;local*CORE::GLOBAL::caller=\&_uplevel_caller;$^W=$old_W;if (CHECK_FRAMES and $_[0]>= _apparent_stack_height()){require Carp;Carp::carp("uplevel $_[0] is more than the caller stack")}local@Up_Frames=(shift,@Up_Frames);my$function=shift;return$function->(@_)}sub _normal_caller (;$) {my ($height)=@_;$height++;my@caller=CORE::caller($height);if (CORE::caller()eq 'DB'){package DB;@caller=CORE::caller($height)}return if!@caller;return$caller[0]if!wantarray;return @_ ? @caller : @caller[0..2]}sub _uplevel_caller (;$) {my$height=$_[0]|| 0;return$Caller_Proxy->($height + 1)if!@Up_Frames;my$saw_uplevel=0;my$adjust=0;my$test_caller;for (my$up=0;$up <= $height + $adjust;$up++ ){$test_caller=scalar CORE::caller($up + 1);if($test_caller && $test_caller eq __PACKAGE__){$adjust += 1 + $Up_Frames[$saw_uplevel];$saw_uplevel++}}my@caller=$Caller_Proxy->($height + $adjust + 1);if (CORE::caller()eq 'DB'){package DB;@caller=$Sub::Uplevel::Caller_Proxy->($height + $adjust + 1)}return if!@caller;return$caller[0]if!wantarray;return @_ ? @caller : @caller[0..2]}1;
SUB_UPLEVEL

$fatpacked{"Sub/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_UTIL';
  package Sub::Util;use strict;use warnings;require Exporter;our@ISA=qw(Exporter);our@EXPORT_OK=qw(prototype set_prototype subname set_subname);our$VERSION="1.62";$VERSION =~ tr/_//d;require List::Util;List::Util->VERSION($VERSION);sub prototype {my ($code)=@_;return CORE::prototype($code)}1;
SUB_UTIL

$fatpacked{"Syntax/Keyword/Try.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SYNTAX_KEYWORD_TRY';
  package Syntax::Keyword::Try 0.27;use v5.14;use warnings;use Carp;require XSLoader;XSLoader::load(__PACKAGE__,our$VERSION);sub import {my$class=shift;my$caller=caller;$class->import_into($caller,@_)}my@EXPERIMENTAL=qw(typed);sub import_into {my$class=shift;my ($caller,@syms)=@_;@syms or @syms=qw(try);my%syms=map {$_=>1}@syms;$^H{"Syntax::Keyword::Try/try"}++ if delete$syms{try};$^H{"Syntax::Keyword::Try/no_finally"}++ if delete$syms{"-no_finally"};$^H{"Syntax::Keyword::Try/require_catch"}++ if delete$syms{"-require_catch"};$^H{"Syntax::Keyword::Try/require_var"}++ if delete$syms{"-require_var"};delete$syms{":experimental($_)"}for qw(var);for (@EXPERIMENTAL){$^H{"Syntax::Keyword::Try/experimental($_)"}++ if delete$syms{":experimental($_)"}}if(delete$syms{":experimental"}){$^H{"Syntax::Keyword::Try/experimental($_)"}++ for@EXPERIMENTAL}delete@syms{qw(catch finally)};if($syms{try_value}or $syms{":experimental(try_value)"}){croak "The 'try_value' experimental feature is now removed\n" ."Instead, you should use  do { try ... }  to yield a value from a try/catch statement"}croak "Unrecognised import symbols @{[ keys %syms ]}" if keys%syms}0x55AA;
SYNTAX_KEYWORD_TRY

$fatpacked{"Syntax/Keyword/Try/Deparse.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SYNTAX_KEYWORD_TRY_DEPARSE';
  package Syntax::Keyword::Try::Deparse 0.27;use v5.14;use warnings;use B qw(opnumber);require B::Deparse;use constant {OP_CUSTOM=>opnumber('custom'),OP_ENTER=>opnumber('enter'),OP_LINESEQ=>opnumber('lineseq'),};my$orig_pp_leave;{no warnings 'redefine';no strict 'refs';$orig_pp_leave=*{"B::Deparse::pp_leave"}{CODE};*{"B::Deparse::pp_leave"}=\&pp_leave}sub pp_leave {my$self=shift;my ($op)=@_;my$enter=$op->first;$enter->type==OP_ENTER or return$self->$orig_pp_leave(@_);my$body=$enter->sibling;my$first=$body->first;my$finally="";if($body->type==OP_LINESEQ and $first->name eq "pushfinally"){my$finally_cv=$first->sv;$finally="\nfinally " .$self->deparse_sub($finally_cv)."\cK";$first=$first->sibling;$first=$first->sibling while$first and $first->name eq "lineseq";if($first->type==0){$body=$first;$first=$first->first}}if($first->type==OP_CUSTOM and $first->name eq "catch"){shift;return$self->deparse($body,@_).$finally}elsif(length$finally){my$try=B::Deparse::scopeop(1,$self,$body,0);return "try {\n\t$try\n\b}" .$finally}return$orig_pp_leave->($self,@_)}sub B::Deparse::pp_catch {my$self=shift;my ($op)=@_;my$tryop=$op->first;my$catchop=$op->first->sibling;my$try=$self->pp_leave($tryop,0);my$catch=$self->deparse($catchop->first,0);return "try {\n\t$try\n\b}\ncatch {\n\t$catch\n\b}\cK"}0x55AA;
SYNTAX_KEYWORD_TRY_DEPARSE

$fatpacked{"TAP/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_BASE';
  package TAP::Base;use strict;use warnings;use base 'TAP::Object';our$VERSION='3.44';use constant GOT_TIME_HIRES=>do {eval 'use Time::HiRes qw(time);';$@ ? 0 : 1};sub _initialize {my ($self,$arg_for,$ok_callback)=@_;my%ok_map=map {$_=>1}@$ok_callback;$self->{ok_callbacks}=\%ok_map;if (my$cb=delete$arg_for->{callbacks}){while (my ($event,$callback)=each %$cb){$self->callback($event,$callback)}}return$self}sub callback {my ($self,$event,$callback)=@_;my%ok_map=%{$self->{ok_callbacks}};$self->_croak('No callbacks may be installed')unless%ok_map;$self->_croak("Callback $event is not supported. Valid callbacks are " .join(', ',sort keys%ok_map))unless exists$ok_map{$event};push @{$self->{code_for}{$event}},$callback;return}sub _has_callbacks {my$self=shift;return keys %{$self->{code_for}}!=0}sub _callback_for {my ($self,$event)=@_;return$self->{code_for}{$event}}sub _make_callback {my$self=shift;my$event=shift;my$cb=$self->_callback_for($event);return unless defined$cb;return map {$_->(@_)}@$cb}sub get_time {return time()}sub time_is_hires {return GOT_TIME_HIRES}sub get_times {return [times()]}1;
TAP_BASE

$fatpacked{"TAP/Formatter/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_BASE';
  package TAP::Formatter::Base;use strict;use warnings;use base 'TAP::Base';use POSIX qw(strftime);my$MAX_ERRORS=5;my%VALIDATION_FOR;BEGIN {%VALIDATION_FOR=(directives=>sub {shift;shift},verbosity=>sub {shift;shift},normalize=>sub {shift;shift},timer=>sub {shift;shift},failures=>sub {shift;shift},comments=>sub {shift;shift},errors=>sub {shift;shift},color=>sub {shift;shift},jobs=>sub {shift;shift},show_count=>sub {shift;shift},stdout=>sub {my ($self,$ref)=@_;$self->_croak("option 'stdout' needs a filehandle")unless$self->_is_filehandle($ref);return$ref},);sub _is_filehandle {my ($self,$ref)=@_;return 0 if!defined$ref;return 1 if ref$ref eq 'GLOB';return 1 if!ref$ref && ref \$ref eq 'GLOB';return 1 if eval {$ref->can('print')};return 0}my@getter_setters=qw(_longest _printed_summary_header _colorizer);__PACKAGE__->mk_methods(@getter_setters,keys%VALIDATION_FOR)}our$VERSION='3.44';sub _initialize {my ($self,$arg_for)=@_;$arg_for ||= {};$self->SUPER::_initialize($arg_for);my%arg_for=%$arg_for;$self->verbosity(0);for my$name (keys%VALIDATION_FOR){my$property=delete$arg_for{$name};if (defined$property){my$validate=$VALIDATION_FOR{$name};$self->$name($self->$validate($property))}}if (my@props=keys%arg_for){$self->_croak("Unknown arguments to " .__PACKAGE__ ."::new (@props)")}$self->stdout(\*STDOUT)unless$self->stdout;if ($self->color){require TAP::Formatter::Color;$self->_colorizer(TAP::Formatter::Color->new)}return$self}sub verbose {shift->verbosity >= 1}sub quiet {shift->verbosity <= -1}sub really_quiet {shift->verbosity <= -2}sub silent {shift->verbosity <= -3}sub prepare {my ($self,@tests)=@_;my$longest=0;for my$test (@tests){$longest=length$test if length$test > $longest}$self->_longest($longest)}sub _format_now {strftime "[%H:%M:%S]",localtime}sub _format_name {my ($self,$test)=@_;my$name=$test;my$periods='.' x ($self->_longest + 2 - length$test);$periods=" $periods ";if ($self->timer){my$stamp=$self->_format_now();return "$stamp $name$periods"}else {return "$name$periods"}}sub open_test {die "Unimplemented."}sub _output_success {my ($self,$msg)=@_;$self->_output($msg)}sub summary {my ($self,$aggregate,$interrupted)=@_;return if$self->silent;my@t=$aggregate->descriptions;my$tests=\@t;my$runtime=$aggregate->elapsed_timestr;my$total=$aggregate->total;my$passed=$aggregate->passed;if ($self->timer){$self->_output($self->_format_now(),"\n")}$self->_failure_output("Test run interrupted!\n")if$interrupted;if ($aggregate->all_passed){$self->_output_success("All tests successful.\n")}if ($total!=$passed or $aggregate->has_problems){$self->_output("\nTest Summary Report");$self->_output("\n-------------------\n");for my$test (@$tests){$self->_printed_summary_header(0);my ($parser)=$aggregate->parsers($test);$self->_output_summary_failure('failed',['  Failed test:  ','  Failed tests:  ' ],$test,$parser);$self->_output_summary_failure('todo_passed',"  TODO passed:   ",$test,$parser);if (my$exit=$parser->exit){$self->_summary_test_header($test,$parser);$self->_failure_output("  Non-zero exit status: $exit\n")}elsif (my$wait=$parser->wait){$self->_summary_test_header($test,$parser);$self->_failure_output("  Non-zero wait status: $wait\n")}if (my@errors=$parser->parse_errors){my$explain;if (@errors > $MAX_ERRORS &&!$self->errors){$explain ="Displayed the first $MAX_ERRORS of " .scalar(@errors)." TAP syntax errors.\n" ."Re-run prove with the -p option to see them all.\n";splice@errors,$MAX_ERRORS}$self->_summary_test_header($test,$parser);$self->_failure_output(sprintf "  Parse errors: %s\n",shift@errors);for my$error (@errors){my$spaces=' ' x 16;$self->_failure_output("$spaces$error\n")}$self->_failure_output($explain)if$explain}}}my$files=@$tests;$self->_output("Files=$files, Tests=$total, $runtime\n");my$status=$aggregate->get_status;$self->_output("Result: $status\n")}sub _output_summary_failure {my ($self,$method,$name,$test,$parser)=@_;my$output=$method eq 'failed' ? '_failure_output' : '_output';if (my@r=$parser->$method()){$self->_summary_test_header($test,$parser);my ($singular,$plural)='ARRAY' eq ref$name ? @$name : ($name,$name);$self->$output(@r==1 ? $singular : $plural);my@results=$self->_balanced_range(40,@r);$self->$output(sprintf "%s\n"=>shift@results);my$spaces=' ' x 16;while (@results){$self->$output(sprintf "$spaces%s\n"=>shift@results)}}}sub _summary_test_header {my ($self,$test,$parser)=@_;return if$self->_printed_summary_header;my$spaces=' ' x ($self->_longest - length$test);$spaces=' ' unless$spaces;my$output=$self->_get_output_method($parser);my$wait=$parser->wait;if (defined$wait){my$signum=$wait & 0x7f;my$description;if ($signum){require Config;my@names=split ' ',$Config::Config{'sig_name'};$description="Signal: $names[$signum]";my$dumped=$wait & 0x80;$description .= ', dumped core' if$dumped}elsif ($wait!=0){$description=sprintf 'exited %d',($wait >> 8)}$wait .= " ($description)" if$wait!=0}else {$wait='(none)'}$self->$output(sprintf "$test$spaces(Wstat: %s Tests: %d Failed: %d)\n",$wait,$parser->tests_run,scalar$parser->failed);$self->_printed_summary_header(1)}sub _output {my$self=shift;print {$self->stdout}@_}sub _failure_output {my$self=shift;$self->_output(@_)}sub _balanced_range {my ($self,$limit,@range)=@_;@range=$self->_range(@range);my$line="";my@lines;my$curr=0;while (@range){if ($curr < $limit){my$range=(shift@range).", ";$line .= $range;$curr += length$range}elsif (@range){$line =~ s/, $//;push@lines=>$line;$line='';$curr=0}}if ($line){$line =~ s/, $//;push@lines=>$line}return@lines}sub _range {my ($self,@numbers)=@_;@numbers=sort {$a <=> $b}@numbers;my ($min,@range);for my$i (0 .. $#numbers){my$num=$numbers[$i];my$next=$numbers[$i + 1 ];if (defined$next && $next==$num + 1){if (!defined$min){$min=$num}}elsif (defined$min){push@range=>"$min-$num";undef$min}else {push@range=>$num}}return@range}sub _get_output_method {my ($self,$parser)=@_;return$parser->has_problems ? '_failure_output' : '_output'}1;
TAP_FORMATTER_BASE

$fatpacked{"TAP/Formatter/Color.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_COLOR';
  package TAP::Formatter::Color;use strict;use warnings;use constant IS_WIN32=>($^O =~ /^(MS)?Win32$/);use base 'TAP::Object';my$NO_COLOR;BEGIN {$NO_COLOR=0;eval 'require Term::ANSIColor';if ($@){$NO_COLOR=$@};if (IS_WIN32){eval 'use Win32::Console::ANSI';if ($@){$NO_COLOR=$@}};if ($NO_COLOR){*set_color=sub {}}else {*set_color=sub {my ($self,$output,$color)=@_;$output->(Term::ANSIColor::color($color))}}}our$VERSION='3.44';sub _initialize {my$self=shift;if ($NO_COLOR){(my$error=$NO_COLOR)=~ s/ in \@INC .*//s;warn "Note: Cannot run tests in color: $error\n";return}return$self}sub can_color {return!$NO_COLOR}1;
TAP_FORMATTER_COLOR

$fatpacked{"TAP/Formatter/Console.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_CONSOLE';
  package TAP::Formatter::Console;use strict;use warnings;use base 'TAP::Formatter::Base';use POSIX qw(strftime);our$VERSION='3.44';sub open_test {my ($self,$test,$parser)=@_;my$class =$self->jobs > 1 ? 'TAP::Formatter::Console::ParallelSession' : 'TAP::Formatter::Console::Session';eval "require $class";$self->_croak($@)if $@;my$session=$class->new({name=>$test,formatter=>$self,parser=>$parser,show_count=>$self->show_count,});$session->header;return$session}sub _set_colors {my ($self,@colors)=@_;if (my$colorizer=$self->_colorizer){my$output_func=$self->{_output_func}||= sub {$self->_output(@_)};$colorizer->set_color($output_func,$_)for@colors}}sub _failure_color {my ($self)=@_;return$ENV{'HARNESS_SUMMARY_COLOR_FAIL'}|| 'red'}sub _success_color {my ($self)=@_;return$ENV{'HARNESS_SUMMARY_COLOR_SUCCESS'}|| 'green'}sub _output_success {my ($self,$msg)=@_;$self->_set_colors($self->_success_color());$self->_output($msg);$self->_set_colors('reset')}sub _failure_output {my$self=shift;$self->_set_colors($self->_failure_color());my$out=join '',@_;my$has_newline=chomp$out;$self->_output($out);$self->_set_colors('reset');$self->_output($/)if$has_newline}1;
TAP_FORMATTER_CONSOLE

$fatpacked{"TAP/Formatter/Console/ParallelSession.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_CONSOLE_PARALLELSESSION';
  package TAP::Formatter::Console::ParallelSession;use strict;use warnings;use File::Spec;use File::Path;use Carp;use base 'TAP::Formatter::Console::Session';use constant WIDTH=>72;my%shared;sub _initialize {my ($self,$arg_for)=@_;$self->SUPER::_initialize($arg_for);my$formatter=$self->formatter;my$context=$shared{$formatter}||= $self->_create_shared_context;push @{$context->{active}},$self;return$self}sub _create_shared_context {my$self=shift;return {active=>[],tests=>0,fails=>0,}}our$VERSION='3.44';sub header {}sub _clear_ruler {my$self=shift;$self->formatter->_output("\r" .(' ' x WIDTH)."\r")}my$now=0;my$start;my$trailer='... )===';my$chop_length=WIDTH - length$trailer;sub _output_ruler {my ($self,$refresh)=@_;my$new_now=time;return if$new_now==$now and!$refresh;$now=$new_now;$start ||= $now;my$formatter=$self->formatter;return if$formatter->really_quiet;my$context=$shared{$formatter};my$ruler=sprintf '===( %7d;%d  ',$context->{tests},$now - $start;for my$active (@{$context->{active}}){my$parser=$active->parser;my$tests=$parser->tests_run;my$planned=$parser->tests_planned || '?';$ruler .= sprintf '%' .length($planned)."d/$planned  ",$tests}chop$ruler;$ruler .= ')===';if (length$ruler > WIDTH){$ruler =~ s/(.{$chop_length}).*/$1$trailer/o}else {$ruler .= '=' x (WIDTH - length($ruler))}$formatter->_output("\r$ruler")}sub result {my ($self,$result)=@_;my$formatter=$self->formatter;if ($result->is_test){my$context=$shared{$formatter};$context->{tests}++;my$active=$context->{active};if (@$active==1){return$self->SUPER::result($result)}$self->_output_ruler($self->parser->tests_run==1)}elsif ($result->is_bailout){$formatter->_failure_output("Bailout called.  Further testing stopped:  " .$result->explanation ."\n")}}sub clear_for_close {my$self=shift;my$formatter=$self->formatter;return if$formatter->really_quiet;my$context=$shared{$formatter};if (@{$context->{active}}==1){$self->SUPER::clear_for_close}else {$self->_clear_ruler}}sub close_test {my$self=shift;my$name=$self->name;my$parser=$self->parser;my$formatter=$self->formatter;my$context=$shared{$formatter};$self->SUPER::close_test;my$active=$context->{active};my@pos=grep {$active->[$_]->name eq $name}0 .. $#$active;die "Can't find myself" unless@pos;splice @$active,$pos[0],1;if (@$active > 1){$self->_output_ruler(1)}elsif (@$active==1){$active->[0]->SUPER::header}else {delete$shared{$formatter}}}1;
TAP_FORMATTER_CONSOLE_PARALLELSESSION

$fatpacked{"TAP/Formatter/Console/Session.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_CONSOLE_SESSION';
  package TAP::Formatter::Console::Session;use strict;use warnings;use base 'TAP::Formatter::Session';my@ACCESSOR;BEGIN {my@CLOSURE_BINDING=qw(header result clear_for_close close_test);for my$method (@CLOSURE_BINDING){no strict 'refs';*$method=sub {my$self=shift;return ($self->{_closures}||= $self->_closures)->{$method}->(@_)}}}our$VERSION='3.44';sub _get_output_result {my$self=shift;my@color_map=({test=>sub {$_->is_test &&!$_->is_ok},colors=>['red'],},{test=>sub {$_->is_test && $_->has_skip},colors=>['white','on_blue' ],},{test=>sub {$_->is_test && $_->has_todo},colors=>['yellow'],},);my$formatter=$self->formatter;my$parser=$self->parser;return$formatter->_colorizer ? sub {my$result=shift;for my$col (@color_map){local $_=$result;if ($col->{test}->()){$formatter->_set_colors(@{$col->{colors}});last}}$formatter->_output($self->_format_for_output($result));$formatter->_set_colors('reset')}: sub {$formatter->_output($self->_format_for_output(shift))}}sub _closures {my$self=shift;my$parser=$self->parser;my$formatter=$self->formatter;my$pretty=$formatter->_format_name($self->name);my$show_count=$self->show_count;my$really_quiet=$formatter->really_quiet;my$quiet=$formatter->quiet;my$verbose=$formatter->verbose;my$directives=$formatter->directives;my$failures=$formatter->failures;my$comments=$formatter->comments;my$output_result=$self->_get_output_result;my$output='_output';my$plan='';my$newline_printed=0;my$last_status_printed=0;return {header=>sub {$formatter->_output($pretty)unless$really_quiet},result=>sub {my$result=shift;if ($result->is_bailout){$formatter->_failure_output("Bailout called.  Further testing stopped:  " .$result->explanation ."\n")}return if$really_quiet;my$is_test=$result->is_test;if (!$plan){my$planned=$parser->tests_planned || '?';$plan="/$planned "}$output=$formatter->_get_output_method($parser);if ($show_count and $is_test){my$number=$result->number;my$now=CORE::time;if ($last_status_printed!=$now){$formatter->$output("\r$pretty$number$plan");$last_status_printed=$now}}if (!$quiet && ($verbose || ($is_test && $failures &&!$result->is_ok)|| ($comments && $result->is_comment)|| ($directives && $result->has_directive))){unless ($newline_printed){$formatter->_output("\n");$newline_printed=1}$output_result->($result);$formatter->_output("\n")}},clear_for_close=>sub {my$spaces =' ' x length('.' .$pretty .$plan .$parser->tests_run);$formatter->$output("\r$spaces")},close_test=>sub {if ($show_count &&!$really_quiet){$self->clear_for_close;$formatter->$output("\r$pretty")}$self->parser(undef);$self->{_closures}={};return if$really_quiet;if (my$skip_all=$parser->skip_all){$formatter->_output("skipped: $skip_all\n")}elsif ($parser->has_problems){$self->_output_test_failure($parser)}else {my$time_report=$self->time_report($formatter,$parser);$formatter->_output($self->_make_ok_line($time_report))}},}}1;
TAP_FORMATTER_CONSOLE_SESSION

$fatpacked{"TAP/Formatter/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_FILE';
  package TAP::Formatter::File;use strict;use warnings;use TAP::Formatter::File::Session;use POSIX qw(strftime);use base 'TAP::Formatter::Base';our$VERSION='3.44';sub open_test {my ($self,$test,$parser)=@_;my$session=TAP::Formatter::File::Session->new({name=>$test,formatter=>$self,parser=>$parser,});$session->header;return$session}sub _should_show_count {return 0}1;
TAP_FORMATTER_FILE

$fatpacked{"TAP/Formatter/File/Session.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_FILE_SESSION';
  package TAP::Formatter::File::Session;use strict;use warnings;use base 'TAP::Formatter::Session';our$VERSION='3.44';sub result {my$self=shift;my$result=shift;my$parser=$self->parser;my$formatter=$self->formatter;if ($result->is_bailout){$formatter->_failure_output("Bailout called.  Further testing stopped:  " .$result->explanation ."\n");return}if (!$formatter->quiet && ($formatter->verbose || ($result->is_test && $formatter->failures &&!$result->is_ok)|| ($formatter->comments && $result->is_comment)|| ($result->has_directive && $formatter->directives))){$self->{results}.= $self->_format_for_output($result)."\n"}}sub close_test {my$self=shift;$self->parser(undef);my$parser=$self->parser;my$formatter=$self->formatter;my$pretty=$formatter->_format_name($self->name);return if$formatter->really_quiet;if (my$skip_all=$parser->skip_all){$formatter->_output($pretty ."skipped: $skip_all\n")}elsif ($parser->has_problems){$formatter->_output($pretty .($self->{results}? "\n" .$self->{results}: "\n"));$self->_output_test_failure($parser)}else {my$time_report=$self->time_report($formatter,$parser);$formatter->_output($pretty .($self->{results}? "\n" .$self->{results}: "").$self->_make_ok_line($time_report))}}1;
TAP_FORMATTER_FILE_SESSION

$fatpacked{"TAP/Formatter/Session.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_SESSION';
  package TAP::Formatter::Session;use strict;use warnings;use base 'TAP::Base';my@ACCESSOR;BEGIN {@ACCESSOR=qw(name formatter parser show_count);for my$method (@ACCESSOR){no strict 'refs';*$method=sub {shift->{$method}}}}our$VERSION='3.44';sub _initialize {my ($self,$arg_for)=@_;$arg_for ||= {};$self->SUPER::_initialize($arg_for);my%arg_for=%$arg_for;for my$name (@ACCESSOR){$self->{$name}=delete$arg_for{$name}}if (!defined$self->show_count){$self->{show_count}=1}if ($self->show_count){$self->{show_count}=$self->_should_show_count}if (my@props=sort keys%arg_for){$self->_croak("Unknown arguments to " .__PACKAGE__ ."::new (@props)")}return$self}sub header {}sub result {}sub close_test {}sub clear_for_close {}sub _should_show_count {my$self=shift;return !$self->formatter->verbose && -t $self->formatter->stdout &&!$ENV{HARNESS_NOTTY}}sub _format_for_output {my ($self,$result)=@_;return$self->formatter->normalize ? $result->as_string : $result->raw}sub _output_test_failure {my ($self,$parser)=@_;my$formatter=$self->formatter;return if$formatter->really_quiet;my$tests_run=$parser->tests_run;my$tests_planned=$parser->tests_planned;my$total =defined$tests_planned ? $tests_planned : $tests_run;my$passed=$parser->passed;my$failed=$parser->failed + $total - $tests_run;my$exit=$parser->exit;if (my$exit=$parser->exit){my$wstat=$parser->wait;my$status=sprintf("%d (wstat %d, 0x%x)",$exit,$wstat,$wstat);$formatter->_failure_output("Dubious, test returned $status\n")}if ($failed==0){$formatter->_failure_output($total ? "All $total subtests passed " : 'No subtests run ')}else {$formatter->_failure_output("Failed $failed/$total subtests ");if (!$total){$formatter->_failure_output("\nNo tests run!")}}if (my$skipped=$parser->skipped){$passed -= $skipped;my$test='subtest' .($skipped!=1 ? 's' : '');$formatter->_output("\n\t(less $skipped skipped $test: $passed okay)")}if (my$failed=$parser->todo_passed){my$test=$failed > 1 ? 'tests' : 'test';$formatter->_output("\n\t($failed TODO $test unexpectedly succeeded)")}$formatter->_output("\n")}sub _make_ok_line {my ($self,$suffix)=@_;return "ok$suffix\n"}sub time_report {my ($self,$formatter,$parser)=@_;my@time_report;if ($formatter->timer){my$start_time=$parser->start_time;my$end_time=$parser->end_time;if (defined$start_time and defined$end_time){my$elapsed=$end_time - $start_time;push@time_report,$self->time_is_hires ? sprintf(' %8d ms',$elapsed * 1000): sprintf(' %8s s',$elapsed || '<1')}my$start_times=$parser->start_times();my$end_times=$parser->end_times();my$usr=$end_times->[0]- $start_times->[0];my$sys=$end_times->[1]- $start_times->[1];my$cusr=$end_times->[2]- $start_times->[2];my$csys=$end_times->[3]- $start_times->[3];push@time_report,sprintf('(%5.2f usr %5.2f sys + %5.2f cusr %5.2f csys = %5.2f CPU)',$usr,$sys,$cusr,$csys,$usr + $sys + $cusr + $csys)}return "@time_report"}1;
TAP_FORMATTER_SESSION

$fatpacked{"TAP/Harness.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_HARNESS';
  package TAP::Harness;use strict;use warnings;use Carp;use File::Spec;use File::Path;use IO::Handle;use base 'TAP::Base';our$VERSION='3.44';$ENV{HARNESS_ACTIVE}=1;$ENV{HARNESS_VERSION}=$VERSION;END {delete$ENV{HARNESS_ACTIVE};delete$ENV{HARNESS_VERSION}}my%VALIDATION_FOR;my@FORMATTER_ARGS;sub _error {my$self=shift;return$self->{error}unless @_;$self->{error}=shift}BEGIN {@FORMATTER_ARGS=qw(directives verbosity timer failures comments errors stdout color show_count normalize);%VALIDATION_FOR=(lib=>sub {my ($self,$libs)=@_;$libs=[$libs]unless 'ARRAY' eq ref$libs;return [map {"-I$_"}@$libs ]},switches=>sub {shift;shift},exec=>sub {shift;shift},merge=>sub {shift;shift},aggregator_class=>sub {shift;shift},formatter_class=>sub {shift;shift},multiplexer_class=>sub {shift;shift},parser_class=>sub {shift;shift},scheduler_class=>sub {shift;shift},formatter=>sub {shift;shift},jobs=>sub {shift;shift},test_args=>sub {shift;shift},ignore_exit=>sub {shift;shift},rules=>sub {shift;shift},rulesfile=>sub {shift;shift},sources=>sub {shift;shift},version=>sub {shift;shift},trap=>sub {shift;shift},);for my$method (sort keys%VALIDATION_FOR){no strict 'refs';if ($method eq 'lib' || $method eq 'switches'){*{$method}=sub {my$self=shift;unless (@_){$self->{$method}||= [];return wantarray ? @{$self->{$method}}: $self->{$method}}$self->_croak("Too many arguments to method '$method'")if @_ > 1;my$args=shift;$args=[$args]unless ref$args;$self->{$method}=$args;return$self}}else {*{$method}=sub {my$self=shift;return$self->{$method}unless @_;$self->{$method}=shift}}}for my$method (@FORMATTER_ARGS){no strict 'refs';*{$method}=sub {my$self=shift;return$self->formatter->$method(@_)}}}{my@legal_callback=qw(parser_args made_parser before_runtests after_runtests after_test);my%default_class=(aggregator_class=>'TAP::Parser::Aggregator',formatter_class=>'TAP::Formatter::Console',multiplexer_class=>'TAP::Parser::Multiplexer',parser_class=>'TAP::Parser',scheduler_class=>'TAP::Parser::Scheduler',);sub _initialize {my ($self,$arg_for)=@_;$arg_for ||= {};$self->SUPER::_initialize($arg_for,\@legal_callback);my%arg_for=%$arg_for;for my$name (sort keys%VALIDATION_FOR){my$property=delete$arg_for{$name};if (defined$property){my$validate=$VALIDATION_FOR{$name};my$value=$self->$validate($property);if ($self->_error){$self->_croak}$self->$name($value)}}$self->jobs(1)unless defined$self->jobs;if (!defined$self->rules){$self->_maybe_load_rulesfile}local$default_class{formatter_class}='TAP::Formatter::File' unless -t ($arg_for{stdout}|| \*STDOUT)&&!$ENV{HARNESS_NOTTY};while (my ($attr,$class)=each%default_class){$self->$attr($self->$attr()|| $class)}unless ($self->formatter){my%formatter_args=(jobs=>$self->jobs);for my$name (@FORMATTER_ARGS){if (defined(my$property=delete$arg_for{$name})){$formatter_args{$name}=$property}}$self->formatter($self->_construct($self->formatter_class,\%formatter_args))}if (my@props=sort keys%arg_for){$self->_croak("Unknown arguments to TAP::Harness::new (@props)")}return$self}sub _maybe_load_rulesfile {my ($self)=@_;my ($rulesfile)=defined$self->rulesfile ? $self->rulesfile : defined($ENV{HARNESS_RULESFILE})? $ENV{HARNESS_RULESFILE}: grep {-r}qw(./testrules.yml t/testrules.yml);if (defined$rulesfile && -r $rulesfile){if (!eval {require CPAN::Meta::YAML;1}){warn "CPAN::Meta::YAML required to process $rulesfile" ;return}my$layer=$] lt "5.008" ? "" : ":encoding(UTF-8)";open my$fh,"<$layer",$rulesfile or die "Couldn't open $rulesfile: $!";my$yaml_text=do {local $/;<$fh>};my$yaml=CPAN::Meta::YAML->read_string($yaml_text)or die CPAN::Meta::YAML->errstr;$self->rules($yaml->[0])}return}}sub runtests {my ($self,@tests)=@_;my$aggregate=$self->_construct($self->aggregator_class);$self->_make_callback('before_runtests',$aggregate);$aggregate->start;my$finish=sub {my$interrupted=shift;$aggregate->stop;$self->summary($aggregate,$interrupted);$self->_make_callback('after_runtests',$aggregate)};my$run=sub {my$bailout;eval {$self->aggregate_tests($aggregate,@tests);1}or do {$bailout=$@ || 'unknown_error'};$finish->();die$bailout if defined$bailout};if ($self->trap){local$SIG{INT}=sub {print "\n";$finish->(1);exit};$run->()}else {$run->()}return$aggregate}sub summary {my ($self,@args)=@_;$self->formatter->summary(@args)}sub _after_test {my ($self,$aggregate,$job,$parser)=@_;$self->_make_callback('after_test',$job->as_array_ref,$parser);$aggregate->add($job->description,$parser)}sub _bailout {my ($self,$result,$parser,$session,$aggregate,$job)=@_;$self->finish_parser($parser,$session);$self->_after_test($aggregate,$job,$parser);$job->finish;my$explanation=$result->explanation;die "FAILED--Further testing stopped" .($explanation ? ": $explanation\n" : ".\n")}sub _aggregate_parallel {my ($self,$aggregate,$scheduler)=@_;my$jobs=$self->jobs;my$mux=$self->_construct($self->multiplexer_class);RESULT: {FILL: while ($mux->parsers < $jobs){my$job=$scheduler->get_job;last FILL if!defined$job || $job->is_spinner;my ($parser,$session)=$self->make_parser($job);$mux->add($parser,[$session,$job ]);$parser->start_time($parser->get_time);$parser->start_times($parser->get_times)}if (my ($parser,$stash,$result)=$mux->next){my ($session,$job)=@$stash;if (defined$result){$session->result($result);$self->_bailout($result,$parser,$session,$aggregate,$job)if$result->is_bailout}else {$self->finish_parser($parser,$session);$self->_after_test($aggregate,$job,$parser);$job->finish}redo RESULT}}return}sub _aggregate_single {my ($self,$aggregate,$scheduler)=@_;JOB: while (my$job=$scheduler->get_job){next JOB if$job->is_spinner;my ($parser,$session)=$self->make_parser($job);while (defined(my$result=$parser->next)){$session->result($result);if ($result->is_bailout){1 while$parser->next;$self->_bailout($result,$parser,$session,$aggregate,$job)}}$self->finish_parser($parser,$session);$self->_after_test($aggregate,$job,$parser);$job->finish}return}sub aggregate_tests {my ($self,$aggregate,@tests)=@_;my$jobs=$self->jobs;my$scheduler=$self->make_scheduler(@tests);local$ENV{HARNESS_IS_VERBOSE}=1 if$self->formatter->verbosity > 0;$self->formatter->prepare(map {$_->description}$scheduler->get_all);if ($self->jobs > 1){$self->_aggregate_parallel($aggregate,$scheduler)}else {$self->_aggregate_single($aggregate,$scheduler)}return}sub _add_descriptions {my$self=shift;return map {@$_==1 ? [$_->[0],$_->[0]]: $_}map {'ARRAY' eq ref $_ ? $_ : [$_]}@_}sub make_scheduler {my ($self,@tests)=@_;return$self->_construct($self->scheduler_class,tests=>[$self->_add_descriptions(@tests)],rules=>$self->rules)}sub _get_parser_args {my ($self,$job)=@_;my$test_prog=$job->filename;my%args=();$args{sources}=$self->sources if$self->sources;my@switches;@switches=$self->lib if$self->lib;push@switches=>$self->switches if$self->switches;$args{switches}=\@switches;$args{spool}=$self->_open_spool($test_prog);$args{merge}=$self->merge;$args{ignore_exit}=$self->ignore_exit;$args{version}=$self->version if$self->version;if (my$exec=$self->exec){$args{exec}=ref$exec eq 'CODE' ? $exec->($self,$test_prog): [@$exec,$test_prog ];if (not defined$args{exec}){$args{source}=$test_prog}elsif ((ref($args{exec})|| "")ne "ARRAY"){$args{source}=delete$args{exec}}}else {$args{source}=$test_prog}if (defined(my$test_args=$self->test_args)){if (ref($test_args)eq 'HASH'){if (exists($test_args->{$job->description })){$test_args=$test_args->{$job->description }}else {$self->_croak("TAP::Harness Can't find test_args for " .$job->description)}}$args{test_args}=$test_args}return \%args}sub make_parser {my ($self,$job)=@_;my$args=$self->_get_parser_args($job);$self->_make_callback('parser_args',$args,$job->as_array_ref);my$parser=$self->_construct($self->parser_class,$args);$self->_make_callback('made_parser',$parser,$job->as_array_ref);my$session=$self->formatter->open_test($job->description,$parser);return ($parser,$session)}sub finish_parser {my ($self,$parser,$session)=@_;$session->close_test;$self->_close_spool($parser);return$parser}sub _open_spool {my$self=shift;my$test=shift;if (my$spool_dir=$ENV{PERL_TEST_HARNESS_DUMP_TAP}){my$spool=File::Spec->catfile($spool_dir,$test);my ($vol,$dir,undef)=File::Spec->splitpath($spool);my$path=File::Spec->catpath($vol,$dir,'');eval {mkpath($path)};$self->_croak($@)if $@;my$spool_handle=IO::Handle->new;open($spool_handle,">$spool")or $self->_croak(" Can't write $spool ( $! ) ");return$spool_handle}return}sub _close_spool {my$self=shift;my ($parser)=@_;if (my$spool_handle=$parser->delete_spool){close($spool_handle)or $self->_croak(" Error closing TAP spool file( $! ) \n ")}return}sub _croak {my ($self,$message)=@_;unless ($message){$message=$self->_error}$self->SUPER::_croak($message);return}1;
TAP_HARNESS

$fatpacked{"TAP/Harness/Env.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_HARNESS_ENV';
  package TAP::Harness::Env;use strict;use warnings;use constant IS_VMS=>($^O eq 'VMS');use TAP::Object;use Text::ParseWords qw/shellwords/;our$VERSION='3.44';sub _filtered_inc_vms {my@inc=grep {!ref}@INC;@inc=grep {!/perl_root/i}@inc;my@default_inc=_default_inc();my@new_inc;my%seen;for my$dir (@inc){next if$seen{$dir}++;if ($dir eq ($default_inc[0]|| '')){shift@default_inc}else {push@new_inc,$dir}shift@default_inc while@default_inc and $seen{$default_inc[0]}}return@new_inc}my@inc;sub _default_inc {return@inc if@inc;local$ENV{PERL5LIB};local$ENV{PERLLIB};my$perl=$ENV{HARNESS_PERL}|| $^X;chomp(@inc=`"$perl" -e "print join qq[\\n], \@INC, q[]"`);return@inc}sub create {my$package=shift;my%input=%{shift || {}};my@libs=@{delete$input{libs}|| []};my@raw_switches=@{delete$input{switches}|| []};my@opt =(@raw_switches,shellwords($ENV{HARNESS_PERL_SWITCHES}|| ''));my@switches;while (my$opt=shift@opt){if ($opt =~ /^ -I (.*) $ /x){push@libs,length($1)? $1 : shift@opt}else {push@switches,$opt}}push@libs,_filtered_inc_vms()if IS_VMS;my$verbose =$ENV{HARNESS_VERBOSE}? $ENV{HARNESS_VERBOSE}!~ /\d/ ? 1 : $ENV{HARNESS_VERBOSE}: 0;my%args=(lib=>\@libs,timer=>$ENV{HARNESS_TIMER}|| 0,switches=>\@switches,color=>$ENV{HARNESS_COLOR}|| 0,verbosity=>$verbose,ignore_exit=>$ENV{HARNESS_IGNORE_EXIT}|| 0,);my$class=delete$input{harness_class}|| $ENV{HARNESS_SUBCLASS}|| 'TAP::Harness';if (defined(my$env_opt=$ENV{HARNESS_OPTIONS})){for my$opt (split /:/,$env_opt){if ($opt =~ /^j(\d*)$/){$args{jobs}=$1 || 9}elsif ($opt eq 'c'){$args{color}=1}elsif ($opt =~ m/^f(.*)$/){my$fmt=$1;$fmt =~ s/-/::/g;$args{formatter_class}=$fmt}elsif ($opt =~ m/^a(.*)$/){my$archive=$1;$class='TAP::Harness::Archive';$args{archive}=$archive}else {die "Unknown HARNESS_OPTIONS item: $opt\n"}}}return TAP::Object->_construct($class,{%args,%input })}1;
TAP_HARNESS_ENV

$fatpacked{"TAP/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_OBJECT';
  package TAP::Object;use strict;use warnings;our$VERSION='3.44';sub new {my$class=shift;my$self=bless {},$class;return$self->_initialize(@_)}sub _initialize {return $_[0]}sub _croak {my$proto=shift;require Carp;Carp::croak(@_);return}sub _confess {my$proto=shift;require Carp;Carp::confess(@_);return}sub _construct {my ($self,$class,@args)=@_;$self->_croak("Bad module name $class")unless$class =~ /^ \w+ (?: :: \w+ ) *$/x;unless ($class->can('new')){local $@;eval "require $class";$self->_croak("Can't load $class: $@")if $@}return$class->new(@args)}sub mk_methods {my ($class,@methods)=@_;for my$method_name (@methods){my$method="${class}::$method_name";no strict 'refs';*$method=sub {my$self=shift;$self->{$method_name}=shift if @_;return$self->{$method_name}}}}1;
TAP_OBJECT

$fatpacked{"TAP/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER';
  package TAP::Parser;use strict;use warnings;use TAP::Parser::Grammar ();use TAP::Parser::Result ();use TAP::Parser::ResultFactory ();use TAP::Parser::Source ();use TAP::Parser::Iterator ();use TAP::Parser::IteratorFactory ();use TAP::Parser::SourceHandler::Executable ();use TAP::Parser::SourceHandler::Perl ();use TAP::Parser::SourceHandler::File ();use TAP::Parser::SourceHandler::RawTAP ();use TAP::Parser::SourceHandler::Handle ();use Carp qw(confess);use base 'TAP::Base';our$VERSION='3.44';my$DEFAULT_TAP_VERSION=12;my$MAX_TAP_VERSION=13;$ENV{TAP_VERSION}=$MAX_TAP_VERSION;END {delete$ENV{TAP_VERSION}}BEGIN {__PACKAGE__->mk_methods(qw(_iterator _spool exec exit is_good_plan plan tests_planned tests_run wait version in_todo start_time end_time start_times end_times skip_all grammar_class result_factory_class iterator_factory_class));sub _stream {my$self=shift;$self->_iterator(@_)}}sub _default_grammar_class {'TAP::Parser::Grammar'}sub _default_result_factory_class {'TAP::Parser::ResultFactory'}sub _default_iterator_factory_class {'TAP::Parser::IteratorFactory'}sub next {my$self=shift;return ($self->{_iter}||= $self->_iter)->()}sub run {my$self=shift;while (defined(my$result=$self->next)){}}sub make_iterator_factory {shift->iterator_factory_class->new(@_)}sub make_grammar {shift->grammar_class->new(@_)}sub make_result {shift->result_factory_class->make_result(@_)}{my%initialize=(version=>$DEFAULT_TAP_VERSION,plan=>'',tests_run=>0,skipped=>[],todo=>[],passed=>[],failed=>[],actual_failed=>[],actual_passed=>[],todo_passed=>[],parse_errors=>[],);my@legal_callback=qw(test version plan comment bailout unknown yaml ALL ELSE EOF);my@class_overrides=qw(grammar_class result_factory_class iterator_factory_class);sub _initialize {my ($self,$arg_for)=@_;my%args=%{$arg_for || {}};$self->SUPER::_initialize(\%args,\@legal_callback);for my$key (@class_overrides){my$default_method="_default_$key";my$val=delete$args{$key}|| $self->$default_method();$self->$key($val)}my$iterator=delete$args{iterator};$iterator ||= delete$args{stream};my$tap=delete$args{tap};my$version=delete$args{version};my$raw_source=delete$args{source};my$sources=delete$args{sources};my$exec=delete$args{exec};my$merge=delete$args{merge};my$spool=delete$args{spool};my$switches=delete$args{switches};my$ignore_exit=delete$args{ignore_exit};my$test_args=delete$args{test_args}|| [];if (1 < grep {defined}$iterator,$tap,$raw_source,$exec){$self->_croak("You may only choose one of 'exec', 'tap', 'source' or 'iterator'")}if (my@excess=sort keys%args){$self->_croak("Unknown options: @excess")}my$type='';my$source=TAP::Parser::Source->new;if ($tap){$type='raw TAP';$source->raw(\$tap)}elsif ($exec){$type='exec ' .$exec->[0];$source->raw({exec=>$exec })}elsif ($raw_source){$type='source ' .ref($raw_source)|| $raw_source;$source->raw(ref($raw_source)? $raw_source : \$raw_source)}elsif ($iterator){$type='iterator ' .ref($iterator)}if ($source->raw){my$src_factory=$self->make_iterator_factory($sources);$source->merge($merge)->switches($switches)->test_args($test_args);$iterator=$src_factory->make_iterator($source)}unless ($iterator){$self->_croak("PANIC: could not determine iterator for input $type")}while (my ($k,$v)=each%initialize){$self->{$k}='ARRAY' eq ref$v ? []: $v}$self->version($version)if$version;$self->_iterator($iterator);$self->_spool($spool);$self->ignore_exit($ignore_exit);return$self}}sub passed {return @{$_[0]->{passed}}if ref $_[0]->{passed};return wantarray ? 1 .. $_[0]->{passed}: $_[0]->{passed}}sub failed {@{shift->{failed}}}sub actual_passed {return @{$_[0]->{actual_passed}}if ref $_[0]->{actual_passed};return wantarray ? 1 .. $_[0]->{actual_passed}: $_[0]->{actual_passed}}*actual_ok=\&actual_passed;sub actual_failed {@{shift->{actual_failed}}}sub todo {@{shift->{todo}}}sub todo_passed {@{shift->{todo_passed}}}sub todo_failed {warn '"todo_failed" is deprecated.  Please use "todo_passed".  See the docs.';goto&todo_passed}sub skipped {@{shift->{skipped}}}sub pragma {my ($self,$pragma)=splice @_,0,2;return$self->{pragma}->{$pragma}unless @_;if (my$state=shift){$self->{pragma}->{$pragma}=1}else {delete$self->{pragma}->{$pragma}}return}sub pragmas {sort keys %{shift->{pragma}|| {}}}sub good_plan {warn 'good_plan() is deprecated.  Please use "is_good_plan()"';goto&is_good_plan}sub has_problems {my$self=shift;return $self->failed || $self->parse_errors || (!$self->ignore_exit && ($self->wait || $self->exit))}sub ignore_exit {shift->pragma('ignore_exit',@_)}sub parse_errors {@{shift->{parse_errors}}}sub _add_error {my ($self,$error)=@_;push @{$self->{parse_errors}}=>$error;return$self}sub _make_state_table {my$self=shift;my%states;my%planned_todo=();my%state_globals=(comment=>{},bailout=>{},yaml=>{},version=>{act=>sub {$self->_add_error('If TAP version is present it must be the first line of output')},},unknown=>{act=>sub {my$unk=shift;if ($self->pragma('strict')){$self->_add_error('Unknown TAP token: "' .$unk->raw .'"')}},},pragma=>{act=>sub {my ($pragma)=@_;for my$pr ($pragma->pragmas){if ($pr =~ /^ ([-+])(\w+) $/x){$self->pragma($2,$1 eq '+')}}},},);my%state_defaults=(plan=>{act=>sub {my ($plan)=@_;$self->tests_planned($plan->tests_planned);$self->plan($plan->plan);if ($plan->has_skip){$self->skip_all($plan->explanation || '(no reason given)')}$planned_todo{$_}++ for @{$plan->todo_list}},},test=>{act=>sub {my ($test)=@_;my ($number,$tests_run)=($test->number,++$self->{tests_run});if (defined$number && delete$planned_todo{$number}){$test->set_directive('TODO')}my$has_todo=$test->has_todo;$self->in_todo($has_todo);if (defined(my$tests_planned=$self->tests_planned)){if ($tests_run > $tests_planned){$test->is_unplanned(1)}}if (defined$number){if ($number!=$tests_run){my$count=$tests_run;$self->_add_error("Tests out of sequence.  Found " ."($number) but expected ($count)")}}else {$test->_number($number=$tests_run)}push @{$self->{todo}}=>$number if$has_todo;push @{$self->{todo_passed}}=>$number if$test->todo_passed;push @{$self->{skipped}}=>$number if$test->has_skip;push @{$self->{$test->is_ok ? 'passed' : 'failed' }}=>$number;push @{$self->{$test->is_actual_ok ? 'actual_passed' : 'actual_failed' }}=>$number},},yaml=>{act=>sub {},},);%states=(INIT=>{version=>{act=>sub {my ($version)=@_;my$ver_num=$version->version;if ($ver_num <= $DEFAULT_TAP_VERSION){my$ver_min=$DEFAULT_TAP_VERSION + 1;$self->_add_error("Explicit TAP version must be at least " ."$ver_min. Got version $ver_num");$ver_num=$DEFAULT_TAP_VERSION}if ($ver_num > $MAX_TAP_VERSION){$self->_add_error("TAP specified version $ver_num but " ."we don't know about versions later " ."than $MAX_TAP_VERSION");$ver_num=$MAX_TAP_VERSION}$self->version($ver_num);$self->_grammar->set_version($ver_num)},goto=>'PLAN' },plan=>{goto=>'PLANNED' },test=>{goto=>'UNPLANNED' },},PLAN=>{plan=>{goto=>'PLANNED' },test=>{goto=>'UNPLANNED' },},PLANNED=>{test=>{goto=>'PLANNED_AFTER_TEST' },plan=>{act=>sub {my ($version)=@_;$self->_add_error('More than one plan found in TAP output')},},},PLANNED_AFTER_TEST=>{test=>{goto=>'PLANNED_AFTER_TEST' },plan=>{act=>sub {},continue=>'PLANNED' },yaml=>{goto=>'PLANNED' },},GOT_PLAN=>{test=>{act=>sub {my ($plan)=@_;my$line=$self->plan;$self->_add_error("Plan ($line) must be at the beginning " ."or end of the TAP output");$self->is_good_plan(0)},continue=>'PLANNED' },plan=>{continue=>'PLANNED' },},UNPLANNED=>{test=>{goto=>'UNPLANNED_AFTER_TEST' },plan=>{goto=>'GOT_PLAN' },},UNPLANNED_AFTER_TEST=>{test=>{act=>sub {},continue=>'UNPLANNED' },plan=>{act=>sub {},continue=>'UNPLANNED' },yaml=>{goto=>'UNPLANNED' },},);for my$name (keys%states){my$st={%state_globals,%{$states{$name}}};for my$next (sort keys %{$st}){if (my$default=$state_defaults{$next}){for my$def (sort keys %{$default}){$st->{$next}->{$def}||= $default->{$def}}}}$states{$name}=$st}return \%states}sub get_select_handles {shift->_iterator->get_select_handles}sub _grammar {my$self=shift;return$self->{_grammar}=shift if @_;return$self->{_grammar}||= $self->make_grammar({iterator=>$self->_iterator,parser=>$self,version=>$self->version })}sub _iter {my$self=shift;my$iterator=$self->_iterator;my$grammar=$self->_grammar;my$spool=$self->_spool;my$state='INIT';my$state_table=$self->_make_state_table;$self->start_time($self->get_time)unless$self->{start_time};$self->start_times($self->get_times)unless$self->{start_times};my$next_state=sub {my$token=shift;my$type=$token->type;TRANS: {my$state_spec=$state_table->{$state}or die "Illegal state: $state";if (my$next=$state_spec->{$type}){if (my$act=$next->{act}){$act->($token)}if (my$cont=$next->{continue}){$state=$cont;redo TRANS}elsif (my$goto=$next->{goto}){$state=$goto}}else {confess("Unhandled token type: $type\n")}}return$token};my$end_handler=sub {$self->exit($iterator->exit);$self->wait($iterator->wait);$self->_finish;return};if ($self->_has_callbacks){return sub {my$result=eval {$grammar->tokenize};$self->_add_error($@)if $@;if (defined$result){$result=$next_state->($result);if (my$code=$self->_callback_for($result->type)){$_->($result)for @{$code}}else {$self->_make_callback('ELSE',$result)}$self->_make_callback('ALL',$result);print {$spool}$result->raw,"\n" if$spool}else {$result=$end_handler->();$self->_make_callback('EOF',$self)unless defined$result}return$result}}else {return sub {my$result=eval {$grammar->tokenize};$self->_add_error($@)if $@;if (defined$result){$result=$next_state->($result);print {$spool}$result->raw,"\n" if$spool}else {$result=$end_handler->()}return$result}}}sub _finish {my$self=shift;$self->end_time($self->get_time);$self->end_times($self->get_times);$self->_iterator(undef);$self->_grammar(undef);$self->{_iter}=sub {return}if $] >= 5.006;if (!$self->plan){$self->_add_error('No plan found in TAP output')}else {$self->is_good_plan(1)unless defined$self->is_good_plan}if ($self->tests_run!=($self->tests_planned || 0)){$self->is_good_plan(0);if (defined(my$planned=$self->tests_planned)){my$ran=$self->tests_run;$self->_add_error("Bad plan.  You planned $planned tests but ran $ran.")}}if ($self->tests_run!=($self->passed + $self->failed)){my$actual=$self->tests_run;my$passed=$self->passed;my$failed=$self->failed;$self->_croak("Panic: planned test count ($actual) did not equal " ."sum of passed ($passed) and failed ($failed) tests!")}$self->is_good_plan(0)unless defined$self->is_good_plan;unless ($self->parse_errors){if ($self->tests_run==@{$self->{passed}}){$self->{passed}=$self->tests_run}if ($self->tests_run==@{$self->{actual_passed}}){$self->{actual_passed}=$self->tests_run}}return$self}sub delete_spool {my$self=shift;return delete$self->{_spool}}1;
TAP_PARSER

$fatpacked{"TAP/Parser/Aggregator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_AGGREGATOR';
  package TAP::Parser::Aggregator;use strict;use warnings;use Benchmark;use base 'TAP::Object';our$VERSION='3.44';my%SUMMARY_METHOD_FOR;BEGIN {%SUMMARY_METHOD_FOR=map {$_=>$_}qw(failed parse_errors passed skipped todo todo_passed total wait exit);$SUMMARY_METHOD_FOR{total}='tests_run';$SUMMARY_METHOD_FOR{planned}='tests_planned';for my$method (keys%SUMMARY_METHOD_FOR){next if 'total' eq $method;no strict 'refs';*$method=sub {my$self=shift;return wantarray ? @{$self->{"descriptions_for_$method"}}: $self->{$method}}}}sub _initialize {my ($self)=@_;$self->{parser_for}={};$self->{parse_order}=[];for my$summary (keys%SUMMARY_METHOD_FOR){$self->{$summary}=0;next if 'total' eq $summary;$self->{"descriptions_for_$summary"}=[]}return$self}sub add {my ($self,$description,$parser)=@_;if (exists$self->{parser_for}{$description}){$self->_croak("You already have a parser for ($description)." ." Perhaps you have run the same test twice.")}push @{$self->{parse_order}}=>$description;$self->{parser_for}{$description}=$parser;while (my ($summary,$method)=each%SUMMARY_METHOD_FOR){next if ($method eq 'exit' || $method eq 'wait')&& $parser->ignore_exit;if (my$count=$parser->$method()){$self->{$summary}+= $count;push @{$self->{"descriptions_for_$summary"}}=>$description}}return$self}sub parsers {my$self=shift;return$self->_get_parsers(@_)if @_;my$descriptions=$self->{parse_order};my@parsers=@{$self->{parser_for}}{@$descriptions};return@parsers}sub _get_parsers {my ($self,@descriptions)=@_;my@parsers;for my$description (@descriptions){$self->_croak("A parser for ($description) could not be found")unless exists$self->{parser_for}{$description};push@parsers=>$self->{parser_for}{$description}}return wantarray ? @parsers : \@parsers}sub descriptions {@{shift->{parse_order}|| []}}sub start {my$self=shift;$self->{start_time}=Benchmark->new}sub stop {my$self=shift;$self->{end_time}=Benchmark->new}sub elapsed {my$self=shift;require Carp;Carp::croak q{Can't call elapsed without first calling start and then stop} unless defined$self->{start_time}&& defined$self->{end_time};return timediff($self->{end_time},$self->{start_time})}sub elapsed_timestr {my$self=shift;my$elapsed=$self->elapsed;return timestr($elapsed)}sub all_passed {my$self=shift;return $self->total && $self->total==$self->passed &&!$self->has_errors}sub get_status {my$self=shift;my$total=$self->total;my$passed=$self->passed;return ($self->has_errors || $total!=$passed)? 'FAIL' : $total ? 'PASS' : 'NOTESTS'}sub total {shift->{total}}sub has_problems {my$self=shift;return$self->todo_passed || $self->has_errors}sub has_errors {my$self=shift;return $self->failed || $self->parse_errors || $self->exit || $self->wait}sub todo_failed {warn '"todo_failed" is deprecated.  Please use "todo_passed".  See the docs.';goto&todo_passed}1;
TAP_PARSER_AGGREGATOR

$fatpacked{"TAP/Parser/Grammar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_GRAMMAR';
  package TAP::Parser::Grammar;use strict;use warnings;use TAP::Parser::ResultFactory ();use TAP::Parser::YAMLish::Reader ();use base 'TAP::Object';our$VERSION='3.44';sub _initialize {my ($self,$args)=@_;$self->{iterator}=$args->{iterator};$self->{iterator}||= $args->{stream};$self->{parser}=$args->{parser};$self->set_version($args->{version}|| 12);return$self}my%language_for;{my$ok=qr/(?:not )?ok\b/;my$num=qr/\d+/;my%v12=(version=>{syntax=>qr/^TAP\s+version\s+(\d+)\s*\z/i,handler=>sub {my ($self,$line)=@_;my$version=$1;return$self->_make_version_token($line,$version,)},},plan=>{syntax=>qr/^1\.\.(\d+)\s*(.*)\z/,handler=>sub {my ($self,$line)=@_;my ($tests_planned,$tail)=($1,$2);my$explanation=undef;my$skip='';if ($tail =~ /^todo((?:\s+\d+)+)/){my@todo=split /\s+/,_trim($1);return$self->_make_plan_token($line,$tests_planned,'TODO','',\@todo)}elsif (0==$tests_planned){$skip='SKIP';($explanation)=$tail =~ /^#\s*SKIP\S*\s+(.*)/i}elsif ($tail !~ /^\s*$/){return$self->_make_unknown_token($line)}$explanation='' unless defined$explanation;return$self->_make_plan_token($line,$tests_planned,$skip,$explanation,[])},},simple_test=>{syntax=>qr/^($ok) \ ($num) (?:\ ([^#]+))? \z/x,handler=>sub {my ($self,$line)=@_;my ($ok,$num,$desc)=($1,$2,$3);return$self->_make_test_token($line,$ok,$num,$desc)},},test=>{syntax=>qr/^($ok) \s* ($num)? \s* (.*) \z/x,handler=>sub {my ($self,$line)=@_;my ($ok,$num,$desc)=($1,$2,$3);my ($dir,$explanation)=('','');if ($desc =~ m/^ ( [^\\\#]* (?: \\. [^\\\#]* )* )
                         \# \s* (SKIP|TODO) \b \s* (.*) $/ix){($desc,$dir,$explanation)=($1,$2,$3)}return$self->_make_test_token($line,$ok,$num,$desc,$dir,$explanation)},},comment=>{syntax=>qr/^#(.*)/,handler=>sub {my ($self,$line)=@_;my$comment=$1;return$self->_make_comment_token($line,$comment)},},bailout=>{syntax=>qr/^\s*Bail out!\s*(.*)/,handler=>sub {my ($self,$line)=@_;my$explanation=$1;return$self->_make_bailout_token($line,$explanation)},},);my%v13=(%v12,plan=>{syntax=>qr/^1\.\.(\d+)\s*(?:\s*#\s*SKIP\b(.*))?\z/i,handler=>sub {my ($self,$line)=@_;my ($tests_planned,$explanation)=($1,$2);my$skip =(0==$tests_planned || defined$explanation)? 'SKIP' : '';$explanation='' unless defined$explanation;return$self->_make_plan_token($line,$tests_planned,$skip,$explanation,[])},},yaml=>{syntax=>qr/^ (\s+) (---.*) $/x,handler=>sub {my ($self,$line)=@_;my ($pad,$marker)=($1,$2);return$self->_make_yaml_token($pad,$marker)},},pragma=>{syntax=>qr/^ pragma \s+ ( [-+] \w+ \s* (?: , \s* [-+] \w+ \s* )* ) $/x,handler=>sub {my ($self,$line)=@_;my$pragmas=$1;return$self->_make_pragma_token($line,$pragmas)},},);%language_for=('12'=>{tokens=>\%v12,},'13'=>{tokens=>\%v13,setup=>sub {shift->{iterator}->handle_unicode},},)}sub set_version {my$self=shift;my$version=shift;if (my$language=$language_for{$version}){$self->{version}=$version;$self->{tokens}=$language->{tokens};if (my$setup=$language->{setup}){$self->$setup()}$self->_order_tokens}else {require Carp;Carp::croak("Unsupported syntax version: $version")}}sub _order_tokens {my$self=shift;my%copy=%{$self->{tokens}};my@ordered_tokens=grep {defined}map {delete$copy{$_}}qw(simple_test test comment plan);push@ordered_tokens,values%copy;$self->{ordered_tokens}=\@ordered_tokens}sub tokenize {my$self=shift;my$line=$self->{iterator}->next;unless (defined$line){delete$self->{parser};return}my$token;for my$token_data (@{$self->{ordered_tokens}}){if ($line =~ $token_data->{syntax}){my$handler=$token_data->{handler};$token=$self->$handler($line);last}}$token=$self->_make_unknown_token($line)unless$token;return$self->{parser}->make_result($token)}sub token_types {my$self=shift;return keys %{$self->{tokens}}}sub syntax_for {my ($self,$type)=@_;return$self->{tokens}->{$type}->{syntax}}sub handler_for {my ($self,$type)=@_;return$self->{tokens}->{$type}->{handler}}sub _make_version_token {my ($self,$line,$version)=@_;return {type=>'version',raw=>$line,version=>$version,}}sub _make_plan_token {my ($self,$line,$tests_planned,$directive,$explanation,$todo)=@_;if ($directive eq 'SKIP' && 0!=$tests_planned && $self->{version}< 13){warn "Specified SKIP directive in plan but more than 0 tests ($line)\n"}return {type=>'plan',raw=>$line,tests_planned=>$tests_planned,directive=>$directive,explanation=>_trim($explanation),todo_list=>$todo,}}sub _make_test_token {my ($self,$line,$ok,$num,$desc,$dir,$explanation)=@_;return {ok=>$ok,test_num=>(defined$num ? 0 + $num : undef),description=>_trim($desc),directive=>(defined$dir ? uc$dir : ''),explanation=>_trim($explanation),raw=>$line,type=>'test',}}sub _make_unknown_token {my ($self,$line)=@_;return {raw=>$line,type=>'unknown',}}sub _make_comment_token {my ($self,$line,$comment)=@_;return {type=>'comment',raw=>$line,comment=>_trim($comment)}}sub _make_bailout_token {my ($self,$line,$explanation)=@_;return {type=>'bailout',raw=>$line,bailout=>_trim($explanation)}}sub _make_yaml_token {my ($self,$pad,$marker)=@_;my$yaml=TAP::Parser::YAMLish::Reader->new;my$iterator=$self->{iterator};my$leader=length($pad);my$strip=qr{ ^ (\s{$leader}) (.*) $ }x;my@extra=($marker);my$reader=sub {return shift@extra if@extra;my$line=$iterator->next;return $2 if$line =~ $strip;return};my$data=$yaml->read($reader);chomp(my$raw=$yaml->get_raw);$raw =~ s/^/$pad/mg;return {type=>'yaml',raw=>$raw,data=>$data }}sub _make_pragma_token {my ($self,$line,$pragmas)=@_;return {type=>'pragma',raw=>$line,pragmas=>[split /\s*,\s*/,_trim($pragmas)],}}sub _trim {my$data=shift;return '' unless defined$data;$data =~ s/^\s+//;$data =~ s/\s+$//;return$data}1;
TAP_PARSER_GRAMMAR

$fatpacked{"TAP/Parser/Iterator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_ITERATOR';
  package TAP::Parser::Iterator;use strict;use warnings;use base 'TAP::Object';our$VERSION='3.44';sub next {my$self=shift;my$line=$self->next_raw;if (defined($line)and $line =~ /^\s*not\s*$/){$line .= ($self->next_raw || '')}return$line}sub next_raw {require Carp;my$msg=Carp::longmess('abstract method called directly!');$_[0]->_croak($msg)}sub handle_unicode {}sub get_select_handles {return}sub wait {require Carp;my$msg=Carp::longmess('abstract method called directly!');$_[0]->_croak($msg)}sub exit {require Carp;my$msg=Carp::longmess('abstract method called directly!');$_[0]->_croak($msg)}1;
TAP_PARSER_ITERATOR

$fatpacked{"TAP/Parser/Iterator/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_ITERATOR_ARRAY';
  package TAP::Parser::Iterator::Array;use strict;use warnings;use base 'TAP::Parser::Iterator';our$VERSION='3.44';sub _initialize {my ($self,$thing)=@_;chomp @$thing;$self->{idx}=0;$self->{array}=$thing;$self->{exit}=undef;return$self}sub wait {shift->exit}sub exit {my$self=shift;return 0 if$self->{idx}>= @{$self->{array}};return}sub next_raw {my$self=shift;return$self->{array}->[$self->{idx}++ ]}1;
TAP_PARSER_ITERATOR_ARRAY

$fatpacked{"TAP/Parser/Iterator/Process.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_ITERATOR_PROCESS';
  package TAP::Parser::Iterator::Process;use strict;use warnings;use Config;use IO::Handle;use base 'TAP::Parser::Iterator';my$IS_WIN32=($^O =~ /^(MS)?Win32$/);our$VERSION='3.44';{no warnings 'uninitialized';local$SIG{__DIE__}=undef;eval {require POSIX;&POSIX::WEXITSTATUS(0)};if ($@){*_wait2exit=sub {$_[1]>> 8}}else {*_wait2exit=sub {POSIX::WEXITSTATUS($_[1])}}}sub _use_open3 {my$self=shift;return unless$Config{d_fork}|| $IS_WIN32;for my$module (qw(IPC::Open3 IO::Select)){eval "use $module";return if $@}return 1}{my$got_unicode;sub _get_unicode {return$got_unicode if defined$got_unicode;eval 'use Encode qw(decode_utf8);';$got_unicode=$@ ? 0 : 1}}sub _initialize {my ($self,$args)=@_;my@command=@{delete$args->{command}|| []}or die "Must supply a command to execute";$self->{command}=[@command];my$chunk_size=delete$args->{_chunk_size}|| 65536;my$merge=delete$args->{merge};my ($pid,$err,$sel);if (my$setup=delete$args->{setup}){$setup->(@command)}my$out=IO::Handle->new;if ($self->_use_open3){my$xclose=\&IPC::Open3::xclose;no warnings;local*IPC::Open3::xclose=sub {my$fh=shift;no strict 'refs';return if (fileno($fh)==fileno(STDIN));$xclose->($fh)};if ($IS_WIN32){$err=$merge ? '' : '>&STDERR';eval {$pid=open3('<&STDIN',$out,$merge ? '' : $err,@command)};die "Could not execute (@command): $@" if $@;if ($] >= 5.006){binmode($out,":crlf")}}else {$err=$merge ? '' : IO::Handle->new;eval {$pid=open3('<&STDIN',$out,$err,@command)};die "Could not execute (@command): $@" if $@;$sel=$merge ? undef : IO::Select->new($out,$err)}}else {$err='';my$command =join(' ',map {$_ =~ /\s/ ? qq{"$_"} : $_}@command);open($out,"$command|")or die "Could not execute ($command): $!"}$self->{out}=$out;$self->{err}=$err;$self->{sel}=$sel;$self->{pid}=$pid;$self->{exit}=undef;$self->{chunk_size}=$chunk_size;if (my$teardown=delete$args->{teardown}){$self->{teardown}=sub {$teardown->(@command)}}return$self}sub handle_unicode {my$self=shift;if ($self->{sel}){if (_get_unicode()){my$next=$self->{_next}||= $self->_next;$self->{_next}=sub {my$line=$next->();return decode_utf8($line)if defined$line;return}}}else {if ($] >= 5.008){eval 'binmode($self->{out}, ":utf8")'}}}sub wait {shift->{wait}}sub exit {shift->{exit}}sub _next {my$self=shift;if (my$out=$self->{out}){if (my$sel=$self->{sel}){my$err=$self->{err};my@buf=();my$partial='';my$chunk_size=$self->{chunk_size};return sub {return shift@buf if@buf;READ: while (my@ready=$sel->can_read){for my$fh (@ready){my$got=sysread$fh,my ($chunk),$chunk_size;if ($got==0){$sel->remove($fh)}elsif ($fh==$err){print STDERR$chunk}else {$chunk=$partial .$chunk;$partial='';unless (substr($chunk,-1,1)eq "\n"){my$nl=rindex$chunk,"\n";if ($nl==-1){$partial=$chunk;redo READ}else {$partial=substr($chunk,$nl + 1);$chunk=substr($chunk,0,$nl)}}push@buf,split /\n/,$chunk;return shift@buf if@buf}}}if (length$partial){my$last=$partial;$partial='';return$last}$self->_finish;return}}else {return sub {if (defined(my$line=<$out>)){chomp$line;return$line}$self->_finish;return}}}else {return sub {$self->_finish;return}}}sub next_raw {my$self=shift;return ($self->{_next}||= $self->_next)->()}sub _finish {my$self=shift;my$status=$?;$self->{_next}=sub {return}if $] >= 5.006;if (defined$self->{pid}){if ($self->{pid}==waitpid($self->{pid},0)){$status=$?}}(delete$self->{out})->close if$self->{out};if ($self->{sel}){(delete$self->{err})->close;delete$self->{sel}}else {$status=$?}$status=0 if$IS_WIN32 && $status==-1;$self->{wait}=$status;$self->{exit}=$self->_wait2exit($status);if (my$teardown=$self->{teardown}){$teardown->()}return$self}sub get_select_handles {my$self=shift;return grep $_,($self->{out},$self->{err})}1;
TAP_PARSER_ITERATOR_PROCESS

$fatpacked{"TAP/Parser/Iterator/Stream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_ITERATOR_STREAM';
  package TAP::Parser::Iterator::Stream;use strict;use warnings;use base 'TAP::Parser::Iterator';our$VERSION='3.44';sub _initialize {my ($self,$thing)=@_;$self->{fh}=$thing;return$self}sub wait {shift->exit}sub exit {shift->{fh}? (): 0}sub next_raw {my$self=shift;my$fh=$self->{fh};if (defined(my$line=<$fh>)){chomp$line;return$line}else {$self->_finish;return}}sub _finish {my$self=shift;close delete$self->{fh}}sub get_select_handles {my$self=shift;return ($self->{fh},)if (-S $self->{fh}|| -p $self->{fh});return}1;
TAP_PARSER_ITERATOR_STREAM

$fatpacked{"TAP/Parser/IteratorFactory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_ITERATORFACTORY';
  package TAP::Parser::IteratorFactory;use strict;use warnings;use Carp qw(confess);use File::Basename qw(fileparse);use base 'TAP::Object';use constant handlers=>[];our$VERSION='3.44';sub _initialize {my ($self,$config)=@_;$self->config($config || {})->load_handlers;return$self}sub register_handler {my ($class,$dclass)=@_;confess("$dclass must implement can_handle & make_iterator methods!")unless UNIVERSAL::can($dclass,'can_handle')&& UNIVERSAL::can($dclass,'make_iterator');my$handlers=$class->handlers;push @{$handlers},$dclass unless grep {$_ eq $dclass}@{$handlers};return$class}sub config {my$self=shift;return$self->{config}unless @_;unless ('HASH' eq ref $_[0]){$self->_croak('Argument to &config must be a hash reference')}$self->{config}=shift;return$self}sub _last_handler {my$self=shift;return$self->{last_handler}unless @_;$self->{last_handler}=shift;return$self}sub _testing {my$self=shift;return$self->{testing}unless @_;$self->{testing}=shift;return$self}sub load_handlers {my ($self)=@_;for my$handler (keys %{$self->config}){my$sclass=$self->_load_handler($handler)}return$self}sub _load_handler {my ($self,$handler)=@_;my@errors;for my$dclass ("TAP::Parser::SourceHandler::$handler",$handler){return$dclass if UNIVERSAL::can($dclass,'can_handle')&& UNIVERSAL::can($dclass,'make_iterator');eval "use $dclass";if (my$e=$@){push@errors,$e;next}return$dclass if UNIVERSAL::can($dclass,'can_handle')&& UNIVERSAL::can($dclass,'make_iterator');push@errors,"handler '$dclass' does not implement can_handle & make_iterator"}$self->_croak("Cannot load handler '$handler': " .join("\n",@errors))}sub make_iterator {my ($self,$source)=@_;$self->_croak('no raw source defined!')unless defined$source->raw;$source->config($self->config)->assemble_meta;return$source->raw if ($source->meta->{is_object}&& UNIVERSAL::isa($source->raw,'TAP::Parser::SourceHandler'));my$sd_class=$self->detect_source($source);$self->_last_handler($sd_class);return if$self->_testing;my$iterator=$sd_class->make_iterator($source);return$iterator}sub detect_source {my ($self,$source)=@_;confess('no raw source ref defined!')unless defined$source->raw;my%confidence_for;for my$handler (@{$self->handlers}){my$confidence=$handler->can_handle($source);$confidence_for{$handler}=$confidence if$confidence}if (!%confidence_for){my$raw_source_short=substr(${$source->raw},0,50);confess("Cannot detect source of '$raw_source_short'!");return}my@handlers=sort {$confidence_for{$b}<=> $confidence_for{$a}}keys%confidence_for;if(@handlers > 1 && $confidence_for{$handlers[0]}==$confidence_for{$handlers[1]}){my$filename=$source->meta->{file}{basename};die("There is a tie between $handlers[0] and $handlers[1].\n"."Both voted $confidence_for{$handlers[0]} on $filename.\n")}if ($ENV{TAP_HARNESS_SOURCE_FACTORY_VOTES}){warn("votes: ",join(', ',map {"$_: $confidence_for{$_}"}@handlers),"\n")}return$handlers[0]}1;
TAP_PARSER_ITERATORFACTORY

$fatpacked{"TAP/Parser/Multiplexer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_MULTIPLEXER';
  package TAP::Parser::Multiplexer;use strict;use warnings;use IO::Select;use Errno;use base 'TAP::Object';use constant IS_WIN32=>$^O =~ /^(MS)?Win32$/;use constant IS_VMS=>$^O eq 'VMS';use constant SELECT_OK=>!(IS_VMS || IS_WIN32);our$VERSION='3.44';sub _initialize {my$self=shift;$self->{select}=IO::Select->new;$self->{avid}=[];$self->{count}=0;return$self}sub add {my ($self,$parser,$stash)=@_;if (SELECT_OK && (my@handles=$parser->get_select_handles)){my$sel=$self->{select};my@filenos=map {fileno $_}@handles;for my$h (@handles){$sel->add([$h,$parser,$stash,@filenos ])}$self->{count}++}else {push @{$self->{avid}},[$parser,$stash ]}}sub parsers {my$self=shift;return$self->{count}+ scalar @{$self->{avid}}}sub _iter {my$self=shift;my$sel=$self->{select};my$avid=$self->{avid};my@ready=();return sub {if (@$avid){my ($parser,$stash)=@{$avid->[0]};my$result=$parser->next;shift @$avid unless defined$result;return ($parser,$stash,$result)}until (@ready){return unless$sel->count;@ready=$sel->can_read;last if@ready || $!!=Errno::EINTR}my ($h,$parser,$stash,@handles)=@{shift@ready};my$result=$parser->next;unless (defined$result){$sel->remove(@handles);$self->{count}--;@ready=()}return ($parser,$stash,$result)}}sub next {my$self=shift;return ($self->{_iter}||= $self->_iter)->()}1;
TAP_PARSER_MULTIPLEXER

$fatpacked{"TAP/Parser/Result.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT';
  package TAP::Parser::Result;use strict;use warnings;use base 'TAP::Object';BEGIN {my@attrs=qw(plan pragma test comment bailout version unknown yaml);no strict 'refs';for my$token (@attrs){my$method="is_$token";*$method=sub {return$token eq shift->type}}}our$VERSION='3.44';sub _initialize {my ($self,$token)=@_;if ($token){@{$self}{keys %$token }=values %$token}return$self}sub raw {shift->{raw}}sub type {shift->{type}}sub as_string {shift->{raw}}sub is_ok {1}sub passed {warn 'passed() is deprecated.  Please use "is_ok()"';shift->is_ok}sub has_directive {my$self=shift;return ($self->has_todo || $self->has_skip)}sub has_todo {'TODO' eq (shift->{directive}|| '')}sub has_skip {'SKIP' eq (shift->{directive}|| '')}sub set_directive {my ($self,$dir)=@_;$self->{directive}=$dir}1;
TAP_PARSER_RESULT

$fatpacked{"TAP/Parser/Result/Bailout.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_BAILOUT';
  package TAP::Parser::Result::Bailout;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.44';sub explanation {shift->{bailout}}sub as_string {shift->{bailout}}1;
TAP_PARSER_RESULT_BAILOUT

$fatpacked{"TAP/Parser/Result/Comment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_COMMENT';
  package TAP::Parser::Result::Comment;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.44';sub comment {shift->{comment}}sub as_string {shift->{raw}}1;
TAP_PARSER_RESULT_COMMENT

$fatpacked{"TAP/Parser/Result/Plan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_PLAN';
  package TAP::Parser::Result::Plan;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.44';sub plan {'1..' .shift->{tests_planned}}sub tests_planned {shift->{tests_planned}}sub directive {shift->{directive}}sub explanation {shift->{explanation}}sub todo_list {shift->{todo_list}}1;
TAP_PARSER_RESULT_PLAN

$fatpacked{"TAP/Parser/Result/Pragma.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_PRAGMA';
  package TAP::Parser::Result::Pragma;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.44';sub pragmas {my@pragmas=@{shift->{pragmas}};return wantarray ? @pragmas : \@pragmas}1;
TAP_PARSER_RESULT_PRAGMA

$fatpacked{"TAP/Parser/Result/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_TEST';
  package TAP::Parser::Result::Test;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.44';sub ok {shift->{ok}}sub number {shift->{test_num}}sub _number {my ($self,$number)=@_;$self->{test_num}=$number}sub description {shift->{description}}sub directive {shift->{directive}}sub explanation {shift->{explanation}}sub is_ok {my$self=shift;return if$self->is_unplanned;return$self->has_todo ? 1 : $self->ok !~ /not/}sub is_actual_ok {my$self=shift;return$self->{ok}!~ /not/}sub actual_passed {warn 'actual_passed() is deprecated.  Please use "is_actual_ok()"';goto&is_actual_ok}sub todo_passed {my$self=shift;return$self->has_todo && $self->is_actual_ok}sub todo_failed {warn 'todo_failed() is deprecated.  Please use "todo_passed()"';goto&todo_passed}sub as_string {my$self=shift;my$string=$self->ok ." " .$self->number;if (my$description=$self->description){$string .= " $description"}if (my$directive=$self->directive){my$explanation=$self->explanation;$string .= " # $directive $explanation"}return$string}sub is_unplanned {my$self=shift;return ($self->{unplanned}|| '')unless @_;$self->{unplanned}=!!shift;return$self}1;
TAP_PARSER_RESULT_TEST

$fatpacked{"TAP/Parser/Result/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_UNKNOWN';
  package TAP::Parser::Result::Unknown;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.44';1;
TAP_PARSER_RESULT_UNKNOWN

$fatpacked{"TAP/Parser/Result/Version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_VERSION';
  package TAP::Parser::Result::Version;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.44';sub version {shift->{version}}1;
TAP_PARSER_RESULT_VERSION

$fatpacked{"TAP/Parser/Result/YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_YAML';
  package TAP::Parser::Result::YAML;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.44';sub data {shift->{data}}1;
TAP_PARSER_RESULT_YAML

$fatpacked{"TAP/Parser/ResultFactory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULTFACTORY';
  package TAP::Parser::ResultFactory;use strict;use warnings;use TAP::Parser::Result::Bailout ();use TAP::Parser::Result::Comment ();use TAP::Parser::Result::Plan ();use TAP::Parser::Result::Pragma ();use TAP::Parser::Result::Test ();use TAP::Parser::Result::Unknown ();use TAP::Parser::Result::Version ();use TAP::Parser::Result::YAML ();use base 'TAP::Object';our$VERSION='3.44';sub make_result {my ($proto,$token)=@_;my$type=$token->{type};return$proto->class_for($type)->new($token)}our%CLASS_FOR=(plan=>'TAP::Parser::Result::Plan',pragma=>'TAP::Parser::Result::Pragma',test=>'TAP::Parser::Result::Test',comment=>'TAP::Parser::Result::Comment',bailout=>'TAP::Parser::Result::Bailout',version=>'TAP::Parser::Result::Version',unknown=>'TAP::Parser::Result::Unknown',yaml=>'TAP::Parser::Result::YAML',);sub class_for {my ($class,$type)=@_;return$CLASS_FOR{$type}if exists$CLASS_FOR{$type};require Carp;Carp::croak("Could not determine class for result type '$type'")}sub register_type {my ($class,$type,$rclass)=@_;$CLASS_FOR{$type}=$rclass;return$class}1;
TAP_PARSER_RESULTFACTORY

$fatpacked{"TAP/Parser/Scheduler.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SCHEDULER';
  package TAP::Parser::Scheduler;use strict;use warnings;use Carp;use TAP::Parser::Scheduler::Job;use TAP::Parser::Scheduler::Spinner;our$VERSION='3.44';sub new {my$class=shift;croak "Need a number of key, value pairs" if @_ % 2;my%args=@_;my$tests=delete$args{tests}|| croak "Need a 'tests' argument";my$rules=delete$args{rules}|| {par=>'**' };croak "Unknown arg(s): ",join ', ',sort keys%args if keys%args;my$self=bless {},$class;$self->_set_rules($rules,$tests);return$self}sub _set_rules {my ($self,$rules,$tests)=@_;my@tests=map {TAP::Parser::Scheduler::Job->new(@$_)}map {'ARRAY' eq ref $_ ? $_ : [$_,$_ ]}@$tests;my$schedule=$self->_rule_clause($rules,\@tests);$schedule=[[$schedule,@tests ]]if@tests;$self->{schedule}=$schedule}sub _rule_clause {my ($self,$rule,$tests)=@_;croak 'Rule clause must be a hash' unless 'HASH' eq ref$rule;my@type=keys %$rule;croak 'Rule clause must have exactly one key' unless@type==1;my%handlers=(par=>sub {[map {[$_]}@_ ]},seq=>sub {[[@_]]},);my$handler=$handlers{$type[0]}|| croak 'Unknown scheduler type: ',$type[0];my$val=$rule->{$type[0]};return$handler->(map {'HASH' eq ref $_ ? $self->_rule_clause($_,$tests): $self->_expand($_,$tests)}'ARRAY' eq ref$val ? @$val : $val)}sub _glob_to_regexp {my ($self,$glob)=@_;my$nesting;my$pattern;while (1){if ($glob =~ /\G\*\*/gc){$pattern .= '.*?'}elsif ($glob =~ /\G\*/gc){$pattern .= '[^/]*'}elsif ($glob =~ /\G\?/gc){$pattern .= '[^/]'}elsif ($glob =~ /\G\{/gc){$pattern .= '(?:';++$nesting}elsif ($nesting and $glob =~ /\G,/gc){$pattern .= '|'}elsif ($nesting and $glob =~ /\G\}/gc){$pattern .= ')';--$nesting}elsif ($glob =~ /\G(\\.)/gc){$pattern .= $1}elsif ($glob =~ /\G([\},])/gc){$pattern .= '\\' .$1}else {$glob =~ /\G([^{?*\\\},]*)/gc;$pattern .= quotemeta $1}return$pattern if pos$glob==length$glob}}sub _expand {my ($self,$name,$tests)=@_;my$pattern=$self->_glob_to_regexp($name);$pattern=qr/^ $pattern $/x;my@match=();for (my$ti=0;$ti < @$tests;$ti++ ){if ($tests->[$ti]->filename =~ $pattern){push@match,splice @$tests,$ti,1;$ti--}}return@match}sub get_all {my$self=shift;my@all=$self->_gather($self->{schedule});$self->{count}=@all;@all}sub _gather {my ($self,$rule)=@_;return unless defined$rule;return$rule unless 'ARRAY' eq ref$rule;return map {defined()? $self->_gather($_): ()}map {@$_}@$rule}sub get_job {my$self=shift;$self->{count}||= $self->get_all;my@jobs=$self->_find_next_job($self->{schedule});if (@jobs){--$self->{count};return$jobs[0]}return TAP::Parser::Scheduler::Spinner->new if$self->{count};return}sub _not_empty {my$ar=shift;return 1 unless 'ARRAY' eq ref$ar;for (@$ar){return 1 if _not_empty($_)}return}sub _is_empty {!_not_empty(@_)}sub _find_next_job {my ($self,$rule)=@_;my@queue=();my$index=0;while ($index < @$rule){my$seq=$rule->[$index];shift @$seq while @$seq && _is_empty($seq->[0]);if (@$seq){if (defined$seq->[0]){if ('ARRAY' eq ref$seq->[0]){push@queue,$seq}else {my$job=splice @$seq,0,1,undef;$job->on_finish(sub {shift @$seq});return$job}}++$index}else {splice @$rule,$index,1}}for my$seq (@queue){if (my@jobs=$self->_find_next_job($seq->[0])){return@jobs}}return}sub as_string {my$self=shift;return$self->_as_string($self->{schedule})}sub _as_string {my ($self,$rule,$depth)=(shift,shift,shift || 0);my$pad=' ' x 2;my$indent=$pad x $depth;if (!defined$rule){return "$indent(undef)\n"}elsif ('ARRAY' eq ref$rule){return unless @$rule;my$type=('par','seq')[$depth % 2 ];return join('',"$indent$type:\n",map {$self->_as_string($_,$depth + 1)}@$rule)}else {return "$indent'" .$rule->filename ."'\n"}}1;
TAP_PARSER_SCHEDULER

$fatpacked{"TAP/Parser/Scheduler/Job.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SCHEDULER_JOB';
  package TAP::Parser::Scheduler::Job;use strict;use warnings;use Carp;our$VERSION='3.44';sub new {my ($class,$name,$desc,@ctx)=@_;return bless {filename=>$name,description=>$desc,@ctx ? (context=>\@ctx): (),},$class}sub on_finish {my ($self,$cb)=@_;$self->{on_finish}=$cb}sub finish {my$self=shift;if (my$cb=$self->{on_finish}){$cb->($self)}}sub filename {shift->{filename}}sub description {shift->{description}}sub context {@{shift->{context}|| []}}sub as_array_ref {my$self=shift;return [$self->filename,$self->description,$self->{context}||= []]}sub is_spinner {0}1;
TAP_PARSER_SCHEDULER_JOB

$fatpacked{"TAP/Parser/Scheduler/Spinner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SCHEDULER_SPINNER';
  package TAP::Parser::Scheduler::Spinner;use strict;use warnings;use Carp;our$VERSION='3.44';sub new {bless {},shift}sub is_spinner {1}1;
TAP_PARSER_SCHEDULER_SPINNER

$fatpacked{"TAP/Parser/Source.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCE';
  package TAP::Parser::Source;use strict;use warnings;use File::Basename qw(fileparse);use base 'TAP::Object';use constant BLK_SIZE=>512;our$VERSION='3.44';sub _initialize {my ($self)=@_;$self->meta({});$self->config({});return$self}sub raw {my$self=shift;return$self->{raw}unless @_;$self->{raw}=shift;return$self}sub meta {my$self=shift;return$self->{meta}unless @_;$self->{meta}=shift;return$self}sub has_meta {return scalar %{shift->meta}? 1 : 0}sub config {my$self=shift;return$self->{config}unless @_;$self->{config}=shift;return$self}sub merge {my$self=shift;return$self->{merge}unless @_;$self->{merge}=shift;return$self}sub switches {my$self=shift;return$self->{switches}unless @_;$self->{switches}=shift;return$self}sub test_args {my$self=shift;return$self->{test_args}unless @_;$self->{test_args}=shift;return$self}sub assemble_meta {my ($self)=@_;return$self->meta if$self->has_meta;my$meta=$self->meta;my$raw=$self->raw;$meta->{is_object}=UNIVERSAL::isa($raw,'UNIVERSAL')? 1 : 0;if ($meta->{is_object}){$meta->{class}=ref($raw)}else {my$ref=lc(ref($raw));$meta->{"is_$ref"}=1}if ($meta->{is_scalar}){my$source=$$raw;$meta->{length}=length($$raw);$meta->{has_newlines}=$$raw =~ /\n/ ? 1 : 0;if (!$meta->{has_newlines}and $meta->{length}< 1024){my$file={};$file->{exists}=-e $source ? 1 : 0;if ($file->{exists}){$meta->{file}=$file;$file->{stat}=[stat(_)];$file->{empty}=-z _ ? 1 : 0;$file->{size}=-s _;$file->{text}=-T _ ? 1 : 0;$file->{binary}=-B _ ? 1 : 0;$file->{read}=-r _ ? 1 : 0;$file->{write}=-w _ ? 1 : 0;$file->{execute}=-x _ ? 1 : 0;$file->{setuid}=-u _ ? 1 : 0;$file->{setgid}=-g _ ? 1 : 0;$file->{sticky}=-k _ ? 1 : 0;$meta->{is_file}=$file->{is_file}=-f _ ? 1 : 0;$meta->{is_dir}=$file->{is_dir}=-d _ ? 1 : 0;$meta->{is_symlink}=$file->{is_symlink}=-l $source ? 1 : 0;if ($file->{is_symlink}){$file->{lstat}=[lstat(_)]}($file->{basename},$file->{dir},$file->{ext})=map {defined $_ ? $_ : ''}fileparse($source,qr/\.[^.]*/);$file->{lc_ext}=lc($file->{ext});$file->{basename}.= $file->{ext}if$file->{ext};if (!$file->{is_dir}&& $file->{read}){eval {$file->{shebang}=$self->shebang($$raw)};if (my$e=$@){warn$e}}}}}elsif ($meta->{is_array}){$meta->{size}=$#$raw + 1}elsif ($meta->{is_hash}){}return$meta}{my%shebang_for;sub _read_shebang {my ($class,$file)=@_;open my$fh,'<',$file or die "Can't read $file: $!\n";my$got=read$fh,my ($buf),BLK_SIZE;defined$got or die "I/O error: $!\n";return $1 if$buf =~ /(.*)/;return}sub shebang {my ($class,$file)=@_;$shebang_for{$file}=$class->_read_shebang($file)unless exists$shebang_for{$file};return$shebang_for{$file}}}sub config_for {my ($self,$class)=@_;my ($abbrv_class)=($class =~ /(?:\:\:)?(\w+)$/);my$config=$self->config->{$abbrv_class}|| $self->config->{$class};return$config}1;
TAP_PARSER_SOURCE

$fatpacked{"TAP/Parser/SourceHandler.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER';
  package TAP::Parser::SourceHandler;use strict;use warnings;use TAP::Parser::Iterator ();use base 'TAP::Object';our$VERSION='3.44';sub can_handle {my ($class,$args)=@_;$class->_croak("Abstract method 'can_handle' not implemented for $class!");return}sub make_iterator {my ($class,$args)=@_;$class->_croak("Abstract method 'make_iterator' not implemented for $class!");return}1;
TAP_PARSER_SOURCEHANDLER

$fatpacked{"TAP/Parser/SourceHandler/Executable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER_EXECUTABLE';
  package TAP::Parser::SourceHandler::Executable;use strict;use warnings;use TAP::Parser::IteratorFactory ();use TAP::Parser::Iterator::Process ();use base 'TAP::Parser::SourceHandler';TAP::Parser::IteratorFactory->register_handler(__PACKAGE__);our$VERSION='3.44';sub can_handle {my ($class,$src)=@_;my$meta=$src->meta;if ($meta->{is_file}){my$file=$meta->{file};return 0.85 if$file->{execute}&& $file->{binary};return 0.8 if$file->{lc_ext}eq '.bat';return 0.25 if$file->{execute}}elsif ($meta->{is_hash}){return 0.9 if$src->raw->{exec}}return 0}sub make_iterator {my ($class,$source)=@_;my$meta=$source->meta;my@command;if ($meta->{is_hash}){@command=@{$source->raw->{exec}|| []}}elsif ($meta->{is_scalar}){@command=${$source->raw}}elsif ($meta->{is_array}){@command=@{$source->raw}}$class->_croak('No command found in $source->raw!')unless@command;$class->_autoflush(\*STDOUT);$class->_autoflush(\*STDERR);push@command,@{$source->test_args || []};return$class->iterator_class->new({command=>\@command,merge=>$source->merge })}use constant iterator_class=>'TAP::Parser::Iterator::Process';sub _autoflush {my ($class,$flushed)=@_;my$old_fh=select$flushed;$|=1;select$old_fh}1;
TAP_PARSER_SOURCEHANDLER_EXECUTABLE

$fatpacked{"TAP/Parser/SourceHandler/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER_FILE';
  package TAP::Parser::SourceHandler::File;use strict;use warnings;use TAP::Parser::IteratorFactory ();use TAP::Parser::Iterator::Stream ();use base 'TAP::Parser::SourceHandler';TAP::Parser::IteratorFactory->register_handler(__PACKAGE__);our$VERSION='3.44';sub can_handle {my ($class,$src)=@_;my$meta=$src->meta;my$config=$src->config_for($class);return 0 unless$meta->{is_file};my$file=$meta->{file};return 0.9 if$file->{lc_ext}eq '.tap';if (my$exts=$config->{extensions}){my@exts=ref$exts eq 'ARRAY' ? @$exts : $exts;return 0.9 if grep {lc($_)eq $file->{lc_ext}}@exts}return 0}sub make_iterator {my ($class,$source)=@_;$class->_croak('$source->raw must be a scalar ref')unless$source->meta->{is_scalar};my$file=${$source->raw};my$fh;open($fh,'<',$file)or $class->_croak("error opening TAP source file '$file': $!");return$class->iterator_class->new($fh)}use constant iterator_class=>'TAP::Parser::Iterator::Stream';1;
TAP_PARSER_SOURCEHANDLER_FILE

$fatpacked{"TAP/Parser/SourceHandler/Handle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER_HANDLE';
  package TAP::Parser::SourceHandler::Handle;use strict;use warnings;use TAP::Parser::IteratorFactory ();use TAP::Parser::Iterator::Stream ();use base 'TAP::Parser::SourceHandler';TAP::Parser::IteratorFactory->register_handler(__PACKAGE__);our$VERSION='3.44';sub can_handle {my ($class,$src)=@_;my$meta=$src->meta;return 0.9 if$meta->{is_object}&& UNIVERSAL::isa($src->raw,'IO::Handle');return 0.8 if$meta->{is_glob};return 0}sub make_iterator {my ($class,$source)=@_;$class->_croak('$source->raw must be a glob ref or an IO::Handle')unless$source->meta->{is_glob}|| UNIVERSAL::isa($source->raw,'IO::Handle');return$class->iterator_class->new($source->raw)}use constant iterator_class=>'TAP::Parser::Iterator::Stream';1;
TAP_PARSER_SOURCEHANDLER_HANDLE

$fatpacked{"TAP/Parser/SourceHandler/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER_PERL';
  package TAP::Parser::SourceHandler::Perl;use strict;use warnings;use Config;use constant IS_WIN32=>($^O =~ /^(MS)?Win32$/);use constant IS_VMS=>($^O eq 'VMS');use TAP::Parser::IteratorFactory ();use TAP::Parser::Iterator::Process ();use Text::ParseWords qw(shellwords);use base 'TAP::Parser::SourceHandler::Executable';TAP::Parser::IteratorFactory->register_handler(__PACKAGE__);our$VERSION='3.44';sub can_handle {my ($class,$source)=@_;my$meta=$source->meta;return 0 unless$meta->{is_file};my$file=$meta->{file};if (my$shebang=$file->{shebang}){return 0.9 if$shebang =~ /^#!.*\bperl/;return 0.3}return 0.8 if$file->{lc_ext}eq '.t';return 0.9 if$file->{lc_ext}eq '.pl';return 0.75 if$file->{dir}=~ /^t\b/;return 0.25}sub _autoflush_stdhandles {my ($class)=@_;$class->_autoflush(\*STDOUT);$class->_autoflush(\*STDERR)}sub make_iterator {my ($class,$source)=@_;my$meta=$source->meta;my$perl_script=${$source->raw};$class->_croak("Cannot find ($perl_script)")unless$meta->{is_file};$class->_autoflush_stdhandles;my ($libs,$switches)=$class->_mangle_switches($class->_filter_libs($class->_switches($source)));$class->_run($source,$libs,$switches)}sub _has_taint_switch {my($class,$switches)=@_;my$has_taint=grep {$_ eq "-T" || $_ eq "-t"}@{$switches};return$has_taint ? 1 : 0}sub _mangle_switches {my ($class,$libs,$switches)=@_;if ($class->_has_taint_switch($switches)){my@perl5lib=defined$ENV{PERL5LIB}? split /$Config{path_sep}/,$ENV{PERL5LIB}: ();return ($libs,[@{$switches},$class->_libs2switches([@$libs,@perl5lib]),defined$ENV{PERL5OPT}? shellwords($ENV{PERL5OPT}): ()],)}return ($libs,$switches)}sub _filter_libs {my ($class,@switches)=@_;my$path_sep=$Config{path_sep};my$path_re=qr{$path_sep};my@libs;my@filtered_switches;for (@switches){if (!/$path_re/ && m/ ^ ['"]? -I ['"]? (.*?) ['"]? $ /x){push@libs,$1}else {push@filtered_switches,$_}}return \@libs,\@filtered_switches}sub _iterator_hooks {my ($class,$source,$libs,$switches)=@_;my$setup=sub {if (@{$libs}and!$class->_has_taint_switch($switches)){$ENV{PERL5LIB}=join($Config{path_sep},grep {defined}@{$libs},$ENV{PERL5LIB})}};my$previous=$ENV{PERL5LIB};my$teardown=sub {if (defined$previous){$ENV{PERL5LIB}=$previous}else {delete$ENV{PERL5LIB}}};return ($setup,$teardown)}sub _run {my ($class,$source,$libs,$switches)=@_;my@command=$class->_get_command_for_switches($source,$switches)or $class->_croak("No command found!");my ($setup,$teardown)=$class->_iterator_hooks($source,$libs,$switches);return$class->_create_iterator($source,\@command,$setup,$teardown)}sub _create_iterator {my ($class,$source,$command,$setup,$teardown)=@_;return TAP::Parser::Iterator::Process->new({command=>$command,merge=>$source->merge,setup=>$setup,teardown=>$teardown,})}sub _get_command_for_switches {my ($class,$source,$switches)=@_;my$file=${$source->raw};my@args=@{$source->test_args || []};my$command=$class->get_perl;my@command=($command,@{$switches},$file,@args);return@command}sub _libs2switches {my$class=shift;return map {"-I$_"}grep {$_}@{$_[0]}}sub get_taint {my ($class,$shebang)=@_;return unless defined$shebang && $shebang =~ /^#!.*\bperl.*\s-\w*([Tt]+)/;return $1}sub _switches {my ($class,$source)=@_;my$file=${$source->raw};my@switches=@{$source->switches || []};my$shebang=$source->meta->{file}->{shebang};return unless defined$shebang;my$taint=$class->get_taint($shebang);push@switches,"-$taint" if defined$taint;if (IS_VMS){for (@switches){$_=qq["$_"]}}return@switches}sub get_perl {my$class=shift;return$ENV{HARNESS_PERL}if defined$ENV{HARNESS_PERL};return qq["$^X"] if IS_WIN32 && ($^X =~ /[^\w\.\/\\]/);return $^X}1;
TAP_PARSER_SOURCEHANDLER_PERL

$fatpacked{"TAP/Parser/SourceHandler/RawTAP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER_RAWTAP';
  package TAP::Parser::SourceHandler::RawTAP;use strict;use warnings;use TAP::Parser::IteratorFactory ();use TAP::Parser::Iterator::Array ();use base 'TAP::Parser::SourceHandler';TAP::Parser::IteratorFactory->register_handler(__PACKAGE__);our$VERSION='3.44';sub can_handle {my ($class,$src)=@_;my$meta=$src->meta;return 0 if$meta->{file};if ($meta->{is_scalar}){return 0 unless$meta->{has_newlines};return 0.9 if ${$src->raw}=~ /\d\.\.\d/;return 0.7 if ${$src->raw}=~ /ok/;return 0.3}elsif ($meta->{is_array}){return 0.5}return 0}sub make_iterator {my ($class,$src)=@_;my$meta=$src->meta;my$tap_array;if ($meta->{is_scalar}){$tap_array=[split "\n"=>${$src->raw}]}elsif ($meta->{is_array}){$tap_array=$src->raw}$class->_croak('No raw TAP found in $source->raw')unless scalar$tap_array;return TAP::Parser::Iterator::Array->new($tap_array)}1;
TAP_PARSER_SOURCEHANDLER_RAWTAP

$fatpacked{"TAP/Parser/YAMLish/Reader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_YAMLISH_READER';
  package TAP::Parser::YAMLish::Reader;use strict;use warnings;use base 'TAP::Object';our$VERSION='3.44';*to_native=(ord "A"==65 || $] < 5.008)? sub {return shift}: sub {utf8::unicode_to_native(shift)};my%UNESCAPES=(z=>"\x00",a=>"\a",t=>"\t",n=>"\n",v=>"\cK",f=>"\f",r=>"\r",e=>"\e",'\\'=>'\\',);my$QQ_STRING=qr{ " (?:\\. | [^"])* " }x;my$HASH_LINE=qr{ ^ ($QQ_STRING|\S+) \s* : \s* (?: (.+?) \s* )? $ }x;my$IS_HASH_KEY=qr{ ^ [\w\'\"] }x;my$IS_END_YAML=qr{ ^ \.\.\. \s* $ }x;my$IS_QQ_STRING=qr{ ^ $QQ_STRING $ }x;my$IS_ARRAY_LINE=qr{ ^ - \s* ($QQ_STRING|\S+) }x;sub read {my$self=shift;my$obj=shift;die "Must have a code reference to read input from" unless ref$obj eq 'CODE';$self->{reader}=$obj;$self->{capture}=[];$self->_next;return unless$self->{next};my$doc=$self->_read;my$dots=$self->_peek;die "Missing '...' at end of YAMLish" unless defined$dots and $dots =~ $IS_END_YAML;delete$self->{reader};delete$self->{next};return$doc}sub get_raw {join("\n",grep defined,@{shift->{capture}|| []})."\n"}sub _peek {my$self=shift;return$self->{next}unless wantarray;my$line=$self->{next};$line =~ /^ (\s*) (.*) $ /x;return ($2,length $1)}sub _next {my$self=shift;die "_next called with no reader" unless$self->{reader};my$line=$self->{reader}->();$self->{next}=$line;push @{$self->{capture}},$line}sub _read {my$self=shift;my$line=$self->_peek;if ($line =~ /^ --- (?: \s* (.+?)? \s* )? $/x){$self->_next;return$self->_read_scalar($1)if defined $1;my ($next,$indent)=$self->_peek;if ($next =~ /^ - /x){return$self->_read_array($indent)}elsif ($next =~ $IS_HASH_KEY){return$self->_read_hash($next,$indent)}elsif ($next =~ $IS_END_YAML){die "Premature end of YAMLish"}else {die "Unsupported YAMLish syntax: '$next'"}}else {die "YAMLish document header not found"}}sub _read_qq {my$self=shift;my$str=shift;unless ($str =~ s/^ " (.*?) " $/$1/x){die "Internal: not a quoted string"}$str =~ s/\\"/"/gx;$str =~ s/ \\ ( [tartan\\favez] | x([0-9a-fA-F]{2}) ) 
                   / (length($1) > 1) ? pack("H2", to_native($2))
                                      : $UNESCAPES{$1} /gex;return$str}sub _read_scalar {my$self=shift;my$string=shift;return undef if$string eq '~';return {}if$string eq '{}';return []if$string eq '[]';if ($string eq '>' || $string eq '|'){my ($line,$indent)=$self->_peek;die "Multi-line scalar content missing" unless defined$line;my@multiline=($line);while (1){$self->_next;my ($next,$ind)=$self->_peek;last if$ind < $indent;my$pad=$string eq '|' ? (' ' x ($ind - $indent)): '';push@multiline,$pad .$next}return join(($string eq '>' ? ' ' : "\n"),@multiline)."\n"}if ($string =~ /^ ' (.*) ' $/x){(my$rv=$1)=~ s/''/'/g;return$rv}if ($string =~ $IS_QQ_STRING){return$self->_read_qq($string)}if ($string =~ /^['"]/){die __PACKAGE__ ." does not support multi-line quoted scalars"}return$string}sub _read_nested {my$self=shift;my ($line,$indent)=$self->_peek;if ($line =~ /^ -/x){return$self->_read_array($indent)}elsif ($line =~ $IS_HASH_KEY){return$self->_read_hash($line,$indent)}else {die "Unsupported YAMLish syntax: '$line'"}}sub _read_array {my ($self,$limit)=@_;my$ar=[];while (1){my ($line,$indent)=$self->_peek;last if$indent < $limit ||!defined$line || $line =~ $IS_END_YAML;if ($indent > $limit){die "Array line over-indented"}if ($line =~ /^ (- \s+) \S+ \s* : (?: \s+ | $ ) /x){$indent += length $1;$line =~ s/-\s+//;push @$ar,$self->_read_hash($line,$indent)}elsif ($line =~ /^ - \s* (.+?) \s* $/x){die "Unexpected start of YAMLish" if$line =~ /^---/;$self->_next;push @$ar,$self->_read_scalar($1)}elsif ($line =~ /^ - \s* $/x){$self->_next;push @$ar,$self->_read_nested}elsif ($line =~ $IS_HASH_KEY){$self->_next;push @$ar,$self->_read_hash($line,$indent,)}else {die "Unsupported YAMLish syntax: '$line'"}}return$ar}sub _read_hash {my ($self,$line,$limit)=@_;my$indent;my$hash={};while (1){die "Badly formed hash line: '$line'" unless$line =~ $HASH_LINE;my ($key,$value)=($self->_read_scalar($1),$2);$self->_next;my ($next_line,$next_indent)=$self->_peek;if (defined$value){$hash->{$key}=$self->_read_scalar($value)}elsif (not defined$value and $next_indent <= $limit and $next_line !~ $IS_ARRAY_LINE){$hash->{$key}=undef}else {$hash->{$key}=$self->_read_nested}($line,$indent)=$self->_peek;last if$indent < $limit ||!defined$line || $line =~ $IS_END_YAML}return$hash}1;
TAP_PARSER_YAMLISH_READER

$fatpacked{"TAP/Parser/YAMLish/Writer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_YAMLISH_WRITER';
  package TAP::Parser::YAMLish::Writer;use strict;use warnings;use base 'TAP::Object';our$VERSION='3.44';*from_native=(ord "A"==65 || $] < 5.008)? sub {return shift}: sub {utf8::native_to_unicode(shift)};my$ESCAPE_CHAR=qr{ [ [:cntrl:] \" ] }x;my$ESCAPE_KEY=qr{ (?: ^\W ) | $ESCAPE_CHAR }x;my@UNPRINTABLE;$UNPRINTABLE[$_]=sprintf("x%02x",from_native($_))for 0 .. ord(" ")- 1;$UNPRINTABLE[ord "\0"]='z';$UNPRINTABLE[ord "\a"]='a';$UNPRINTABLE[ord "\t"]='t';$UNPRINTABLE[ord "\n"]='n';$UNPRINTABLE[ord "\cK"]='v';$UNPRINTABLE[ord "\f"]='f';$UNPRINTABLE[ord "\r"]='r';$UNPRINTABLE[ord "\e"]='e';sub write {my$self=shift;die "Need something to write" unless @_;my$obj=shift;my$out=shift || \*STDOUT;die "Need a reference to something I can write to" unless ref$out;$self->{writer}=$self->_make_writer($out);$self->_write_obj('---',$obj);$self->_put('...');delete$self->{writer}}sub _make_writer {my$self=shift;my$out=shift;my$ref=ref$out;if ('CODE' eq $ref){return$out}elsif ('ARRAY' eq $ref){return sub {push @$out,shift}}elsif ('SCALAR' eq $ref){return sub {$$out .= shift()."\n"}}elsif ('GLOB' eq $ref || 'IO::Handle' eq $ref){return sub {print$out shift(),"\n"}}die "Can't write to $out"}sub _put {my$self=shift;$self->{writer}->(join '',@_)}sub _enc_scalar {my$self=shift;my$val=shift;my$rule=shift;return '~' unless defined$val;if ($val =~ /$rule/){$val =~ s/\\/\\\\/g;$val =~ s/"/\\"/g;$val =~ s/ ( [[:cntrl:]] ) / '\\' . $UNPRINTABLE[ ord($1) ] /gex;return qq{"$val"}}if (length($val)==0 or $val =~ /\s/){$val =~ s/'/''/;return "'$val'"}return$val}sub _write_obj {my$self=shift;my$prefix=shift;my$obj=shift;my$indent=shift || 0;if (my$ref=ref$obj){my$pad='  ' x $indent;if ('HASH' eq $ref){if (keys %$obj){$self->_put($prefix);for my$key (sort keys %$obj){my$value=$obj->{$key};$self->_write_obj($pad .$self->_enc_scalar($key,$ESCAPE_KEY).':',$value,$indent + 1)}}else {$self->_put($prefix,' {}')}}elsif ('ARRAY' eq $ref){if (@$obj){$self->_put($prefix);for my$value (@$obj){$self->_write_obj($pad .'-',$value,$indent + 1)}}else {$self->_put($prefix,' []')}}else {die "Don't know how to encode $ref"}}else {$self->_put($prefix,' ',$self->_enc_scalar($obj,$ESCAPE_CHAR))}}1;
TAP_PARSER_YAMLISH_WRITER

$fatpacked{"Task/Weaken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TASK_WEAKEN';
  package Task::Weaken;use 5.005;use strict;our$VERSION='1.06';1;
TASK_WEAKEN

$fatpacked{"Test/Builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER';
  package Test::Builder;use 5.006;use strict;use warnings;our$VERSION='1.302190';BEGIN {if($] < 5.008){require Test::Builder::IO::Scalar}}use Scalar::Util qw/blessed reftype weaken/;use Test2::Util qw/USE_THREADS try get_tid/;use Test2::API qw/context release/;BEGIN {warn "Test::Builder was loaded after Test2 initialization, this is not recommended." if Test2::API::test2_init_done()|| Test2::API::test2_load_done();if (USE_THREADS &&!Test2::API::test2_ipc_disabled()){require Test2::IPC;require Test2::IPC::Driver::Files;Test2::IPC::Driver::Files->import;Test2::API::test2_ipc_enable_polling();Test2::API::test2_no_wait(1)}}use Test2::Event::Subtest;use Test2::Hub::Subtest;use Test::Builder::Formatter;use Test::Builder::TodoDiag;our$Level=1;our$Test=$ENV{TB_NO_EARLY_INIT}? undef : Test::Builder->new;sub _add_ts_hooks {my$self=shift;my$hub=$self->{Stack}->top;my$epkgr=\$self->{Exported_To};$hub->pre_filter(sub {my ($active_hub,$e)=@_;my$epkg=$$epkgr;my$cpkg=$e->{trace}? $e->{trace}->{frame}->[0]: undef;no strict 'refs';no warnings 'once';my$todo;$todo=${"$cpkg\::TODO"}if$cpkg;$todo=${"$epkg\::TODO"}if$epkg &&!$todo;return$e unless defined($todo);return$e unless length($todo);return Test::Builder::TodoDiag->new(%$e)if ref($e)eq 'Test2::Event::Diag';$e->set_todo($todo)if$e->can('set_todo');$e->add_amnesty({tag=>'TODO',details=>$todo});if ($e->isa('Test2::Event::Ok')){$e->set_effective_pass(1);if (my$result=$e->get_meta(__PACKAGE__)){$result->{reason}||= $todo;$result->{type}||= 'todo';$result->{ok}=1}}return$e},inherit=>1,intercept_inherit=>{clean=>sub {my%params=@_;my$state=$params{state};my$trace=$params{trace};my$epkg=$$epkgr;my$cpkg=$trace->{frame}->[0];no strict 'refs';no warnings 'once';$state->{+__PACKAGE__}={};$state->{+__PACKAGE__}->{"$cpkg\::TODO"}=${"$cpkg\::TODO"}if$cpkg;$state->{+__PACKAGE__}->{"$epkg\::TODO"}=${"$epkg\::TODO"}if$epkg;${"$cpkg\::TODO"}=undef if$cpkg;${"$epkg\::TODO"}=undef if$epkg},restore=>sub {my%params=@_;my$state=$params{state};no strict 'refs';no warnings 'once';for my$item (keys %{$state->{+__PACKAGE__}}){no strict 'refs';no warnings 'once';${"$item"}=$state->{+__PACKAGE__}->{$item}}},},)}{no warnings;INIT {use warnings;Test2::API::test2_load()unless Test2::API::test2_in_preload()}}sub new {my($class)=shift;unless($Test){$Test=$class->create(singleton=>1);Test2::API::test2_add_callback_post_load(sub {$Test->{Original_Pid}=$$ if!$Test->{Original_Pid}|| $Test->{Original_Pid}==0;$Test->reset(singleton=>1);$Test->_add_ts_hooks});Test2::API::test2_add_callback_context_aquire(sub {$_[0]->{level}+= $Level - 1});Test2::API::test2_add_callback_exit(sub {$Test->_ending(@_)});Test2::API::test2_ipc()->set_no_fatal(1)if Test2::API::test2_has_ipc()}return$Test}sub create {my$class=shift;my%params=@_;my$self=bless {},$class;if ($params{singleton}){$self->{Stack}=Test2::API::test2_stack()}else {$self->{Stack}=Test2::API::Stack->new;$self->{Stack}->new_hub(formatter=>Test::Builder::Formatter->new,ipc=>Test2::API::test2_ipc(),);$self->reset(%params);$self->_add_ts_hooks}return$self}sub ctx {my$self=shift;context(level=>2,fudge=>1,stack=>$self->{Stack},hub=>$self->{Hub},wrapped=>1,@_)}sub parent {my$self=shift;my$ctx=$self->ctx;my$chub=$self->{Hub}|| $ctx->hub;$ctx->release;my$meta=$chub->meta(__PACKAGE__,{});my$parent=$meta->{parent};return undef unless$parent;return bless {Original_Pid=>$$,Stack=>$self->{Stack},Hub=>$parent,},blessed($self)}sub child {my($self,$name)=@_;$name ||= "Child of " .$self->name;my$ctx=$self->ctx;my$parent=$ctx->hub;my$pmeta=$parent->meta(__PACKAGE__,{});$self->croak("You already have a child named ($pmeta->{child}) running")if$pmeta->{child};$pmeta->{child}=$name;my$orig_TODO=$self->find_TODO(undef,1,undef);my$subevents=[];my$hub=$ctx->stack->new_hub(class=>'Test2::Hub::Subtest',);$hub->pre_filter(sub {my ($active_hub,$e)=@_;return Test::Builder::TodoDiag->new(%$e)if ref($e)eq 'Test2::Event::Diag';return$e},inherit=>1)if$orig_TODO;$hub->listen(sub {push @$subevents=>$_[1]});$hub->set_nested($parent->nested + 1);my$meta=$hub->meta(__PACKAGE__,{});$meta->{Name}=$name;$meta->{TODO}=$orig_TODO;$meta->{TODO_PKG}=$ctx->trace->package;$meta->{parent}=$parent;$meta->{Test_Results}=[];$meta->{subevents}=$subevents;$meta->{subtest_id}=$hub->id;$meta->{subtest_uuid}=$hub->uuid;$meta->{subtest_buffered}=$parent->format ? 0 : 1;$self->_add_ts_hooks;$ctx->release;return bless {Original_Pid=>$$,Stack=>$self->{Stack},Hub=>$hub,no_log_results=>$self->{no_log_results}},blessed($self)}sub finalize {my$self=shift;my$ok=1;($ok)=@_ if @_;my$st_ctx=$self->ctx;my$chub=$self->{Hub}|| return$st_ctx->release;my$meta=$chub->meta(__PACKAGE__,{});if ($meta->{child}){$self->croak("Can't call finalize() with child ($meta->{child}) active")}local $?=0;$self->{Stack}->pop($chub);$self->find_TODO($meta->{TODO_PKG},1,$meta->{TODO});my$parent=$self->parent;my$ctx=$parent->ctx;my$trace=$ctx->trace;delete$ctx->hub->meta(__PACKAGE__,{})->{child};$chub->finalize($trace->snapshot(hid=>$chub->hid,nested=>$chub->nested),1)if$ok && $chub->count &&!$chub->no_ending &&!$chub->ended;my$plan=$chub->plan || 0;my$count=$chub->count;my$failed=$chub->failed;my$passed=$chub->is_passing;my$num_extra=$plan =~ m/\D/ ? 0 : $count - $plan;if ($count && $num_extra!=0){my$s=$plan==1 ? '' : 's';$st_ctx->diag(<<"FAIL")}if ($failed){my$s=$failed==1 ? '' : 's';my$qualifier=$num_extra==0 ? '' : ' run';$st_ctx->diag(<<"FAIL")}if (!$passed &&!$failed && $count &&!$num_extra){$st_ctx->diag(<<"FAIL")}$st_ctx->release;unless ($chub->bailed_out){my$plan=$chub->plan;if ($plan && $plan eq 'SKIP'){$parent->skip($chub->skip_reason,$meta->{Name})}elsif (!$chub->count){$parent->ok(0,sprintf q[No tests run for subtest "%s"],$meta->{Name})}else {$parent->{subevents}=$meta->{subevents};$parent->{subtest_id}=$meta->{subtest_id};$parent->{subtest_uuid}=$meta->{subtest_uuid};$parent->{subtest_buffered}=$meta->{subtest_buffered};$parent->ok($chub->is_passing,$meta->{Name})}}$ctx->release;return$chub->is_passing}sub subtest {my$self=shift;my ($name,$code,@args)=@_;my$ctx=$self->ctx;$ctx->throw("subtest()'s second argument must be a code ref")unless$code && reftype($code)eq 'CODE';$name ||= "Child of " .$self->name;$_->($name,$code,@args)for Test2::API::test2_list_pre_subtest_callbacks();$ctx->note("Subtest: $name");my$child=$self->child($name);my$start_pid=$$;my$st_ctx;my ($ok,$err,$finished,$child_error);T2_SUBTEST_WRAPPER: {my$ctx=$self->ctx;$st_ctx=$ctx->snapshot;$ctx->release;$ok=eval {local$Level=1;$code->(@args);1};($err,$child_error)=($@,$?);if (!$ok && $err =~ m/Label not found for "last T2_SUBTEST_WRAPPER"/ || (blessed($err)&& blessed($err)eq 'Test::Builder::Exception')){$ok=undef;$err=undef}else {$finished=1}}if ($start_pid!=$$ &&!$INC{'Test2/IPC.pm'}){warn$ok ? "Forked inside subtest, but subtest never finished!\n" : $err;exit 255}my$trace=$ctx->trace;if (!$finished){if(my$bailed=$st_ctx->hub->bailed_out){my$chub=$child->{Hub};$self->{Stack}->pop($chub);$ctx->bail($bailed->reason)}my$code=$st_ctx->hub->exit_code;$ok=!$code;$err="Subtest ended with exit code $code" if$code}my$st_hub=$st_ctx->hub;my$plan=$st_hub->plan;my$count=$st_hub->count;if (!$count && (!defined($plan)|| "$plan" ne 'SKIP')){$st_ctx->plan(0)unless defined$plan;$st_ctx->diag('No tests run!')}$child->finalize($st_ctx->trace);$ctx->release;die$err unless$ok;$?=$child_error if defined$child_error;return$st_hub->is_passing}sub name {my$self=shift;my$ctx=$self->ctx;release$ctx,$ctx->hub->meta(__PACKAGE__,{})->{Name}}sub reset {my ($self,%params)=@_;Test2::API::test2_unset_is_end();$Level=1;$self->{no_log_results}=$ENV{TEST_NO_LOG_RESULTS}? 1 : 0 unless$params{singleton};$self->{Original_Pid}=Test2::API::test2_in_preload()? -1 : $$;my$ctx=$self->ctx;my$hub=$ctx->hub;$ctx->release;unless ($params{singleton}){$hub->reset_state();$hub->_tb_reset()}$ctx=$self->ctx;my$meta=$ctx->hub->meta(__PACKAGE__,{});%$meta=(Name=>$0,Ending=>0,Done_Testing=>undef,Skip_All=>0,Test_Results=>[],parent=>$meta->{parent},);$self->{Exported_To}=undef unless$params{singleton};$self->{Orig_Handles}||= do {my$format=$ctx->hub->format;my$out;if ($format && $format->isa('Test2::Formatter::TAP')){$out=$format->handles}$out ? [@$out]: []};$self->use_numbers(1);$self->no_header(0)unless$params{singleton};$self->no_ending(0)unless$params{singleton};$self->reset_outputs;$ctx->release;return}my%plan_cmds=(no_plan=>\&no_plan,skip_all=>\&skip_all,tests=>\&_plan_tests,);sub plan {my($self,$cmd,$arg)=@_;return unless$cmd;my$ctx=$self->ctx;my$hub=$ctx->hub;$ctx->throw("You tried to plan twice")if$hub->plan;local$Level=$Level + 1;if(my$method=$plan_cmds{$cmd}){local$Level=$Level + 1;$self->$method($arg)}else {my@args=grep {defined}($cmd,$arg);$ctx->throw("plan() doesn't understand @args")}release$ctx,1}sub _plan_tests {my($self,$arg)=@_;my$ctx=$self->ctx;if($arg){local$Level=$Level + 1;$self->expected_tests($arg)}elsif(!defined$arg){$ctx->throw("Got an undefined number of tests")}else {$ctx->throw("You said to run 0 tests")}$ctx->release}sub expected_tests {my$self=shift;my($max)=@_;my$ctx=$self->ctx;if(@_){$self->croak("Number of tests must be a positive integer.  You gave it '$max'")unless$max =~ /^\+?\d+$/;$ctx->plan($max)}my$hub=$ctx->hub;$ctx->release;my$plan=$hub->plan;return 0 unless$plan;return 0 if$plan =~ m/\D/;return$plan}sub no_plan {my($self,$arg)=@_;my$ctx=$self->ctx;if (defined$ctx->hub->plan){warn "Plan already set, no_plan() is a no-op, this will change to a hard failure in the future.";$ctx->release;return}$ctx->alert("no_plan takes no arguments")if$arg;$ctx->hub->plan('NO PLAN');release$ctx,1}sub done_testing {my($self,$num_tests)=@_;my$ctx=$self->ctx;my$meta=$ctx->hub->meta(__PACKAGE__,{});if ($meta->{Done_Testing}){my ($file,$line)=@{$meta->{Done_Testing}}[1,2];local$ctx->hub->{ended};$self->ok(0,"done_testing() was already called at $file line $line");$ctx->release;return}$meta->{Done_Testing}=[$ctx->trace->call];my$plan=$ctx->hub->plan;my$count=$ctx->hub->count;if(defined$num_tests){$ctx->plan($num_tests)if!$plan || $plan eq 'NO PLAN'}elsif ($count && defined$num_tests && $count!=$num_tests){$self->ok(0,"planned to run @{[ $self->expected_tests ]} but done_testing() expects $num_tests")}else {$num_tests=$self->current_test}if($self->expected_tests && $num_tests!=$self->expected_tests){$self->ok(0,"planned to run @{[ $self->expected_tests ]} "."but done_testing() expects $num_tests")}$ctx->plan($num_tests)if$ctx->hub->plan && $ctx->hub->plan eq 'NO PLAN';$ctx->hub->finalize($ctx->trace,1);release$ctx,1}sub has_plan {my$self=shift;my$ctx=$self->ctx;my$plan=$ctx->hub->plan;$ctx->release;return($plan)if$plan && $plan !~ m/\D/;return('no_plan')if$plan && $plan eq 'NO PLAN';return(undef)}sub skip_all {my($self,$reason)=@_;my$ctx=$self->ctx;$ctx->hub->meta(__PACKAGE__,{})->{Skip_All}=$reason || 1;if ($] < 5.020000){my$begin=0;my$level=0;while (my@call=caller($level++)){last unless@call && $call[0];next unless$call[3]=~ m/::BEGIN$/;$begin++;last}die 'Label not found for "last T2_SUBTEST_WRAPPER"' if$begin && $ctx->hub->meta(__PACKAGE__,{})->{parent}}$reason="$reason" if defined$reason;$ctx->plan(0,SKIP=>$reason)}sub exported_to {my($self,$pack)=@_;if(defined$pack){$self->{Exported_To}=$pack}return$self->{Exported_To}}sub ok {my($self,$test,$name)=@_;my$ctx=$self->ctx;$test=$test ? 1 : 0;no warnings qw/uninitialized numeric/;$name="$name" if defined$name;$self->diag(<<"    ERR")if 0 + $name && $name =~ /^[\d\s]+$/;use warnings qw/uninitialized numeric/;my$trace=$ctx->{trace};my$hub=$ctx->{hub};my$result={ok=>$test,actual_ok=>$test,reason=>'',type=>'',(name=>defined($name)? $name : ''),};$hub->{_meta}->{+__PACKAGE__}->{Test_Results}[$hub->{count}]=$result unless$self->{no_log_results};my$orig_name=$name;my@attrs;my$subevents=delete$self->{subevents};my$subtest_id=delete$self->{subtest_id};my$subtest_uuid=delete$self->{subtest_uuid};my$subtest_buffered=delete$self->{subtest_buffered};my$epkg='Test2::Event::Ok';if ($subevents){$epkg='Test2::Event::Subtest';push@attrs=>(subevents=>$subevents,subtest_id=>$subtest_id,subtest_uuid=>$subtest_uuid,buffered=>$subtest_buffered)}my$e=bless {trace=>bless({%$trace},'Test2::EventFacet::Trace'),pass=>$test,name=>$name,_meta=>{'Test::Builder'=>$result},effective_pass=>$test,@attrs,},$epkg;$hub->send($e);$self->_ok_debug($trace,$orig_name)unless($test);$ctx->release;return$test}sub _ok_debug {my$self=shift;my ($trace,$orig_name)=@_;my$is_todo=$self->in_todo;my$msg=$is_todo ? "Failed (TODO)" : "Failed";my (undef,$file,$line)=$trace->call;if (defined$orig_name){$self->diag(qq[  $msg test '$orig_name'\n  at $file line $line.\n])}else {$self->diag(qq[  $msg test at $file line $line.\n])}}sub _diag_fh {my$self=shift;local$Level=$Level + 1;return$self->in_todo ? $self->todo_output : $self->failure_output}sub _unoverload {my ($self,$type,$thing)=@_;return unless ref $$thing;return unless blessed($$thing)|| scalar$self->_try(sub{$$thing->isa('UNIVERSAL')});{local ($!,$@);require overload}my$string_meth=overload::Method($$thing,$type)|| return;$$thing=$$thing->$string_meth(undef,0)}sub _unoverload_str {my$self=shift;$self->_unoverload(q[""],$_)for @_}sub _unoverload_num {my$self=shift;$self->_unoverload('0+',$_)for @_;for my$val (@_){next unless$self->_is_dualvar($$val);$$val=$$val + 0}}sub _is_dualvar {my($self,$val)=@_;return 0 if ref$val;no warnings 'numeric';my$numval=$val + 0;return ($numval!=0 and $numval ne $val ? 1 : 0)}sub is_eq {my($self,$got,$expect,$name)=@_;my$ctx=$self->ctx;local$Level=$Level + 1;if(!defined$got ||!defined$expect){my$test=!defined$got &&!defined$expect;$self->ok($test,$name);$self->_is_diag($got,'eq',$expect)unless$test;$ctx->release;return$test}release$ctx,$self->cmp_ok($got,'eq',$expect,$name)}sub is_num {my($self,$got,$expect,$name)=@_;my$ctx=$self->ctx;local$Level=$Level + 1;if(!defined$got ||!defined$expect){my$test=!defined$got &&!defined$expect;$self->ok($test,$name);$self->_is_diag($got,'==',$expect)unless$test;$ctx->release;return$test}release$ctx,$self->cmp_ok($got,'==',$expect,$name)}sub _diag_fmt {my($self,$type,$val)=@_;if(defined $$val){if($type eq 'eq' or $type eq 'ne'){$$val="'$$val'"}else {$self->_unoverload_num($val)}}else {$$val='undef'}return}sub _is_diag {my($self,$got,$type,$expect)=@_;$self->_diag_fmt($type,$_)for \$got,\$expect;local$Level=$Level + 1;return$self->diag(<<"DIAGNOSTIC")}sub _isnt_diag {my($self,$got,$type)=@_;$self->_diag_fmt($type,\$got);local$Level=$Level + 1;return$self->diag(<<"DIAGNOSTIC")}sub isnt_eq {my($self,$got,$dont_expect,$name)=@_;my$ctx=$self->ctx;local$Level=$Level + 1;if(!defined$got ||!defined$dont_expect){my$test=defined$got || defined$dont_expect;$self->ok($test,$name);$self->_isnt_diag($got,'ne')unless$test;$ctx->release;return$test}release$ctx,$self->cmp_ok($got,'ne',$dont_expect,$name)}sub isnt_num {my($self,$got,$dont_expect,$name)=@_;my$ctx=$self->ctx;local$Level=$Level + 1;if(!defined$got ||!defined$dont_expect){my$test=defined$got || defined$dont_expect;$self->ok($test,$name);$self->_isnt_diag($got,'!=')unless$test;$ctx->release;return$test}release$ctx,$self->cmp_ok($got,'!=',$dont_expect,$name)}sub like {my($self,$thing,$regex,$name)=@_;my$ctx=$self->ctx;local$Level=$Level + 1;release$ctx,$self->_regex_ok($thing,$regex,'=~',$name)}sub unlike {my($self,$thing,$regex,$name)=@_;my$ctx=$self->ctx;local$Level=$Level + 1;release$ctx,$self->_regex_ok($thing,$regex,'!~',$name)}my%numeric_cmps=map {($_,1)}("<","<=",">",">=","==","!=","<=>");my%cmp_ok_bl=map {($_,1)}("=","+=",".=","x=","^=","|=","||=","&&=","...");sub cmp_ok {my($self,$got,$type,$expect,$name)=@_;my$ctx=$self->ctx;if ($cmp_ok_bl{$type}){$ctx->throw("$type is not a valid comparison operator in cmp_ok()")}my ($test,$succ);my$error;{local($@,$!,$SIG{__DIE__});my($pack,$file,$line)=$ctx->trace->call();my$warning_bits=$ctx->trace->warning_bits;my$bits_code=defined$warning_bits ? qq["\Q$warning_bits\E"] : 'undef';$succ=eval qq[
  Looks like you planned $plan test$s but ran $count.
  FAIL
  Looks like you failed $failed test$s of $count$qualifier.
  FAIL
  All assertions inside the subtest passed, but errors were encountered.
  FAIL
      You named your test '$name'.  You shouldn't use numbers for your test names.
      Very confusing.
      ERR
           got: $got
      expected: $expect
  DIAGNOSTIC
           got: $got
      expected: anything else
  DIAGNOSTIC
  BEGIN {\${^WARNING_BITS} = $bits_code};
  #line $line "(eval in cmp_ok) $file"
  \$test = (\$got $type \$expect);
  1;
  ];$error=$@}local$Level=$Level + 1;my$ok=$self->ok($test,$name);my$unoverload =$numeric_cmps{$type}? '_unoverload_num' : '_unoverload_str';$self->diag(<<"END")unless$succ;unless($ok){$self->$unoverload(\$got,\$expect);if($type =~ /^(eq|==)$/){$self->_is_diag($got,$type,$expect)}elsif($type =~ /^(ne|!=)$/){no warnings;my$eq=($got eq $expect || $got==$expect)&& ((defined($got)xor defined($expect))|| (length($got)!=length($expect)));use warnings;if ($eq){$self->_cmp_diag($got,$type,$expect)}else {$self->_isnt_diag($got,$type)}}else {$self->_cmp_diag($got,$type,$expect)}}return release$ctx,$ok}sub _cmp_diag {my($self,$got,$type,$expect)=@_;$got=defined$got ? "'$got'" : 'undef';$expect=defined$expect ? "'$expect'" : 'undef';local$Level=$Level + 1;return$self->diag(<<"DIAGNOSTIC")}sub _caller_context {my$self=shift;my($pack,$file,$line)=$self->caller(1);my$code='';$code .= "#line $line $file\n" if defined$file and defined$line;return$code}sub BAIL_OUT {my($self,$reason)=@_;my$ctx=$self->ctx;$self->{Bailed_Out}=1;$ctx->bail($reason)}{no warnings 'once';*BAILOUT=\&BAIL_OUT}sub skip {my($self,$why,$name)=@_;$why ||= '';$name='' unless defined$name;$self->_unoverload_str(\$why);my$ctx=$self->ctx;$name="$name";$why="$why";$name =~ s|#|\\#|g;$name =~ s{\n}{\n# }sg;$why =~ s{\n}{\n# }sg;$ctx->hub->meta(__PACKAGE__,{})->{Test_Results}[$ctx->hub->count ]={'ok'=>1,actual_ok=>1,name=>$name,type=>'skip',reason=>$why,}unless$self->{no_log_results};my$tctx=$ctx->snapshot;$tctx->skip('',$why);return release$ctx,1}sub todo_skip {my($self,$why)=@_;$why ||= '';my$ctx=$self->ctx;$ctx->hub->meta(__PACKAGE__,{})->{Test_Results}[$ctx->hub->count ]={'ok'=>1,actual_ok=>0,name=>'',type=>'todo_skip',reason=>$why,}unless$self->{no_log_results};$why =~ s{\n}{\n# }sg;my$tctx=$ctx->snapshot;$tctx->send_event('Skip',todo=>$why,todo_diag=>1,reason=>$why,pass=>0);return release$ctx,1}sub maybe_regex {my($self,$regex)=@_;my$usable_regex=undef;return$usable_regex unless defined$regex;my($re,$opts);if(_is_qr($regex)){$usable_regex=$regex}elsif(($re,$opts)=$regex =~ m{^ /(.*)/ (\w*) $ }sx or (undef,$re,$opts)=$regex =~ m,^ m([^\w\s]) (.+) \1 (\w*) $,sx){$usable_regex=length$opts ? "(?$opts)$re" : $re}return$usable_regex}sub _is_qr {my$regex=shift;return re::is_regexp($regex)if defined&re::is_regexp;return ref$regex eq 'Regexp'}sub _regex_ok {my($self,$thing,$regex,$cmp,$name)=@_;my$ok=0;my$usable_regex=$self->maybe_regex($regex);unless(defined$usable_regex){local$Level=$Level + 1;$ok=$self->ok(0,$name);$self->diag("    '$regex' doesn't look much like a regex to me.");return$ok}{my$test;my$context=$self->_caller_context;{local($@,$!,$SIG{__DIE__});no warnings 'uninitialized';$test=eval$context .q{$test = $thing =~ /$usable_regex/ ? 1 : 0}}$test=!$test if$cmp eq '!~';local$Level=$Level + 1;$ok=$self->ok($test,$name)}unless($ok){$thing=defined$thing ? "'$thing'" : 'undef';my$match=$cmp eq '=~' ? "doesn't match" : "matches";local$Level=$Level + 1;$self->diag(sprintf <<'DIAGNOSTIC',$thing,$match,$regex)}return$ok}sub is_fh {my$self=shift;my$maybe_fh=shift;return 0 unless defined$maybe_fh;return 1 if ref$maybe_fh eq 'GLOB';return 1 if ref \$maybe_fh eq 'GLOB';return eval {$maybe_fh->isa("IO::Handle")}|| eval {tied($maybe_fh)->can('TIEHANDLE')}}sub level {my($self,$level)=@_;if(defined$level){$Level=$level}return$Level}sub use_numbers {my($self,$use_nums)=@_;my$ctx=$self->ctx;my$format=$ctx->hub->format;unless ($format && $format->can('no_numbers')&& $format->can('set_no_numbers')){warn "The current formatter does not support 'use_numbers'" if$format;return release$ctx,0}$format->set_no_numbers(!$use_nums)if defined$use_nums;return release$ctx,$format->no_numbers ? 0 : 1}BEGIN {for my$method (qw(no_header no_diag)){my$set="set_$method";my$code=sub {my($self,$no)=@_;my$ctx=$self->ctx;my$format=$ctx->hub->format;unless ($format && $format->can($set)){warn "The current formatter does not support '$method'" if$format;$ctx->release;return}$format->$set($no)if defined$no;return release$ctx,$format->$method ? 1 : 0};no strict 'refs';*$method=$code}}sub no_ending {my($self,$no)=@_;my$ctx=$self->ctx;$ctx->hub->set_no_ending($no)if defined$no;return release$ctx,$ctx->hub->no_ending}sub diag {my$self=shift;return unless @_;my$text=join ''=>map {defined($_)? $_ : 'undef'}@_;if (Test2::API::test2_in_preload()){chomp($text);$text =~ s/^/# /msg;print STDERR$text,"\n";return 0}my$ctx=$self->ctx;$ctx->diag($text);$ctx->release;return 0}sub note {my$self=shift;return unless @_;my$text=join ''=>map {defined($_)? $_ : 'undef'}@_;if (Test2::API::test2_in_preload()){chomp($text);$text =~ s/^/# /msg;print STDOUT$text,"\n";return 0}my$ctx=$self->ctx;$ctx->note($text);$ctx->release;return 0}sub explain {my$self=shift;local ($@,$!);require Data::Dumper;return map {ref $_ ? do {my$dumper=Data::Dumper->new([$_]);$dumper->Indent(1)->Terse(1);$dumper->Sortkeys(1)if$dumper->can("Sortkeys");$dumper->Dump}: $_}@_}sub output {my($self,$fh)=@_;my$ctx=$self->ctx;my$format=$ctx->hub->format;$ctx->release;return unless$format && $format->isa('Test2::Formatter::TAP');$format->handles->[Test2::Formatter::TAP::OUT_STD()]=$self->_new_fh($fh)if defined$fh;return$format->handles->[Test2::Formatter::TAP::OUT_STD()]}sub failure_output {my($self,$fh)=@_;my$ctx=$self->ctx;my$format=$ctx->hub->format;$ctx->release;return unless$format && $format->isa('Test2::Formatter::TAP');$format->handles->[Test2::Formatter::TAP::OUT_ERR()]=$self->_new_fh($fh)if defined$fh;return$format->handles->[Test2::Formatter::TAP::OUT_ERR()]}sub todo_output {my($self,$fh)=@_;my$ctx=$self->ctx;my$format=$ctx->hub->format;$ctx->release;return unless$format && $format->isa('Test::Builder::Formatter');$format->handles->[Test::Builder::Formatter::OUT_TODO()]=$self->_new_fh($fh)if defined$fh;return$format->handles->[Test::Builder::Formatter::OUT_TODO()]}sub _new_fh {my$self=shift;my($file_or_fh)=shift;my$fh;if($self->is_fh($file_or_fh)){$fh=$file_or_fh}elsif(ref$file_or_fh eq 'SCALAR'){if($] >= 5.008){open$fh,">>",$file_or_fh or $self->croak("Can't open scalar ref $file_or_fh: $!")}else {$fh=Test::Builder::IO::Scalar->new($file_or_fh)or $self->croak("Can't tie scalar ref $file_or_fh")}}else {open$fh,">",$file_or_fh or $self->croak("Can't open test output log $file_or_fh: $!");_autoflush($fh)}return$fh}sub _autoflush {my($fh)=shift;my$old_fh=select$fh;$|=1;select$old_fh;return}sub reset_outputs {my$self=shift;my$ctx=$self->ctx;my$format=$ctx->hub->format;$ctx->release;return unless$format && $format->isa('Test2::Formatter::TAP');$format->set_handles([@{$self->{Orig_Handles}}])if$self->{Orig_Handles};return}sub carp {my$self=shift;my$ctx=$self->ctx;$ctx->alert(join "",@_);$ctx->release}sub croak {my$self=shift;my$ctx=$self->ctx;$ctx->throw(join "",@_);$ctx->release}sub current_test {my($self,$num)=@_;my$ctx=$self->ctx;my$hub=$ctx->hub;if(defined$num){$hub->set_count($num);unless ($self->{no_log_results}){my$test_results=$ctx->hub->meta(__PACKAGE__,{})->{Test_Results};if ($num > @$test_results){my$start=@$test_results ? @$test_results : 0;for ($start .. $num - 1){$test_results->[$_]={'ok'=>1,actual_ok=>undef,reason=>'incrementing test number',type=>'unknown',name=>undef }}}elsif ($num < @$test_results){$#{$test_results}=$num - 1}}}return release$ctx,$hub->count}sub is_passing {my$self=shift;my$ctx=$self->ctx;my$hub=$ctx->hub;if(@_){my ($bool)=@_;$hub->set_failed(0)if$bool;$hub->is_passing($bool)}return release$ctx,$hub->is_passing}sub summary {my($self)=shift;return if$self->{no_log_results};my$ctx=$self->ctx;my$data=$ctx->hub->meta(__PACKAGE__,{})->{Test_Results};$ctx->release;return map {$_ ? $_->{'ok'}: ()}@$data}sub details {my$self=shift;return if$self->{no_log_results};my$ctx=$self->ctx;my$data=$ctx->hub->meta(__PACKAGE__,{})->{Test_Results};$ctx->release;return @$data}sub find_TODO {my($self,$pack,$set,$new_value)=@_;my$ctx=$self->ctx;$pack ||= $ctx->trace->package || $self->exported_to;$ctx->release;return unless$pack;no strict 'refs';no warnings 'once';my$old_value=${$pack .'::TODO'};$set and ${$pack .'::TODO'}=$new_value;return$old_value}sub todo {my($self,$pack)=@_;local$Level=$Level + 1;my$ctx=$self->ctx;$ctx->release;my$meta=$ctx->hub->meta(__PACKAGE__,{todo=>[]})->{todo};return$meta->[-1]->[1]if$meta && @$meta;$pack ||= $ctx->trace->package;return unless$pack;no strict 'refs';no warnings 'once';return ${$pack .'::TODO'}}sub in_todo {my$self=shift;local$Level=$Level + 1;my$ctx=$self->ctx;$ctx->release;my$meta=$ctx->hub->meta(__PACKAGE__,{todo=>[]})->{todo};return 1 if$meta && @$meta;my$pack=$ctx->trace->package || return 0;no strict 'refs';no warnings 'once';my$todo=${$pack .'::TODO'};return 0 unless defined$todo;return 0 if "$todo" eq '';return 1}sub todo_start {my$self=shift;my$message=@_ ? shift : '';my$ctx=$self->ctx;my$hub=$ctx->hub;my$filter=$hub->pre_filter(sub {my ($active_hub,$e)=@_;return Test::Builder::TodoDiag->new(%$e)if ref($e)eq 'Test2::Event::Diag';if ($hub==$active_hub && $e->isa('Test2::Event::Ok')){$e->set_todo($message);$e->set_effective_pass(1);if (my$result=$e->get_meta(__PACKAGE__)){$result->{reason}||= $message;$result->{type}||= 'todo';$result->{ok}=1}}return$e},inherit=>1);push @{$ctx->hub->meta(__PACKAGE__,{todo=>[]})->{todo}}=>[$filter,$message];$ctx->release;return}sub todo_end {my$self=shift;my$ctx=$self->ctx;my$set=pop @{$ctx->hub->meta(__PACKAGE__,{todo=>[]})->{todo}};$ctx->throw('todo_end() called without todo_start()')unless$set;$ctx->hub->pre_unfilter($set->[0]);$ctx->release;return}sub caller {my($self)=@_;my$ctx=$self->ctx;my$trace=$ctx->trace;$ctx->release;return wantarray ? $trace->call : $trace->package}sub _try {my($self,$code,%opts)=@_;my$error;my$return;{local $!;local $@;local$SIG{__DIE__};$return=eval {$code->()};$error=$@}die$error if$error and $opts{die_on_fail};return wantarray ? ($return,$error): $return}sub _ending {my$self=shift;my ($ctx,$real_exit_code,$new)=@_;unless ($ctx){my$octx=$self->ctx;$ctx=$octx->snapshot;$octx->release}return if$ctx->hub->no_ending;return if$ctx->hub->meta(__PACKAGE__,{})->{Ending}++;return unless$self->{Original_Pid}==$$;my$hub=$ctx->hub;return if$hub->bailed_out;my$plan=$hub->plan;my$count=$hub->count;my$failed=$hub->failed;my$passed=$hub->is_passing;return unless$plan || $count || $failed;if(!$hub->plan and $hub->count){$self->diag("Tests were run but no plan was declared and done_testing() was not seen.");if($real_exit_code){$self->diag(<<"FAIL");$$new ||= $real_exit_code;return}if($failed > 0){my$exit_code=$failed <= 254 ? $failed : 254;$$new ||= $exit_code;return}$$new ||= 254;return}if ($real_exit_code &&!$count){$self->diag("Looks like your test exited with $real_exit_code before it could output anything.");$$new ||= $real_exit_code;return}return if$plan && "$plan" eq 'SKIP';if (!$count){$self->diag('No tests run!');$$new ||= 255;return}if ($real_exit_code){$self->diag(<<"FAIL");$$new ||= $real_exit_code;return}if ($plan eq 'NO PLAN'){$ctx->plan($count);$plan=$hub->plan}my$num_extra=$count - $plan;if ($num_extra!=0){my$s=$plan==1 ? '' : 's';$self->diag(<<"FAIL")}if ($failed){my$s=$failed==1 ? '' : 's';my$qualifier=$num_extra==0 ? '' : ' run';$self->diag(<<"FAIL")}if (!$passed &&!$failed && $count &&!$num_extra){$ctx->diag(<<"FAIL")}my$exit_code=0;if ($failed){$exit_code=$failed <= 254 ? $failed : 254}elsif ($num_extra!=0){$exit_code=255}elsif (!$passed){$exit_code=255}$$new ||= $exit_code;return}sub _print_comment {my($self,$fh,@msgs)=@_;return if$self->no_diag;return unless@msgs;return if $^C;my$msg=join '',map {defined($_)? $_ : 'undef'}@msgs;$msg =~ s/^/# /;local($\,$",$,)=(undef,' ','');print$fh $msg;return 0}sub coordinate_forks {my$self=shift;{local ($@,$!);require Test2::IPC}Test2::IPC->import;Test2::API::test2_ipc_enable_polling();Test2::API::test2_load();my$ipc=Test2::IPC::apply_ipc($self->{Stack});$ipc->set_no_fatal(1);Test2::API::test2_no_wait(1)}sub no_log_results {$_[0]->{no_log_results}=1}1;
  An error occurred while using $type:
  ------------------------------------
  $error
  ------------------------------------
  END
      $got
          $type
      $expect
  DIAGNOSTIC
                    %s
      %13s '%s'
  DIAGNOSTIC
  Looks like your test exited with $real_exit_code just after $count.
  FAIL
  Looks like your test exited with $real_exit_code just after $count.
  FAIL
  Looks like you planned $plan test$s but ran $count.
  FAIL
  Looks like you failed $failed test$s of $count$qualifier.
  FAIL
  All assertions passed, but errors were encountered.
  FAIL
TEST_BUILDER

$fatpacked{"Test/Builder/Formatter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER_FORMATTER';
  package Test::Builder::Formatter;use strict;use warnings;our$VERSION='1.302190';BEGIN {require Test2::Formatter::TAP;our@ISA=qw(Test2::Formatter::TAP)}use Test2::Util::HashBase qw/no_header no_diag/;BEGIN {*OUT_STD=Test2::Formatter::TAP->can('OUT_STD');*OUT_ERR=Test2::Formatter::TAP->can('OUT_ERR');my$todo=OUT_ERR()+ 1;*OUT_TODO=sub() {$todo}}sub init {my$self=shift;$self->SUPER::init(@_);$self->{+HANDLES}->[OUT_TODO]=$self->{+HANDLES}->[OUT_STD]}sub plan_tap {my ($self,$f)=@_;return if$self->{+NO_HEADER};return$self->SUPER::plan_tap($f)}sub debug_tap {my ($self,$f,$num)=@_;return if$self->{+NO_DIAG};my@out=$self->SUPER::debug_tap($f,$num);$self->redirect(\@out)if@out && ref$f->{about}&& defined$f->{about}->{package}&& $f->{about}->{package}eq 'Test::Builder::TodoDiag';return@out}sub info_tap {my ($self,$f)=@_;return if$self->{+NO_DIAG};my@out=$self->SUPER::info_tap($f);$self->redirect(\@out)if@out && ref$f->{about}&& defined$f->{about}->{package}&& $f->{about}->{package}eq 'Test::Builder::TodoDiag';return@out}sub redirect {my ($self,$out)=@_;$_->[0]=OUT_TODO for @$out}sub no_subtest_space {1}1;
TEST_BUILDER_FORMATTER

$fatpacked{"Test/Builder/IO/Scalar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER_IO_SCALAR';
  package Test::Builder::IO::Scalar;use Carp;use strict;use vars qw($VERSION @ISA);use IO::Handle;use 5.005;$VERSION="2.114";@ISA=qw(IO::Handle);sub new {my$proto=shift;my$class=ref($proto)|| $proto;my$self=bless \do {local*FH},$class;tie *$self,$class,$self;$self->open(@_);$self}sub DESTROY {shift->close}sub open {my ($self,$sref)=@_;defined($sref)or do {my$s='';$sref=\$s};(ref($sref)eq "SCALAR")or croak "open() needs a ref to a scalar";*$self->{Pos}=0;*$self->{SR}=$sref;$self}sub opened {*{shift()}->{SR}}sub close {my$self=shift;%{*$self}=();1}sub flush {"0 but true"}sub getc {my$self=shift;return undef if$self->eof;substr(${*$self->{SR}},*$self->{Pos}++,1)}sub getline {my$self=shift;return undef if$self->eof;my$sr=*$self->{SR};my$i=*$self->{Pos};if (!defined($/)){*$self->{Pos}=length $$sr;return substr($$sr,$i)}elsif ($/ eq "\012"){my$len=length($$sr);for (;$i < $len;++$i){last if ord (substr ($$sr,$i,1))==10}my$line;if ($i < $len){$line=substr ($$sr,*$self->{Pos},$i - *$self->{Pos}+ 1);*$self->{Pos}=$i+1}else {$line=substr ($$sr,*$self->{Pos},$i - *$self->{Pos});*$self->{Pos}=$len}return$line}elsif (ref($/)){my$len=length($$sr);my$i=${$/}+ 0;my$line=substr ($$sr,*$self->{Pos},$i);*$self->{Pos}+= $i;*$self->{Pos}=$len if (*$self->{Pos}> $len);return$line}else {pos($$sr)=$i;length($/)or (($$sr =~ m/\G\n*/g)and ($i=pos($$sr)));if (length($/)? $$sr =~ m,\Q$/\E,g : $$sr =~ m,\n\n,g){*$self->{Pos}=pos $$sr;return substr($$sr,$i,*$self->{Pos}-$i)}else {*$self->{Pos}=length $$sr;return substr($$sr,$i)}}}sub getlines {my$self=shift;wantarray or croak("can't call getlines in scalar context!");my ($line,@lines);push@lines,$line while (defined($line=$self->getline));@lines}sub print {my$self=shift;*$self->{Pos}=length(${*$self->{SR}}.= join('',@_).(defined($\)? $\ : ""));1}sub _unsafe_print {my$self=shift;my$append=join('',@_).$\;${*$self->{SR}}.= $append;*$self->{Pos}+= length($append);1}sub _old_print {my$self=shift;${*$self->{SR}}.= join('',@_).$\;*$self->{Pos}=length(${*$self->{SR}});1}sub read {my$self=$_[0];my$n=$_[2];my$off=$_[3]|| 0;my$read=substr(${*$self->{SR}},*$self->{Pos},$n);$n=length($read);*$self->{Pos}+= $n;($off ? substr($_[1],$off): $_[1])=$read;return$n}sub write {my$self=$_[0];my$n=$_[2];my$off=$_[3]|| 0;my$data=substr($_[1],$off,$n);$n=length($data);$self->print($data);return$n}sub sysread {my$self=shift;$self->read(@_)}sub syswrite {my$self=shift;$self->write(@_)}sub autoflush {}sub binmode {}sub clearerr {1}sub eof {my$self=shift;(*$self->{Pos}>= length(${*$self->{SR}}))}sub seek {my ($self,$pos,$whence)=@_;my$eofpos=length(${*$self->{SR}});if ($whence==0){*$self->{Pos}=$pos}elsif ($whence==1){*$self->{Pos}+= $pos}elsif ($whence==2){*$self->{Pos}=$eofpos + $pos}else {croak "bad seek whence ($whence)"}if (*$self->{Pos}< 0){*$self->{Pos}=0}if (*$self->{Pos}> $eofpos){*$self->{Pos}=$eofpos}return 1}sub sysseek {my$self=shift;$self->seek (@_)}sub tell {*{shift()}->{Pos}}sub use_RS {my ($self,$yesno)=@_;carp "use_RS is deprecated and ignored; \$/ is always consulted\n"}sub setpos {shift->seek($_[0],0)}*getpos=\&tell;sub sref {*{shift()}->{SR}}sub TIEHANDLE {((defined($_[1])&& UNIVERSAL::isa($_[1],__PACKAGE__))? $_[1]: shift->new(@_))}sub GETC {shift->getc(@_)}sub PRINT {shift->print(@_)}sub PRINTF {shift->print(sprintf(shift,@_))}sub READ {shift->read(@_)}sub READLINE {wantarray ? shift->getlines(@_): shift->getline(@_)}sub WRITE {shift->write(@_)}sub CLOSE {shift->close(@_)}sub SEEK {shift->seek(@_)}sub TELL {shift->tell(@_)}sub EOF {shift->eof(@_)}sub FILENO {-1}1;
TEST_BUILDER_IO_SCALAR

$fatpacked{"Test/Builder/Module.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER_MODULE';
  package Test::Builder::Module;use strict;use Test::Builder;require Exporter;our@ISA=qw(Exporter);our$VERSION='1.302190';sub import {my($class)=shift;Test2::API::test2_load()unless Test2::API::test2_in_preload();return 1 if$class eq 'Test::Builder::Module';my$test=$class->builder;my$caller=caller;$test->exported_to($caller);$class->import_extra(\@_);my(@imports)=$class->_strip_imports(\@_);$test->plan(@_);local$Exporter::ExportLevel=$Exporter::ExportLevel + 1;$class->Exporter::import(@imports)}sub _strip_imports {my$class=shift;my$list=shift;my@imports=();my@other=();my$idx=0;while($idx <= $#{$list}){my$item=$list->[$idx];if(defined$item and $item eq 'import'){push@imports,@{$list->[$idx + 1 ]};$idx++}else {push@other,$item}$idx++}@$list=@other;return@imports}sub import_extra {}sub builder {return Test::Builder->new}1;
TEST_BUILDER_MODULE

$fatpacked{"Test/Builder/Tester.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER_TESTER';
  package Test::Builder::Tester;use strict;our$VERSION='1.302190';use Test::Builder;use Symbol;use Carp;my$t=Test::Builder->new;use Exporter;our@ISA=qw(Exporter);our@EXPORT=qw(test_out test_err test_fail test_diag test_test line_num);sub import {my$class=shift;my(@plan)=@_;my$caller=caller;$t->exported_to($caller);$t->plan(@plan);my@imports=();for my$idx (0 .. $#plan){if($plan[$idx]eq 'import'){@imports=@{$plan[$idx + 1 ]};last}}__PACKAGE__->export_to_level(1,__PACKAGE__,@imports)}my$output_handle=gensym;my$error_handle=gensym;my$out=tie *$output_handle,"Test::Builder::Tester::Tie","STDOUT";my$err=tie *$error_handle,"Test::Builder::Tester::Tie","STDERR";my$testing=0;my$testing_num;my$original_is_passing;my$original_output_handle;my$original_failure_handle;my$original_todo_handle;my$original_formatter;my$original_harness_env;sub _start_testing {$INC{'Test/Stream.pm'}||= 'fake' if$INC{'Test/Moose/More.pm'};$original_harness_env=$ENV{HARNESS_ACTIVE}|| 0;$ENV{HARNESS_ACTIVE}=0;my$hub=$t->{Hub}|| ($t->{Stack}? $t->{Stack}->top : Test2::API::test2_stack->top);$original_formatter=$hub->format;unless ($original_formatter && $original_formatter->isa('Test::Builder::Formatter')){my$fmt=Test::Builder::Formatter->new;$hub->format($fmt)}$original_output_handle=$t->output();$original_failure_handle=$t->failure_output();$original_todo_handle=$t->todo_output();$t->output($output_handle);$t->failure_output($error_handle);$t->todo_output($output_handle);$out->reset();$err->reset();$testing=1;$testing_num=$t->current_test;$t->current_test(0);$original_is_passing=$t->is_passing;$t->is_passing(1);$t->no_ending(1)}sub test_out {_start_testing()unless$testing;$out->expect(@_)}sub test_err {_start_testing()unless$testing;$err->expect(@_)}sub test_fail {_start_testing()unless$testing;my($package,$filename,$line)=caller;$line=$line + (shift()|| 0);$err->expect("#     Failed test ($filename at line $line)")}sub test_diag {_start_testing()unless$testing;local $_;$err->expect(map {"# $_"}@_)}sub test_test {delete$INC{'Test/Stream.pm'}if$INC{'Test/Stream.pm'}&& $INC{'Test/Stream.pm'}eq 'fake';my$mess;my%args;if(@_==1){$mess=shift}else {%args=@_;$mess=$args{name}if exists($args{name});$mess=$args{title}if exists($args{title});$mess=$args{label}if exists($args{label})}croak "Not testing.  You must declare output with a test function first." unless$testing;my$hub=$t->{Hub}|| Test2::API::test2_stack->top;$hub->format($original_formatter);$t->output($original_output_handle);$t->failure_output($original_failure_handle);$t->todo_output($original_todo_handle);$t->current_test($testing_num);$testing=0;$t->is_passing($original_is_passing);$ENV{HARNESS_ACTIVE}=$original_harness_env;unless($t->ok(($args{skip_out}|| $out->check)&& ($args{skip_err}|| $err->check),$mess)){local $_;$t->diag(map {"$_\n"}$out->complaint)unless$args{skip_out}|| $out->check;$t->diag(map {"$_\n"}$err->complaint)unless$args{skip_err}|| $err->check}}sub line_num {my($package,$filename,$line)=caller;return$line + (shift()|| 0)}my$color;sub color {$color=shift if @_;$color}1;package Test::Builder::Tester::Tie;sub expect {my$self=shift;my@checks=@_;for my$check (@checks){$check=$self->_account_for_subtest($check);$check=$self->_translate_Failed_check($check);push @{$self->{wanted}},ref$check ? $check : "$check\n"}}sub _account_for_subtest {my($self,$check)=@_;my$hub=$t->{Stack}->top;my$nesting=$hub->isa('Test2::Hub::Subtest')? $hub->nested : 0;return ref($check)? $check : ('    ' x $nesting).$check}sub _translate_Failed_check {my($self,$check)=@_;if($check =~ /\A(.*)#     (Failed .*test) \((.*?) at line (\d+)\)\Z(?!\n)/){$check="/\Q$1\E#\\s+\Q$2\E.*?\\n?.*?\Qat $3\E line \Q$4\E.*\\n?/"}return$check}sub check {my$self=shift;local $^W=0;my@checks=@{$self->{wanted}};my$got=$self->{got};for my$check (@checks){$check="\Q$check\E" unless($check =~ s,^/(.*)/$,$1, or ref$check);return 0 unless$got =~ s/^$check//}return length$got==0}sub complaint {my$self=shift;my$type=$self->type;my$got=$self->got;my$wanted=join '',@{$self->wanted};if(Test::Builder::Tester::color){eval {require Term::ANSIColor};unless($@){eval {require Win32::Console::ANSI}if 'MSWin32' eq $^O;my$green=Term::ANSIColor::color("black").Term::ANSIColor::color("on_green");my$red=Term::ANSIColor::color("black").Term::ANSIColor::color("on_red");my$reset=Term::ANSIColor::color("reset");my$char=0;$char++ while substr($got,$char,1)eq substr($wanted,$char,1);my$start=$green .substr($wanted,0,$char);my$gotend=$red .substr($got,$char).$reset;my$wantedend=$red .substr($wanted,$char).$reset;$start =~ s/\n/$reset\n$green/g;$gotend =~ s/\n/$reset\n$red/g;$wantedend =~ s/\n/$reset\n$red/g;$got=$start .$gotend;$wanted=$start .$wantedend}}my@got=split "\n",$got;my@wanted=split "\n",$wanted;$got="";$wanted="";while (@got || @wanted){my$g=shift@got || "";my$w=shift@wanted || "";if ($g ne $w){if($g =~ s/(\s+)$/    |> /g){$g .= ($_ eq ' ' ? '_' : '\t')for split '',$1}if($w =~ s/(\s+)$/    |> /g){$w .= ($_ eq ' ' ? '_' : '\t')for split '',$1}$g="> $g";$w="> $w"}else {$g="  $g";$w="  $w"}$got=$got ? "$got\n$g" : $g;$wanted=$wanted ? "$wanted\n$w" : $w}return "$type is:\n" ."$got\nnot:\n$wanted\nas expected"}sub reset {my$self=shift;%$self=(type=>$self->{type},got=>'',wanted=>[],)}sub got {my$self=shift;return$self->{got}}sub wanted {my$self=shift;return$self->{wanted}}sub type {my$self=shift;return$self->{type}}sub PRINT {my$self=shift;$self->{got}.= join '',@_}sub TIEHANDLE {my($class,$type)=@_;my$self=bless {type=>$type },$class;$self->reset;return$self}sub READ {}sub READLINE {}sub GETC {}sub FILENO {}1;
TEST_BUILDER_TESTER

$fatpacked{"Test/Builder/Tester/Color.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER_TESTER_COLOR';
  package Test::Builder::Tester::Color;use strict;our$VERSION='1.302190';require Test::Builder::Tester;sub import {Test::Builder::Tester::color(1)}1;
TEST_BUILDER_TESTER_COLOR

$fatpacked{"Test/Builder/TodoDiag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER_TODODIAG';
  package Test::Builder::TodoDiag;use strict;use warnings;our$VERSION='1.302190';BEGIN {require Test2::Event::Diag;our@ISA=qw(Test2::Event::Diag)}sub diagnostics {0}sub facet_data {my$self=shift;my$out=$self->SUPER::facet_data();$out->{info}->[0]->{debug}=0;return$out}1;
TEST_BUILDER_TODODIAG

$fatpacked{"Test/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_EXCEPTION';
  use strict;use warnings;package Test::Exception;use Test::Builder;use Sub::Uplevel qw(uplevel);use base qw(Exporter);our$VERSION='0.43';$VERSION=eval$VERSION;our@EXPORT=qw(dies_ok lives_ok throws_ok lives_and);my$Tester=Test::Builder->new;sub import {my$self=shift;if (@_){my$package=caller;$Tester->exported_to($package);$Tester->plan(@_)};$self->export_to_level(1,$self,$_)foreach@EXPORT}sub _quiet_caller (;$) {my$height=$_[0];$height++;if (CORE::caller()eq 'DB'){package DB;if(wantarray){if (!@_){return (CORE::caller($height))[0..2]}else {my@frame_info=CORE::caller($height);@DB::args=();return@frame_info}}return CORE::caller($height)}else {if(wantarray and!@_){return (CORE::caller($height))[0..2]}else {return CORE::caller($height)}}}sub _try_as_caller {my$coderef=shift;local*CORE::GLOBAL::caller;{no warnings 'redefine';*CORE::GLOBAL::caller=\&_quiet_caller}eval {uplevel 3,$coderef};return $@};sub _is_exception {my$exception=shift;return ref$exception || $exception ne ''};sub _exception_as_string {my ($prefix,$exception)=@_;return "$prefix normal exit" unless _is_exception($exception);my$class=ref$exception;$exception="$class ($exception)" if$class && "$exception" !~ m/^\Q$class/;chomp$exception;return "$prefix $exception"};sub throws_ok (&$;$) {my ($coderef,$expecting,$description)=@_;unless (defined$expecting){require Carp;Carp::croak("throws_ok: must pass exception class/object or regex")}$description=_exception_as_string("threw",$expecting)unless defined$description;my$exception=_try_as_caller($coderef);my$regex=$Tester->maybe_regex($expecting);my$ok=$regex ? ($exception =~ m/$regex/): eval {$exception->isa(ref$expecting ? ref$expecting : $expecting)};$Tester->ok($ok,$description);unless ($ok){$Tester->diag(_exception_as_string("expecting:",$expecting));$Tester->diag(_exception_as_string("found:",$exception))};$@=$exception;return$ok};sub dies_ok (&;$) {my ($coderef,$description)=@_;my$exception=_try_as_caller($coderef);my$ok=$Tester->ok(_is_exception($exception),$description);$@=$exception;return$ok}sub lives_ok (&;$) {my ($coderef,$description)=@_;my$exception=_try_as_caller($coderef);my$ok=$Tester->ok(!_is_exception($exception),$description);$Tester->diag(_exception_as_string("died:",$exception))unless$ok;$@=$exception;return$ok}sub lives_and (&;$) {my ($test,$description)=@_;{my$ok=\&Test::Builder::ok;no warnings;local*Test::Builder::ok=sub {local$Test::Builder::Level=$Test::Builder::Level + 1;$_[2]=$description unless defined $_[2];$ok->(@_)};use warnings;eval {$test->()}and return 1};my$exception=$@;if (_is_exception($exception)){$Tester->ok(0,$description);$Tester->diag(_exception_as_string("died:",$exception))};$@=$exception;return}1;
TEST_EXCEPTION

$fatpacked{"Test/Fatal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_FATAL';
  use strict;use warnings;package Test::Fatal;$Test::Fatal::VERSION='0.016';use Carp ();use Try::Tiny 0.07;use Exporter 5.57 'import';our@EXPORT=qw(exception);our@EXPORT_OK=qw(exception success dies_ok lives_ok);our ($REAL_TBL,$REAL_CALCULATED_TBL)=(1,1);sub exception (&) {my$code=shift;return try {my$incremented=defined$Test::Builder::Level ? $Test::Builder::Level - $REAL_CALCULATED_TBL : 0;local$Test::Builder::Level=$REAL_CALCULATED_TBL;if ($incremented){$Test::Builder::Level += 5;for my$i (1..$incremented){my$caller=caller($Test::Builder::Level - 2);if ($caller eq __PACKAGE__){$Test::Builder::Level=$Test::Builder::Level + 5}else {$Test::Builder::Level=$Test::Builder::Level + 1}}}local$REAL_CALCULATED_TBL=$Test::Builder::Level;local$Carp::MaxArgNums=-1;$code->();return undef}catch {return $_ if $_;my$problem=defined $_ ? 'false' : 'undef';Carp::confess("$problem exception caught by Test::Fatal::exception")}}sub success (&;@) {my$code=shift;return finally(sub {return if @_;$code->()},@_)}my$Tester;sub dies_ok (&;$) {my$code=shift;my$name=shift;require Test::Builder;$Tester ||= Test::Builder->new;my$tap_pos=$Tester->current_test;my$exception=exception(\&$code);$name ||= $tap_pos!=$Tester->current_test ? "...and code should throw an exception" : "code should throw an exception";my$ok=$Tester->ok($exception,$name);$ok or $Tester->diag("expected an exception but none was raised");return$ok}sub lives_ok (&;$) {my$code=shift;my$name=shift;require Test::Builder;$Tester ||= Test::Builder->new;my$tap_pos=$Tester->current_test;my$exception=exception(\&$code);$name ||= $tap_pos!=$Tester->current_test ? "...and code should not throw an exception" : "code should not throw an exception";my$ok=$Tester->ok(!$exception,$name);$ok or $Tester->diag("expected return but an exception was raised");return$ok}1;
TEST_FATAL

$fatpacked{"Test/Harness.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_HARNESS';
  package Test::Harness;use 5.006;use strict;use warnings;use constant IS_WIN32=>($^O =~ /^(MS)?Win32$/);use constant IS_VMS=>($^O eq 'VMS');use TAP::Harness ();use TAP::Parser::Aggregator ();use TAP::Parser::Source ();use TAP::Parser::SourceHandler::Perl ();use Text::ParseWords qw(shellwords);use Config;use base 'Exporter';BEGIN {eval q{use Time::HiRes 'time'};our$has_time_hires=!$@}our$VERSION='3.44';*verbose=*Verbose;*switches=*Switches;*debug=*Debug;$ENV{HARNESS_ACTIVE}=1;$ENV{HARNESS_VERSION}=$VERSION;END {delete$ENV{HARNESS_ACTIVE};delete$ENV{HARNESS_VERSION}}our@EXPORT=qw(&runtests);our@EXPORT_OK=qw(&execute_tests $verbose $switches);our$Verbose=$ENV{HARNESS_VERBOSE}|| 0;our$Debug=$ENV{HARNESS_DEBUG}|| 0;our$Switches='-w';our$Columns=$ENV{HARNESS_COLUMNS}|| $ENV{COLUMNS}|| 80;$Columns--;our$Timer=$ENV{HARNESS_TIMER}|| 0;our$Color=$ENV{HARNESS_COLOR}|| 0;our$IgnoreExit=$ENV{HARNESS_IGNORE_EXIT}|| 0;sub _has_taint {my$test=shift;return TAP::Parser::SourceHandler::Perl->get_taint(TAP::Parser::Source->shebang($test))}sub _aggregate {my ($harness,$aggregate,@tests)=@_;local$ENV{HARNESS_OPTIONS};_apply_extra_INC($harness);_aggregate_tests($harness,$aggregate,@tests)}sub _apply_extra_INC {my$harness=shift;$harness->callback(parser_args=>sub {my ($args,$test)=@_;push @{$args->{switches}},map {"-I$_"}_filtered_inc()})}sub _aggregate_tests {my ($harness,$aggregate,@tests)=@_;$aggregate->start();$harness->aggregate_tests($aggregate,@tests);$aggregate->stop()}sub runtests {my@tests=@_;local ($\,$,);my$harness=_new_harness();my$aggregate=TAP::Parser::Aggregator->new();local$ENV{PERL_USE_UNSAFE_INC}=1 if not exists$ENV{PERL_USE_UNSAFE_INC};_aggregate($harness,$aggregate,@tests);$harness->formatter->summary($aggregate);my$total=$aggregate->total;my$passed=$aggregate->passed;my$failed=$aggregate->failed;my@parsers=$aggregate->parsers;my$num_bad=0;for my$parser (@parsers){$num_bad++ if$parser->has_problems}die(sprintf("Failed %d/%d test programs. %d/%d subtests failed.\n",$num_bad,scalar@parsers,$failed,$total))if$num_bad;return$total && $total==$passed}sub _canon {my@list=sort {$a <=> $b}@_;my@ranges=();my$count=scalar@list;my$pos=0;while ($pos < $count){my$end=$pos + 1;$end++ while$end < $count && $list[$end]<= $list[$end - 1 ]+ 1;push@ranges,($end==$pos + 1)? $list[$pos]: join('-',$list[$pos],$list[$end - 1 ]);$pos=$end}return join(' ',@ranges)}sub _new_harness {my$sub_args=shift || {};my (@lib,@switches);my@opt=map {shellwords($_)}grep {defined}$Switches,$ENV{HARNESS_PERL_SWITCHES};while (my$opt=shift@opt){if ($opt =~ /^ -I (.*) $ /x){push@lib,length($1)? $1 : shift@opt}else {push@switches,$opt}}push@lib,_filtered_inc()if IS_VMS;my$verbosity=($Verbose ? ($Verbose !~ /\d/)? 1 : $Verbose : 0);my$args={timer=>$Timer,directives=>our$Directives,lib=>\@lib,switches=>\@switches,color=>$Color,verbosity=>$verbosity,ignore_exit=>$IgnoreExit,};$args->{stdout}=$sub_args->{out}if exists$sub_args->{out};my$class=$ENV{HARNESS_SUBCLASS}|| 'TAP::Harness';if (defined(my$env_opt=$ENV{HARNESS_OPTIONS})){for my$opt (split /:/,$env_opt){if ($opt =~ /^j(\d*)$/){$args->{jobs}=$1 || 9}elsif ($opt eq 'c'){$args->{color}=1}elsif ($opt =~ m/^f(.*)$/){my$fmt=$1;$fmt =~ s/-/::/g;$args->{formatter_class}=$fmt}elsif ($opt =~ m/^a(.*)$/){my$archive=$1;$class="TAP::Harness::Archive";$args->{archive}=$archive}else {die "Unknown HARNESS_OPTIONS item: $opt\n"}}}return TAP::Harness->_construct($class,$args)}sub _filtered_inc {my@inc=grep {!ref}@INC;if (IS_VMS){@inc=grep!/perl_root/i,@inc}elsif (IS_WIN32){s/[\\\/]+$// for@inc}my@default_inc=_default_inc();my@new_inc;my%seen;for my$dir (@inc){next if$seen{$dir}++;if ($dir eq ($default_inc[0]|| '')){shift@default_inc}else {push@new_inc,$dir}shift@default_inc while@default_inc and $seen{$default_inc[0]}}return@new_inc}{my@inc;sub _default_inc {return@inc if@inc;local$ENV{PERL5LIB};local$ENV{PERLLIB};my$perl=$ENV{HARNESS_PERL}|| $^X;chomp(@inc=`"$perl" -e "print join qq[\\n], \@INC, q[]"`);return@inc}}sub _check_sequence {my@list=@_;my$prev;while (my$next=shift@list){return if defined$prev && $next <= $prev;$prev=$next}return 1}sub execute_tests {my%args=@_;my$harness=_new_harness(\%args);my$aggregate=TAP::Parser::Aggregator->new();my%tot=(bonus=>0,max=>0,ok=>0,bad=>0,good=>0,files=>0,tests=>0,sub_skipped=>0,todo=>0,skipped=>0,bench=>undef,);$harness->callback(made_parser=>sub {my$parser=shift;$parser->callback(plan=>sub {my$plan=shift;if ($plan->directive eq 'SKIP'){$tot{skipped}++}})});local$ENV{PERL_USE_UNSAFE_INC}=1 if not exists$ENV{PERL_USE_UNSAFE_INC};_aggregate($harness,$aggregate,@{$args{tests}});$tot{bench}=$aggregate->elapsed;my@tests=$aggregate->descriptions;$tot{files}=$tot{tests}=scalar@tests;my%failedtests=();my%todo_passed=();for my$test (@tests){my ($parser)=$aggregate->parsers($test);my@failed=$parser->failed;my$wstat=$parser->wait;my$estat=$parser->exit;my$planned=$parser->tests_planned;my@errors=$parser->parse_errors;my$passed=$parser->passed;my$actual_passed=$parser->actual_passed;my$ok_seq=_check_sequence($parser->actual_passed);$estat ||= '' unless$wstat;$wstat ||= '';$tot{max}+= ($planned || 0);$tot{bonus}+= $parser->todo_passed;$tot{ok}+= $passed > $actual_passed ? $passed : $actual_passed;$tot{sub_skipped}+= $parser->skipped;$tot{todo}+= $parser->todo;if (@failed || $estat || @errors){$tot{bad}++;my$huh_planned=$planned ? undef : '??';my$huh_errors=$ok_seq ? undef : '??';$failedtests{$test}={'canon'=>$huh_planned || $huh_errors || _canon(@failed)|| '??','estat'=>$estat,'failed'=>$huh_planned || $huh_errors || scalar@failed,'max'=>$huh_planned || $planned,'name'=>$test,'wstat'=>$wstat }}else {$tot{good}++}my@todo=$parser->todo_passed;if (@todo){$todo_passed{$test}={'canon'=>_canon(@todo),'estat'=>$estat,'failed'=>scalar@todo,'max'=>scalar$parser->todo,'name'=>$test,'wstat'=>$wstat }}}return (\%tot,\%failedtests,\%todo_passed)}1;
TEST_HARNESS

$fatpacked{"Test/More.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_MORE';
  package Test::More;use 5.006;use strict;use warnings;sub _carp {my($file,$line)=(caller(1))[1,2 ];return warn @_," at $file line $line\n"}our$VERSION='1.302190';use Test::Builder::Module;our@ISA=qw(Test::Builder::Module);our@EXPORT=qw(ok use_ok require_ok is isnt like unlike is_deeply cmp_ok skip todo todo_skip pass fail eq_array eq_hash eq_set $TODO plan done_testing can_ok isa_ok new_ok diag note explain subtest BAIL_OUT);sub plan {my$tb=Test::More->builder;return$tb->plan(@_)}sub import_extra {my$class=shift;my$list=shift;my@other=();my$idx=0;my$import;while($idx <= $#{$list}){my$item=$list->[$idx];if(defined$item and $item eq 'no_diag'){$class->builder->no_diag(1)}elsif(defined$item and $item eq 'import'){if ($import){push @$import,@{$list->[++$idx ]}}else {$import=$list->[++$idx ];push@other,$item,$import}}else {push@other,$item}$idx++}@$list=@other;if ($class eq __PACKAGE__ && (!$import || grep $_ eq '$TODO',@$import)){my$to=$class->builder->exported_to;no strict 'refs';*{"$to\::TODO"}=\our$TODO;if ($import){@$import=grep $_ ne '$TODO',@$import}else {push @$list,import=>[grep $_ ne '$TODO',@EXPORT]}}return}sub done_testing {my$tb=Test::More->builder;$tb->done_testing(@_)}sub ok ($;$) {my($test,$name)=@_;my$tb=Test::More->builder;return$tb->ok($test,$name)}sub is ($$;$) {my$tb=Test::More->builder;return$tb->is_eq(@_)}sub isnt ($$;$) {my$tb=Test::More->builder;return$tb->isnt_eq(@_)}*isn::t=\&isnt;sub like ($$;$) {my$tb=Test::More->builder;return$tb->like(@_)}sub unlike ($$;$) {my$tb=Test::More->builder;return$tb->unlike(@_)}sub cmp_ok($$$;$) {my$tb=Test::More->builder;return$tb->cmp_ok(@_)}sub can_ok ($@) {my($proto,@methods)=@_;my$class=ref$proto || $proto;my$tb=Test::More->builder;unless($class){my$ok=$tb->ok(0,"->can(...)");$tb->diag('    can_ok() called with empty class or reference');return$ok}unless(@methods){my$ok=$tb->ok(0,"$class->can(...)");$tb->diag('    can_ok() called with no methods');return$ok}my@nok=();for my$method (@methods){$tb->_try(sub {$proto->can($method)})or push@nok,$method}my$name=(@methods==1)? "$class->can('$methods[0]')" : "$class->can(...)" ;my$ok=$tb->ok(!@nok,$name);$tb->diag(map "    $class->can('$_') failed\n",@nok);return$ok}sub isa_ok ($$;$) {my($thing,$class,$thing_name)=@_;my$tb=Test::More->builder;my$whatami;if(!defined$thing){$whatami='undef'}elsif(ref$thing){$whatami='reference';local($@,$!);require Scalar::Util;if(Scalar::Util::blessed($thing)){$whatami='object'}}else {$whatami='class'}my($rslt,$error)=$tb->_try(sub {$thing->isa($class)});if($error){die <<WHOA unless$error =~ /^Can't (locate|call) method "isa"/}if($whatami eq 'reference'){$rslt=UNIVERSAL::isa($thing,$class)}my($diag,$name);if(defined$thing_name){$name="'$thing_name' isa '$class'";$diag=defined$thing ? "'$thing_name' isn't a '$class'" : "'$thing_name' isn't defined"}elsif($whatami eq 'object'){my$my_class=ref$thing;$thing_name=qq[An object of class '$my_class'];$name="$thing_name isa '$class'";$diag="The object of class '$my_class' isn't a '$class'"}elsif($whatami eq 'reference'){my$type=ref$thing;$thing_name=qq[A reference of type '$type'];$name="$thing_name isa '$class'";$diag="The reference of type '$type' isn't a '$class'"}elsif($whatami eq 'undef'){$thing_name='undef';$name="$thing_name isa '$class'";$diag="$thing_name isn't defined"}elsif($whatami eq 'class'){$thing_name=qq[The class (or class-like) '$thing'];$name="$thing_name isa '$class'";$diag="$thing_name isn't a '$class'"}else {die}my$ok;if($rslt){$ok=$tb->ok(1,$name)}else {$ok=$tb->ok(0,$name);$tb->diag("    $diag\n")}return$ok}sub new_ok {my$tb=Test::More->builder;$tb->croak("new_ok() must be given at least a class")unless @_;my($class,$args,$object_name)=@_;$args ||= [];my$obj;my($success,$error)=$tb->_try(sub {$obj=$class->new(@$args);1});if($success){local$Test::Builder::Level=$Test::Builder::Level + 1;isa_ok$obj,$class,$object_name}else {$class='undef' if!defined$class;$tb->ok(0,"$class->new() died");$tb->diag("    Error was:  $error")}return$obj}sub subtest {my$tb=Test::More->builder;return$tb->subtest(@_)}sub pass (;$) {my$tb=Test::More->builder;return$tb->ok(1,@_)}sub fail (;$) {my$tb=Test::More->builder;return$tb->ok(0,@_)}sub require_ok ($) {my($module)=shift;my$tb=Test::More->builder;my$pack=caller;$module=qq['$module'] unless _is_module_name($module);my$code=<<REQUIRE;my($eval_result,$eval_error)=_eval($code);my$ok=$tb->ok($eval_result,"require $module;");unless($ok){chomp$eval_error;$tb->diag(<<DIAGNOSTIC)}return$ok}sub _is_module_name {my$module=shift;$module =~ s/\b::\b//g;return$module =~ /^[a-zA-Z]\w*$/ ? 1 : 0}sub use_ok ($;@) {my($module,@imports)=@_;@imports=()unless@imports;my$tb=Test::More->builder;my%caller;@caller{qw/pack file line sub args want eval req strict warn/}=caller(0);my ($pack,$filename,$line,$warn)=@caller{qw/pack file line warn/};$filename =~ y/\n\r/_/;my$code;if(@imports==1 and $imports[0]=~ /^\d+(?:\.\d+)?$/){$code=<<USE}else {$code=<<USE}my ($eval_result,$eval_error)=_eval($code,\@imports,$warn);my$ok=$tb->ok($eval_result,"use $module;");unless($ok){chomp$eval_error;$@ =~ s{^BEGIN failed--compilation aborted at .*$}
  WHOA! I tried to call ->isa on your $whatami and got some weird error.
  Here's the error.
  $error
  WHOA
  package $pack;
  require $module;
  1;
  REQUIRE
      Tried to require '$module'.
      Error:  $eval_error
  DIAGNOSTIC
  package $pack;
  BEGIN { \${^WARNING_BITS} = \$args[-1] if defined \$args[-1] }
  #line $line $filename
  use $module $imports[0];
  1;
  USE
  package $pack;
  BEGIN { \${^WARNING_BITS} = \$args[-1] if defined \$args[-1] }
  #line $line $filename
  use $module \@{\$args[0]};
  1;
  USE
                  {BEGIN failed--compilation aborted at $filename line $line.}m;$tb->diag(<<DIAGNOSTIC)}return$ok}sub _eval {my($code,@args)=@_;my($sigdie,$eval_result,$eval_error);{local($@,$!,$SIG{__DIE__});$eval_result=eval$code;$eval_error=$@;$sigdie=$SIG{__DIE__}|| undef}$SIG{__DIE__}=$sigdie if defined$sigdie;return($eval_result,$eval_error)}our(@Data_Stack,%Refs_Seen);my$DNE=bless [],'Does::Not::Exist';sub _dne {return ref $_[0]eq ref$DNE}sub is_deeply {my$tb=Test::More->builder;unless(@_==2 or @_==3){my$msg=<<'WARNING';chop$msg;_carp sprintf$msg,scalar @_;return$tb->ok(0)}my($got,$expected,$name)=@_;$tb->_unoverload_str(\$expected,\$got);my$ok;if(!ref$got and!ref$expected){$ok=$tb->is_eq($got,$expected,$name)}elsif(!ref$got xor!ref$expected){$ok=$tb->ok(0,$name);$tb->diag(_format_stack({vals=>[$got,$expected ]}))}else {local@Data_Stack=();if(_deep_check($got,$expected)){$ok=$tb->ok(1,$name)}else {$ok=$tb->ok(0,$name);$tb->diag(_format_stack(@Data_Stack))}}return$ok}sub _format_stack {my(@Stack)=@_;my$var='$FOO';my$did_arrow=0;for my$entry (@Stack){my$type=$entry->{type}|| '';my$idx=$entry->{'idx'};if($type eq 'HASH'){$var .= "->" unless$did_arrow++;$var .= "{$idx}"}elsif($type eq 'ARRAY'){$var .= "->" unless$did_arrow++;$var .= "[$idx]"}elsif($type eq 'REF'){$var="\${$var}"}}my@vals=@{$Stack[-1]{vals}}[0,1 ];my@vars=();($vars[0]=$var)=~ s/\$FOO/     \$got/;($vars[1]=$var)=~ s/\$FOO/\$expected/;my$out="Structures begin differing at:\n";for my$idx (0 .. $#vals){my$val=$vals[$idx];$vals[$idx]=!defined$val ? 'undef' : _dne($val)? "Does not exist" : ref$val ? "$val" : "'$val'"}$out .= "$vars[0] = $vals[0]\n";$out .= "$vars[1] = $vals[1]\n";$out =~ s/^/    /msg;return$out}sub _type {my$thing=shift;return '' if!ref$thing;for my$type (qw(Regexp ARRAY HASH REF SCALAR GLOB CODE VSTRING)){return$type if UNIVERSAL::isa($thing,$type)}return ''}sub diag {return Test::More->builder->diag(@_)}sub note {return Test::More->builder->note(@_)}sub explain {return Test::More->builder->explain(@_)}sub skip {my($why,$how_many)=@_;my$tb=Test::More->builder;unless (defined$how_many){my$plan=$tb->has_plan;_carp "skip() needs to know \$how_many tests are in the block" if$plan && $plan =~ m/^\d+$/;$how_many=1}if(defined$how_many and $how_many =~ /\D/){_carp "skip() was passed a non-numeric number of tests.  Did you get the arguments backwards?";$how_many=1}for(1 .. $how_many){$tb->skip($why)}no warnings 'exiting';last SKIP}sub todo_skip {my($why,$how_many)=@_;my$tb=Test::More->builder;unless(defined$how_many){_carp "todo_skip() needs to know \$how_many tests are in the block" unless$tb->has_plan eq 'no_plan';$how_many=1}for(1 .. $how_many){$tb->todo_skip($why)}no warnings 'exiting';last TODO}sub BAIL_OUT {my$reason=shift;my$tb=Test::More->builder;$tb->BAIL_OUT($reason)}sub eq_array {local@Data_Stack=();_deep_check(@_)}sub _eq_array {my($a1,$a2)=@_;if(grep _type($_)ne 'ARRAY',$a1,$a2){warn "eq_array passed a non-array ref";return 0}return 1 if$a1 eq $a2;my$ok=1;my$max=$#$a1 > $#$a2 ? $#$a1 : $#$a2;for(0 .. $max){my$e1=$_ > $#$a1 ? $DNE : $a1->[$_];my$e2=$_ > $#$a2 ? $DNE : $a2->[$_];next if _equal_nonrefs($e1,$e2);push@Data_Stack,{type=>'ARRAY',idx=>$_,vals=>[$e1,$e2 ]};$ok=_deep_check($e1,$e2);pop@Data_Stack if$ok;last unless$ok}return$ok}sub _equal_nonrefs {my($e1,$e2)=@_;return if ref$e1 or ref$e2;if (defined$e1){return 1 if defined$e2 and $e1 eq $e2}else {return 1 if!defined$e2}return}sub _deep_check {my($e1,$e2)=@_;my$tb=Test::More->builder;my$ok=0;local%Refs_Seen=%Refs_Seen;{$tb->_unoverload_str(\$e1,\$e2);my$same_ref=!(!ref$e1 xor!ref$e2);my$not_ref=(!ref$e1 and!ref$e2);if(defined$e1 xor defined$e2){$ok=0}elsif(!defined$e1 and!defined$e2){$ok=1}elsif(_dne($e1)xor _dne($e2)){$ok=0}elsif($same_ref and($e1 eq $e2)){$ok=1}elsif($not_ref){push@Data_Stack,{type=>'',vals=>[$e1,$e2 ]};$ok=0}else {if($Refs_Seen{$e1}){return$Refs_Seen{$e1}eq $e2}else {$Refs_Seen{$e1}="$e2"}my$type=_type($e1);$type='DIFFERENT' unless _type($e2)eq $type;if($type eq 'DIFFERENT'){push@Data_Stack,{type=>$type,vals=>[$e1,$e2 ]};$ok=0}elsif($type eq 'ARRAY'){$ok=_eq_array($e1,$e2)}elsif($type eq 'HASH'){$ok=_eq_hash($e1,$e2)}elsif($type eq 'REF'){push@Data_Stack,{type=>$type,vals=>[$e1,$e2 ]};$ok=_deep_check($$e1,$$e2);pop@Data_Stack if$ok}elsif($type eq 'SCALAR'){push@Data_Stack,{type=>'REF',vals=>[$e1,$e2 ]};$ok=_deep_check($$e1,$$e2);pop@Data_Stack if$ok}elsif($type){push@Data_Stack,{type=>$type,vals=>[$e1,$e2 ]};$ok=0}else {_whoa(1,"No type in _deep_check")}}}return$ok}sub _whoa {my($check,$desc)=@_;if($check){die <<"WHOA"}}sub eq_hash {local@Data_Stack=();return _deep_check(@_)}sub _eq_hash {my($a1,$a2)=@_;if(grep _type($_)ne 'HASH',$a1,$a2){warn "eq_hash passed a non-hash ref";return 0}return 1 if$a1 eq $a2;my$ok=1;my$bigger=keys %$a1 > keys %$a2 ? $a1 : $a2;for my$k (keys %$bigger){my$e1=exists$a1->{$k}? $a1->{$k}: $DNE;my$e2=exists$a2->{$k}? $a2->{$k}: $DNE;next if _equal_nonrefs($e1,$e2);push@Data_Stack,{type=>'HASH',idx=>$k,vals=>[$e1,$e2 ]};$ok=_deep_check($e1,$e2);pop@Data_Stack if$ok;last unless$ok}return$ok}sub eq_set {my($a1,$a2)=@_;return 0 unless @$a1==@$a2;no warnings 'uninitialized';return eq_array([grep(ref,@$a1),sort(grep(!ref,@$a1))],[grep(ref,@$a2),sort(grep(!ref,@$a2))],)}1;
      Tried to use '$module'.
      Error:  $eval_error
  DIAGNOSTIC
  is_deeply() takes two or three args, you gave %d.
  This usually means you passed an array or hash instead 
  of a reference to it
  WARNING
  WHOA!  $desc
  This should never happen!  Please contact the author immediately!
  WHOA
TEST_MORE

$fatpacked{"Test/NoWarnings.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_NOWARNINGS';
  package Test::NoWarnings;use 5.006;use strict;use warnings;use Carp ();use Exporter ();use Test::Builder ();use Test::NoWarnings::Warning ();our ($VERSION,@EXPORT_OK,@ISA,$do_end_test);BEGIN {$VERSION='1.06';@ISA='Exporter';@EXPORT_OK=qw(clear_warnings had_no_warnings warnings);$do_end_test=0}my$TEST=Test::Builder->new;my$PID=$$;my@WARNINGS=();my$EARLY=0;$SIG{__WARN__}=make_catcher(\@WARNINGS);sub import {$do_end_test=1;if (grep {$_ eq ':early'}@_){@_=grep {$_ ne ':early'}@_;$EARLY=1}goto&Exporter::import}END {had_no_warnings()if$do_end_test}sub make_warning {local$SIG{__WARN__};my$msg=shift;my$warning=Test::NoWarnings::Warning->new;$warning->setMessage($msg);$warning->fillTest($TEST);$warning->fillTrace(__PACKAGE__);$Carp::Internal{__PACKAGE__.""}++;local$Carp::CarpLevel=$Carp::CarpLevel + 1;$warning->fillCarp($msg);$Carp::Internal{__PACKAGE__.""}--;return$warning}sub make_catcher {my$array=shift;return sub {my$msg=shift;$Carp::Internal{__PACKAGE__.""}++;push(@$array,make_warning($msg));$Carp::Internal{__PACKAGE__.""}--;if ($EARLY){$TEST->diag($array->[-1]->toString)}return$msg}}sub had_no_warnings {return 0 if $$!=$PID;$do_end_test=0;local$SIG{__WARN__};my$name=shift || "no warnings";my$ok;my$diag;if (@WARNINGS==0){$ok=1}else {$ok=0;$diag="There were " .scalar(@WARNINGS)." warning(s)\n";unless ($EARLY){$diag .= join "----------\n",map {$_->toString}@WARNINGS}}$TEST->ok($ok,$name)|| $TEST->diag($diag);return$ok}sub clear_warnings {local$SIG{__WARN__};@WARNINGS=()}sub warnings {local$SIG{__WARN__};return@WARNINGS}sub builder {local$SIG{__WARN__};if (@_){$TEST=shift}return$TEST}1;
TEST_NOWARNINGS

$fatpacked{"Test/NoWarnings/Warning.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_NOWARNINGS_WARNING';
  package Test::NoWarnings::Warning;use 5.006;use strict;use Carp ();our$VERSION;BEGIN {$VERSION='1.06';eval {require Devel::StackTrace}}sub new {my$class=shift;bless {@_ },$class}sub getTrace {$_[0]->{Trace}}sub fillTrace {my$self=shift;$self->{Trace}=Devel::StackTrace->new(ignore_class=>[__PACKAGE__,@_],)if$Devel::StackTrace::VERSION}sub getCarp {$_[0]->{Carp}}sub fillCarp {my$self=shift;my$msg=shift;$Carp::Internal{__PACKAGE__ ."" }++;local$Carp::CarpLevel=$Carp::CarpLevel + 1;$self->{Carp}=Carp::longmess($msg);$Carp::Internal{__PACKAGE__ ."" }--}sub getMessage {$_[0]->{Message}}sub setMessage {$_[0]->{Message}=$_[1]}sub fillTest {my$self=shift;my$builder=shift;my$prev_test=$builder->current_test;$self->{Test}=$prev_test;my@tests=$builder->details;my$prev_test_name=$prev_test ? $tests[$prev_test - 1]->{name}: "";$self->{TestName}=$prev_test_name}sub getTest {$_[0]->{Test}}sub getTestName {$_[0]->{TestName}}sub toString {my$self=shift;return <<EOM}1;
      Previous test $self->{Test} '$self->{TestName}'
      $self->{Carp}
  EOM
TEST_NOWARNINGS_WARNING

$fatpacked{"Test/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_OBJECT';
  package Test::Object;use strict;use Carp ();use Exporter ();use Test::More ();use Scalar::Util ();use Test::Object::Test ();our$VERSION='0.08';use vars qw{@ISA @EXPORT};BEGIN {@ISA='Exporter';@EXPORT='object_ok'}my@TESTS=();sub register {my$class=shift;push@TESTS,Test::Object::Test->new(@_)}sub object_ok {my$object=Scalar::Util::blessed($_[0])? shift : Carp::croak("Did not provide an object to object_ok");for my$test (@TESTS){$test->run($object)if$object->isa($test->class)}1}1;
TEST_OBJECT

$fatpacked{"Test/Object/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_OBJECT_TEST';
  package Test::Object::Test;use strict;use Carp ();use Scalar::Util ();our$VERSION='0.08';sub new {my$class=shift;my$self=bless {@_ },$class;unless (_CLASS($self->class)){Carp::croak("Did not provide a valid test class")}unless (_CODELIKE($self->code)){Carp::croak("Did not provide a valid CODE or callable object")}$self}sub class {$_[0]->{class}}sub tests {$_[0]->{tests}}sub code {$_[0]->{code}}sub run {$_[0]->code->($_[1])}sub _CLASS ($) {(defined $_[0]and!ref $_[0]and $_[0]=~ m/^[^\W\d]\w*(?:::\w+)*\z/s)? $_[0]: undef}sub _CODELIKE {(Scalar::Util::reftype($_[0])||'')eq 'CODE' or Scalar::Util::blessed($_[0])and overload::Method($_[0],'&{}')? $_[0]: undef}1;
TEST_OBJECT_TEST

$fatpacked{"Test/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_SIMPLE';
  package Test::Simple;use 5.006;use strict;our$VERSION='1.302190';use Test::Builder::Module;our@ISA=qw(Test::Builder::Module);our@EXPORT=qw(ok);my$CLASS=__PACKAGE__;sub ok ($;$) {return$CLASS->builder->ok(@_)}1;
TEST_SIMPLE

$fatpacked{"Test/SubCalls.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_SUBCALLS';
  package Test::SubCalls;use 5.006;use strict;use File::Spec 0.80 ();use Test::More 0.42 ();use Hook::LexWrap 0.20 ();use Exporter ();use Test::Builder ();our$VERSION='1.10';use vars qw{@ISA @EXPORT};BEGIN {@ISA='Exporter';@EXPORT=qw{sub_track sub_calls sub_reset sub_reset_all}}my$Test=Test::Builder->new;my%CALLS=();sub sub_track {my$subname=shift;SCOPE: {no strict 'refs';unless (defined *{"$subname"}{CODE}){die "Test::SubCalls::sub_track : The sub '$subname' does not exist"}if (defined$CALLS{$subname}){die "Test::SubCalls::sub_track : Cannot add duplicate tracker for '$subname'"}}$CALLS{$subname}=0;Hook::LexWrap::wrap($subname,pre=>sub {$CALLS{$subname}++},);1}sub sub_calls {my$subname=shift;unless (defined$CALLS{$subname}){die "Test::SubCalls::sub_calls : Cannot test untracked sub '$subname'"}my$count=shift;unless ($count =~ /^(?:0|[1-9]\d*)\z/s){die "Test::SubCalls::sub_calls : Expected count '$count' is not an integer"}my$message=shift || "$subname was called $count times";$Test->is_num($CALLS{$subname},$count,$message)}sub sub_reset {my$subname=shift;unless (defined$CALLS{$subname}){die "Test::SubCalls::sub_reset : Cannot reset untracked sub '$subname'"}$CALLS{$subname}=0;1}sub sub_reset_all {for my$subname (keys%CALLS){$CALLS{$subname}=0}1}1;
TEST_SUBCALLS

$fatpacked{"Test/Tester.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TESTER';
  use strict;package Test::Tester;BEGIN {if (*Test::Builder::new{CODE}){warn "You should load Test::Tester before Test::Builder (or anything that loads Test::Builder)"}}use Test::Builder;use Test::Tester::CaptureRunner;use Test::Tester::Delegate;require Exporter;use vars qw(@ISA @EXPORT);our$VERSION='1.302190';@EXPORT=qw(run_tests check_tests check_test cmp_results show_space);@ISA=qw(Exporter);my$Test=Test::Builder->new;my$Capture=Test::Tester::Capture->new;my$Delegator=Test::Tester::Delegate->new;$Delegator->{Object}=$Test;my$runner=Test::Tester::CaptureRunner->new;my$want_space=$ENV{TESTTESTERSPACE};sub show_space {$want_space=1}my$colour='';my$reset='';if (my$want_colour=$ENV{TESTTESTERCOLOUR}|| $ENV{TESTTESTERCOLOR}){if (eval {require Term::ANSIColor;1}){eval {require Win32::Console::ANSI}if 'MSWin32' eq $^O;my ($f,$b)=split(",",$want_colour);$colour=Term::ANSIColor::color($f).Term::ANSIColor::color("on_$b");$reset=Term::ANSIColor::color("reset")}}sub new_new {return$Delegator}sub capture {return Test::Tester::Capture->new}sub fh {$runner=Test::Tester::FHRunner->new;return$Test}sub find_run_tests {my$d=1;my$found=0;while ((not $found)and (my ($sub)=(caller($d))[3])){$found=($sub eq "Test::Tester::run_tests");$d++}return$d}sub run_tests {local($Delegator->{Object})=$Capture;$runner->run_tests(@_);return ($runner->get_premature,$runner->get_results)}sub check_test {my$test=shift;my$expect=shift;my$name=shift;$name="" unless defined($name);@_=($test,[$expect],$name);goto&check_tests}sub check_tests {my$test=shift;my$expects=shift;my$name=shift;$name="" unless defined($name);my ($prem,@results)=eval {run_tests($test,$name)};$Test->ok(!$@,"Test '$name' completed")|| $Test->diag($@);$Test->ok(!length($prem),"Test '$name' no premature diagnostication")|| $Test->diag("Before any testing anything, your tests said\n$prem");local$Test::Builder::Level=$Test::Builder::Level + 1;cmp_results(\@results,$expects,$name);return ($prem,@results)}sub cmp_field {my ($result,$expect,$field,$desc)=@_;if (defined$expect->{$field}){$Test->is_eq($result->{$field},$expect->{$field},"$desc compare $field")}}sub cmp_result {my ($result,$expect,$name)=@_;my$sub_name=$result->{name};$sub_name="" unless defined($name);my$desc="subtest '$sub_name' of '$name'";{local$Test::Builder::Level=$Test::Builder::Level + 1;cmp_field($result,$expect,"ok",$desc);cmp_field($result,$expect,"actual_ok",$desc);cmp_field($result,$expect,"type",$desc);cmp_field($result,$expect,"reason",$desc);cmp_field($result,$expect,"name",$desc)}my$depth=1;if (exists$expect->{depth}){$depth=$expect->{depth}}if (defined$depth){$Test->is_eq($result->{depth},$depth,"checking depth")|| $Test->diag('You need to change $Test::Builder::Level')}if (defined(my$exp=$expect->{diag})){my$got='';if (ref$exp eq 'Regexp'){if (not $Test->like($result->{diag},$exp,"subtest '$sub_name' of '$name' compare diag")){$got=$result->{diag}}}else {$exp .= "\n" if (length($exp)and $exp !~ /\n$/);if (not $Test->ok($result->{diag}eq $exp,"subtest '$sub_name' of '$name' compare diag")){$got=$result->{diag}}}if ($got){my$glen=length($got);my$elen=length($exp);for ($got,$exp){my@lines=split("\n",$_);$_=join("\n",map {if ($want_space){$_=$colour.escape($_).$reset}else {"'$colour$_$reset'"}}@lines)}$Test->diag(<<EOM)}}}sub escape {my$str=shift;my$res='';for my$char (split("",$str)){my$c=ord($char);if(($c>32 and $c<125)or $c==10){$res .= $char}else {$res .= sprintf('\x{%x}',$c)}}return$res}sub cmp_results {my ($results,$expects,$name)=@_;$Test->is_num(scalar @$results,scalar @$expects,"Test '$name' result count");for (my$i=0;$i < @$expects;$i++){my$expect=$expects->[$i];my$result=$results->[$i];local$Test::Builder::Level=$Test::Builder::Level + 1;cmp_result($result,$expect,$name)}}sub plan {my(@plan)=@_;my$caller=caller;$Test->exported_to($caller);my@imports=();for my$idx (0..$#plan){if($plan[$idx]eq 'import'){my($tag,$imports)=splice@plan,$idx,2;@imports=@$imports;last}}$Test->plan(@plan);__PACKAGE__->_export_to_level(1,__PACKAGE__,@imports)}sub import {my($class)=shift;{no warnings 'redefine';*Test::Builder::new=\&new_new}goto&plan}sub _export_to_level {my$pkg=shift;my$level=shift;(undef)=shift;my$callpkg=caller($level);$pkg->export($callpkg,@_)}1;
  Got diag ($glen bytes):
  $got
  Expected diag ($elen bytes):
  $exp
  EOM
TEST_TESTER

$fatpacked{"Test/Tester/Capture.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TESTER_CAPTURE';
  use strict;package Test::Tester::Capture;our$VERSION='1.302190';use Test::Builder;use vars qw(@ISA);@ISA=qw(Test::Builder);BEGIN {use Config;*share=sub {0};*lock=sub {0}}my$Curr_Test=0;share($Curr_Test);my@Test_Results=();share(@Test_Results);my$Prem_Diag={diag=>""};share($Curr_Test);sub new {my$class=shift;return bless {},$class}sub ok {my($self,$test,$name)=@_;my$ctx=$self->ctx;$test=$test ? 1 : 0;lock$Curr_Test;$Curr_Test++;my($pack,$file,$line)=$self->caller;my$todo=$self->todo();my$result={};share($result);unless($test){@$result{'ok','actual_ok' }=(($todo ? 1 : 0),0)}else {@$result{'ok','actual_ok' }=(1,$test)}if(defined$name){$name =~ s|#|\\#|g;$result->{name}=$name}else {$result->{name}=''}if($todo){my$what_todo=$todo;$result->{reason}=$what_todo;$result->{type}='todo'}else {$result->{reason}='';$result->{type}=''}$Test_Results[$Curr_Test-1]=$result;unless($test){my$msg=$todo ? "Failed (TODO)" : "Failed";$result->{fail_diag}=("	$msg test ($file at line $line)\n")}$result->{diag}="";$result->{_level}=$Test::Builder::Level;$result->{_depth}=Test::Tester::find_run_tests();$ctx->release;return$test ? 1 : 0}sub skip {my($self,$why)=@_;$why ||= '';my$ctx=$self->ctx;lock($Curr_Test);$Curr_Test++;my%result;share(%result);%result=('ok'=>1,actual_ok=>1,name=>'',type=>'skip',reason=>$why,diag=>"",_level=>$Test::Builder::Level,_depth=>Test::Tester::find_run_tests(),);$Test_Results[$Curr_Test-1]=\%result;$ctx->release;return 1}sub todo_skip {my($self,$why)=@_;$why ||= '';my$ctx=$self->ctx;lock($Curr_Test);$Curr_Test++;my%result;share(%result);%result=('ok'=>1,actual_ok=>0,name=>'',type=>'todo_skip',reason=>$why,diag=>"",_level=>$Test::Builder::Level,_depth=>Test::Tester::find_run_tests(),);$Test_Results[$Curr_Test-1]=\%result;$ctx->release;return 1}sub diag {my($self,@msgs)=@_;return unless@msgs;return if $^C;my$ctx=$self->ctx;for (@msgs){$_='undef' unless defined}push@msgs,"\n" unless$msgs[-1]=~ /\n\Z/;my$result=$Curr_Test ? $Test_Results[$Curr_Test - 1]: $Prem_Diag;$result->{diag}.= join("",@msgs);$ctx->release;return 0}sub details {return@Test_Results}sub note {}sub explain {return Test::Builder::explain(@_)}sub premature {return$Prem_Diag->{diag}}sub current_test {if (@_ > 1){die "Don't try to change the test number!"}else {return$Curr_Test}}sub reset {$Curr_Test=0;@Test_Results=();$Prem_Diag={diag=>""}}1;
TEST_TESTER_CAPTURE

$fatpacked{"Test/Tester/CaptureRunner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TESTER_CAPTURERUNNER';
  use strict;package Test::Tester::CaptureRunner;our$VERSION='1.302190';use Test::Tester::Capture;require Exporter;sub new {my$pkg=shift;my$self=bless {},$pkg;return$self}sub run_tests {my$self=shift;my$test=shift;capture()->reset;$self->{StartLevel}=$Test::Builder::Level;&$test()}sub get_results {my$self=shift;my@results=capture()->details;my$start=$self->{StartLevel};for my$res (@results){next if defined$res->{depth};my$depth=$res->{_depth}- $res->{_level}- $start - 3;$res->{depth}=$depth}return@results}sub get_premature {return capture()->premature}sub capture {return Test::Tester::Capture->new}
TEST_TESTER_CAPTURERUNNER

$fatpacked{"Test/Tester/Delegate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TESTER_DELEGATE';
  use strict;use warnings;package Test::Tester::Delegate;our$VERSION='1.302190';use Scalar::Util();use vars '$AUTOLOAD';sub new {my$pkg=shift;my$obj=shift;my$self=bless {},$pkg;return$self}sub AUTOLOAD {my ($sub)=$AUTOLOAD =~ /.*::(.*?)$/;return if$sub eq "DESTROY";my$obj=$_[0]->{Object};my$ref=$obj->can($sub);shift(@_);unshift(@_,$obj);goto &$ref}sub can {my$this=shift;my ($sub)=@_;return$this->{Object}->can($sub)if Scalar::Util::blessed($this);return$this->SUPER::can(@_)}1;
TEST_TESTER_DELEGATE

$fatpacked{"Test/use/ok.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_USE_OK';
  package Test::use::ok;use 5.005;our$VERSION='1.302190';
TEST_USE_OK

$fatpacked{"Test2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2';
  package Test2;use strict;use warnings;our$VERSION='1.302190';1;
TEST2

$fatpacked{"Test2/API.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_API';
  package Test2::API;use strict;use warnings;use Time::HiRes qw/time/;use Test2::Util qw/USE_THREADS/;BEGIN {$ENV{TEST_ACTIVE}||= 1;$ENV{TEST2_ACTIVE}=1}our$VERSION='1.302190';my$INST;my$ENDING=0;sub test2_unset_is_end {$ENDING=0}sub test2_get_is_end {$ENDING}sub test2_set_is_end {my$before=$ENDING;($ENDING)=@_ ? @_ : (1);return if$before;return unless$ENDING;return unless$INST;my$stack=$INST->stack or return;my$root=$stack->root or return;return unless$root->count;return unless $$==$INST->pid;return unless get_tid()==$INST->tid;my$trace=Test2::EventFacet::Trace->new(frame=>[__PACKAGE__,__FILE__,__LINE__,__PACKAGE__ .'::test2_set_is_end'],);my$ctx=Test2::API::Context->new(trace=>$trace,hub=>$root,);$ctx->send_ev2(control=>{phase=>'END',details=>'Transition to END phase' });1}use Test2::API::Instance(\$INST);END {test2_set_is_end();$INST->set_exit()}sub CLONE {my$init=test2_init_done();my$load=test2_load_done();return if$init && $load;require Carp;Carp::croak "Test2 must be fully loaded before you start a new thread!\n"}{no warnings;INIT {eval 'END { test2_set_is_end() }; 1' or die $@}}BEGIN {no warnings 'once';if($] ge '5.014' || $ENV{T2_CHECK_DEPTH}|| $Test2::API::DO_DEPTH_CHECK){*DO_DEPTH_CHECK=sub() {1}}else {*DO_DEPTH_CHECK=sub() {0}}}use Test2::EventFacet::Trace();use Test2::Util::Trace();use Test2::Hub::Subtest();use Test2::Hub::Interceptor();use Test2::Hub::Interceptor::Terminator();use Test2::Event::Ok();use Test2::Event::Diag();use Test2::Event::Note();use Test2::Event::Plan();use Test2::Event::Bail();use Test2::Event::Exception();use Test2::Event::Waiting();use Test2::Event::Skip();use Test2::Event::Subtest();use Carp qw/carp croak confess/;use Scalar::Util qw/blessed weaken/;use Test2::Util qw/get_tid clone_io pkg_to_file gen_uid/;our@EXPORT_OK=qw{context release context_do no_context intercept intercept_deep run_subtest test2_init_done test2_load_done test2_load test2_start_preload test2_stop_preload test2_in_preload test2_is_testing_done test2_set_is_end test2_unset_is_end test2_get_is_end test2_pid test2_tid test2_stack test2_no_wait test2_ipc_wait_enable test2_ipc_wait_disable test2_ipc_wait_enabled test2_add_uuid_via test2_add_callback_testing_done test2_add_callback_context_aquire test2_add_callback_context_acquire test2_add_callback_context_init test2_add_callback_context_release test2_add_callback_exit test2_add_callback_post_load test2_add_callback_pre_subtest test2_list_context_aquire_callbacks test2_list_context_acquire_callbacks test2_list_context_init_callbacks test2_list_context_release_callbacks test2_list_exit_callbacks test2_list_post_load_callbacks test2_list_pre_subtest_callbacks test2_ipc test2_has_ipc test2_ipc_disable test2_ipc_disabled test2_ipc_drivers test2_ipc_add_driver test2_ipc_polling test2_ipc_disable_polling test2_ipc_enable_polling test2_ipc_get_pending test2_ipc_set_pending test2_ipc_get_timeout test2_ipc_set_timeout test2_formatter test2_formatters test2_formatter_add test2_formatter_set test2_stdout test2_stderr test2_reset_io};BEGIN {require Exporter;our@ISA=qw(Exporter)}my$STACK=$INST->stack;my$CONTEXTS=$INST->contexts;my$INIT_CBS=$INST->context_init_callbacks;my$ACQUIRE_CBS=$INST->context_acquire_callbacks;my$STDOUT=clone_io(\*STDOUT);my$STDERR=clone_io(\*STDERR);sub test2_stdout {$STDOUT ||= clone_io(\*STDOUT)}sub test2_stderr {$STDERR ||= clone_io(\*STDERR)}sub test2_post_preload_reset {test2_reset_io();$INST->post_preload_reset}sub test2_reset_io {$STDOUT=clone_io(\*STDOUT);$STDERR=clone_io(\*STDERR)}sub test2_init_done {$INST->finalized}sub test2_load_done {$INST->loaded}sub test2_load {$INST->load}sub test2_start_preload {$ENV{T2_IN_PRELOAD}=1;$INST->start_preload}sub test2_stop_preload {$ENV{T2_IN_PRELOAD}=0;$INST->stop_preload}sub test2_in_preload {$INST->preload}sub test2_pid {$INST->pid}sub test2_tid {$INST->tid}sub test2_stack {$INST->stack}sub test2_ipc_wait_enable {$INST->set_no_wait(0)}sub test2_ipc_wait_disable {$INST->set_no_wait(1)}sub test2_ipc_wait_enabled {!$INST->no_wait}sub test2_is_testing_done {return 1 unless$INST;my$stack=$INST->stack or return 1;return 0 unless @$stack;my$root_hub=$stack->[0]or return 1;return 1 if$root_hub->ended;return 0}sub test2_no_wait {$INST->set_no_wait(@_)if @_;$INST->no_wait}sub test2_add_callback_testing_done {my$cb=shift;test2_add_callback_post_load(sub {my$stack=test2_stack();$stack->top;my ($hub)=Test2::API::test2_stack->all;$hub->set_active(1);$hub->follow_up($cb)});return}sub test2_add_callback_context_acquire {$INST->add_context_acquire_callback(@_)}sub test2_add_callback_context_aquire {$INST->add_context_acquire_callback(@_)}sub test2_add_callback_context_init {$INST->add_context_init_callback(@_)}sub test2_add_callback_context_release {$INST->add_context_release_callback(@_)}sub test2_add_callback_exit {$INST->add_exit_callback(@_)}sub test2_add_callback_post_load {$INST->add_post_load_callback(@_)}sub test2_add_callback_pre_subtest {$INST->add_pre_subtest_callback(@_)}sub test2_list_context_aquire_callbacks {@{$INST->context_acquire_callbacks}}sub test2_list_context_acquire_callbacks {@{$INST->context_acquire_callbacks}}sub test2_list_context_init_callbacks {@{$INST->context_init_callbacks}}sub test2_list_context_release_callbacks {@{$INST->context_release_callbacks}}sub test2_list_exit_callbacks {@{$INST->exit_callbacks}}sub test2_list_post_load_callbacks {@{$INST->post_load_callbacks}}sub test2_list_pre_subtest_callbacks {@{$INST->pre_subtest_callbacks}}sub test2_add_uuid_via {$INST->set_add_uuid_via(@_)if @_;$INST->add_uuid_via()}sub test2_ipc {$INST->ipc}sub test2_has_ipc {$INST->has_ipc}sub test2_ipc_disable {$INST->ipc_disable}sub test2_ipc_disabled {$INST->ipc_disabled}sub test2_ipc_add_driver {$INST->add_ipc_driver(@_)}sub test2_ipc_drivers {@{$INST->ipc_drivers}}sub test2_ipc_polling {$INST->ipc_polling}sub test2_ipc_enable_polling {$INST->enable_ipc_polling}sub test2_ipc_disable_polling {$INST->disable_ipc_polling}sub test2_ipc_get_pending {$INST->get_ipc_pending}sub test2_ipc_set_pending {$INST->set_ipc_pending(@_)}sub test2_ipc_set_timeout {$INST->set_ipc_timeout(@_)}sub test2_ipc_get_timeout {$INST->ipc_timeout()}sub test2_ipc_enable_shm {0}sub test2_formatter {if ($ENV{T2_FORMATTER}&& $ENV{T2_FORMATTER}=~ m/^(\+)?(.*)$/){my$formatter=$1 ? $2 : "Test2::Formatter::$2";my$file=pkg_to_file($formatter);require$file;return$formatter}return$INST->formatter}sub test2_formatters {@{$INST->formatters}}sub test2_formatter_add {$INST->add_formatter(@_)}sub test2_formatter_set {my ($formatter)=@_;croak "No formatter specified" unless$formatter;croak "Global Formatter already set" if$INST->formatter_set;$INST->set_formatter($formatter)}sub _contexts_ref {$INST->contexts}sub _context_acquire_callbacks_ref {$INST->context_acquire_callbacks}sub _context_init_callbacks_ref {$INST->context_init_callbacks}sub _context_release_callbacks_ref {$INST->context_release_callbacks}sub _add_uuid_via_ref {\($INST->{Test2::API::Instance::ADD_UUID_VIA()})}sub _set_ipc {$INST->set_ipc(@_)}sub context_do(&;@) {my$code=shift;my@args=@_;my$ctx=context(level=>1);my$want=wantarray;my@out;my$ok=eval {$want ? @out=$code->($ctx,@args): defined($want)? $out[0]=$code->($ctx,@args): $code->($ctx,@args);1};my$err=$@;$ctx->release;die$err unless$ok;return@out if$want;return$out[0]if defined$want;return}sub no_context(&;$) {my ($code,$hid)=@_;$hid ||= $STACK->top->hid;my$ctx=$CONTEXTS->{$hid};delete$CONTEXTS->{$hid};my$ok=eval {$code->();1};my$err=$@;$CONTEXTS->{$hid}=$ctx;weaken($CONTEXTS->{$hid});die$err unless$ok;return};my$UUID_VIA=_add_uuid_via_ref();sub context {my ($errno,$eval_error,$child_error,$extended_error)=(0 + $!,$@,$?,$^E);my%params=(level=>0,wrapped=>0,@_);$INST->load unless$INST->{loaded};croak "context() called, but return value is ignored" unless defined wantarray;my$stack=$params{stack}|| $STACK;my$hub=$params{hub}|| (@$stack ? $stack->[-1]: $stack->top);if (!$hub &&!exists($params{hub})&& @$stack){my$msg=Carp::longmess("Attempt to get Test2 context after testing has completed (did you attempt a testing event after done_testing?)");print STDERR$msg;$?=1;die$msg}my$hid=$hub->{hid};my$current=$CONTEXTS->{$hid};$_->(\%params)for @$ACQUIRE_CBS;map $_->(\%params),@{$hub->{_context_acquire}}if$hub->{_context_acquire};my$phase=${^GLOBAL_PHASE} || 'NA';my$end_phase=$ENDING || $phase eq 'END' || $phase eq 'DESTRUCT';my$level=1 + $params{level};my ($pkg,$file,$line,$sub,@other)=$end_phase ? caller(0): caller($level);unless ($pkg || $end_phase){confess "Could not find context at depth $level" unless$params{fudge};($pkg,$file,$line,$sub,@other)=caller(--$level)while ($level >= 0 &&!$pkg)}my$depth=$level;$depth++ while DO_DEPTH_CHECK &&!$end_phase && (!$current || $depth <= $current->{_depth}+ $params{wrapped})&& caller($depth + 1);$depth -= $params{wrapped};my$depth_ok=!DO_DEPTH_CHECK || $end_phase ||!$current || $current->{_depth}< $depth;if ($current && $params{on_release}&& $depth_ok){$current->{_on_release}||= [];push @{$current->{_on_release}}=>$params{on_release}}($!,$@,$?,$^E)=($errno,$eval_error,$child_error,$extended_error)and return bless({%$current,_is_canon=>undef,errno=>$errno,eval_error=>$eval_error,child_error=>$child_error,_is_spawn=>[$pkg,$file,$line,$sub],},'Test2::API::Context')if$current && $depth_ok;if ($current){unless (${$current->{_aborted}}){_canon_error($current,[$pkg,$file,$line,$sub,$depth])unless$current->{_is_canon};_depth_error($current,[$pkg,$file,$line,$sub,$depth])unless$depth_ok}$current->release if$current->{_is_canon};delete$CONTEXTS->{$hid}}my$trace=bless({frame=>[$pkg,$file,$line,$sub],pid=>$$,tid=>get_tid(),cid=>gen_uid(),hid=>$hid,nested=>$hub->{nested},buffered=>$hub->{buffered},full_caller=>[$pkg,$file,$line,$sub,@other],$$UUID_VIA ? (huuid=>$hub->{uuid},uuid=>${$UUID_VIA}->('context'),): (),},'Test2::EventFacet::Trace');my$aborted=0;$current=bless({_aborted=>\$aborted,stack=>$stack,hub=>$hub,trace=>$trace,_is_canon=>1,_depth=>$depth,errno=>$errno,eval_error=>$eval_error,child_error=>$child_error,$params{on_release}? (_on_release=>[$params{on_release}]): (),},'Test2::API::Context');$CONTEXTS->{$hid}=$current;weaken($CONTEXTS->{$hid});$_->($current)for @$INIT_CBS;map $_->($current),@{$hub->{_context_init}}if$hub->{_context_init};$params{on_init}->($current)if$params{on_init};($!,$@,$?,$^E)=($errno,$eval_error,$child_error,$extended_error);return$current}sub _depth_error {_existing_error(@_,<<"    EOT")}sub _canon_error {_existing_error(@_,<<"    EOT")}sub _existing_error {my ($ctx,$details,$msg)=@_;my ($pkg,$file,$line,$sub,$depth)=@$details;my$oldframe=$ctx->{trace}->frame;my$olddepth=$ctx->{_depth};my$mess=Carp::longmess();warn <<"    EOT"}sub release($;$) {$_[0]->release;return $_[1]}sub intercept(&) {my$code=shift;my$ctx=context();my$events=_intercept($code,deep=>0);$ctx->release;return$events}sub intercept_deep(&) {my$code=shift;my$ctx=context();my$events=_intercept($code,deep=>1);$ctx->release;return$events}sub _intercept {my$code=shift;my%params=@_;my$ctx=context();my$ipc;if (my$global_ipc=test2_ipc()){my$driver=blessed($global_ipc);$ipc=$driver->new}my$hub=Test2::Hub::Interceptor->new(ipc=>$ipc,no_ending=>1,);my@events;$hub->listen(sub {push@events=>$_[1]},inherit=>$params{deep});$ctx->stack->top;$ctx->stack->push($hub);my$trace=$ctx->trace;my$state={};$hub->clean_inherited(trace=>$trace,state=>$state);my ($ok,$err)=(1,undef);T2_SUBTEST_WRAPPER: {$ok=eval {$code->(hub=>$hub,context=>$ctx->snapshot);1};$err=$@;if (!$ok && $err =~ m/Label not found for "last T2_SUBTEST_WRAPPER"/ || (blessed($err)&& $err->isa('Test2::Hub::Interceptor::Terminator'))){$ok=1;$err=undef}}$hub->cull;$ctx->stack->pop($hub);$hub->restore_inherited(trace=>$trace,state=>$state);$ctx->release;die$err unless$ok;$hub->finalize($trace,1)if$ok &&!$hub->no_ending &&!$hub->ended;require Test2::API::InterceptResult;return Test2::API::InterceptResult->new_from_ref(\@events)}sub run_subtest {my ($name,$code,$params,@args)=@_;$_->($name,$code,@args)for Test2::API::test2_list_pre_subtest_callbacks();$params={buffered=>$params}unless ref$params;my$inherit_trace=delete$params->{inherit_trace};my$ctx=context();my$parent=$ctx->hub;my$buffered=$params->{buffered}|| $parent->{buffered};$ctx->note($name)unless$buffered;my$stack=$ctx->stack || $STACK;my$hub=$stack->new_hub(class=>'Test2::Hub::Subtest',%$params,buffered=>$buffered,);my@events;$hub->listen(sub {push@events=>$_[1]});if ($buffered){if (my$format=$hub->format){my$hide=$format->can('hide_buffered')? $format->hide_buffered : 1;$hub->format(undef)if$hide}}if ($inherit_trace){my$orig=$code;$code=sub {my$base_trace=$ctx->trace;my$trace=$base_trace->snapshot(nested=>1 + $base_trace->nested);my$st_ctx=Test2::API::Context->new(trace=>$trace,hub=>$hub,);$st_ctx->do_in_context($orig,@args)}}my$start_stamp=time;my ($ok,$err,$finished);T2_SUBTEST_WRAPPER: {$ok=eval {$code->(@args);1};$err=$@;if (!$ok && $err =~ m/Label not found for "last T2_SUBTEST_WRAPPER"/ || (blessed($err)&& blessed($err)eq 'Test::Builder::Exception')){$ok=undef;$err=undef}else {$finished=1}}my$stop_stamp=time;if ($params->{no_fork}){if ($$!=$ctx->trace->pid){warn$ok ? "Forked inside subtest, but subtest never finished!\n" : $err;exit 255}if (get_tid()!=$ctx->trace->tid){warn$ok ? "Started new thread inside subtest, but thread never finished!\n" : $err;exit 255}}elsif (!$parent->is_local &&!$parent->ipc){warn$ok ? "A new process or thread was started inside subtest, but IPC is not enabled!\n" : $err;exit 255}$stack->pop($hub);my$trace=$ctx->trace;my$bailed=$hub->bailed_out;if (!$finished){if ($bailed &&!$buffered){$ctx->bail($bailed->reason)}elsif ($bailed && $buffered){$ok=1}else {my$code=$hub->exit_code;$ok=!$code;$err="Subtest ended with exit code $code" if$code}}$hub->finalize($trace->snapshot(huuid=>$hub->uuid,hid=>$hub->hid,nested=>$hub->nested,buffered=>$buffered),1)if$ok &&!$hub->no_ending &&!$hub->ended;my$pass=$ok && $hub->is_passing;my$e=$ctx->build_event('Subtest',pass=>$pass,name=>$name,subtest_id=>$hub->id,subtest_uuid=>$hub->uuid,buffered=>$buffered,subevents=>\@events,start_stamp=>$start_stamp,stop_stamp=>$stop_stamp,);my$plan_ok=$hub->check_plan;$ctx->hub->send($e);$ctx->failure_diag($e)unless$e->pass;$ctx->diag("Caught exception in subtest: $err")unless$ok;$ctx->diag("Bad subtest plan, expected " .$hub->plan ." but ran " .$hub->count)if defined($plan_ok)&&!$plan_ok;$ctx->bail($bailed->reason)if$bailed && $buffered;$ctx->release;return$pass}require Test2::API::Context;1;
  context() was called to retrieve an existing context, however the existing
  context was created in a stack frame at the same, or deeper level. This usually
  means that a tool failed to release the context when it was finished.
      EOT
  context() was called to retrieve an existing context, however the existing
  context has an invalid internal state (!_canon_count). This should not normally
  happen unless something is mucking about with internals...
      EOT
  $msg
  Old context details:
     File: $oldframe->[1]
     Line: $oldframe->[2]
     Tool: $oldframe->[3]
    Depth: $olddepth
  
  New context details:
     File: $file
     Line: $line
     Tool: $sub
    Depth: $depth
  
  Trace: $mess
  
  Removing the old context and creating a new one...
      EOT
TEST2_API

$fatpacked{"Test2/API/Breakage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_API_BREAKAGE';
  package Test2::API::Breakage;use strict;use warnings;our$VERSION='1.302190';use Test2::Util qw/pkg_to_file/;our@EXPORT_OK=qw{upgrade_suggested upgrade_required known_broken};BEGIN {require Exporter;our@ISA=qw(Exporter)}sub upgrade_suggested {return ('Test::Exception'=>'0.42','Test::FITesque'=>'0.04','Test::Module::Used'=>'0.2.5','Test::Moose::More'=>'0.025',)}sub upgrade_required {return ('Test::Builder::Clutch'=>'0.07','Test::Dist::VersionSync'=>'1.1.4','Test::Modern'=>'0.012','Test::SharedFork'=>'0.34','Test::Alien'=>'0.04','Test::UseAllModules'=>'0.14','Test::More::Prefix'=>'0.005','Test2::Tools::EventDumper'=>0.000007,'Test2::Harness'=>0.000013,'Test::DBIx::Class::Schema'=>'1.0.9','Test::Clustericious::Cluster'=>'0.30',)}sub known_broken {return ('Net::BitTorrent'=>'0.052','Test::Able'=>'0.11','Test::Aggregate'=>'0.373','Test::Flatten'=>'0.11','Test::Group'=>'0.20','Test::ParallelSubtest'=>'0.05','Test::Pretty'=>'0.32','Test::Wrapper'=>'0.3.0','Log::Dispatch::Config::TestLog'=>'0.02',)}sub report {my$class=shift;my ($require)=@_;my%suggest=__PACKAGE__->upgrade_suggested();my%required=__PACKAGE__->upgrade_required();my%broken=__PACKAGE__->known_broken();my@warn;for my$mod (keys%suggest){my$file=pkg_to_file($mod);next unless$INC{$file}|| ($require && eval {require$file;1});my$want=$suggest{$mod};next if eval {$mod->VERSION($want);1};my$error=$@;chomp$error;push@warn=>" * Module '$mod' is outdated, we recommed updating above $want. error was: '$error'; INC is $INC{$file}"}for my$mod (keys%required){my$file=pkg_to_file($mod);next unless$INC{$file}|| ($require && eval {require$file;1});my$want=$required{$mod};next if eval {$mod->VERSION($want);1};push@warn=>" * Module '$mod' is outdated and known to be broken, please update to $want or higher."}for my$mod (keys%broken){my$file=pkg_to_file($mod);next unless$INC{$file}|| ($require && eval {require$file;1});my$tested=$broken{$mod};push@warn=>" * Module '$mod' is known to be broken in version $tested and below, newer versions have not been tested. You have: " .$mod->VERSION}return@warn}1;
TEST2_API_BREAKAGE

$fatpacked{"Test2/API/Context.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_API_CONTEXT';
  package Test2::API::Context;use strict;use warnings;our$VERSION='1.302190';use Carp qw/confess croak/;use Scalar::Util qw/weaken blessed/;use Test2::Util qw/get_tid try pkg_to_file get_tid/;use Test2::EventFacet::Trace();use Test2::API();my%LOADED=(map {my$pkg="Test2::Event::$_";my$file="Test2/Event/$_.pm";require$file unless$INC{$file};($pkg=>$pkg,$_=>$pkg)}qw/Ok Diag Note Plan Bail Exception Waiting Skip Subtest Pass Fail V2/);use Test2::Util::ExternalMeta qw/meta get_meta set_meta delete_meta/;use Test2::Util::HashBase qw{stack hub trace _on_release _depth _is_canon _is_spawn _aborted errno eval_error child_error thrown};my$ON_RELEASE=Test2::API::_context_release_callbacks_ref();my$CONTEXTS=Test2::API::_contexts_ref();sub init {my$self=shift;confess "The 'trace' attribute is required" unless$self->{+TRACE};confess "The 'hub' attribute is required" unless$self->{+HUB};$self->{+_DEPTH}=0 unless defined$self->{+_DEPTH};$self->{+ERRNO}=$! unless exists$self->{+ERRNO};$self->{+EVAL_ERROR}=$@ unless exists$self->{+EVAL_ERROR};$self->{+CHILD_ERROR}=$? unless exists$self->{+CHILD_ERROR}}sub snapshot {bless {%{$_[0]},_is_canon=>undef,_is_spawn=>undef,_aborted=>undef},__PACKAGE__}sub restore_error_vars {my$self=shift;($!,$@,$?)=@$self{+ERRNO,+EVAL_ERROR,+CHILD_ERROR}}sub DESTROY {return unless $_[0]->{+_IS_CANON}|| $_[0]->{+_IS_SPAWN};return if $_[0]->{+_ABORTED}&& ${$_[0]->{+_ABORTED}};my ($self)=@_;my$hub=$self->{+HUB};my$hid=$hub->{hid};{no warnings 'uninitialized';if($self->{+EVAL_ERROR}eq $@ && $hub->is_local){require Carp;my$mess=Carp::longmess("Context destroyed");my$frame=$self->{+_IS_SPAWN}|| $self->{+TRACE}->frame;warn <<"            EOT"}}return if$self->{+_IS_SPAWN};delete$CONTEXTS->{$hid};$self->{+_IS_CANON}=undef;if (my$cbk=$self->{+_ON_RELEASE}){$_->($self)for reverse @$cbk}if (my$hcbk=$hub->{_context_release}){$_->($self)for reverse @$hcbk}$_->($self)for reverse @$ON_RELEASE}sub release {my ($self)=@_;($!,$@,$?)=@$self{+ERRNO,+EVAL_ERROR,+CHILD_ERROR}and return if$self->{+THROWN};($!,$@,$?)=@$self{+ERRNO,+EVAL_ERROR,+CHILD_ERROR}and return$self->{+_IS_SPAWN}=undef if$self->{+_IS_SPAWN};croak "release() should not be called on context that is neither canon nor a child" unless$self->{+_IS_CANON};my$hub=$self->{+HUB};my$hid=$hub->{hid};croak "context thinks it is canon, but it is not" unless$CONTEXTS->{$hid}&& $CONTEXTS->{$hid}==$self;$self->{+_IS_CANON}=undef;delete$CONTEXTS->{$hid};if (my$cbk=$self->{+_ON_RELEASE}){$_->($self)for reverse @$cbk}if (my$hcbk=$hub->{_context_release}){$_->($self)for reverse @$hcbk}$_->($self)for reverse @$ON_RELEASE;($!,$@,$?)=@$self{+ERRNO,+EVAL_ERROR,+CHILD_ERROR};return}sub do_in_context {my$self=shift;my ($sub,@args)=@_;my$clone=$self->snapshot;@$clone{+ERRNO,+EVAL_ERROR,+CHILD_ERROR}=($!,$@,$?);$clone->{+TRACE}=$clone->{+TRACE}->snapshot(pid=>$$,tid=>get_tid());my$hub=$clone->{+HUB};my$hid=$hub->hid;my$old=$CONTEXTS->{$hid};$clone->{+_IS_CANON}=1;$CONTEXTS->{$hid}=$clone;weaken($CONTEXTS->{$hid});my ($ok,$err)=&try($sub,@args);my ($rok,$rerr)=try {$clone->release};delete$clone->{+_IS_CANON};if ($old){$CONTEXTS->{$hid}=$old;weaken($CONTEXTS->{$hid})}else {delete$CONTEXTS->{$hid}}die$err unless$ok;die$rerr unless$rok}sub done_testing {my$self=shift;$self->hub->finalize($self->trace,1);return}sub throw {my ($self,$msg)=@_;$self->{+THROWN}=1;${$self->{+_ABORTED}}++ if$self->{+_ABORTED};$self->release if$self->{+_IS_CANON}|| $self->{+_IS_SPAWN};$self->trace->throw($msg)}sub alert {my ($self,$msg)=@_;$self->trace->alert($msg)}sub send_ev2_and_release {my$self=shift;my$out=$self->send_ev2(@_);$self->release;return$out}sub send_ev2 {my$self=shift;my$e;{local$Carp::CarpLevel=$Carp::CarpLevel + 1;$e=Test2::Event::V2->new(trace=>$self->{+TRACE}->snapshot,@_,)}if ($self->{+_ABORTED}){my$f=$e->facet_data;${$self->{+_ABORTED}}++ if$f->{control}->{halt}|| defined($f->{control}->{terminate})|| defined($e->terminate)}$self->{+HUB}->send($e)}sub build_ev2 {my$self=shift;local$Carp::CarpLevel=$Carp::CarpLevel + 1;Test2::Event::V2->new(trace=>$self->{+TRACE}->snapshot,@_,)}sub send_event_and_release {my$self=shift;my$out=$self->send_event(@_);$self->release;return$out}sub send_event {my$self=shift;my$event=shift;my%args=@_;my$pkg=$LOADED{$event}|| $self->_parse_event($event);my$e;{local$Carp::CarpLevel=$Carp::CarpLevel + 1;$e=$pkg->new(trace=>$self->{+TRACE}->snapshot,%args,)}if ($self->{+_ABORTED}){my$f=$e->facet_data;${$self->{+_ABORTED}}++ if$f->{control}->{halt}|| defined($f->{control}->{terminate})|| defined($e->terminate)}$self->{+HUB}->send($e)}sub build_event {my$self=shift;my$event=shift;my%args=@_;my$pkg=$LOADED{$event}|| $self->_parse_event($event);local$Carp::CarpLevel=$Carp::CarpLevel + 1;$pkg->new(trace=>$self->{+TRACE}->snapshot,%args,)}sub pass {my$self=shift;my ($name)=@_;my$e=bless({trace=>bless({%{$self->{+TRACE}}},'Test2::EventFacet::Trace'),name=>$name,},"Test2::Event::Pass");$self->{+HUB}->send($e);return$e}sub pass_and_release {my$self=shift;my ($name)=@_;my$e=bless({trace=>bless({%{$self->{+TRACE}}},'Test2::EventFacet::Trace'),name=>$name,},"Test2::Event::Pass");$self->{+HUB}->send($e);$self->release;return 1}sub fail {my$self=shift;my ($name,@diag)=@_;my$e=bless({trace=>bless({%{$self->{+TRACE}}},'Test2::EventFacet::Trace'),name=>$name,},"Test2::Event::Fail");for my$msg (@diag){if (ref($msg)eq 'Test2::EventFacet::Info::Table'){$e->add_info({tag=>'DIAG',debug=>1,$msg->info_args})}else {$e->add_info({tag=>'DIAG',debug=>1,details=>$msg})}}$self->{+HUB}->send($e);return$e}sub fail_and_release {my$self=shift;my ($name,@diag)=@_;my$e=bless({trace=>bless({%{$self->{+TRACE}}},'Test2::EventFacet::Trace'),name=>$name,},"Test2::Event::Fail");for my$msg (@diag){if (ref($msg)eq 'Test2::EventFacet::Info::Table'){$e->add_info({tag=>'DIAG',debug=>1,$msg->info_args})}else {$e->add_info({tag=>'DIAG',debug=>1,details=>$msg})}}$self->{+HUB}->send($e);$self->release;return 0}sub ok {my$self=shift;my ($pass,$name,$on_fail)=@_;my$hub=$self->{+HUB};my$e=bless {trace=>bless({%{$self->{+TRACE}}},'Test2::EventFacet::Trace'),pass=>$pass,name=>$name,},'Test2::Event::Ok';$e->init;$hub->send($e);return$e if$pass;$self->failure_diag($e);if ($on_fail && @$on_fail){$self->diag($_)for @$on_fail}return$e}sub failure_diag {my$self=shift;my ($e)=@_;my$name=$e->name;my$trace=$e->trace;my$debug=$trace ? $trace->debug : "[No trace info available]";my$msg=defined($name)? qq[Failed test '$name'\n$debug.\n] : qq[Failed test $debug.\n];$self->diag($msg)}sub skip {my$self=shift;my ($name,$reason,@extra)=@_;$self->send_event('Skip',name=>$name,reason=>$reason,pass=>1,@extra,)}sub note {my$self=shift;my ($message)=@_;$self->send_event('Note',message=>$message)}sub diag {my$self=shift;my ($message)=@_;my$hub=$self->{+HUB};$self->send_event('Diag',message=>$message,)}sub plan {my ($self,$max,$directive,$reason)=@_;$self->send_event('Plan',max=>$max,directive=>$directive,reason=>$reason)}sub bail {my ($self,$reason)=@_;$self->send_event('Bail',reason=>$reason)}sub _parse_event {my$self=shift;my$event=shift;my$pkg;if ($event =~ m/^\+(.*)/){$pkg=$1}else {$pkg="Test2::Event::$event"}unless ($LOADED{$pkg}){my$file=pkg_to_file($pkg);my ($ok,$err)=try {require$file};$self->throw("Could not load event module '$pkg': $err")unless$ok;$LOADED{$pkg}=$pkg}confess "'$pkg' is not a subclass of 'Test2::Event'" unless$pkg->isa('Test2::Event');$LOADED{$event}=$pkg;return$pkg}1;
  A context appears to have been destroyed without first calling release().
  Based on \$@ it does not look like an exception was thrown (this is not always
  a reliable test)
  
  This is a problem because the global error variables (\$!, \$@, and \$?) will
  not be restored. In addition some release callbacks will not work properly from
  inside a DESTROY method.
  
  Here are the context creation details, just in case a tool forgot to call
  release():
    File: $frame->[1]
    Line: $frame->[2]
    Tool: $frame->[3]
  
  Here is a trace to the code that caused the context to be destroyed, this could
  be an exit(), a goto, or simply the end of a scope:
  $mess
  
  Cleaning up the CONTEXT stack...
              EOT
TEST2_API_CONTEXT

$fatpacked{"Test2/API/Instance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_API_INSTANCE';
  package Test2::API::Instance;use strict;use warnings;our$VERSION='1.302190';our@CARP_NOT=qw/Test2::API Test2::API::Instance Test2::IPC::Driver Test2::Formatter/;use Carp qw/confess carp/;use Scalar::Util qw/reftype/;use Test2::Util qw/get_tid USE_THREADS CAN_FORK pkg_to_file try CAN_SIGSYS/;use Test2::EventFacet::Trace();use Test2::API::Stack();use Test2::Util::HashBase qw{_pid _tid no_wait finalized loaded ipc stack formatter contexts add_uuid_via -preload ipc_disabled ipc_polling ipc_drivers ipc_timeout formatters exit_callbacks post_load_callbacks context_acquire_callbacks context_init_callbacks context_release_callbacks pre_subtest_callbacks};sub DEFAULT_IPC_TIMEOUT() {30}sub pid {$_[0]->{+_PID}}sub tid {$_[0]->{+_TID}}BEGIN {for my$finalizer (IPC,FORMATTER){my$orig=__PACKAGE__->can($finalizer);my$new=sub {my$self=shift;$self->_finalize unless$self->{+FINALIZED};$self->$orig};no strict 'refs';no warnings 'redefine';*{$finalizer}=$new}}sub has_ipc {!!$_[0]->{+IPC}}sub import {my$class=shift;return unless @_;my ($ref)=@_;$$ref=$class->new}sub init {$_[0]->reset}sub start_preload {my$self=shift;confess "preload cannot be started, Test2::API has already been initialized" if$self->{+FINALIZED}|| $self->{+LOADED};return$self->{+PRELOAD}=1}sub stop_preload {my$self=shift;return 0 unless$self->{+PRELOAD};$self->{+PRELOAD}=0;$self->post_preload_reset();return 1}sub post_preload_reset {my$self=shift;delete$self->{+_PID};delete$self->{+_TID};$self->{+ADD_UUID_VIA}=undef unless exists$self->{+ADD_UUID_VIA};$self->{+CONTEXTS}={};$self->{+FORMATTERS}=[];$self->{+FINALIZED}=undef;$self->{+IPC}=undef;$self->{+IPC_DISABLED}=$ENV{T2_NO_IPC}? 1 : 0;$self->{+IPC_TIMEOUT}=DEFAULT_IPC_TIMEOUT()unless defined$self->{+IPC_TIMEOUT};$self->{+LOADED}=0;$self->{+STACK}||= Test2::API::Stack->new}sub reset {my$self=shift;delete$self->{+_PID};delete$self->{+_TID};$self->{+ADD_UUID_VIA}=undef;$self->{+CONTEXTS}={};$self->{+IPC_DRIVERS}=[];$self->{+IPC_POLLING}=undef;$self->{+FORMATTERS}=[];$self->{+FORMATTER}=undef;$self->{+FINALIZED}=undef;$self->{+IPC}=undef;$self->{+IPC_DISABLED}=$ENV{T2_NO_IPC}? 1 : 0;$self->{+IPC_TIMEOUT}=DEFAULT_IPC_TIMEOUT()unless defined$self->{+IPC_TIMEOUT};$self->{+NO_WAIT}=0;$self->{+LOADED}=0;$self->{+EXIT_CALLBACKS}=[];$self->{+POST_LOAD_CALLBACKS}=[];$self->{+CONTEXT_ACQUIRE_CALLBACKS}=[];$self->{+CONTEXT_INIT_CALLBACKS}=[];$self->{+CONTEXT_RELEASE_CALLBACKS}=[];$self->{+PRE_SUBTEST_CALLBACKS}=[];$self->{+STACK}=Test2::API::Stack->new}sub _finalize {my$self=shift;my ($caller)=@_;$caller ||= [caller(1)];confess "Attempt to initialize Test2::API during preload" if$self->{+PRELOAD};$self->{+FINALIZED}=$caller;$self->{+_PID}=$$ unless defined$self->{+_PID};$self->{+_TID}=get_tid()unless defined$self->{+_TID};unless ($self->{+FORMATTER}){my ($formatter,$source);if ($ENV{T2_FORMATTER}){$source="set by the 'T2_FORMATTER' environment variable";if ($ENV{T2_FORMATTER}=~ m/^(\+)?(.*)$/){$formatter=$1 ? $2 : "Test2::Formatter::$2"}else {$formatter=''}}elsif (@{$self->{+FORMATTERS}}){($formatter)=@{$self->{+FORMATTERS}};$source="Most recently added"}else {$formatter='Test2::Formatter::TAP';$source='default formatter'}unless (ref($formatter)|| $formatter->can('write')){my$file=pkg_to_file($formatter);my ($ok,$err)=try {require$file};unless ($ok){my$line="* COULD NOT LOAD FORMATTER '$formatter' ($source) *";my$border='*' x length($line);die "\n\n  $border\n  $line\n  $border\n\n$err"}}$self->{+FORMATTER}=$formatter}return if$self->{+IPC_DISABLED};return unless USE_THREADS || $INC{'Test2/IPC.pm'}|| @{$self->{+IPC_DRIVERS}};$self->enable_ipc_polling;unless (@{$self->{+IPC_DRIVERS}}){my ($ok,$error)=try {require Test2::IPC::Driver::Files};die$error unless$ok;push @{$self->{+IPC_DRIVERS}}=>'Test2::IPC::Driver::Files'}for my$driver (@{$self->{+IPC_DRIVERS}}){next unless$driver->can('is_viable')&& $driver->is_viable;$self->{+IPC}=$driver->new or next;return}die "IPC has been requested, but no viable drivers were found. Aborting...\n"}sub formatter_set {$_[0]->{+FORMATTER}? 1 : 0}sub add_formatter {my$self=shift;my ($formatter)=@_;unshift @{$self->{+FORMATTERS}}=>$formatter;return unless$self->{+FINALIZED};local%Carp::Internal=%Carp::Internal;$Carp::Internal{'Test2::Formatter'}=1;carp "Formatter $formatter loaded too late to be used as the global formatter"}sub add_context_acquire_callback {my$self=shift;my ($code)=@_;my$rtype=reftype($code)|| "";confess "Context-acquire callbacks must be coderefs" unless$code && $rtype eq 'CODE';push @{$self->{+CONTEXT_ACQUIRE_CALLBACKS}}=>$code}sub add_context_init_callback {my$self=shift;my ($code)=@_;my$rtype=reftype($code)|| "";confess "Context-init callbacks must be coderefs" unless$code && $rtype eq 'CODE';push @{$self->{+CONTEXT_INIT_CALLBACKS}}=>$code}sub add_context_release_callback {my$self=shift;my ($code)=@_;my$rtype=reftype($code)|| "";confess "Context-release callbacks must be coderefs" unless$code && $rtype eq 'CODE';push @{$self->{+CONTEXT_RELEASE_CALLBACKS}}=>$code}sub add_post_load_callback {my$self=shift;my ($code)=@_;my$rtype=reftype($code)|| "";confess "Post-load callbacks must be coderefs" unless$code && $rtype eq 'CODE';push @{$self->{+POST_LOAD_CALLBACKS}}=>$code;$code->()if$self->{+LOADED}}sub add_pre_subtest_callback {my$self=shift;my ($code)=@_;my$rtype=reftype($code)|| "";confess "Pre-subtest callbacks must be coderefs" unless$code && $rtype eq 'CODE';push @{$self->{+PRE_SUBTEST_CALLBACKS}}=>$code}sub load {my$self=shift;unless ($self->{+LOADED}){confess "Attempt to initialize Test2::API during preload" if$self->{+PRELOAD};$self->{+_PID}=$$ unless defined$self->{+_PID};$self->{+_TID}=get_tid()unless defined$self->{+_TID};eval "END { Test2::API::test2_set_is_end() }; 1" or die $@;$self->{+LOADED}=1;$_->()for @{$self->{+POST_LOAD_CALLBACKS}}}return$self->{+LOADED}}sub add_exit_callback {my$self=shift;my ($code)=@_;my$rtype=reftype($code)|| "";confess "End callbacks must be coderefs" unless$code && $rtype eq 'CODE';push @{$self->{+EXIT_CALLBACKS}}=>$code}sub ipc_disable {my$self=shift;confess "Attempt to disable IPC after it has been initialized" if$self->{+IPC};$self->{+IPC_DISABLED}=1}sub add_ipc_driver {my$self=shift;my ($driver)=@_;unshift @{$self->{+IPC_DRIVERS}}=>$driver;return unless$self->{+FINALIZED};local%Carp::Internal=%Carp::Internal;$Carp::Internal{'Test2::IPC::Driver'}=1;carp "IPC driver $driver loaded too late to be used as the global ipc driver"}sub enable_ipc_polling {my$self=shift;$self->{+_PID}=$$ unless defined$self->{+_PID};$self->{+_TID}=get_tid()unless defined$self->{+_TID};$self->add_context_init_callback(sub {return unless$self->{+IPC_POLLING};return unless$self->{+IPC};return unless$self->{+IPC}->pending();return $_[0]->{hub}->cull})unless defined$self->ipc_polling;$self->set_ipc_polling(1)}sub get_ipc_pending {my$self=shift;return -1 unless$self->{+IPC};$self->{+IPC}->pending()}sub _check_pid {my$self=shift;my ($pid)=@_;return kill(0,$pid)}sub set_ipc_pending {my$self=shift;return unless$self->{+IPC};my ($val)=@_;confess "value is required for set_ipc_pending" unless$val;$self->{+IPC}->set_pending($val)}sub disable_ipc_polling {my$self=shift;return unless defined$self->{+IPC_POLLING};$self->{+IPC_POLLING}=0}sub _ipc_wait {my ($timeout)=@_;my$fail=0;$timeout=DEFAULT_IPC_TIMEOUT()unless defined$timeout;my$ok=eval {if (CAN_FORK){local$SIG{ALRM}=sub {die "Timeout waiting on child processes"};alarm$timeout;while (1){my$pid=CORE::wait();my$err=$?;last if$pid==-1;next unless$err;$fail++;my$sig=$err & 127;my$exit=$err >> 8;warn "Process $pid did not exit cleanly (wstat: $err, exit: $exit, sig: $sig)\n"}alarm 0}if (USE_THREADS){my$start=time;while (1){last unless threads->list();die "Timeout waiting on child thread" if time - $start >= $timeout;sleep 1;for my$t (threads->list){next if$t->can('is_joinable')&&!$t->is_joinable;$t->join;my$err=$t->can('error')? $t->error : undef;next unless$err;my$tid=$t->tid();$fail++;chomp($err);warn "Thread $tid did not end cleanly: $err\n"}}}1};my$error=$@;return 0 if$ok &&!$fail;warn$error unless$ok;return 255}sub set_exit {my$self=shift;return if$self->{+PRELOAD};my$exit=$?;my$new_exit=$exit;if ($INC{'Test/Builder.pm'}&& $Test::Builder::VERSION ne $Test2::API::VERSION){print STDERR <<"        EOT"}for my$ctx (values %{$self->{+CONTEXTS}}){next unless$ctx;next if$ctx->_aborted && ${$ctx->_aborted};my$trace=$ctx->trace || next;next unless$trace->pid && $trace->pid==$$;my$hub=$ctx->hub || next;next if$hub->bailed_out;next if defined$hub->skip_reason;$trace->alert("context object was never released! This means a testing tool is behaving very badly");$exit=255;$new_exit=255}if (!defined($self->{+_PID})or!defined($self->{+_TID})or $self->{+_PID}!=$$ or $self->{+_TID}!=get_tid()){$?=$exit;return}my@hubs=$self->{+STACK}? $self->{+STACK}->all : ();if (@hubs and $self->{+IPC}and!$self->{+NO_WAIT}){local $?;my%seen;for my$hub (reverse@hubs){my$ipc=$hub->ipc or next;next if$seen{$ipc}++;$ipc->waiting()}my$ipc_exit=_ipc_wait($self->{+IPC_TIMEOUT});$new_exit ||= $ipc_exit}if(my$root=shift@hubs){my$trace=Test2::EventFacet::Trace->new(frame=>[__PACKAGE__,__FILE__,0,__PACKAGE__ .'::END'],detail=>__PACKAGE__ .' END Block finalization',);my$ctx=Test2::API::Context->new(trace=>$trace,hub=>$root,);if (@hubs){$ctx->diag("Test ended with extra hubs on the stack!");$new_exit=255}unless ($root->no_ending){local $?;$root->finalize($trace)unless$root->ended;$_->($ctx,$exit,\$new_exit)for @{$self->{+EXIT_CALLBACKS}};$new_exit ||= $root->failed;$new_exit ||= 255 unless$root->is_passing}}$new_exit=255 if$new_exit > 255;if ($new_exit && eval {require Test2::API::Breakage;1}){my@warn=Test2::API::Breakage->report();if (@warn){print STDERR "\nYou have loaded versions of test modules known to have problems with Test2.\nThis could explain some test failures.\n";print STDERR "$_\n" for@warn;print STDERR "\n"}}$?=$new_exit}1;
  
  ********************************************************************************
  *                                                                              *
  *            Test::Builder -- Test2::API version mismatch detected             *
  *                                                                              *
  ********************************************************************************
     Test2::API Version: $Test2::API::VERSION
  Test::Builder Version: $Test::Builder::VERSION
  
  This is not a supported configuration, you will have problems.
  
          EOT
TEST2_API_INSTANCE

$fatpacked{"Test2/API/InterceptResult.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_API_INTERCEPTRESULT';
  package Test2::API::InterceptResult;use strict;use warnings;our$VERSION='1.302190';use Scalar::Util qw/blessed/;use Test2::Util qw/pkg_to_file/;use Storable qw/dclone/;use Carp qw/croak/;use Test2::API::InterceptResult::Squasher;use Test2::API::InterceptResult::Event;use Test2::API::InterceptResult::Hub;sub new {croak "Called a method that creates a new instance in void context" unless defined wantarray;my$class=shift;bless([@_],$class)}sub new_from_ref {croak "Called a method that creates a new instance in void context" unless defined wantarray;bless($_[1],$_[0])}sub clone {blessed($_[0])->new(@{dclone($_[0])})}sub event_list {@{$_[0]}}sub _upgrade {my$self=shift;my ($event,%params)=@_;my$blessed=blessed($event);my$upgrade_class=$params{upgrade_class}||= 'Test2::API::InterceptResult::Event';return$event if$blessed && $event->isa($upgrade_class)&&!$params{_upgrade_clone};my$fd=dclone($blessed ? $event->facet_data : $event);my$class=$params{result_class}||= blessed($self);if (my$parent=$fd->{parent}){$parent->{children}=$class->new_from_ref($parent->{children}|| [])->upgrade(%params)}my$uc_file=pkg_to_file($upgrade_class);require($uc_file)unless$INC{$uc_file};return$upgrade_class->new(facet_data=>$fd,result_class=>$class)}sub hub {my$self=shift;my$hub=Test2::API::InterceptResult::Hub->new();$hub->process($_)for @$self;$hub->set_ended(1);return$hub}sub state {my$self=shift;my%params=@_;my$hub=$self->hub;my$out={map {($_=>scalar$hub->$_)}qw/count failed is_passing plan bailed_out skip_reason/ };$out->{bailed_out}=$self->_upgrade($out->{bailed_out},%params)->bailout_reason || 1 if$out->{bailed_out};$out->{follows_plan}=$hub->check_plan;return$out}sub upgrade {my$self=shift;my%params=@_;my@out=map {$self->_upgrade($_,%params,_upgrade_clone=>1)}@$self;return blessed($self)->new_from_ref(\@out)unless$params{in_place};@$self=@out;return$self}sub squash_info {my$self=shift;my%params=@_;my@out;{my$squasher=Test2::API::InterceptResult::Squasher->new(events=>\@out);$squasher->process($self->_upgrade($_,%params)->clone)for @$self;$squasher->flush_down()}return blessed($self)->new_from_ref(\@out)unless$params{in_place};@$self=@out;return$self}sub asserts {shift->grep(has_assert=>@_)}sub subtests {shift->grep(has_subtest=>@_)}sub diags {shift->grep(has_diags=>@_)}sub notes {shift->grep(has_notes=>@_)}sub errors {shift->grep(has_errors=>@_)}sub plans {shift->grep(has_plan=>@_)}sub causes_fail {shift->grep(causes_fail=>@_)}sub causes_failure {shift->grep(causes_failure=>@_)}sub flatten {shift->map(flatten=>@_)}sub briefs {shift->map(brief=>@_)}sub summaries {shift->map(summary=>@_)}sub subtest_results {shift->map(subtest_result=>@_)}sub diag_messages {shift->map(diag_messages=>@_)}sub note_messages {shift->map(note_messages=>@_)}sub error_messages {shift->map(error_messages=>@_)}no warnings 'once';*map=sub {my$self=shift;my ($call,%params)=@_;my$args=$params{args}||= [];return [map {local $_=$self->_upgrade($_,%params);$_->$call(@$args)}@$self]};*grep=sub {my$self=shift;my ($call,%params)=@_;my$args=$params{args}||= [];my@out=grep {local $_=$self->_upgrade($_,%params);$_->$call(@$args)}@$self;return blessed($self)->new_from_ref(\@out)unless$params{in_place};@$self=@out;return$self};1;
TEST2_API_INTERCEPTRESULT

$fatpacked{"Test2/API/InterceptResult/Event.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_API_INTERCEPTRESULT_EVENT';
  package Test2::API::InterceptResult::Event;use strict;use warnings;our$VERSION='1.302190';use List::Util qw/first/;use Test2::Util qw/pkg_to_file/;use Scalar::Util qw/reftype blessed/;use Storable qw/dclone/;use Carp qw/confess croak/;use Test2::API::InterceptResult::Facet;use Test2::API::InterceptResult::Hub;use Test2::Util::HashBase qw{+causes_failure <facet_data <result_class};my%FACETS;BEGIN {local $@;local*plugins;if (eval {require Module::Pluggable;1}){Module::Pluggable->import(require=>1,on_require_error=>sub {1},search_path=>['Test2::EventFacet'],max_depth=>3,min_depth=>3,);for my$facet_type (__PACKAGE__->plugins){my ($key,$list);eval {$key=$facet_type->facet_key;$list=$facet_type->is_list};next unless$key && defined($list);$FACETS{$key}={list=>$list,class=>$facet_type,loaded=>1}}}$FACETS{__GENERIC__}={class=>'Test2::API::InterceptResult::Facet',loaded=>1}}sub facet_map {\%FACETS}sub facet_info {my$facet=pop;return$FACETS{$facet}if exists$FACETS{$facet};my$mname=ucfirst(lc($facet));$mname =~ s/s$//;for my$name ($mname,"${mname}s"){my$file="Test2/EventFacet/$name.pm";my$class="Test2::EventFacet::$name";local $@;my$ok=eval {require$file;my$key=$class->facet_key;my$list=$class->is_list;$FACETS{$key}={list=>$list,class=>$class,loaded=>1};$FACETS{$facet}=$FACETS{$key}if$facet ne $key;1};return$FACETS{$facet}if$ok && $FACETS{$facet}}return$FACETS{$facet}=$FACETS{__GENERIC__}}sub init {my$self=shift;my$rc=$self->{+RESULT_CLASS}||= 'Test2::API::InterceptResult';my$rc_file=pkg_to_file($rc);require($rc_file)unless$INC{$rc_file};my$fd=$self->{+FACET_DATA}||= {};for my$facet (keys %$fd){my$finfo=$self->facet_info($facet);my$is_list=$finfo->{list};next unless defined$is_list;my$type=reftype($fd->{$facet});if ($is_list){confess "Facet '$facet' is a list facet, but got '$type' instead of an arrayref" unless$type eq 'ARRAY';for my$item (@{$fd->{$facet}}){my$itype=reftype($item);next if$itype eq 'HASH';confess "Got item type '$itype' in list-facet '$facet', all items must be hashrefs"}}else {confess "Facet '$facet' is an only-one facet, but got '$type' instead of a hashref" unless$type eq 'HASH'}}}sub clone {my$self=shift;my$class=blessed($self);my%data=%$self;$data{+FACET_DATA}=dclone($data{+FACET_DATA});return bless(\%data,$class)}sub _facet_class {my$self=shift;my ($name)=@_;my$spec=$self->facet_info($name);my$class=$spec->{class};unless ($spec->{loaded}){my$file=pkg_to_file($class);require$file unless$INC{$file};$spec->{loaded}=1}return$class}sub the_facet {my$self=shift;my ($name)=@_;return undef unless defined$self->{+FACET_DATA}->{$name};my$data=$self->{+FACET_DATA}->{$name};my$type=reftype($data)or confess "Facet '$name' has a value that is not a reference, this should not happen";return$self->_facet_class($name)->new(%{dclone($data)})if$type eq 'HASH';if ($type eq 'ARRAY'){return undef unless @$data;croak "'the_facet' called for facet '$name', but '$name' has '" .@$data ."' items" if @$data!=1;return$self->_facet_class($name)->new(%{dclone($data->[0])})}die "Invalid facet data type: $type"}sub facet {my$self=shift;my ($name)=@_;return ()unless exists$self->{+FACET_DATA}->{$name};my$data=$self->{+FACET_DATA}->{$name};my$type=reftype($data)or confess "Facet '$name' has a value that is not a reference, this should not happen";my@out;@out=($data)if$type eq 'HASH';@out=(@$data)if$type eq 'ARRAY';my$class=$self->_facet_class($name);return map {$class->new(%{dclone($_)})}@out}sub causes_failure {my$self=shift;return$self->{+CAUSES_FAILURE}if exists$self->{+CAUSES_FAILURE};my$hub=Test2::API::InterceptResult::Hub->new();$hub->process($self);return$self->{+CAUSES_FAILURE}=($hub->is_passing ? 0 : 1)}sub causes_fail {shift->causes_failure}sub trace {$_[0]->facet('trace')}sub the_trace {$_[0]->the_facet('trace')}sub frame {my$t=$_[0]->the_trace or return undef;$t->{frame}|| undef}sub trace_details {my$t=$_[0]->the_trace or return undef;$t->{details}|| undef}sub trace_package {my$f=$_[0]->frame or return undef;$f->[0]|| undef}sub trace_file {my$f=$_[0]->frame or return undef;$f->[1]|| undef}sub trace_line {my$f=$_[0]->frame or return undef;$f->[2]|| undef}sub trace_subname {my$f=$_[0]->frame or return undef;$f->[3]|| undef}sub trace_tool {my$f=$_[0]->frame or return undef;$f->[3]|| undef}sub trace_signature {my$t=$_[0]->the_trace or return undef;Test2::EventFacet::Trace::signature($t)|| undef}sub brief {my$self=shift;my@try=qw{bailout_brief error_brief assert_brief plan_brief};for my$meth (@try){my$got=$self->$meth or next;return$got}return}sub flatten {my$self=shift;my%params=@_;my$todo={%{$self->{+FACET_DATA}}};delete$todo->{hubs};delete$todo->{meta};delete$todo->{trace};my$out=$self->summary;delete$out->{brief};delete$out->{facets};delete$out->{trace_tool};delete$out->{trace_details}unless defined($out->{trace_details});for my$tagged (grep {my$finfo=$self->facet_info($_);$finfo->{list}&& $finfo->{class}->can('tag')}keys%FACETS,keys %$todo){my$set=delete$todo->{$tagged}or next;my$fd=$self->{+FACET_DATA};my$has_assert=$self->has_assert;my$has_parent=$self->has_subtest;my$has_fatal_error=$self->has_errors && grep {$_->{fail}}$self->errors;next if$tagged eq 'amnesty' &&!($has_assert || $has_parent || $has_fatal_error);for my$item (@$set){push @{$out->{lc($item->{tag})}}=>$item->{fail}? "FATAL: $item->{details}" : $item->{details}}}if (my$assert=delete$todo->{assert}){$out->{pass}=$assert->{pass};$out->{name}=$assert->{details}}if (my$parent=delete$todo->{parent}){delete$out->{subtest}->{bailed_out}unless defined$out->{subtest}->{bailed_out};delete$out->{subtest}->{skip_reason}unless defined$out->{subtest}->{skip_reason};if (my$res=$self->subtest_result){my$state=$res->state;delete$state->{$_}for grep {!defined($state->{$_})}keys %$state;$out->{subtest}=$state;$out->{subevents}=$res->flatten(%params)if$params{include_subevents}}}if (my$control=delete$todo->{control}){if ($control->{halt}){$out->{bailed_out}=$control->{details}|| 1}elsif(defined$control->{details}){$out->{control}=$control->{details}}}if (my$plan=delete$todo->{plan}){$out->{plan}=$self->plan_brief;$out->{plan}=~ s/^PLAN\s*//}for my$other (keys %$todo){my$data=$todo->{$other}or next;if (reftype($data)eq 'ARRAY'){if (!$out->{$other}|| reftype($out->{$other})eq 'ARRAY'){for my$item (@$data){push @{$out->{$other}}=>$item->{details}if defined$item->{details}}}}else {$out->{$other}=$data->{details}if defined($data->{details})&&!defined($out->{$other})}}if (my$fields=$params{fields}){$out={map {exists($out->{$_})? ($_=>$out->{$_}): ()}@$fields }}if (my$remove=$params{remove}){delete$out->{$_}for @$remove}return$out}sub summary {my$self=shift;my%params=@_;my$out={brief=>$self->brief || '',causes_failure=>$self->causes_failure,trace_line=>$self->trace_line,trace_file=>$self->trace_file,trace_tool=>$self->trace_subname,trace_details=>$self->trace_details,facets=>[sort keys(%{$self->{+FACET_DATA}})],};if (my$fields=$params{fields}){$out={map {exists($out->{$_})? ($_=>$out->{$_}): ()}@$fields }}if (my$remove=$params{remove}){delete$out->{$_}for @$remove}return$out}sub has_assert {$_[0]->{+FACET_DATA}->{assert}? 1 : 0}sub the_assert {$_[0]->the_facet('assert')}sub assert {$_[0]->facet('assert')}sub assert_brief {my$self=shift;my$fd=$self->{+FACET_DATA};my$as=$fd->{assert}or return;my$am=$fd->{amnesty};my$out=$as->{pass}? "PASS" : "FAIL";$out .= " with amnesty" if$am;return$out}sub has_subtest {$_[0]->{+FACET_DATA}->{parent}? 1 : 0}sub the_subtest {$_[0]->the_facet('parent')}sub subtest {$_[0]->facet('parent')}sub subtest_result {my$self=shift;my$parent=$self->{+FACET_DATA}->{parent}or return;my$children=$parent->{children}|| [];$children=$self->{+RESULT_CLASS}->new(@$children)->upgrade unless blessed($children)&& $children->isa($self->{+RESULT_CLASS});return$children}sub has_bailout {$_[0]->bailout ? 1 : 0}sub the_bailout {my ($b)=$_[0]->bailout;$b}sub bailout {my$self=shift;my$control=$self->{+FACET_DATA}->{control}or return;return$control if$control->{halt};return}sub bailout_brief {my$self=shift;my$bo=$self->bailout or return;my$reason=$bo->{details}or return "BAILED OUT";return "BAILED OUT: $reason"}sub bailout_reason {my$self=shift;my$bo=$self->bailout or return;return$bo->{details}|| ''}sub has_plan {$_[0]->{+FACET_DATA}->{plan}? 1 : 0}sub the_plan {$_[0]->the_facet('plan')}sub plan {$_[0]->facet('plan')}sub plan_brief {my$self=shift;my$plan=$self->{+FACET_DATA}->{plan}or return;my$base=$self->_plan_brief($plan);my$reason=$plan->{details}or return$base;return "$base: $reason"}sub _plan_brief {my$self=shift;my ($plan)=@_;return 'NO PLAN' if$plan->{none};return "SKIP ALL" if$plan->{skip}||!$plan->{count};return "PLAN $plan->{count}"}sub has_amnesty {$_[0]->{+FACET_DATA}->{amnesty}? 1 : 0}sub the_amnesty {$_[0]->the_facet('amnesty')}sub amnesty {$_[0]->facet('amnesty')}sub amnesty_reasons {map {$_->{details}}$_[0]->amnesty}sub has_todos {&first(sub {uc($_->{tag})eq 'TODO'},$_[0]->amnesty)? 1 : 0}sub todos {grep {uc($_->{tag})eq 'TODO'}$_[0]->amnesty}sub todo_reasons {map {$_->{details}|| 'TODO'}$_[0]->todos}sub has_skips {&first(sub {uc($_->{tag})eq 'SKIP'},$_[0]->amnesty)? 1 : 0}sub skips {grep {uc($_->{tag})eq 'SKIP'}$_[0]->amnesty}sub skip_reasons {map {$_->{details}|| 'SKIP'}$_[0]->skips}my%TODO_OR_SKIP=(SKIP=>1,TODO=>1);sub has_other_amnesty {&first(sub {!$TODO_OR_SKIP{uc($_->{tag})}},$_[0]->amnesty)? 1 : 0}sub other_amnesty {grep {!$TODO_OR_SKIP{uc($_->{tag})}}$_[0]->amnesty}sub other_amnesty_reasons {map {$_->{details}|| $_->{tag}|| 'AMNESTY'}$_[0]->other_amnesty}sub has_errors {$_[0]->{+FACET_DATA}->{errors}? 1 : 0}sub the_errors {$_[0]->the_facet('errors')}sub errors {$_[0]->facet('errors')}sub error_messages {map {$_->{details}|| $_->{tag}|| 'ERROR'}$_[0]->errors}sub error_brief {my$self=shift;my$errors=$self->{+FACET_DATA}->{errors}or return;my$base=@$errors > 1 ? "ERRORS" : "ERROR";return$base unless @$errors;my ($msg,@extra)=split /[\n\r]+/,$errors->[0]->{details};my$out="$base: $msg";$out .= " [...]" if@extra || @$errors > 1;return$out}sub has_info {$_[0]->{+FACET_DATA}->{info}? 1 : 0}sub the_info {$_[0]->the_facet('info')}sub info {$_[0]->facet('info')}sub info_messages {map {$_->{details}}$_[0]->info}sub has_diags {&first(sub {uc($_->{tag})eq 'DIAG'},$_[0]->info)? 1 : 0}sub diags {grep {uc($_->{tag})eq 'DIAG'}$_[0]->info}sub diag_messages {map {$_->{details}|| 'DIAG'}$_[0]->diags}sub has_notes {&first(sub {uc($_->{tag})eq 'NOTE'},$_[0]->info)? 1 : 0}sub notes {grep {uc($_->{tag})eq 'NOTE'}$_[0]->info}sub note_messages {map {$_->{details}|| 'NOTE'}$_[0]->notes}my%NOTE_OR_DIAG=(NOTE=>1,DIAG=>1);sub has_other_info {&first(sub {!$NOTE_OR_DIAG{uc($_->{tag})}},$_[0]->info)? 1 : 0}sub other_info {grep {!$NOTE_OR_DIAG{uc($_->{tag})}}$_[0]->info}sub other_info_messages {map {$_->{details}|| $_->{tag}|| 'INFO'}$_[0]->other_info}1;
TEST2_API_INTERCEPTRESULT_EVENT

$fatpacked{"Test2/API/InterceptResult/Facet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_API_INTERCEPTRESULT_FACET';
  package Test2::API::InterceptResult::Facet;use strict;use warnings;our$VERSION='1.302190';BEGIN {require Test2::EventFacet;our@ISA=('Test2::EventFacet')}our$AUTOLOAD;sub AUTOLOAD {my$self=shift;my$name=$AUTOLOAD;$name =~ s/^.*:://g;return undef unless exists$self->{$name};return$self->{$name}}sub DESTROY {}1;
TEST2_API_INTERCEPTRESULT_FACET

$fatpacked{"Test2/API/InterceptResult/Hub.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_API_INTERCEPTRESULT_HUB';
  package Test2::API::InterceptResult::Hub;use strict;use warnings;our$VERSION='1.302190';BEGIN {require Test2::Hub;our@ISA=qw(Test2::Hub)}use Test2::Util::HashBase;sub init {my$self=shift;$self->SUPER::init();$self->{+NESTED}=0}sub inherit {my$self=shift;$self->{+NESTED}=0}sub terminate {}1;
TEST2_API_INTERCEPTRESULT_HUB

$fatpacked{"Test2/API/InterceptResult/Squasher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_API_INTERCEPTRESULT_SQUASHER';
  package Test2::API::InterceptResult::Squasher;use strict;use warnings;our$VERSION='1.302190';use Carp qw/croak/;use List::Util qw/first/;use Test2::Util::HashBase qw{<events +down_sig +down_buffer +up_into +up_sig +up_clear};sub init {my$self=shift;croak "'events' is a required attribute" unless$self->{+EVENTS}}sub can_squash {my$self=shift;my ($event)=@_;return unless$event->has_info;return if first {$event->$_}'causes_fail','has_assert','has_bailout','has_errors','has_plan','has_subtest';return$event->trace_signature}sub process {my$self=shift;my ($event)=@_;return if$self->squash_up($event);return if$self->squash_down($event);$self->flush_down($event);push @{$self->{+EVENTS}}=>$event;return}sub squash_down {my$self=shift;my ($event)=@_;my$sig=$self->can_squash($event)or return;$self->flush_down()if$self->{+DOWN_SIG}&& $self->{+DOWN_SIG}ne $sig;$self->{+DOWN_SIG}||= $sig;push @{$self->{+DOWN_BUFFER}}=>$event;return 1}sub flush_down {my$self=shift;my ($into)=@_;my$sig=delete$self->{+DOWN_SIG};my$buffer=delete$self->{+DOWN_BUFFER};return unless$buffer && @$buffer;my$fsig=$into ? $into->trace_signature : undef;if ($fsig && $fsig eq $sig){$self->squash($into,@$buffer)}else {push @{$self->{+EVENTS}}=>@$buffer if$buffer}}sub clear_up {my$self=shift;return unless$self->{+UP_CLEAR};delete$self->{+UP_INTO};delete$self->{+UP_SIG};delete$self->{+UP_CLEAR}}sub squash_up {my$self=shift;my ($event)=@_;no warnings 'uninitialized';$self->clear_up;if ($event->has_assert){if(my$sig=$event->trace_signature){$self->{+UP_INTO}=$event;$self->{+UP_SIG}=$sig;$self->{+UP_CLEAR}=0}else {$self->{+UP_CLEAR}=1;$self->clear_up}return}my$into=$self->{+UP_INTO}or return;$self->{+UP_CLEAR}=1;my$sig=$self->can_squash($event);return unless$sig eq $self->{+UP_SIG};$self->{+UP_CLEAR}=0;$self->squash($into,$event);return 1}sub squash {my$self=shift;my ($into,@from)=@_;push @{$into->facet_data->{info}}=>$_->info for@from}sub DESTROY {my$self=shift;return unless$self->{+EVENTS};$self->flush_down();return}1;
TEST2_API_INTERCEPTRESULT_SQUASHER

$fatpacked{"Test2/API/Stack.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_API_STACK';
  package Test2::API::Stack;use strict;use warnings;our$VERSION='1.302190';use Test2::Hub();use Carp qw/confess/;sub new {my$class=shift;return bless [],$class}sub new_hub {my$self=shift;my%params=@_;my$class=delete$params{class}|| 'Test2::Hub';my$hub=$class->new(%params);if (@$self){$hub->inherit($self->[-1],%params)}else {require Test2::API;$hub->format(Test2::API::test2_formatter()->new_root)unless$hub->format || exists($params{formatter});my$ipc=Test2::API::test2_ipc();if ($ipc &&!$hub->ipc &&!exists($params{ipc})){$hub->set_ipc($ipc);$ipc->add_hub($hub->hid)}}push @$self=>$hub;$hub}sub top {my$self=shift;return$self->new_hub unless @$self;return$self->[-1]}sub peek {my$self=shift;return @$self ? $self->[-1]: undef}sub cull {my$self=shift;$_->cull for reverse @$self}sub all {my$self=shift;return @$self}sub root {my$self=shift;return unless @$self;return$self->[0]}sub clear {my$self=shift;@$self=()}{no warnings 'once';*push=sub {my$self=shift;my ($hub)=@_;$hub->inherit($self->[-1])if @$self;push @$self=>$hub};*pop=sub {my$self=shift;my ($hub)=@_;confess "No hubs on the stack" unless @$self;confess "You cannot pop the root hub" if 1==@$self;confess "Hub stack mismatch, attempted to pop incorrect hub" unless$self->[-1]==$hub;pop @$self}}1;
TEST2_API_STACK

$fatpacked{"Test2/Event.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT';
  package Test2::Event;use strict;use warnings;our$VERSION='1.302190';use Scalar::Util qw/blessed reftype/;use Carp qw/croak/;use Test2::Util::HashBase qw/trace -amnesty uuid -_eid -hubs/;use Test2::Util::ExternalMeta qw/meta get_meta set_meta delete_meta/;use Test2::Util qw/pkg_to_file gen_uid/;use Test2::EventFacet::About();use Test2::EventFacet::Amnesty();use Test2::EventFacet::Assert();use Test2::EventFacet::Control();use Test2::EventFacet::Error();use Test2::EventFacet::Info();use Test2::EventFacet::Meta();use Test2::EventFacet::Parent();use Test2::EventFacet::Plan();use Test2::EventFacet::Trace();use Test2::EventFacet::Hub();require Test2::Util::Trace;my%LOADED_FACETS=('about'=>'Test2::EventFacet::About','amnesty'=>'Test2::EventFacet::Amnesty','assert'=>'Test2::EventFacet::Assert','control'=>'Test2::EventFacet::Control','errors'=>'Test2::EventFacet::Error','info'=>'Test2::EventFacet::Info','meta'=>'Test2::EventFacet::Meta','parent'=>'Test2::EventFacet::Parent','plan'=>'Test2::EventFacet::Plan','trace'=>'Test2::EventFacet::Trace','hubs'=>'Test2::EventFacet::Hub',);sub FACET_TYPES {sort values%LOADED_FACETS}sub load_facet {my$class=shift;my ($facet)=@_;return$LOADED_FACETS{$facet}if exists$LOADED_FACETS{$facet};my@check=($facet);if ('s' eq substr($facet,-1,1)){push@check=>substr($facet,0,-1)}else {push@check=>$facet .'s'}my$found;for my$check (@check){my$mod="Test2::EventFacet::" .ucfirst($facet);my$file=pkg_to_file($mod);next unless eval {require$file;1};$found=$mod;last}return undef unless$found;$LOADED_FACETS{$facet}=$found}sub causes_fail {0}sub increments_count {0}sub diagnostics {0}sub no_display {0}sub subtest_id {undef}sub callback {}sub terminate {()}sub global {()}sub sets_plan {()}sub summary {ref($_[0])}sub related {my$self=shift;my ($event)=@_;my$tracea=$self->trace or return undef;my$traceb=$event->trace or return undef;my$uuida=$tracea->uuid;my$uuidb=$traceb->uuid;if ($uuida && $uuidb){return 1 if$uuida eq $uuidb;return 0}my$siga=$tracea->signature or return undef;my$sigb=$traceb->signature or return undef;return 1 if$siga eq $sigb;return 0}sub add_hub {my$self=shift;unshift @{$self->{+HUBS}}=>@_}sub add_amnesty {my$self=shift;for my$am (@_){$am={%$am}if ref($am)ne 'ARRAY';$am=Test2::EventFacet::Amnesty->new($am);push @{$self->{+AMNESTY}}=>$am}}sub eid {$_[0]->{+_EID}||= gen_uid()}sub common_facet_data {my$self=shift;my%out;$out{about}={package=>ref($self)|| undef};if (my$uuid=$self->uuid){$out{about}->{uuid}=$uuid}$out{about}->{eid}=$self->{+_EID}|| $self->eid;if (my$trace=$self->trace){$out{trace}={%$trace }}if (my$hubs=$self->hubs){$out{hubs}=$hubs}$out{amnesty}=[map {{%{$_}}}@{$self->{+AMNESTY}}]if$self->{+AMNESTY};if (my$meta=$self->meta_facet_data){$out{meta}=$meta}return \%out}sub meta_facet_data {my$self=shift;my$key=Test2::Util::ExternalMeta::META_KEY();my$hash=$self->{$key}or return undef;return {%$hash}}sub facet_data {my$self=shift;my$out=$self->common_facet_data;$out->{about}->{details}=$self->summary || undef;$out->{about}->{no_display}=$self->no_display || undef;my$terminate=$self->terminate;$out->{control}={global=>$self->global || 0,terminate=>$terminate,has_callback=>$self->can('callback')==\&callback ? 0 : 1,};$out->{assert}={no_debug=>1,pass=>$self->causes_fail ? 0 : 1,details=>$self->summary,}if$self->increments_count;$out->{parent}={hid=>$self->subtest_id}if$self->subtest_id;if (my@plan=$self->sets_plan){$out->{plan}={};$out->{plan}->{count}=$plan[0]if defined$plan[0];$out->{plan}->{details}=$plan[2]if defined$plan[2];if ($plan[1]){$out->{plan}->{skip}=1 if$plan[1]eq 'SKIP';$out->{plan}->{none}=1 if$plan[1]eq 'NO PLAN'}$out->{control}->{terminate}||= 0 if$out->{plan}->{skip}}if ($self->causes_fail &&!$out->{assert}){$out->{errors}=[{tag=>'FAIL',fail=>1,details=>$self->summary,}]}my%IGNORE=(trace=>1,about=>1,control=>1);my$do_info=!grep {!$IGNORE{$_}}keys %$out;if ($do_info &&!$self->no_display && $self->diagnostics){$out->{info}=[{tag=>'DIAG',debug=>1,details=>$self->summary,}]}return$out}sub facets {my$self=shift;my%out;my$data=$self->facet_data;my@errors=$self->validate_facet_data($data);die join "\n"=>@errors if@errors;for my$facet (keys %$data){my$class=$self->load_facet($facet);my$val=$data->{$facet};unless($class){$out{$facet}=$val;next}my$is_list=reftype($val)eq 'ARRAY' ? 1 : 0;if ($is_list){$out{$facet}=[map {$class->new($_)}@$val]}else {$out{$facet}=$class->new($val)}}return \%out}sub validate_facet_data {my$class_or_self=shift;my ($f,%params);$f=shift if @_ && (reftype($_[0])|| '')eq 'HASH';%params=@_;$f ||= $class_or_self->facet_data if blessed($class_or_self);croak "No facet data" unless$f;my@errors;for my$k (sort keys %$f){my$fclass=$class_or_self->load_facet($k);push@errors=>"Could not find a facet class for facet '$k'" if$params{require_facet_class}&&!$fclass;next unless$fclass;my$v=$f->{$k};next unless defined($v);my$is_list=$fclass->is_list();my$got_list=reftype($v)eq 'ARRAY' ? 1 : 0;push@errors=>"Facet '$k' should be a list, but got a single item ($v)" if$is_list &&!$got_list;push@errors=>"Facet '$k' should not be a list, but got a a list ($v)" if$got_list &&!$is_list}return@errors}sub nested {my$self=shift;Carp::cluck("Use of Test2::Event->nested() is deprecated, use Test2::Event->trace->nested instead")if$ENV{AUTHOR_TESTING};if (my$hubs=$self->{+HUBS}){return$hubs->[0]->{nested}if @$hubs}my$trace=$self->{+TRACE}or return undef;return$trace->{nested}}sub in_subtest {my$self=shift;Carp::cluck("Use of Test2::Event->in_subtest() is deprecated, use Test2::Event->trace->hid instead")if$ENV{AUTHOR_TESTING};my$hubs=$self->{+HUBS};if ($hubs && @$hubs){return undef unless$hubs->[0]->{nested};return$hubs->[0]->{hid}}my$trace=$self->{+TRACE}or return undef;return undef unless$trace->{nested};return$trace->{hid}}1;
TEST2_EVENT

$fatpacked{"Test2/Event/Bail.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_BAIL';
  package Test2::Event::Bail;use strict;use warnings;our$VERSION='1.302190';BEGIN {require Test2::Event;our@ISA=qw(Test2::Event)}use Test2::Util::HashBase qw{reason buffered};sub terminate {255};sub global {1};sub causes_fail {1}sub summary {my$self=shift;return "Bail out!  " .$self->{+REASON}if$self->{+REASON};return "Bail out!"}sub diagnostics {1}sub facet_data {my$self=shift;my$out=$self->common_facet_data;$out->{control}={global=>1,halt=>1,details=>$self->{+REASON},terminate=>255,};return$out}1;
TEST2_EVENT_BAIL

$fatpacked{"Test2/Event/Diag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_DIAG';
  package Test2::Event::Diag;use strict;use warnings;our$VERSION='1.302190';BEGIN {require Test2::Event;our@ISA=qw(Test2::Event)}use Test2::Util::HashBase qw/message/;sub init {$_[0]->{+MESSAGE}='undef' unless defined $_[0]->{+MESSAGE}}sub summary {$_[0]->{+MESSAGE}}sub diagnostics {1}sub facet_data {my$self=shift;my$out=$self->common_facet_data;$out->{info}=[{tag=>'DIAG',debug=>1,details=>$self->{+MESSAGE},}];return$out}1;
TEST2_EVENT_DIAG

$fatpacked{"Test2/Event/Encoding.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_ENCODING';
  package Test2::Event::Encoding;use strict;use warnings;our$VERSION='1.302190';use Carp qw/croak/;BEGIN {require Test2::Event;our@ISA=qw(Test2::Event)}use Test2::Util::HashBase qw/encoding/;sub init {my$self=shift;defined$self->{+ENCODING}or croak "'encoding' is a required attribute"}sub summary {'Encoding set to ' .$_[0]->{+ENCODING}}sub facet_data {my$self=shift;my$out=$self->common_facet_data;$out->{control}->{encoding}=$self->{+ENCODING};$out->{about}->{details}=$self->summary;return$out}1;
TEST2_EVENT_ENCODING

$fatpacked{"Test2/Event/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_EXCEPTION';
  package Test2::Event::Exception;use strict;use warnings;our$VERSION='1.302190';BEGIN {require Test2::Event;our@ISA=qw(Test2::Event)}use Test2::Util::HashBase qw{error};sub init {my$self=shift;$self->{+ERROR}="$self->{+ERROR}"}sub causes_fail {1}sub summary {my$self=shift;chomp(my$msg="Exception: " .$self->{+ERROR});return$msg}sub diagnostics {1}sub facet_data {my$self=shift;my$out=$self->common_facet_data;$out->{errors}=[{tag=>'ERROR',fail=>1,details=>$self->{+ERROR},}];return$out}1;
TEST2_EVENT_EXCEPTION

$fatpacked{"Test2/Event/Fail.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_FAIL';
  package Test2::Event::Fail;use strict;use warnings;our$VERSION='1.302190';use Test2::EventFacet::Info;BEGIN {require Test2::Event;our@ISA=qw(Test2::Event);*META_KEY=\&Test2::Util::ExternalMeta::META_KEY}use Test2::Util::HashBase qw{-name -info};sub summary {"fail"}sub increments_count {1}sub diagnostics {0}sub no_display {0}sub subtest_id {undef}sub terminate {()}sub global {()}sub sets_plan {()}sub causes_fail {my$self=shift;return 0 if$self->{+AMNESTY}&& @{$self->{+AMNESTY}};return 1}sub add_info {my$self=shift;for my$in (@_){$in={%$in}if ref($in)ne 'ARRAY';$in=Test2::EventFacet::Info->new($in);push @{$self->{+INFO}}=>$in}}sub facet_data {my$self=shift;my$out=$self->common_facet_data;$out->{about}->{details}='fail';$out->{assert}={pass=>0,details=>$self->{+NAME}};$out->{info}=[map {{%{$_}}}@{$self->{+INFO}}]if$self->{+INFO};return$out}1;
TEST2_EVENT_FAIL

$fatpacked{"Test2/Event/Generic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_GENERIC';
  package Test2::Event::Generic;use strict;use warnings;use Carp qw/croak/;use Scalar::Util qw/reftype/;our$VERSION='1.302190';BEGIN {require Test2::Event;our@ISA=qw(Test2::Event)}use Test2::Util::HashBase;my@FIELDS=qw{causes_fail increments_count diagnostics no_display callback terminate global sets_plan summary facet_data};my%DEFAULTS=(causes_fail=>0,increments_count=>0,diagnostics=>0,no_display=>0,);sub init {my$self=shift;for my$field (@FIELDS){my$val=defined$self->{$field}? delete$self->{$field}: $DEFAULTS{$field};next unless defined$val;my$set="set_$field";$self->$set($val)}}for my$field (@FIELDS){no strict 'refs';*$field=sub {exists $_[0]->{$field}? $_[0]->{$field}: ()}unless exists &{$field};*{"set_$field"}=sub {$_[0]->{$field}=$_[1]}unless exists &{"set_$field"}}sub can {my$self=shift;my ($name)=@_;return$self->SUPER::can($name)unless$name eq 'callback';return$self->{callback}|| \&Test2::Event::callback}sub facet_data {my$self=shift;return$self->{facet_data}|| $self->SUPER::facet_data()}sub summary {my$self=shift;return$self->{summary}if defined$self->{summary};$self->SUPER::summary()}sub sets_plan {my$self=shift;return unless$self->{sets_plan};return @{$self->{sets_plan}}}sub callback {my$self=shift;my$cb=$self->{callback}|| return;$self->$cb(@_)}sub set_global {my$self=shift;my ($bool)=@_;if(!defined$bool){delete$self->{global};return undef}$self->{global}=$bool}sub set_callback {my$self=shift;my ($cb)=@_;if(!defined$cb){delete$self->{callback};return undef}croak "callback must be a code reference" unless ref($cb)&& reftype($cb)eq 'CODE';$self->{callback}=$cb}sub set_terminate {my$self=shift;my ($exit)=@_;if(!defined$exit){delete$self->{terminate};return undef}croak "terminate must be a positive integer" unless$exit =~ m/^\d+$/;$self->{terminate}=$exit}sub set_sets_plan {my$self=shift;my ($plan)=@_;if(!defined$plan){delete$self->{sets_plan};return undef}croak "'sets_plan' must be an array reference" unless ref($plan)&& reftype($plan)eq 'ARRAY';$self->{sets_plan}=$plan}1;
TEST2_EVENT_GENERIC

$fatpacked{"Test2/Event/Note.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_NOTE';
  package Test2::Event::Note;use strict;use warnings;our$VERSION='1.302190';BEGIN {require Test2::Event;our@ISA=qw(Test2::Event)}use Test2::Util::HashBase qw/message/;sub init {$_[0]->{+MESSAGE}='undef' unless defined $_[0]->{+MESSAGE}}sub summary {$_[0]->{+MESSAGE}}sub facet_data {my$self=shift;my$out=$self->common_facet_data;$out->{info}=[{tag=>'NOTE',debug=>0,details=>$self->{+MESSAGE},}];return$out}1;
TEST2_EVENT_NOTE

$fatpacked{"Test2/Event/Ok.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_OK';
  package Test2::Event::Ok;use strict;use warnings;our$VERSION='1.302190';BEGIN {require Test2::Event;our@ISA=qw(Test2::Event)}use Test2::Util::HashBase qw{pass effective_pass name todo};sub init {my$self=shift;$self->{+PASS}=$self->{+PASS}? 1 : 0;$self->{+EFFECTIVE_PASS}=$self->{+PASS}|| (defined($self->{+TODO})? 1 : 0)}{no warnings 'redefine';sub set_todo {my$self=shift;my ($todo)=@_;$self->{+TODO}=$todo;$self->{+EFFECTIVE_PASS}=defined($todo)? 1 : $self->{+PASS}}}sub increments_count {1};sub causes_fail {!$_[0]->{+EFFECTIVE_PASS}}sub summary {my$self=shift;my$name=$self->{+NAME}|| "Nameless Assertion";my$todo=$self->{+TODO};if ($todo){$name .= " (TODO: $todo)"}elsif (defined$todo){$name .= " (TODO)"}return$name}sub extra_amnesty {my$self=shift;return unless defined($self->{+TODO})|| ($self->{+EFFECTIVE_PASS}&&!$self->{+PASS});return {tag=>'TODO',details=>$self->{+TODO},}}sub facet_data {my$self=shift;my$out=$self->common_facet_data;$out->{assert}={no_debug=>1,pass=>$self->{+PASS},details=>$self->{+NAME},};if (my@exra_amnesty=$self->extra_amnesty){my%seen;$out->{amnesty}=[grep {!$seen{defined($_->{tag})? $_->{tag}: ''}->{defined($_->{details})? $_->{details}: ''}++}@exra_amnesty,@{$out->{amnesty}},]}return$out}1;
TEST2_EVENT_OK

$fatpacked{"Test2/Event/Pass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_PASS';
  package Test2::Event::Pass;use strict;use warnings;our$VERSION='1.302190';use Test2::EventFacet::Info;BEGIN {require Test2::Event;our@ISA=qw(Test2::Event);*META_KEY=\&Test2::Util::ExternalMeta::META_KEY}use Test2::Util::HashBase qw{-name -info};sub summary {"pass"}sub increments_count {1}sub causes_fail {0}sub diagnostics {0}sub no_display {0}sub subtest_id {undef}sub terminate {()}sub global {()}sub sets_plan {()}sub add_info {my$self=shift;for my$in (@_){$in={%$in}if ref($in)ne 'ARRAY';$in=Test2::EventFacet::Info->new($in);push @{$self->{+INFO}}=>$in}}sub facet_data {my$self=shift;my$out=$self->common_facet_data;$out->{about}->{details}='pass';$out->{assert}={pass=>1,details=>$self->{+NAME}};$out->{info}=[map {{%{$_}}}@{$self->{+INFO}}]if$self->{+INFO};return$out}1;
TEST2_EVENT_PASS

$fatpacked{"Test2/Event/Plan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_PLAN';
  package Test2::Event::Plan;use strict;use warnings;our$VERSION='1.302190';BEGIN {require Test2::Event;our@ISA=qw(Test2::Event)}use Test2::Util::HashBase qw{max directive reason};use Carp qw/confess/;my%ALLOWED=('SKIP'=>1,'NO PLAN'=>1,);sub init {if ($_[0]->{+DIRECTIVE}){$_[0]->{+DIRECTIVE}='SKIP' if $_[0]->{+DIRECTIVE}eq 'skip_all';$_[0]->{+DIRECTIVE}='NO PLAN' if $_[0]->{+DIRECTIVE}eq 'no_plan';confess "'" .$_[0]->{+DIRECTIVE}."' is not a valid plan directive" unless$ALLOWED{$_[0]->{+DIRECTIVE}}}else {confess "Cannot have a reason without a directive!" if defined $_[0]->{+REASON};confess "No number of tests specified" unless defined $_[0]->{+MAX};confess "Plan test count '" .$_[0]->{+MAX}."' does not appear to be a valid positive integer" unless $_[0]->{+MAX}=~ m/^\d+$/;$_[0]->{+DIRECTIVE}=''}}sub sets_plan {my$self=shift;return ($self->{+MAX},$self->{+DIRECTIVE},$self->{+REASON},)}sub terminate {my$self=shift;return 0 if$self->{+DIRECTIVE}&& $self->{+DIRECTIVE}eq 'SKIP';return undef}sub summary {my$self=shift;my$max=$self->{+MAX};my$directive=$self->{+DIRECTIVE};my$reason=$self->{+REASON};return "Plan is $max assertions" if$max ||!$directive;return "Plan is '$directive', $reason" if$reason;return "Plan is '$directive'"}sub facet_data {my$self=shift;my$out=$self->common_facet_data;$out->{control}->{terminate}=$self->{+DIRECTIVE}eq 'SKIP' ? 0 : undef unless defined$out->{control}->{terminate};$out->{plan}={count=>$self->{+MAX}};$out->{plan}->{details}=$self->{+REASON}if defined$self->{+REASON};if (my$dir=$self->{+DIRECTIVE}){$out->{plan}->{skip}=1 if$dir eq 'SKIP';$out->{plan}->{none}=1 if$dir eq 'NO PLAN'}return$out}1;
TEST2_EVENT_PLAN

$fatpacked{"Test2/Event/Skip.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_SKIP';
  package Test2::Event::Skip;use strict;use warnings;our$VERSION='1.302190';BEGIN {require Test2::Event::Ok;our@ISA=qw(Test2::Event::Ok)}use Test2::Util::HashBase qw{reason};sub init {my$self=shift;$self->SUPER::init;$self->{+EFFECTIVE_PASS}=1}sub causes_fail {0}sub summary {my$self=shift;my$out=$self->SUPER::summary(@_);if (my$reason=$self->reason){$out .= " (SKIP: $reason)"}else {$out .= " (SKIP)"}return$out}sub extra_amnesty {my$self=shift;my@out;push@out=>{tag=>'TODO',details=>$self->{+TODO},}if defined$self->{+TODO};push@out=>{tag=>'skip',details=>$self->{+REASON},inherited=>0,};return@out}1;
TEST2_EVENT_SKIP

$fatpacked{"Test2/Event/Subtest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_SUBTEST';
  package Test2::Event::Subtest;use strict;use warnings;our$VERSION='1.302190';BEGIN {require Test2::Event::Ok;our@ISA=qw(Test2::Event::Ok)}use Test2::Util::HashBase qw{subevents buffered subtest_id subtest_uuid start_stamp stop_stamp};sub init {my$self=shift;$self->SUPER::init();$self->{+SUBEVENTS}||= [];if ($self->{+EFFECTIVE_PASS}){$_->set_effective_pass(1)for grep {$_->can('effective_pass')}@{$self->{+SUBEVENTS}}}}{no warnings 'redefine';sub set_subevents {my$self=shift;my@subevents=@_;if ($self->{+EFFECTIVE_PASS}){$_->set_effective_pass(1)for grep {$_->can('effective_pass')}@subevents}$self->{+SUBEVENTS}=\@subevents}sub set_effective_pass {my$self=shift;my ($pass)=@_;if ($pass){$_->set_effective_pass(1)for grep {$_->can('effective_pass')}@{$self->{+SUBEVENTS}}}elsif ($self->{+EFFECTIVE_PASS}&&!$pass){for my$s (grep {$_->can('effective_pass')}@{$self->{+SUBEVENTS}}){$_->set_effective_pass(0)unless$s->can('todo')&& defined$s->todo}}$self->{+EFFECTIVE_PASS}=$pass}}sub summary {my$self=shift;my$name=$self->{+NAME}|| "Nameless Subtest";my$todo=$self->{+TODO};if ($todo){$name .= " (TODO: $todo)"}elsif (defined$todo){$name .= " (TODO)"}return$name}sub facet_data {my$self=shift;my$out=$self->SUPER::facet_data();my$start=$self->start_stamp;my$stop=$self->stop_stamp;$out->{parent}={hid=>$self->subtest_id,children=>[map {$_->facet_data}@{$self->{+SUBEVENTS}}],buffered=>$self->{+BUFFERED},$start ? (start_stamp=>$start): (),$stop ? (stop_stamp=>$stop): (),};return$out}sub add_amnesty {my$self=shift;for my$am (@_){$am={%$am}if ref($am)ne 'ARRAY';$am=Test2::EventFacet::Amnesty->new($am);push @{$self->{+AMNESTY}}=>$am;for my$e (@{$self->{+SUBEVENTS}}){$e->add_amnesty($am->clone(inherited=>1))}}}1;
TEST2_EVENT_SUBTEST

$fatpacked{"Test2/Event/TAP/Version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_TAP_VERSION';
  package Test2::Event::TAP::Version;use strict;use warnings;our$VERSION='1.302190';use Carp qw/croak/;BEGIN {require Test2::Event;our@ISA=qw(Test2::Event)}use Test2::Util::HashBase qw/version/;sub init {my$self=shift;defined$self->{+VERSION}or croak "'version' is a required attribute"}sub summary {'TAP version ' .$_[0]->{+VERSION}}sub facet_data {my$self=shift;my$out=$self->common_facet_data;$out->{about}->{details}=$self->summary;push @{$out->{info}}=>{tag=>'INFO',debug=>0,details=>$self->summary,};return$out}1;
TEST2_EVENT_TAP_VERSION

$fatpacked{"Test2/Event/V2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_V2';
  package Test2::Event::V2;use strict;use warnings;our$VERSION='1.302190';use Scalar::Util qw/reftype/;use Carp qw/croak/;BEGIN {require Test2::Event;our@ISA=qw(Test2::Event)}use Test2::Util::Facets2Legacy qw{causes_fail diagnostics global increments_count no_display sets_plan subtest_id summary terminate};use Test2::Util::HashBase qw/-about/;sub non_facet_keys {return (+UUID,Test2::Util::ExternalMeta::META_KEY(),)}sub init {my$self=shift;my$uuid;if ($uuid=$self->{+UUID}){croak "uuid '$uuid' passed to constructor, but uuid '$self->{+ABOUT}->{uuid}' is already set in the 'about' facet" if$self->{+ABOUT}->{uuid}&& $self->{+ABOUT}->{uuid}ne $uuid;$self->{+ABOUT}->{uuid}=$uuid}elsif ($self->{+ABOUT}&& $self->{+ABOUT}->{uuid}){$uuid=$self->{+ABOUT}->{uuid};$self->SUPER::set_uuid($uuid)}if (my$trace=$self->{+TRACE}){$self->{+TRACE}=Test2::EventFacet::Trace->new(%$trace)}}sub set_uuid {my$self=shift;my ($uuid)=@_;$self->{+ABOUT}->{uuid}=$uuid;$self->SUPER::set_uuid($uuid)}sub facet_data {my$self=shift;my$f={%{$self}};delete$f->{$_}for$self->non_facet_keys;my%out;for my$k (keys %$f){next if substr($k,0,1)eq '_';my$data=$f->{$k}or next;my$is_list='ARRAY' eq (reftype($data)|| '');$out{$k}=$is_list ? [map {{%{$_}}}@$data ]: {%$data}}if (my$meta=$self->meta_facet_data){$out{meta}={%$meta,%{$out{meta}|| {}}}}return \%out}1;
TEST2_EVENT_V2

$fatpacked{"Test2/Event/Waiting.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_WAITING';
  package Test2::Event::Waiting;use strict;use warnings;our$VERSION='1.302190';BEGIN {require Test2::Event;our@ISA=qw(Test2::Event)}use Test2::Util::HashBase;sub global {1};sub summary {"IPC is waiting for children to finish..."}sub facet_data {my$self=shift;my$out=$self->common_facet_data;push @{$out->{info}}=>{tag=>'INFO',debug=>0,details=>$self->summary,};return$out}1;
TEST2_EVENT_WAITING

$fatpacked{"Test2/EventFacet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET';
  package Test2::EventFacet;use strict;use warnings;our$VERSION='1.302190';use Test2::Util::HashBase qw/-details/;use Carp qw/croak/;my$SUBLEN=length(__PACKAGE__ .'::');sub facet_key {my$key=ref($_[0])|| $_[0];substr($key,0,$SUBLEN,'');return lc($key)}sub is_list {0}sub clone {my$self=shift;my$type=ref($self);return bless {%$self,@_},$type}1;
TEST2_EVENTFACET

$fatpacked{"Test2/EventFacet/About.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_ABOUT';
  package Test2::EventFacet::About;use strict;use warnings;our$VERSION='1.302190';BEGIN {require Test2::EventFacet;our@ISA=qw(Test2::EventFacet)}use Test2::Util::HashBase qw{-package -no_display -uuid -eid};1;
TEST2_EVENTFACET_ABOUT

$fatpacked{"Test2/EventFacet/Amnesty.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_AMNESTY';
  package Test2::EventFacet::Amnesty;use strict;use warnings;our$VERSION='1.302190';sub is_list {1}BEGIN {require Test2::EventFacet;our@ISA=qw(Test2::EventFacet)}use Test2::Util::HashBase qw{-tag -inherited};1;
TEST2_EVENTFACET_AMNESTY

$fatpacked{"Test2/EventFacet/Assert.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_ASSERT';
  package Test2::EventFacet::Assert;use strict;use warnings;our$VERSION='1.302190';BEGIN {require Test2::EventFacet;our@ISA=qw(Test2::EventFacet)}use Test2::Util::HashBase qw{-pass -no_debug -number};1;
TEST2_EVENTFACET_ASSERT

$fatpacked{"Test2/EventFacet/Control.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_CONTROL';
  package Test2::EventFacet::Control;use strict;use warnings;our$VERSION='1.302190';BEGIN {require Test2::EventFacet;our@ISA=qw(Test2::EventFacet)}use Test2::Util::HashBase qw{-global -terminate -halt -has_callback -encoding -phase};1;
TEST2_EVENTFACET_CONTROL

$fatpacked{"Test2/EventFacet/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_ERROR';
  package Test2::EventFacet::Error;use strict;use warnings;our$VERSION='1.302190';sub facet_key {'errors'}sub is_list {1}BEGIN {require Test2::EventFacet;our@ISA=qw(Test2::EventFacet)}use Test2::Util::HashBase qw{-tag -fail};1;
TEST2_EVENTFACET_ERROR

$fatpacked{"Test2/EventFacet/Hub.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_HUB';
  package Test2::EventFacet::Hub;use strict;use warnings;our$VERSION='1.302190';sub is_list {1}sub facet_key {'hubs'}BEGIN {require Test2::EventFacet;our@ISA=qw(Test2::EventFacet)}use Test2::Util::HashBase qw{-pid -tid -hid -nested -buffered -uuid -ipc};1;
TEST2_EVENTFACET_HUB

$fatpacked{"Test2/EventFacet/Info.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_INFO';
  package Test2::EventFacet::Info;use strict;use warnings;our$VERSION='1.302190';sub is_list {1}BEGIN {require Test2::EventFacet;our@ISA=qw(Test2::EventFacet)}use Test2::Util::HashBase qw{-tag -debug -important -table};1;
TEST2_EVENTFACET_INFO

$fatpacked{"Test2/EventFacet/Info/Table.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_INFO_TABLE';
  package Test2::EventFacet::Info::Table;use strict;use warnings;our$VERSION='1.302190';use Carp qw/confess/;use Test2::Util::HashBase qw{-header -rows -collapse -no_collapse -as_string};sub init {my$self=shift;confess "Table may not be empty" unless ref($self->{+ROWS})eq 'ARRAY' && @{$self->{+ROWS}};$self->{+AS_STRING}||= '<TABLE NOT DISPLAYED>'}sub as_hash {my$out=+{%{$_[0]}};delete$out->{as_string};$out}sub info_args {my$self=shift;my$hash=$self->as_hash;my$desc=$self->as_string;return (table=>$hash,details=>$desc)}1;
TEST2_EVENTFACET_INFO_TABLE

$fatpacked{"Test2/EventFacet/Meta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_META';
  package Test2::EventFacet::Meta;use strict;use warnings;our$VERSION='1.302190';BEGIN {require Test2::EventFacet;our@ISA=qw(Test2::EventFacet)}use vars qw/$AUTOLOAD/;{no warnings 'redefine';sub set_details {$_[0]->{'set_details'}}}sub can {my$self=shift;my ($name)=@_;my$existing=$self->SUPER::can($name);return$existing if$existing;return undef unless ref($self);my$sub=sub {$_[0]->{$name}};{no strict 'refs';*$name=$sub}return$sub}sub AUTOLOAD {my$name=$AUTOLOAD;$name =~ s/^.*:://g;my$sub=$_[0]->can($name);goto &$sub}1;
TEST2_EVENTFACET_META

$fatpacked{"Test2/EventFacet/Parent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_PARENT';
  package Test2::EventFacet::Parent;use strict;use warnings;our$VERSION='1.302190';use Carp qw/confess/;BEGIN {require Test2::EventFacet;our@ISA=qw(Test2::EventFacet)}use Test2::Util::HashBase qw{-hid -children -buffered -start_stamp -stop_stamp};sub init {confess "Attribute 'hid' must be set" unless defined $_[0]->{+HID};$_[0]->{+CHILDREN}||= []}1;
TEST2_EVENTFACET_PARENT

$fatpacked{"Test2/EventFacet/Plan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_PLAN';
  package Test2::EventFacet::Plan;use strict;use warnings;our$VERSION='1.302190';BEGIN {require Test2::EventFacet;our@ISA=qw(Test2::EventFacet)}use Test2::Util::HashBase qw{-count -skip -none};1;
TEST2_EVENTFACET_PLAN

$fatpacked{"Test2/EventFacet/Render.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_RENDER';
  package Test2::EventFacet::Render;use strict;use warnings;our$VERSION='1.302190';sub is_list {1}BEGIN {require Test2::EventFacet;our@ISA=qw(Test2::EventFacet)}use Test2::Util::HashBase qw{-tag -facet -mode};1;
TEST2_EVENTFACET_RENDER

$fatpacked{"Test2/EventFacet/Trace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_TRACE';
  package Test2::EventFacet::Trace;use strict;use warnings;our$VERSION='1.302190';BEGIN {require Test2::EventFacet;our@ISA=qw(Test2::EventFacet)}use Test2::Util qw/get_tid pkg_to_file gen_uid/;use Carp qw/confess/;use Test2::Util::HashBase qw{^frame ^pid ^tid ^cid -hid -nested details -buffered -uuid -huuid <full_caller};{no warnings 'once';*DETAIL=\&DETAILS;*detail=\&details;*set_detail=\&set_details}sub init {confess "The 'frame' attribute is required" unless $_[0]->{+FRAME};$_[0]->{+DETAILS}=delete $_[0]->{detail}if $_[0]->{detail};unless (defined($_[0]->{+PID})|| defined($_[0]->{+TID})|| defined($_[0]->{+CID})){$_[0]->{+PID}=$$ unless defined $_[0]->{+PID};$_[0]->{+TID}=get_tid()unless defined $_[0]->{+TID}}}sub snapshot {my ($orig,@override)=@_;bless {%$orig,@override},__PACKAGE__}sub signature {my$self=shift;return join ':'=>map {(defined($_)&& length($_))? $_ : return undef}($self->{+CID},$self->{+PID},$self->{+TID},$self->{+FRAME}->[1],$self->{+FRAME}->[2],)}sub debug {my$self=shift;return$self->{+DETAILS}if$self->{+DETAILS};my ($pkg,$file,$line)=$self->call;return "at $file line $line"}sub alert {my$self=shift;my ($msg)=@_;warn$msg .' ' .$self->debug .".\n"}sub throw {my$self=shift;my ($msg)=@_;die$msg .' ' .$self->debug .".\n"}sub call {@{$_[0]->{+FRAME}}}sub full_call {@{$_[0]->{+FULL_CALLER}}}sub package {$_[0]->{+FRAME}->[0]}sub file {$_[0]->{+FRAME}->[1]}sub line {$_[0]->{+FRAME}->[2]}sub subname {$_[0]->{+FRAME}->[3]}sub warning_bits {$_[0]->{+FULL_CALLER}? $_[0]->{+FULL_CALLER}->[9]: undef}1;
TEST2_EVENTFACET_TRACE

$fatpacked{"Test2/Formatter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_FORMATTER';
  package Test2::Formatter;use strict;use warnings;our$VERSION='1.302190';my%ADDED;sub import {my$class=shift;return if$class eq __PACKAGE__;return if$ADDED{$class}++;require Test2::API;Test2::API::test2_formatter_add($class)}sub new_root {my$class=shift;return$class->new(@_)}sub supports_tables {0}sub hide_buffered {1}sub terminate {}sub finalize {}1;
TEST2_FORMATTER

$fatpacked{"Test2/Formatter/TAP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_FORMATTER_TAP';
  package Test2::Formatter::TAP;use strict;use warnings;our$VERSION='1.302190';use Test2::Util qw/clone_io/;use Test2::Util::HashBase qw{no_numbers handles _encoding _last_fh -made_assertion};sub OUT_STD() {0}sub OUT_ERR() {1}BEGIN {require Test2::Formatter;our@ISA=qw(Test2::Formatter)}my$supports_tables;sub supports_tables {if (!defined$supports_tables){local$SIG{__DIE__}='DEFAULT';local $@;$supports_tables =($INC{'Term/Table.pm'}&& $INC{'Term/Table/Util.pm'})|| eval {require Term::Table;require Term::Table::Util;1}|| 0}return$supports_tables}sub _autoflush {my($fh)=pop;my$old_fh=select$fh;$|=1;select$old_fh}_autoflush(\*STDOUT);_autoflush(\*STDERR);sub hide_buffered {1}sub init {my$self=shift;$self->{+HANDLES}||= $self->_open_handles;if(my$enc=delete$self->{encoding}){$self->encoding($enc)}}sub _open_handles {my$self=shift;require Test2::API;my$out=clone_io(Test2::API::test2_stdout());my$err=clone_io(Test2::API::test2_stderr());_autoflush($out);_autoflush($err);return [$out,$err]}sub encoding {my$self=shift;if ($] ge "5.007003" and @_){my ($enc)=@_;my$handles=$self->{+HANDLES};if ($enc =~ m/^utf-?8$/i){binmode($_,":utf8")for @$handles}else {binmode($_,":encoding($enc)")for @$handles}$self->{+_ENCODING}=$enc}return$self->{+_ENCODING}}if ($^C){no warnings 'redefine';*write=sub {}}sub write {my ($self,$e,$num,$f)=@_;return if$self->print_optimal_pass($e,$num);$f ||= $e->facet_data;$self->encoding($f->{control}->{encoding})if$f->{control}->{encoding};my@tap=$self->event_tap($f,$num)or return;$self->{+MADE_ASSERTION}=1 if$f->{assert};my$nesting=$f->{trace}->{nested}|| 0;my$handles=$self->{+HANDLES};my$indent='    ' x $nesting;local($\,$,)=(undef,'')if $\ || $,;for my$set (@tap){no warnings 'uninitialized';my ($hid,$msg)=@$set;next unless$msg;my$io=$handles->[$hid]or next;print$io "\n" if$ENV{HARNESS_ACTIVE}&& $hid==OUT_ERR && $self->{+_LAST_FH}!=$io && $msg =~ m/^#\s*Failed( \(TODO\))? test /;$msg =~ s/^/$indent/mg if$nesting;print$io $msg;$self->{+_LAST_FH}=$io}}sub print_optimal_pass {my ($self,$e,$num)=@_;my$type=ref($e);return unless$type eq 'Test2::Event::Pass' || ($type eq 'Test2::Event::Ok' && $e->{pass});return if ($e->{amnesty}&& @{$e->{amnesty}})|| defined($e->{todo});return if defined($e->{name})&& (-1!=index($e->{name},"\n")|| -1!=index($e->{name},'#'));my$ok='ok';$ok .= " $num" if$num &&!$self->{+NO_NUMBERS};$ok .= defined($e->{name})? " - $e->{name}\n" : "\n";if (my$nesting=$e->{trace}->{nested}){my$indent='    ' x $nesting;$ok="$indent$ok"}my$io=$self->{+HANDLES}->[OUT_STD];local($\,$,)=(undef,'')if $\ || $,;print$io $ok;$self->{+_LAST_FH}=$io;return 1}sub event_tap {my ($self,$f,$num)=@_;my@tap;push@tap=>$self->plan_tap($f)if$f->{plan}&&!$self->{+MADE_ASSERTION};if ($f->{assert}){push@tap=>$self->assert_tap($f,$num);push@tap=>$self->debug_tap($f,$num)unless$f->{assert}->{no_debug}|| $f->{assert}->{pass}}push@tap=>$self->error_tap($f)if$f->{errors};push@tap=>$self->info_tap($f)if$f->{info};push@tap=>$self->plan_tap($f)if$self->{+MADE_ASSERTION}&& $f->{plan};push@tap=>$self->halt_tap($f)if$f->{control}->{halt};return@tap if@tap;return@tap if$f->{control}->{halt};return@tap if grep {$f->{$_}}qw/assert plan info errors/;return$self->summary_tap($f,$num)}sub error_tap {my$self=shift;my ($f)=@_;my$IO=($f->{amnesty}&& @{$f->{amnesty}})? OUT_STD : OUT_ERR;return map {my$details=$_->{details};my$msg;if (ref($details)){require Data::Dumper;my$dumper=Data::Dumper->new([$details])->Indent(2)->Terse(1)->Pad('# ')->Useqq(1)->Sortkeys(1);chomp($msg=$dumper->Dump)}else {chomp($msg=$details);$msg =~ s/^/# /;$msg =~ s/\n/\n# /g}[$IO,"$msg\n"]}@{$f->{errors}}}sub plan_tap {my$self=shift;my ($f)=@_;my$plan=$f->{plan}or return;return if$plan->{none};if ($plan->{skip}){my$reason=$plan->{details}or return [OUT_STD,"1..0 # SKIP\n"];chomp($reason);return [OUT_STD,'1..0 # SKIP ' .$reason ."\n"]}return [OUT_STD,"1.." .$plan->{count}."\n"]}sub no_subtest_space {0}sub assert_tap {my$self=shift;my ($f,$num)=@_;my$assert=$f->{assert}or return;my$pass=$assert->{pass};my$name=$assert->{details};my$ok=$pass ? 'ok' : 'not ok';$ok .= " $num" if$num &&!$self->{+NO_NUMBERS};my@extra;defined($name)&& ((index($name,"\n")!=-1 && (($name,@extra)=split(/\n\r?/,$name,-1))),((index($name,"#")!=-1 || substr($name,-1)eq '\\')&& (($name =~ s|\\|\\\\|g),($name =~ s|#|\\#|g))));my$extra_space=@extra ? ' ' x (length($ok)+ 2): '';my$extra_indent='';my ($directives,$reason,$is_skip);if ($f->{amnesty}){my%directives;for my$am (@{$f->{amnesty}}){next if$am->{inherited};my$tag=$am->{tag}or next;$is_skip=1 if$tag eq 'skip';$directives{$tag}||= $am->{details}}my%seen;my@order=grep {!$seen{$_}++}sort {lc$b cmp lc$a}keys%directives;$directives=' # ' .join ' & '=>@order;for my$tag ('skip',@order){next unless defined($directives{$tag})&& length($directives{$tag});$reason=$directives{$tag};last}}$ok .= " - $name" if defined$name &&!($is_skip &&!$name);my@subtap;if ($f->{parent}&& $f->{parent}->{buffered}){$ok .= ' {';if ($ENV{HARNESS_IS_VERBOSE}||!$ENV{HARNESS_ACTIVE}){$extra_indent="    ";$extra_space=' '}my$count=0;@subtap=map {my$f2=$_;$count++ if$f2->{assert};map {$_->[1]=~ s/^(.*\S.*)$/    $1/mg;$_}$self->event_tap($f2,$count)}@{$f->{parent}->{children}};push@subtap=>[OUT_STD,"}\n"]}if ($directives){$directives=' # TODO & SKIP' if$directives eq ' # TODO & skip';$ok .= $directives;$ok .= " $reason" if defined($reason)}$extra_space=' ' if$self->no_subtest_space;my@out=([OUT_STD,"$ok\n"]);push@out=>map {[OUT_STD,"${extra_indent}#${extra_space}$_\n"]}@extra if@extra;push@out=>@subtap;return@out}sub debug_tap {my ($self,$f,$num)=@_;my$name=$f->{assert}->{details};my$trace=$f->{trace};my$debug="[No trace info available]";if ($trace->{details}){$debug=$trace->{details}}elsif ($trace->{frame}){my ($pkg,$file,$line)=@{$trace->{frame}};$debug="at $file line $line." if$file && $line}my$amnesty=$f->{amnesty}&& @{$f->{amnesty}}? ' (with amnesty)' : '';my$msg=defined($name)? qq[# Failed test${amnesty} '$name'\n# $debug\n] : qq[# Failed test${amnesty} $debug\n];my$IO=$f->{amnesty}&& @{$f->{amnesty}}? OUT_STD : OUT_ERR;return [$IO,$msg]}sub halt_tap {my ($self,$f)=@_;return if$f->{trace}->{nested}&&!$f->{trace}->{buffered};my$details=$f->{control}->{details};return [OUT_STD,"Bail out!\n"]unless defined($details)&& length($details);return [OUT_STD,"Bail out!  $details\n"]}sub info_tap {my ($self,$f)=@_;return map {my$details=$_->{details};my$table=$_->{table};my$IO=$_->{debug}&&!($f->{amnesty}&& @{$f->{amnesty}})? OUT_ERR : OUT_STD;my$msg;if ($table && $self->supports_tables){$msg=join "\n"=>map {"# $_"}Term::Table->new(header=>$table->{header},rows=>$table->{rows},collapse=>$table->{collapse},no_collapse=>$table->{no_collapse},sanitize=>1,mark_tail=>1,max_width=>$self->calc_table_size($f),)->render()}elsif (ref($details)){require Data::Dumper;my$dumper=Data::Dumper->new([$details])->Indent(2)->Terse(1)->Pad('# ')->Useqq(1)->Sortkeys(1);chomp($msg=$dumper->Dump)}else {chomp($msg=$details);$msg =~ s/^/# /;$msg =~ s/\n/\n# /g}[$IO,"$msg\n"]}@{$f->{info}}}sub summary_tap {my ($self,$f,$num)=@_;return if$f->{about}->{no_display};my$summary=$f->{about}->{details}or return;chomp($summary);$summary =~ s/^/# /smg;return [OUT_STD,"$summary\n"]}sub calc_table_size {my$self=shift;my ($f)=@_;my$term=Term::Table::Util::term_size();my$nesting=2 + (($f->{trace}->{nested}|| 0)* 4);my$total=$term - $nesting;return 50 if$total < 50;return$total}1;
TEST2_FORMATTER_TAP

$fatpacked{"Test2/Hub.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_HUB';
  package Test2::Hub;use strict;use warnings;our$VERSION='1.302190';use Carp qw/carp croak confess/;use Test2::Util qw/get_tid gen_uid/;use Scalar::Util qw/weaken/;use List::Util qw/first/;use Test2::Util::ExternalMeta qw/meta get_meta set_meta delete_meta/;use Test2::Util::HashBase qw{pid tid hid ipc nested buffered no_ending _filters _pre_filters _listeners _follow_ups _formatter _context_acquire _context_init _context_release uuid active count failed ended bailed_out _passing _plan skip_reason};my$UUID_VIA;sub init {my$self=shift;$self->{+PID}=$$;$self->{+TID}=get_tid();$self->{+HID}=gen_uid();$UUID_VIA ||= Test2::API::_add_uuid_via_ref();$self->{+UUID}=${$UUID_VIA}->('hub')if $$UUID_VIA;$self->{+NESTED}=0 unless defined$self->{+NESTED};$self->{+BUFFERED}=0 unless defined$self->{+BUFFERED};$self->{+COUNT}=0;$self->{+FAILED}=0;$self->{+_PASSING}=1;if (my$formatter=delete$self->{formatter}){$self->format($formatter)}if (my$ipc=$self->{+IPC}){$ipc->add_hub($self->{+HID})}}sub is_subtest {0}sub _tb_reset {my$self=shift;return if$self->{+PID}==$$ && $self->{+TID}==get_tid();$self->{+PID}=$$;$self->{+TID}=get_tid();$self->{+HID}=gen_uid();if (my$ipc=$self->{+IPC}){$ipc->add_hub($self->{+HID})}}sub reset_state {my$self=shift;$self->{+COUNT}=0;$self->{+FAILED}=0;$self->{+_PASSING}=1;delete$self->{+_PLAN};delete$self->{+ENDED};delete$self->{+BAILED_OUT};delete$self->{+SKIP_REASON}}sub inherit {my$self=shift;my ($from,%params)=@_;$self->{+NESTED}||= 0;$self->{+_FORMATTER}=$from->{+_FORMATTER}unless$self->{+_FORMATTER}|| exists($params{formatter});if ($from->{+IPC}&&!$self->{+IPC}&&!exists($params{ipc})){my$ipc=$from->{+IPC};$self->{+IPC}=$ipc;$ipc->add_hub($self->{+HID})}if (my$ls=$from->{+_LISTENERS}){push @{$self->{+_LISTENERS}}=>grep {$_->{inherit}}@$ls}if (my$pfs=$from->{+_PRE_FILTERS}){push @{$self->{+_PRE_FILTERS}}=>grep {$_->{inherit}}@$pfs}if (my$fs=$from->{+_FILTERS}){push @{$self->{+_FILTERS}}=>grep {$_->{inherit}}@$fs}}sub format {my$self=shift;my$old=$self->{+_FORMATTER};($self->{+_FORMATTER})=@_ if @_;return$old}sub is_local {my$self=shift;return $$==$self->{+PID}&& get_tid()==$self->{+TID}}sub listen {my$self=shift;my ($sub,%params)=@_;carp "Useless addition of a listener in a child process or thread!" if $$!=$self->{+PID}|| get_tid()!=$self->{+TID};croak "listen only takes coderefs for arguments, got '$sub'" unless ref$sub && ref$sub eq 'CODE';push @{$self->{+_LISTENERS}}=>{%params,code=>$sub };$sub}sub unlisten {my$self=shift;carp "Useless removal of a listener in a child process or thread!" if $$!=$self->{+PID}|| get_tid()!=$self->{+TID};my%subs=map {$_=>$_}@_;@{$self->{+_LISTENERS}}=grep {!$subs{$_->{code}}}@{$self->{+_LISTENERS}}}sub filter {my$self=shift;my ($sub,%params)=@_;carp "Useless addition of a filter in a child process or thread!" if $$!=$self->{+PID}|| get_tid()!=$self->{+TID};croak "filter only takes coderefs for arguments, got '$sub'" unless ref$sub && ref$sub eq 'CODE';push @{$self->{+_FILTERS}}=>{%params,code=>$sub };$sub}sub unfilter {my$self=shift;carp "Useless removal of a filter in a child process or thread!" if $$!=$self->{+PID}|| get_tid()!=$self->{+TID};my%subs=map {$_=>$_}@_;@{$self->{+_FILTERS}}=grep {!$subs{$_->{code}}}@{$self->{+_FILTERS}}}sub pre_filter {my$self=shift;my ($sub,%params)=@_;croak "pre_filter only takes coderefs for arguments, got '$sub'" unless ref$sub && ref$sub eq 'CODE';push @{$self->{+_PRE_FILTERS}}=>{%params,code=>$sub };$sub}sub pre_unfilter {my$self=shift;my%subs=map {$_=>$_}@_;@{$self->{+_PRE_FILTERS}}=grep {!$subs{$_->{code}}}@{$self->{+_PRE_FILTERS}}}sub follow_up {my$self=shift;my ($sub)=@_;carp "Useless addition of a follow-up in a child process or thread!" if $$!=$self->{+PID}|| get_tid()!=$self->{+TID};croak "follow_up only takes coderefs for arguments, got '$sub'" unless ref$sub && ref$sub eq 'CODE';push @{$self->{+_FOLLOW_UPS}}=>$sub}*add_context_aquire=\&add_context_acquire;sub add_context_acquire {my$self=shift;my ($sub)=@_;croak "add_context_acquire only takes coderefs for arguments, got '$sub'" unless ref$sub && ref$sub eq 'CODE';push @{$self->{+_CONTEXT_ACQUIRE}}=>$sub;$sub}*remove_context_aquire=\&remove_context_acquire;sub remove_context_acquire {my$self=shift;my%subs=map {$_=>$_}@_;@{$self->{+_CONTEXT_ACQUIRE}}=grep {!$subs{$_}==$_}@{$self->{+_CONTEXT_ACQUIRE}}}sub add_context_init {my$self=shift;my ($sub)=@_;croak "add_context_init only takes coderefs for arguments, got '$sub'" unless ref$sub && ref$sub eq 'CODE';push @{$self->{+_CONTEXT_INIT}}=>$sub;$sub}sub remove_context_init {my$self=shift;my%subs=map {$_=>$_}@_;@{$self->{+_CONTEXT_INIT}}=grep {!$subs{$_}==$_}@{$self->{+_CONTEXT_INIT}}}sub add_context_release {my$self=shift;my ($sub)=@_;croak "add_context_release only takes coderefs for arguments, got '$sub'" unless ref$sub && ref$sub eq 'CODE';push @{$self->{+_CONTEXT_RELEASE}}=>$sub;$sub}sub remove_context_release {my$self=shift;my%subs=map {$_=>$_}@_;@{$self->{+_CONTEXT_RELEASE}}=grep {!$subs{$_}==$_}@{$self->{+_CONTEXT_RELEASE}}}sub send {my$self=shift;my ($e)=@_;$e->eid;$e->add_hub({details=>ref($self),buffered=>$self->{+BUFFERED},hid=>$self->{+HID},nested=>$self->{+NESTED},pid=>$self->{+PID},tid=>$self->{+TID},uuid=>$self->{+UUID},ipc=>$self->{+IPC}? 1 : 0,});$e->set_uuid(${$UUID_VIA}->('event'))if $$UUID_VIA;if ($self->{+_PRE_FILTERS}){for (@{$self->{+_PRE_FILTERS}}){$e=$_->{code}->($self,$e);return unless$e}}my$ipc=$self->{+IPC}|| return$self->process($e);if($e->global){$ipc->send($self->{+HID},$e,'GLOBAL');return$self->process($e)}return$ipc->send($self->{+HID},$e)if $$!=$self->{+PID}|| get_tid()!=$self->{+TID};$self->process($e)}sub process {my$self=shift;my ($e)=@_;if ($self->{+_FILTERS}){for (@{$self->{+_FILTERS}}){$e=$_->{code}->($self,$e);return unless$e}}my$type=ref($e);if ($type eq 'Test2::Event::Pass' || ($type eq 'Test2::Event::Ok' && $e->{pass})){my$count=++($self->{+COUNT});$self->{+_FORMATTER}->write($e,$count)if$self->{+_FORMATTER};if ($self->{+_LISTENERS}){$_->{code}->($self,$e,$count)for @{$self->{+_LISTENERS}}}return$e}my$f=$e->facet_data;my$fail=0;$fail=1 if$f->{assert}&&!$f->{assert}->{pass};$fail=1 if$f->{errors}&& grep {$_->{fail}}@{$f->{errors}};$fail=0 if$f->{amnesty};$self->{+COUNT}++ if$f->{assert};$self->{+FAILED}++ if$fail && $f->{assert};$self->{+_PASSING}=0 if$fail;my$code=$f->{control}? $f->{control}->{terminate}: undef;my$count=$self->{+COUNT};if (my$plan=$f->{plan}){if ($plan->{skip}){$self->plan('SKIP');$self->set_skip_reason($plan->{details}|| 1);$code ||= 0}elsif ($plan->{none}){$self->plan('NO PLAN')}else {$self->plan($plan->{count})}}$e->callback($self)if$f->{control}&& $f->{control}->{has_callback};$self->{+_FORMATTER}->write($e,$count,$f)if$self->{+_FORMATTER};if ($self->{+_LISTENERS}){$_->{code}->($self,$e,$count,$f)for @{$self->{+_LISTENERS}}}if ($f->{control}&& $f->{control}->{halt}){$code ||= 255;$self->set_bailed_out($e)}if (defined$code){$self->{+_FORMATTER}->terminate($e,$f)if$self->{+_FORMATTER};$self->terminate($code,$e,$f)}return$e}sub terminate {my$self=shift;my ($code)=@_;exit($code)}sub cull {my$self=shift;my$ipc=$self->{+IPC}|| return;return if$self->{+PID}!=$$ || $self->{+TID}!=get_tid();$self->process($_)for$ipc->cull($self->{+HID})}sub finalize {my$self=shift;my ($trace,$do_plan)=@_;$self->cull();my$plan=$self->{+_PLAN};my$count=$self->{+COUNT};my$failed=$self->{+FAILED};my$active=$self->{+ACTIVE};unless ($active || $do_plan || defined($plan)|| $count || $failed){$self->{+_FORMATTER}->finalize($plan,$count,$failed,0,$self->is_subtest)if$self->{+_FORMATTER};return}unless ($self->{+ENDED}){if ($self->{+_FOLLOW_UPS}){$_->($trace,$self)for reverse @{$self->{+_FOLLOW_UPS}}}$plan=$self->{+_PLAN};$count=$self->{+COUNT};$failed=$self->{+FAILED};if (($plan && $plan eq 'NO PLAN')|| ($do_plan &&!$plan)){$self->send(Test2::Event::Plan->new(trace=>$trace,max=>$count,))}$plan=$self->{+_PLAN}}my$frame=$trace->frame;if($self->{+ENDED}){my (undef,$ffile,$fline)=@{$self->{+ENDED}};my (undef,$sfile,$sline)=@$frame;die <<"        EOT"}$self->{+ENDED}=$frame;my$pass=$self->is_passing();$self->{+_FORMATTER}->finalize($plan,$count,$failed,$pass,$self->is_subtest)if$self->{+_FORMATTER};return$pass}sub is_passing {my$self=shift;($self->{+_PASSING})=@_ if @_;my$pass=$self->{+_PASSING}or return 0;return$self->{+_PASSING}=0 if$self->{+FAILED};my$count=$self->{+COUNT};my$ended=$self->{+ENDED};my$plan=$self->{+_PLAN};return$pass if!$count && $plan && $plan =~ m/^SKIP$/;return$self->{+_PASSING}=0 if$ended && (!$count ||!$plan);return$pass unless$plan && $plan =~ m/^\d+$/;if ($ended){return$self->{+_PASSING}=0 if$count!=$plan}else {return$self->{+_PASSING}=0 if$count > $plan}return$pass}sub plan {my$self=shift;return$self->{+_PLAN}unless @_;my ($plan)=@_;confess "You cannot unset the plan" unless defined$plan;confess "You cannot change the plan" if$self->{+_PLAN}&& $self->{+_PLAN}!~ m/^NO PLAN$/;confess "'$plan' is not a valid plan! Plan must be an integer greater than 0, 'NO PLAN', or 'SKIP'" unless$plan =~ m/^(\d+|NO PLAN|SKIP)$/;$self->{+_PLAN}=$plan}sub check_plan {my$self=shift;return undef unless$self->{+ENDED};my$plan=$self->{+_PLAN}|| return undef;return 1 if$plan !~ m/^\d+$/;return 1 if$plan==$self->{+COUNT};return 0}sub DESTROY {my$self=shift;my$ipc=$self->{+IPC}|| return;return unless $$==$self->{+PID};return unless get_tid()==$self->{+TID};$ipc->drop_hub($self->{+HID})}1;
  Test already ended!
  First End:  $ffile line $fline
  Second End: $sfile line $sline
          EOT
TEST2_HUB

$fatpacked{"Test2/Hub/Interceptor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_HUB_INTERCEPTOR';
  package Test2::Hub::Interceptor;use strict;use warnings;our$VERSION='1.302190';use Test2::Hub::Interceptor::Terminator();BEGIN {require Test2::Hub;our@ISA=qw(Test2::Hub)}use Test2::Util::HashBase;sub init {my$self=shift;$self->SUPER::init();$self->{+NESTED}=0}sub inherit {my$self=shift;my ($from,%params)=@_;$self->{+NESTED}=0;if ($from->{+IPC}&&!$self->{+IPC}&&!exists($params{ipc})){my$ipc=$from->{+IPC};$self->{+IPC}=$ipc;$ipc->add_hub($self->{+HID})}if (my$ls=$from->{+_LISTENERS}){push @{$self->{+_LISTENERS}}=>grep {$_->{intercept_inherit}}@$ls}if (my$pfs=$from->{+_PRE_FILTERS}){push @{$self->{+_PRE_FILTERS}}=>grep {$_->{intercept_inherit}}@$pfs}if (my$fs=$from->{+_FILTERS}){push @{$self->{+_FILTERS}}=>grep {$_->{intercept_inherit}}@$fs}}sub clean_inherited {my$self=shift;my%params=@_;my@sets=($self->{+_LISTENERS},$self->{+_PRE_FILTERS},$self->{+_FILTERS},);for my$set (@sets){next unless$set;for my$i (@$set){my$cbs=$i->{intercept_inherit}or next;next unless ref($cbs)eq 'HASH';my$cb=$cbs->{clean}or next;$cb->(%params)}}}sub restore_inherited {my$self=shift;my%params=@_;my@sets=($self->{+_FILTERS},$self->{+_PRE_FILTERS},$self->{+_LISTENERS},);for my$set (@sets){next unless$set;for my$i (@$set){my$cbs=$i->{intercept_inherit}or next;next unless ref($cbs)eq 'HASH';my$cb=$cbs->{restore}or next;$cb->(%params)}}}sub terminate {my$self=shift;my ($code)=@_;eval {no warnings 'exiting';last T2_SUBTEST_WRAPPER};my$err=$@;die bless(\$err,'Test2::Hub::Interceptor::Terminator')}1;
TEST2_HUB_INTERCEPTOR

$fatpacked{"Test2/Hub/Interceptor/Terminator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_HUB_INTERCEPTOR_TERMINATOR';
  package Test2::Hub::Interceptor::Terminator;use strict;use warnings;our$VERSION='1.302190';1;
TEST2_HUB_INTERCEPTOR_TERMINATOR

$fatpacked{"Test2/Hub/Subtest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_HUB_SUBTEST';
  package Test2::Hub::Subtest;use strict;use warnings;our$VERSION='1.302190';BEGIN {require Test2::Hub;our@ISA=qw(Test2::Hub)}use Test2::Util::HashBase qw/nested exit_code manual_skip_all/;use Test2::Util qw/get_tid/;sub is_subtest {1}sub inherit {my$self=shift;my ($from)=@_;$self->SUPER::inherit($from);$self->{+NESTED}=$from->nested + 1}{no warnings 'once';*ID=\&Test2::Hub::HID;*id=\&Test2::Hub::hid;*set_id=\&Test2::Hub::set_hid}sub send {my$self=shift;my ($e)=@_;my$out=$self->SUPER::send($e);return$out if$self->{+MANUAL_SKIP_ALL};my$f=$e->facet_data;my$plan=$f->{plan}or return$out;return$out unless$plan->{skip};my$trace=$f->{trace}or die "Missing Trace!";return$out unless$trace->{pid}!=$self->pid || $trace->{tid}!=$self->tid;no warnings 'exiting';last T2_SUBTEST_WRAPPER}sub terminate {my$self=shift;my ($code,$e,$f)=@_;$self->set_exit_code($code);return if$self->{+MANUAL_SKIP_ALL};$f ||= $e->facet_data;if(my$plan=$f->{plan}){my$trace=$f->{trace}or die "Missing Trace!";return if$plan->{skip}&& ($trace->{pid}!=$$ || $trace->{tid}!=get_tid)}no warnings 'exiting';last T2_SUBTEST_WRAPPER}1;
TEST2_HUB_SUBTEST

$fatpacked{"Test2/IPC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_IPC';
  package Test2::IPC;use strict;use warnings;our$VERSION='1.302190';use Test2::API::Instance;use Test2::Util qw/get_tid/;use Test2::API qw{test2_in_preload test2_init_done test2_ipc test2_has_ipc test2_ipc_enable_polling test2_pid test2_stack test2_tid context};{no warnings 'void';INIT {use warnings 'void';context()->release()unless test2_in_preload()}}use Carp qw/confess/;our@EXPORT_OK=qw/cull/;BEGIN {require Exporter;our@ISA=qw(Exporter)}sub unimport {Test2::API::test2_ipc_disable()}sub import {goto&Exporter::import if test2_has_ipc ||!test2_init_done();confess "IPC is disabled" if Test2::API::test2_ipc_disabled();confess "Cannot add IPC in a child process (" .test2_pid()." vs $$)" if test2_pid()!=$$;confess "Cannot add IPC in a child thread (" .test2_tid()." vs " .get_tid().")" if test2_tid()!=get_tid();Test2::API::_set_ipc(_make_ipc());apply_ipc(test2_stack());goto&Exporter::import}sub _make_ipc {my ($driver)=Test2::API::test2_ipc_drivers();unless ($driver){require Test2::IPC::Driver::Files;$driver='Test2::IPC::Driver::Files'}return$driver->new()}sub apply_ipc {my$stack=shift;my ($root)=@$stack;return unless$root;confess "Cannot add IPC in a child process" if$root->pid!=$$;confess "Cannot add IPC in a child thread" if$root->tid!=get_tid();my$ipc=$root->ipc || test2_ipc()|| _make_ipc();for my$hub (@$stack){my$has=$hub->ipc;confess "IPC Mismatch!" if$has && $has!=$ipc;next if$has;$hub->set_ipc($ipc);$ipc->add_hub($hub->hid)}test2_ipc_enable_polling();return$ipc}sub cull {my$ctx=context();$ctx->hub->cull;$ctx->release}1;
TEST2_IPC

$fatpacked{"Test2/IPC/Driver.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_IPC_DRIVER';
  package Test2::IPC::Driver;use strict;use warnings;our$VERSION='1.302190';use Carp qw/confess/;use Test2::Util::HashBase qw{no_fatal no_bail};use Test2::API qw/test2_ipc_add_driver/;my%ADDED;sub import {my$class=shift;return if$class eq __PACKAGE__;return if$ADDED{$class}++;test2_ipc_add_driver($class)}sub pending {-1}sub set_pending {-1}for my$meth (qw/send cull add_hub drop_hub waiting is_viable/){no strict 'refs';*$meth=sub {my$thing=shift;confess "'$thing' did not define the required method '$meth'."}}sub abort {my$self=shift;chomp(my ($msg)=@_);$self->driver_abort($msg)if$self->can('driver_abort');print STDERR "IPC Fatal Error: $msg\n";print STDOUT "Bail out! IPC Fatal Error: $msg\n" unless$self->no_bail;CORE::exit(255)unless$self->no_fatal}sub abort_trace {my$self=shift;my ($msg)=@_;$self->abort(Carp::longmess($msg))}1;
TEST2_IPC_DRIVER

$fatpacked{"Test2/IPC/Driver/Files.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_IPC_DRIVER_FILES';
  package Test2::IPC::Driver::Files;use strict;use warnings;our$VERSION='1.302190';BEGIN {require Test2::IPC::Driver;our@ISA=qw(Test2::IPC::Driver)}use Test2::Util::HashBase qw{tempdir event_ids read_ids timeouts tid pid globals};use Scalar::Util qw/blessed/;use File::Temp();use Storable();use File::Spec();use POSIX();use Test2::Util qw/try get_tid pkg_to_file IS_WIN32 ipc_separator do_rename do_unlink try_sig_mask/;use Test2::API qw/test2_ipc_set_pending/;sub is_viable {1}sub init {my$self=shift;my$tmpdir=File::Temp::tempdir($ENV{T2_TEMPDIR_TEMPLATE}|| "test2" .ipc_separator .$$ .ipc_separator ."XXXXXX",CLEANUP=>0,TMPDIR=>1,);$self->abort_trace("Could not get a temp dir")unless$tmpdir;$self->{+TEMPDIR}=File::Spec->canonpath($tmpdir);print STDERR "\nIPC Temp Dir: $tmpdir\n\n" if$ENV{T2_KEEP_TEMPDIR};$self->{+EVENT_IDS}={};$self->{+READ_IDS}={};$self->{+TIMEOUTS}={};$self->{+TID}=get_tid();$self->{+PID}=$$;$self->{+GLOBALS}={};return$self}sub hub_file {my$self=shift;my ($hid)=@_;my$tdir=$self->{+TEMPDIR};return File::Spec->catfile($tdir,"HUB" .ipc_separator .$hid)}sub event_file {my$self=shift;my ($hid,$e)=@_;my$tempdir=$self->{+TEMPDIR};my$type=blessed($e)or $self->abort("'$e' is not a blessed object!");$self->abort("'$e' is not an event object!")unless$type->isa('Test2::Event');my$tid=get_tid();my$eid=$self->{+EVENT_IDS}->{$hid}->{$$}->{$tid}+= 1;my@type=split '::',$type;my$name=join(ipc_separator,$hid,$$,$tid,$eid,@type);return File::Spec->catfile($tempdir,$name)}sub add_hub {my$self=shift;my ($hid)=@_;my$hfile=$self->hub_file($hid);$self->abort_trace("File for hub '$hid' already exists")if -e $hfile;open(my$fh,'>',$hfile)or $self->abort_trace("Could not create hub file '$hid': $!");print$fh "$$\n" .get_tid()."\n";close($fh)}sub drop_hub {my$self=shift;my ($hid)=@_;my$tdir=$self->{+TEMPDIR};my$hfile=$self->hub_file($hid);$self->abort_trace("File for hub '$hid' does not exist")unless -e $hfile;open(my$fh,'<',$hfile)or $self->abort_trace("Could not open hub file '$hid': $!");my ($pid,$tid)=<$fh>;close($fh);$self->abort_trace("A hub file can only be closed by the process that started it\nExpected $pid, got $$")unless$pid==$$;$self->abort_trace("A hub file can only be closed by the thread that started it\nExpected $tid, got " .get_tid())unless get_tid()==$tid;if ($ENV{T2_KEEP_TEMPDIR}){my ($ok,$err)=do_rename($hfile,File::Spec->canonpath("$hfile.complete"));$self->abort_trace("Could not rename file '$hfile' -> '$hfile.complete': $err")unless$ok}else {my ($ok,$err)=do_unlink($hfile);$self->abort_trace("Could not remove file for hub '$hid': $err")unless$ok}opendir(my$dh,$tdir)or $self->abort_trace("Could not open temp dir!");my%bad;for my$file (readdir($dh)){next if$file =~ m{\.complete$};next unless$file =~ m{^$hid};eval {$bad{$file}=$self->read_event_file(File::Spec->catfile($tdir,$file));1}or $bad{$file}=$@ || "Unknown error reading file"}closedir($dh);return unless keys%bad;my$data;my$ok=eval {require JSON::PP;local*UNIVERSAL::TO_JSON=sub {+{%{$_[0]}}};my$json=JSON::PP->new->ascii->pretty->canonical->allow_unknown->allow_blessed->convert_blessed;$data=$json->encode(\%bad);1};$ok ||= eval {require Data::Dumper;local$Data::Dumper::Sortkeys=1;$data=Data::Dumper::Dumper(\%bad);1};$data="Could not dump data... sorry." unless defined$data;$self->abort_trace("Not all files from hub '$hid' have been collected!\nHere is the leftover data:\n========================\n$data\n===================\n")}sub send {my$self=shift;my ($hid,$e,$global)=@_;my$tempdir=$self->{+TEMPDIR};my$hfile=$self->hub_file($hid);my$dest=$global ? 'GLOBAL' : $hid;$self->abort(<<"    EOT")unless$global || -f $hfile;my$file=$self->event_file($dest,$e);my$ready=File::Spec->canonpath("$file.ready");if ($global){my$name=$ready;$name =~ s{^.*(GLOBAL)}{GLOBAL};$self->{+GLOBALS}->{$hid}->{$name}++}my ($ren_ok,$ren_err);my ($ok,$err)=try_sig_mask(sub {Storable::store($e,$file);($ren_ok,$ren_err)=do_rename("$file",$ready)});if ($ok){$self->abort("Could not rename file '$file' -> '$ready': $ren_err")unless$ren_ok;test2_ipc_set_pending($file)}else {my$src_file=__FILE__;$err =~ s{ at \Q$src_file\E.*$}{};chomp($err);my$tid=get_tid();my$trace=$e->trace->debug;my$type=blessed($e);$self->abort(<<"        EOT")}return 1}sub driver_abort {my$self=shift;my ($msg)=@_;local ($@,$!,$?,$^E);eval {my$abort=File::Spec->catfile($self->{+TEMPDIR},"ABORT");open(my$fh,'>>',$abort)or die "Could not open abort file: $!";print$fh $msg,"\n";close($fh)or die "Could not close abort file: $!";1}or warn $@}sub cull {my$self=shift;my ($hid)=@_;my$tempdir=$self->{+TEMPDIR};opendir(my$dh,$tempdir)or $self->abort("could not open IPC temp dir ($tempdir)!");my$read=$self->{+READ_IDS};my$timeouts=$self->{+TIMEOUTS};my@out;for my$info (sort cmp_events map {$self->should_read_event($hid,$_)}readdir($dh)){unless ($info->{global}){my$next=$self->{+READ_IDS}->{$info->{hid}}->{$info->{pid}}->{$info->{tid}}||= 1;$timeouts->{$info->{file}}||= time;if ($next!=$info->{eid}){next unless 5 < time - $timeouts->{$info->{file}};$self->abort("Missing event HID: $info->{hid}, PID: $info->{pid}, TID: $info->{tid}, EID: $info->{eid}.")}$self->{+READ_IDS}->{$info->{hid}}->{$info->{pid}}->{$info->{tid}}=$info->{eid}+ 1}my$full=$info->{full_path};my$obj=$self->read_event_file($full);push@out=>$obj;next if$info->{global};if ($ENV{T2_KEEP_TEMPDIR}){my$complete=File::Spec->canonpath("$full.complete");my ($ok,$err)=do_rename($full,$complete);$self->abort("Could not rename IPC file '$full', '$complete': $err")unless$ok}else {my ($ok,$err)=do_unlink("$full");$self->abort("Could not unlink IPC file '$full': $err")unless$ok}}closedir($dh);return@out}sub parse_event_filename {my$self=shift;my ($file)=@_;my$complete=substr($file,-9,9)eq '.complete' || 0 and substr($file,-9,9,"");my$ready=substr($file,-6,6)eq '.ready' || 0 and substr($file,-6,6,"");my@parts=split ipc_separator,$file;my ($global,$hid)=$parts[0]eq 'GLOBAL' ? (1,shift@parts): (0,join ipc_separator,splice(@parts,0,4));my ($pid,$tid,$eid)=splice(@parts,0,3);my$type=join '::'=>@parts;return {file=>$file,ready=>!!$ready,complete=>!!$complete,global=>$global,type=>$type,hid=>$hid,pid=>$pid,tid=>$tid,eid=>$eid,}}sub should_read_event {my$self=shift;my ($hid,$file)=@_;return if substr($file,0,1)eq '.';return if substr($file,0,3)eq 'HUB';CORE::exit(255)if$file eq 'ABORT';my$parsed=$self->parse_event_filename($file);return if$parsed->{complete};return unless$parsed->{ready};return unless$parsed->{global}|| $parsed->{hid}eq $hid;return if$parsed->{global}&& $self->{+GLOBALS}->{$hid}->{$file}++;my$full=File::Spec->catfile($self->{+TEMPDIR},$file);($full)=($full =~ m/^(.*)$/gs)if ${^TAINT};$parsed->{full_path}=$full;return$parsed}sub cmp_events {return -1 if$a->{global}&&!$b->{global};return 1 if$b->{global}&&!$a->{global};return$a->{pid}<=> $b->{pid}|| $a->{tid}<=> $b->{tid}|| $a->{eid}<=> $b->{eid}}sub read_event_file {my$self=shift;my ($file)=@_;my$obj=Storable::retrieve($file);$self->abort("Got an unblessed object: '$obj'")unless blessed($obj);unless ($obj->isa('Test2::Event')){my$pkg=blessed($obj);my$mod_file=pkg_to_file($pkg);my ($ok,$err)=try {require$mod_file};$self->abort("Event has unknown type ($pkg), tried to load '$mod_file' but failed: $err")unless$ok;$self->abort("'$obj' is not a 'Test2::Event' object")unless$obj->isa('Test2::Event')}return$obj}sub waiting {my$self=shift;require Test2::Event::Waiting;$self->send(GLOBAL=>Test2::Event::Waiting->new(trace=>Test2::EventFacet::Trace->new(frame=>[caller()]),),'GLOBAL');return}sub DESTROY {my$self=shift;return unless defined$self->pid;return unless defined$self->tid;return unless $$==$self->pid;return unless get_tid()==$self->tid;my$tempdir=$self->{+TEMPDIR};my$aborted=0;my$abort_file=File::Spec->catfile($self->{+TEMPDIR},"ABORT");if (-e $abort_file){$aborted=1;my ($ok,$err)=do_unlink($abort_file);warn$err unless$ok}opendir(my$dh,$tempdir)or $self->abort("Could not open temp dir! ($tempdir)");while(my$file=readdir($dh)){next if$file =~ m/^\.+$/;next if$file =~ m/\.complete$/;my$full=File::Spec->catfile($tempdir,$file);my$sep=ipc_separator;if ($aborted || $file =~ m/^(GLOBAL|HUB$sep)/){$full =~ m/^(.*)$/;$full=$1;next if$ENV{T2_KEEP_TEMPDIR};my ($ok,$err)=do_unlink($full);$self->abort("Could not unlink IPC file '$full': $err")unless$ok;next}$self->abort("Leftover files in the directory ($full)!\n")}closedir($dh);if ($ENV{T2_KEEP_TEMPDIR}){print STDERR "# Not removing temp dir: $tempdir\n";return}my$abort=File::Spec->catfile($self->{+TEMPDIR},"ABORT");unlink($abort)if -e $abort;rmdir($tempdir)or warn "Could not remove IPC temp dir ($tempdir)"}1;
  hub '$hid' is not available, failed to send event!
  
  There was an attempt to send an event to a hub in a parent process or thread,
  but that hub appears to be gone. This can happen if you fork, or start a new
  thread from inside subtest, and the parent finishes the subtest before the
  child returns.
  
  This can also happen if the parent process is done testing before the child
  finishes. Test2 normally waits automatically in the root process, but will not
  do so if Test::Builder is loaded for legacy reasons.
      EOT
  
  *******************************************************************************
  There was an error writing an event:
  Destination: $dest
  Origin PID:  $$
  Origin TID:  $tid
  Event Type:  $type
  Event Trace: $trace
  File Name:   $file
  Ready Name:  $ready
  Error: $err
  *******************************************************************************
  
          EOT
TEST2_IPC_DRIVER_FILES

$fatpacked{"Test2/Tools/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_TINY';
  package Test2::Tools::Tiny;use strict;use warnings;BEGIN {if ($] lt "5.008"){require Test::Builder::IO::Scalar}}use Scalar::Util qw/blessed/;use Test2::Util qw/try/;use Test2::API qw/context run_subtest test2_stack/;use Test2::Hub::Interceptor();use Test2::Hub::Interceptor::Terminator();our$VERSION='1.302190';BEGIN {require Exporter;our@ISA=qw(Exporter)}our@EXPORT=qw{ok is isnt like unlike is_deeply diag note skip_all todo plan done_testing warnings exception tests capture};sub ok($;$@) {my ($bool,$name,@diag)=@_;my$ctx=context();return$ctx->pass_and_release($name)if$bool;return$ctx->fail_and_release($name,@diag)}sub is($$;$@) {my ($got,$want,$name,@diag)=@_;my$ctx=context();my$bool;if (defined($got)&& defined($want)){$bool="$got" eq "$want"}elsif (defined($got)xor defined($want)){$bool=0}else {$bool=1}return$ctx->pass_and_release($name)if$bool;$got='*NOT DEFINED*' unless defined$got;$want='*NOT DEFINED*' unless defined$want;unshift@diag=>("GOT:      $got","EXPECTED: $want",);return$ctx->fail_and_release($name,@diag)}sub isnt($$;$@) {my ($got,$want,$name,@diag)=@_;my$ctx=context();my$bool;if (defined($got)&& defined($want)){$bool="$got" ne "$want"}elsif (defined($got)xor defined($want)){$bool=1}else {$bool=0}return$ctx->pass_and_release($name)if$bool;unshift@diag=>"Strings are the same (they should not be)" unless$bool;return$ctx->fail_and_release($name,@diag)}sub like($$;$@) {my ($thing,$pattern,$name,@diag)=@_;my$ctx=context();my$bool;if (defined($thing)){$bool="$thing" =~ $pattern;unshift@diag=>("Value: $thing","Does not match: $pattern")unless$bool}else {$bool=0;unshift@diag=>"Got an undefined value."}return$ctx->pass_and_release($name)if$bool;return$ctx->fail_and_release($name,@diag)}sub unlike($$;$@) {my ($thing,$pattern,$name,@diag)=@_;my$ctx=context();my$bool;if (defined($thing)){$bool="$thing" !~ $pattern;unshift@diag=>("Unexpected pattern match (it should not match)","Value:   $thing","Matches: $pattern")unless$bool}else {$bool=0;unshift@diag=>"Got an undefined value."}return$ctx->pass_and_release($name)if$bool;return$ctx->fail_and_release($name,@diag)}sub is_deeply($$;$@) {my ($got,$want,$name,@diag)=@_;my$ctx=context();no warnings 'once';require Data::Dumper;local$Data::Dumper::Useperl=1;local$Data::Dumper::Sortkeys=1;local$Data::Dumper::Deparse=1;local$Data::Dumper::Freezer='XXX';local*UNIVERSAL::XXX=sub {my ($thing)=@_;if (ref($thing)){$thing={%$thing}if "$thing" =~ m/=HASH/;$thing=[@$thing]if "$thing" =~ m/=ARRAY/;$thing=\"$$thing" if "$thing" =~ m/=SCALAR/}$_[0]=$thing};my$g=Data::Dumper::Dumper($got);my$w=Data::Dumper::Dumper($want);my$bool=$g eq $w;return$ctx->pass_and_release($name)if$bool;return$ctx->fail_and_release($name,$g,$w,@diag)}sub diag {my$ctx=context();$ctx->diag(join '',@_);$ctx->release}sub note {my$ctx=context();$ctx->note(join '',@_);$ctx->release}sub skip_all {my ($reason)=@_;my$ctx=context();$ctx->plan(0,SKIP=>$reason);$ctx->release if$ctx}sub todo {my ($reason,$sub)=@_;my$ctx=context();my$hub=test2_stack->top;my$filter=$hub->pre_filter(sub {my ($active_hub,$event)=@_;if ($active_hub==$hub){$event->set_todo($reason)if$event->can('set_todo');$event->add_amnesty({tag=>'TODO',details=>$reason})}else {$event->add_amnesty({tag=>'TODO',details=>$reason,inherited=>1})}return$event},inherit=>1,todo=>$reason,);$sub->();$hub->pre_unfilter($filter);$ctx->release if$ctx}sub plan {my ($max)=@_;my$ctx=context();$ctx->plan($max);$ctx->release}sub done_testing {my$ctx=context();$ctx->done_testing;$ctx->release}sub warnings(&) {my$code=shift;my@warnings;local$SIG{__WARN__}=sub {push@warnings=>@_};$code->();return \@warnings}sub exception(&) {my$code=shift;local ($@,$!,$SIG{__DIE__});my$ok=eval {$code->();1};my$error=$@ || 'SQUASHED ERROR';return$ok ? undef : $error}sub tests {my ($name,$code)=@_;my$ctx=context();my$be=caller->can('before_each');$be->($name)if$be;my$bool=run_subtest($name,$code,1);$ctx->release;return$bool}sub capture(&) {my$code=shift;my ($err,$out)=("","");my$handles=test2_stack->top->format->handles;my ($ok,$e);{my ($out_fh,$err_fh);($ok,$e)=try {if ($] ge "5.008"){open($out_fh,'>',\$out)or die "Failed to open a temporary STDOUT: $!";open($err_fh,'>',\$err)or die "Failed to open a temporary STDERR: $!"}else {$out_fh=Test::Builder::IO::Scalar->new(\$out)or die "Failed to open a temporary STDOUT";$err_fh=Test::Builder::IO::Scalar->new(\$err)or die "Failed to open a temporary STDERR"}test2_stack->top->format->set_handles([$out_fh,$err_fh,$out_fh]);$code->()}}test2_stack->top->format->set_handles($handles);die$e unless$ok;$err =~ s/ $/_/mg;$out =~ s/ $/_/mg;return {STDOUT=>$out,STDERR=>$err,}}1;
TEST2_TOOLS_TINY

$fatpacked{"Test2/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL';
  package Test2::Util;use strict;use warnings;our$VERSION='1.302190';use POSIX();use Config qw/%Config/;use Carp qw/croak/;BEGIN {local ($@,$!,$SIG{__DIE__});*HAVE_PERLIO=eval {require PerlIO;PerlIO->VERSION(1.02)}? sub() {1}: sub() {0}}our@EXPORT_OK=qw{try pkg_to_file get_tid USE_THREADS CAN_THREAD CAN_REALLY_FORK CAN_FORK CAN_SIGSYS IS_WIN32 ipc_separator gen_uid do_rename do_unlink try_sig_mask clone_io};BEGIN {require Exporter;our@ISA=qw(Exporter)}BEGIN {*IS_WIN32=($^O eq 'MSWin32')? sub() {1}: sub() {0}}sub _can_thread {return 0 unless $] >= 5.008001;return 0 unless$Config{'useithreads'};if ($]==5.010000 && $Config{'ccname'}eq 'gcc' && $Config{'gccversion'}){return 0 unless$Config{'gccversion'}=~ m/^(\d+)\.(\d+)/;my@parts=split /[\.\s]+/,$Config{'gccversion'};return 0 if$parts[0]> 4 || ($parts[0]==4 && $parts[1]>= 8)}return 0 if$INC{'Devel/Cover.pm'};return 1}sub _can_fork {return 1 if$Config{d_fork};return 0 unless IS_WIN32 || $^O eq 'NetWare';return 0 unless$Config{useithreads};return 0 unless$Config{ccflags}=~ /-DPERL_IMPLICIT_SYS/;return _can_thread()}BEGIN {no warnings 'once';*CAN_THREAD=_can_thread()? sub() {1}: sub() {0}}my$can_fork;sub CAN_FORK () {return$can_fork if defined$can_fork;$can_fork=!!_can_fork();no warnings 'redefine';*CAN_FORK=$can_fork ? sub() {1}: sub() {0};$can_fork}my$can_really_fork;sub CAN_REALLY_FORK () {return$can_really_fork if defined$can_really_fork;$can_really_fork=!!$Config{d_fork};no warnings 'redefine';*CAN_REALLY_FORK=$can_really_fork ? sub() {1}: sub() {0};$can_really_fork}sub _manual_try(&;@) {my$code=shift;my$args=\@_;my$err;my$die=delete$SIG{__DIE__};eval {$code->(@$args);1}or $err=$@ || "Error was squashed!\n";$die ? $SIG{__DIE__}=$die : delete$SIG{__DIE__};return (!defined($err),$err)}sub _local_try(&;@) {my$code=shift;my$args=\@_;my$err;no warnings;local$SIG{__DIE__};eval {$code->(@$args);1}or $err=$@ || "Error was squashed!\n";return (!defined($err),$err)}BEGIN {if (IS_WIN32 && $] < 5.020002){*try=\&_manual_try}else {*try=\&_local_try}}BEGIN {if (CAN_THREAD){if ($INC{'threads.pm'}){*USE_THREADS=sub() {1};*get_tid=sub() {threads->tid()}}else {*USE_THREADS=sub() {$INC{'threads.pm'}? 1 : 0};*get_tid=sub() {$INC{'threads.pm'}? threads->tid(): 0}}}else {*USE_THREADS=sub() {0};*get_tid=sub() {0}}}sub pkg_to_file {my$pkg=shift;my$file=$pkg;$file =~ s{(::|')}{/}g;$file .= '.pm';return$file}sub ipc_separator() {"~"}my$UID=1;sub gen_uid() {join ipc_separator()=>($$,get_tid(),time,$UID++)}sub _check_for_sig_sys {my$sig_list=shift;return$sig_list =~ m/\bSYS\b/}BEGIN {if (_check_for_sig_sys($Config{sig_name})){*CAN_SIGSYS=sub() {1}}else {*CAN_SIGSYS=sub() {0}}}my%PERLIO_SKIP=(unix=>1,via=>1,);sub clone_io {my ($fh)=@_;my$fileno=eval {fileno($fh)};return$fh if!defined($fileno)||!length($fileno)|| $fileno < 0;open(my$out,'>&' .$fileno)or die "Can't dup fileno $fileno: $!";my%seen;my@layers=HAVE_PERLIO ? grep {!$PERLIO_SKIP{$_}and!$seen{$_}++}PerlIO::get_layers($fh): ();binmode($out,join(":","","raw",@layers));my$old=select$fh;my$af=$|;select$out;$|=$af;select$old;return$out}BEGIN {if (IS_WIN32){my$max_tries=5;*do_rename=sub {my ($from,$to)=@_;my$err;for (1 .. $max_tries){return (1)if rename($from,$to);$err="$!";last if $_==$max_tries;sleep 1}return (0,$err)};*do_unlink=sub {my ($file)=@_;my$err;for (1 .. $max_tries){return (1)if unlink($file);$err="$!";last if $_==$max_tries;sleep 1}return (0,"$!")}}else {*do_rename=sub {my ($from,$to)=@_;return (1)if rename($from,$to);return (0,"$!")};*do_unlink=sub {my ($file)=@_;return (1)if unlink($file);return (0,"$!")}}}sub try_sig_mask(&) {my$code=shift;my ($old,$blocked);unless(IS_WIN32){my$to_block=POSIX::SigSet->new(POSIX::SIGINT(),POSIX::SIGALRM(),POSIX::SIGHUP(),POSIX::SIGTERM(),POSIX::SIGUSR1(),POSIX::SIGUSR2(),);$old=POSIX::SigSet->new;$blocked=POSIX::sigprocmask(POSIX::SIG_BLOCK(),$to_block,$old)}my ($ok,$err)=&try($code);POSIX::sigprocmask(POSIX::SIG_SETMASK(),$old,POSIX::SigSet->new())if defined$blocked;return ($ok,$err)}1;
TEST2_UTIL

$fatpacked{"Test2/Util/ExternalMeta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_EXTERNALMETA';
  package Test2::Util::ExternalMeta;use strict;use warnings;our$VERSION='1.302190';use Carp qw/croak/;sub META_KEY() {'_meta'}our@EXPORT=qw/meta set_meta get_meta delete_meta/;BEGIN {require Exporter;our@ISA=qw(Exporter)}sub set_meta {my$self=shift;my ($key,$value)=@_;validate_key($key);$self->{+META_KEY}||= {};$self->{+META_KEY}->{$key}=$value}sub get_meta {my$self=shift;my ($key)=@_;validate_key($key);my$meta=$self->{+META_KEY}or return undef;return$meta->{$key}}sub delete_meta {my$self=shift;my ($key)=@_;validate_key($key);my$meta=$self->{+META_KEY}or return undef;delete$meta->{$key}}sub meta {my$self=shift;my ($key,$default)=@_;validate_key($key);my$meta=$self->{+META_KEY};return undef unless$meta || defined($default);unless($meta){$meta={};$self->{+META_KEY}=$meta}$meta->{$key}=$default if defined($default)&&!defined($meta->{$key});return$meta->{$key}}sub validate_key {my$key=shift;return if$key &&!ref($key);my$render_key=defined($key)? "'$key'" : 'undef';croak "Invalid META key: $render_key, keys must be true, and may not be references"}1;
TEST2_UTIL_EXTERNALMETA

$fatpacked{"Test2/Util/Facets2Legacy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_FACETS2LEGACY';
  package Test2::Util::Facets2Legacy;use strict;use warnings;our$VERSION='1.302190';use Carp qw/croak confess/;use Scalar::Util qw/blessed/;use base 'Exporter';our@EXPORT_OK=qw{causes_fail diagnostics global increments_count no_display sets_plan subtest_id summary terminate uuid};our%EXPORT_TAGS=(ALL=>\@EXPORT_OK);our$CYCLE_DETECT=0;sub _get_facet_data {my$in=shift;if (blessed($in)&& $in->isa('Test2::Event')){confess "Cycle between Facets2Legacy and $in\->facet_data() (Did you forget to override the facet_data() method?)" if$CYCLE_DETECT;local$CYCLE_DETECT=1;return$in->facet_data}return$in if ref($in)eq 'HASH';croak "'$in' Does not appear to be either a Test::Event or an EventFacet hashref"}sub causes_fail {my$facet_data=_get_facet_data(shift @_);return 1 if$facet_data->{errors}&& grep {$_->{fail}}@{$facet_data->{errors}};if (my$control=$facet_data->{control}){return 1 if$control->{halt};return 1 if$control->{terminate}}return 0 if$facet_data->{amnesty}&& @{$facet_data->{amnesty}};return 1 if$facet_data->{assert}&&!$facet_data->{assert}->{pass};return 0}sub diagnostics {my$facet_data=_get_facet_data(shift @_);return 1 if$facet_data->{errors}&& @{$facet_data->{errors}};return 0 unless$facet_data->{info}&& @{$facet_data->{info}};return (grep {$_->{debug}}@{$facet_data->{info}})? 1 : 0}sub global {my$facet_data=_get_facet_data(shift @_);return 0 unless$facet_data->{control};return$facet_data->{control}->{global}}sub increments_count {my$facet_data=_get_facet_data(shift @_);return$facet_data->{assert}? 1 : 0}sub no_display {my$facet_data=_get_facet_data(shift @_);return 0 unless$facet_data->{about};return$facet_data->{about}->{no_display}}sub sets_plan {my$facet_data=_get_facet_data(shift @_);my$plan=$facet_data->{plan}or return;my@out=($plan->{count}|| 0);if ($plan->{skip}){push@out=>'SKIP';push@out=>$plan->{details}if defined$plan->{details}}elsif ($plan->{none}){push@out=>'NO PLAN'}return@out}sub subtest_id {my$facet_data=_get_facet_data(shift @_);return undef unless$facet_data->{parent};return$facet_data->{parent}->{hid}}sub summary {my$facet_data=_get_facet_data(shift @_);return '' unless$facet_data->{about}&& $facet_data->{about}->{details};return$facet_data->{about}->{details}}sub terminate {my$facet_data=_get_facet_data(shift @_);return undef unless$facet_data->{control};return$facet_data->{control}->{terminate}}sub uuid {my$in=shift;if ($CYCLE_DETECT){if (blessed($in)&& $in->isa('Test2::Event')){my$meth=$in->can('uuid');$meth=$in->can('SUPER::uuid')if$meth==\&uuid;my$uuid=$in->$meth if$meth && $meth!=\&uuid;return$uuid if$uuid}return undef}my$facet_data=_get_facet_data($in);return$facet_data->{about}->{uuid}if$facet_data->{about}&& $facet_data->{about}->{uuid};return undef}1;
TEST2_UTIL_FACETS2LEGACY

$fatpacked{"Test2/Util/HashBase.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_HASHBASE';
  package Test2::Util::HashBase;use strict;use warnings;our$VERSION='1.302190';{no warnings 'once';$Test2::Util::HashBase::HB_VERSION='0.009';*Test2::Util::HashBase::ATTR_SUBS=\%Object::HashBase::ATTR_SUBS;*Test2::Util::HashBase::ATTR_LIST=\%Object::HashBase::ATTR_LIST;*Test2::Util::HashBase::VERSION=\%Object::HashBase::VERSION;*Test2::Util::HashBase::CAN_CACHE=\%Object::HashBase::CAN_CACHE}require Carp;{no warnings 'once';$Carp::Internal{+__PACKAGE__}=1}BEGIN {*_isa=($] >= 5.010 && require mro)? \&mro::get_linear_isa : sub {no strict 'refs';my@packages=($_[0]);my%seen;for my$package (@packages){push@packages,grep!$seen{$_}++,@{"$package\::ISA"}}return \@packages}}my%SPEC=('^'=>{reader=>1,writer=>0,dep_writer=>1,read_only=>0,strip=>1},'-'=>{reader=>1,writer=>0,dep_writer=>0,read_only=>1,strip=>1},'>'=>{reader=>0,writer=>1,dep_writer=>0,read_only=>0,strip=>1},'<'=>{reader=>1,writer=>0,dep_writer=>0,read_only=>0,strip=>1},'+'=>{reader=>0,writer=>0,dep_writer=>0,read_only=>0,strip=>1},);sub import {my$class=shift;my$into=caller;my$ver=$Test2::Util::HashBase::HB_VERSION || $Test2::Util::HashBase::VERSION;$Test2::Util::HashBase::VERSION{$into}=$ver if!$Test2::Util::HashBase::VERSION{$into}|| $Test2::Util::HashBase::VERSION{$into}> $ver;my$isa=_isa($into);my$attr_list=$Test2::Util::HashBase::ATTR_LIST{$into}||= [];my$attr_subs=$Test2::Util::HashBase::ATTR_SUBS{$into}||= {};my%subs=(($into->can('new')? (): (new=>\&_new)),(map %{$Test2::Util::HashBase::ATTR_SUBS{$_}|| {}},@{$isa}[1 .. $#$isa]),(map {my$p=substr($_,0,1);my$x=$_;my$spec=$SPEC{$p}|| {reader=>1,writer=>1};substr($x,0,1)='' if$spec->{strip};push @$attr_list=>$x;my ($sub,$attr)=(uc$x,$x);$attr_subs->{$sub}=sub() {$attr};my%out=($sub=>$attr_subs->{$sub});$out{$attr}=sub {$_[0]->{$attr}}if$spec->{reader};$out{"set_$attr"}=sub {$_[0]->{$attr}=$_[1]}if$spec->{writer};$out{"set_$attr"}=sub {Carp::croak("'$attr' is read-only")}if$spec->{read_only};$out{"set_$attr"}=sub {Carp::carp("set_$attr() is deprecated");$_[0]->{$attr}=$_[1]}if$spec->{dep_writer};%out}@_),);no strict 'refs';*{"$into\::$_"}=$subs{$_}for keys%subs}sub attr_list {my$class=shift;my$isa=_isa($class);my%seen;my@list=grep {!$seen{$_}++}map {my@out;if (0.004 > ($Test2::Util::HashBase::VERSION{$_}|| 0)){Carp::carp("$_ uses an inlined version of Test2::Util::HashBase too old to support attr_list()")}else {my$list=$Test2::Util::HashBase::ATTR_LIST{$_};@out=$list ? @$list : ()}@out}reverse @$isa;return@list}sub _new {my$class=shift;my$self;if (@_==1){my$arg=shift;my$type=ref($arg);if ($type eq 'HASH'){$self=bless({%$arg},$class)}else {Carp::croak("Not sure what to do with '$type' in $class constructor")unless$type eq 'ARRAY';my%proto;my@attributes=attr_list($class);while (@$arg){my$val=shift @$arg;my$key=shift@attributes or Carp::croak("Too many arguments for $class constructor");$proto{$key}=$val}$self=bless(\%proto,$class)}}else {$self=bless({@_},$class)}$Test2::Util::HashBase::CAN_CACHE{$class}=$self->can('init')unless exists$Test2::Util::HashBase::CAN_CACHE{$class};$self->init if$Test2::Util::HashBase::CAN_CACHE{$class};$self}1;
TEST2_UTIL_HASHBASE

$fatpacked{"Test2/Util/Trace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_TRACE';
  package Test2::Util::Trace;require Test2::EventFacet::Trace;use warnings;use strict;our@ISA=('Test2::EventFacet::Trace');our$VERSION='1.302190';1;
TEST2_UTIL_TRACE

$fatpacked{"Time/CTime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TIME_CTIME';
  package Time::CTime;require 5.000;use Time::Timezone;use Time::CTime;require Exporter;@ISA=qw(Exporter);@EXPORT=qw(ctime asctime strftime);@EXPORT_OK=qw(asctime_n ctime_n @DoW @MoY @DayOfWeek @MonthOfYear);use strict;use vars qw(@DoW @DayOfWeek @MoY @MonthOfYear %strftime_conversion $VERSION);use vars qw($template $sec $min $hour $mday $mon $year $wday $yday $isdst);$VERSION=2011.0505;CONFIG: {@DoW=qw(Sun Mon Tue Wed Thu Fri Sat);@DayOfWeek=qw(Sunday Monday Tuesday Wednesday Thursday Friday Saturday);@MoY=qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);@MonthOfYear=qw(January February March April May June July August September October November December);%strftime_conversion=('%',sub {'%'},'a',sub {$DoW[$wday]},'A',sub {$DayOfWeek[$wday]},'b',sub {$MoY[$mon]},'B',sub {$MonthOfYear[$mon]},'c',sub {asctime_n($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst,"")},'d',sub {sprintf("%02d",$mday)},'D',sub {sprintf("%02d/%02d/%02d",$mon+1,$mday,$year%100)},'e',sub {sprintf("%2d",$mday)},'f',sub {fracprintf ("%3.3f",$sec)},'F',sub {fracprintf ("%6.6f",$sec)},'h',sub {$MoY[$mon]},'H',sub {sprintf("%02d",$hour)},'I',sub {sprintf("%02d",$hour % 12 || 12)},'j',sub {sprintf("%03d",$yday + 1)},'k',sub {sprintf("%2d",$hour)},'l',sub {sprintf("%2d",$hour % 12 || 12)},'m',sub {sprintf("%02d",$mon+1)},'M',sub {sprintf("%02d",$min)},'n',sub {"\n"},'o',sub {sprintf("%d%s",$mday,(($mday < 20 && $mday > 3)? 'th' : ($mday%10==1 ? "st" : ($mday%10==2 ? "nd" : ($mday%10==3 ? "rd" : "th")))))},'p',sub {$hour > 11 ? "PM" : "AM"},'r',sub {sprintf("%02d:%02d:%02d %s",$hour % 12 || 12,$min,$sec,$hour > 11 ? 'PM' : 'AM')},'R',sub {sprintf("%02d:%02d",$hour,$min)},'S',sub {sprintf("%02d",$sec)},'t',sub {"\t"},'T',sub {sprintf("%02d:%02d:%02d",$hour,$min,$sec)},'U',sub {wkyr(0,$wday,$yday)},'v',sub {sprintf("%2d-%s-%4d",$mday,$MoY[$mon],$year+1900)},'w',sub {$wday},'W',sub {wkyr(1,$wday,$yday)},'y',sub {sprintf("%02d",$year%100)},'Y',sub {$year + 1900},'x',sub {sprintf("%02d/%02d/%02d",$mon + 1,$mday,$year%100)},'X',sub {sprintf("%02d:%02d:%02d",$hour,$min,$sec)},'Z',sub {&tz2zone(undef,undef,$isdst)})}sub fracprintf {my($t,$s)=@_;my($p)=sprintf($t,$s-int($s));$p=~s/^0+//;$p}sub asctime_n {my($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst,$TZname)=@_;($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst,$TZname)=localtime($sec)unless defined$min;$year += 1900;$TZname .= ' ' if$TZname;sprintf("%s %s %2d %2d:%02d:%02d %s%4d",$DoW[$wday],$MoY[$mon],$mday,$hour,$min,$sec,$TZname,$year)}sub asctime {return asctime_n(@_)."\n"}sub wkyr {my($wstart,$wday,$yday)=@_;$wday=($wday + 7 - $wstart)% 7;return int(($yday - $wday + 13)/ 7 - 1)}sub ctime {my($time)=@_;asctime(localtime($time),&tz2zone(undef,$time))}sub ctime_n {my($time)=@_;asctime_n(localtime($time),&tz2zone(undef,$time))}sub strftime {local ($template,$sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=@_;undef $@;$template =~ s/%([%aAbBcdDefFhHIjklmMnopQrRStTUvwWxXyYZ])/&{$Time::CTime::strftime_conversion{$1}}()/egs;die $@ if $@;return$template}1;
TIME_CTIME

$fatpacked{"Time/DaysInMonth.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TIME_DAYSINMONTH';
  package Time::DaysInMonth;use Carp;require 5.000;@ISA=qw(Exporter);@EXPORT=qw(days_in is_leap);@EXPORT_OK=qw(%mltable);use strict;use vars qw($VERSION %mltable);$VERSION=99.1117;CONFIG: {%mltable=qw(1 31 3 31 4 30 5 31 6 30 7 31 8 31 9 30 10 31 11 30 12 31)}sub days_in {my ($year,$month)=@_;return$mltable{$month+0}unless$month==2;return 28 unless&is_leap($year);return 29}sub is_leap {my ($year)=@_;return 0 unless$year % 4==0;return 1 unless$year % 100==0;return 0 unless$year % 400==0;return 1}1;
TIME_DAYSINMONTH

$fatpacked{"Time/JulianDay.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TIME_JULIANDAY';
  package Time::JulianDay;require 5.000;use Carp;use Time::Timezone;@ISA=qw(Exporter);@EXPORT=qw(julian_day inverse_julian_day day_of_week jd_secondsgm jd_secondslocal jd_timegm jd_timelocal gm_julian_day local_julian_day);@EXPORT_OK=qw($brit_jd);use strict;use integer;use vars qw($brit_jd $jd_epoch $jd_epoch_remainder $VERSION);$VERSION=2011.0505;sub julian_day {my($year,$month,$day)=@_;my($tmp);use Carp;$tmp=$day - 32075 + 1461 * ($year + 4800 - (14 - $month)/ 12)/4 + 367 * ($month - 2 + ((14 - $month)/ 12)* 12)/ 12 - 3 * (($year + 4900 - (14 - $month)/ 12)/ 100)/ 4 ;return($tmp)}sub gm_julian_day {my($secs)=@_;my($sec,$min,$hour,$mon,$year,$day,$month);($sec,$min,$hour,$day,$mon,$year)=gmtime($secs);$month=$mon + 1;$year += 1900;return julian_day($year,$month,$day)}sub local_julian_day {my($secs)=@_;my($sec,$min,$hour,$mon,$year,$day,$month);($sec,$min,$hour,$day,$mon,$year)=localtime($secs);$month=$mon + 1;$year += 1900;return julian_day($year,$month,$day)}sub day_of_week {my ($jd)=@_;return (($jd + 1)% 7)}$brit_jd=2361222;sub inverse_julian_day {my($jd)=@_;my($jdate_tmp);my($m,$d,$y);carp("warning: julian date $jd pre-dates British use of Gregorian calendar\n")if ($jd < $brit_jd);$jdate_tmp=$jd - 1721119;$y=(4 * $jdate_tmp - 1)/146097;$jdate_tmp=4 * $jdate_tmp - 1 - 146097 * $y;$d=$jdate_tmp/4;$jdate_tmp=(4 * $d + 3)/1461;$d=4 * $d + 3 - 1461 * $jdate_tmp;$d=($d + 4)/4;$m=(5 * $d - 3)/153;$d=5 * $d - 3 - 153 * $m;$d=($d + 5)/ 5;$y=100 * $y + $jdate_tmp;if($m < 10){$m += 3}else {$m -= 9;++$y}return ($y,$m,$d)}{my($sec,$min,$hour,$day,$mon,$year)=gmtime(0);$year += 1900;if ($year==1970 && $mon==0 && $day==1){$jd_epoch=2440588}else {$jd_epoch=julian_day($year,$mon+1,$day)}$jd_epoch_remainder=$hour*3600 + $min*60 + $sec}sub jd_secondsgm {my($jd,$hr,$min,$sec)=@_;my($r)=(($jd - $jd_epoch)* 86400 + $hr * 3600 + $min * 60 - $jd_epoch_remainder);no integer;return ($r + $sec);use integer}sub jd_secondslocal {my($jd,$hr,$min,$sec)=@_;my$jds=jd_secondsgm($jd,$hr,$min,$sec);return$jds - tz_local_offset($jds)}sub jd_timelocal {my ($sec,$min,$hours,$mday,$mon,$year)=@_;$year += 1900 unless$year > 1000;my$jd=julian_day($year,$mon+1,$mday);my$jds=jd_secondsgm($jd,$hours,$min,$sec);return$jds - tz_local_offset($jds)}sub jd_timegm {my ($sec,$min,$hours,$mday,$mon,$year)=@_;$year += 1900 unless$year > 1000;my$jd=julian_day($year,$mon+1,$mday);return jd_secondsgm($jd,$hours,$min,$sec)}1;
TIME_JULIANDAY

$fatpacked{"Time/ParseDate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TIME_PARSEDATE';
  package Time::ParseDate;require 5.000;use Carp;use Time::Timezone;use Time::JulianDay;require Exporter;@ISA=qw(Exporter);@EXPORT=qw(parsedate);@EXPORT_OK=qw(pd_raw %mtable %umult %wdays);use strict;use vars qw(%mtable %umult %wdays $VERSION);$VERSION=2015.1030;use vars qw($debug);use vars qw($parse);my%mtable;my%umult;my%wdays;my$y2k;CONFIG: {%mtable=qw(Jan 1 Jan. 1 January 1 Feb 2 Feb. 2 February 2 Mar 3 Mar. 3 March 3 Apr 4 Apr. 4 April 4 May 5 Jun 6 Jun. 6 June 6 Jul 7 Jul. 7 July 7 Aug 8 Aug. 8 August 8 Sep 9 Sep. 9 September 9 Sept 9 Oct 10 Oct. 10 October 10 Nov 11 Nov. 11 November 11 Dec 12 Dec. 12 December 12);%umult=qw(sec 1 second 1 min 60 minute 60 hour 3600 day 86400 week 604800 fortnight 1209600);%wdays=qw(sun 0 sunday 0 mon 1 monday 1 tue 2 tuesday 2 wed 3 wednesday 3 thu 4 thursday 4 fri 5 friday 5 sat 6 saturday 6);$y2k=946684800}my$break=qr{(?:\s+|\Z|\b(?![-:.,/]\d))};sub parsedate {my ($t,%options)=@_;my ($y,$m,$d);my ($H,$M,$S);my$tz;my$tzo;my ($rd,$rs);my$rel;my$isspec;my$now=defined($options{NOW})? $options{NOW}: time;my$passes=0;my$uk=defined($options{UK})? $options{UK}: 0;local$parse='';if ($t =~ s#^   ([ \d]\d) 
  			/ (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)
  			/ (\d\d\d\d)
  			: (\d\d)
  			: (\d\d)
  			: (\d\d)
  			(?:
  			 [ ]
  			 ([-+] \d\d\d\d)
  			  (?: \("?(?:(?:[A-Z]{1,4}[TCW56])|IDLE)\))?
  			 )?
  			 $break
  			##xi){($d,$m,$y,$H,$M,$S,$tzo)=($1,$mtable{"\u\L$2"},$3,$4,$5,$6,$7 ? &mkoff($7): ($tzo || undef));$parse .= " ".__LINE__ if$debug}elsif ($t =~ s#^(\d\d)/(\d\d)/(\d\d)\.(\d\d)\:(\d\d)($break)##){($y,$m,$d,$H,$M,$S)=($1,$2,$3,$4,$5,0);$parse .= " ".__LINE__ if$debug}else {while(1){if (!defined$m and!defined$rd and!defined$y and!($passes==0 and $options{'TIMEFIRST'})){if (&parse_date_only(\$t,\$y,\$m,\$d,$uk)){$parse .= " ".__LINE__ if$debug;next}}if (!defined$H and!defined$rs){if (&parse_time_only(\$t,\$H,\$M,\$S,\$tz,%options)){$parse .= " ".__LINE__ if$debug;next}}next if$passes==0 and $options{'TIMEFIRST'};if (!defined$y){if (&parse_year_only(\$t,\$y,$now,%options)){$parse .= " ".__LINE__ if$debug;next}}if (!defined$tz and!defined$tzo and!defined$rs and (defined$m or defined$H)){if (&parse_tz_only(\$t,\$tz,\$tzo)){$parse .= " ".__LINE__ if$debug;next}}if (!defined$H and!defined$rs){if (&parse_time_offset(\$t,\$rs,%options)){$rel=1;$parse .= " ".__LINE__ if$debug;next}}if (!defined$m and!defined$rd and!defined$y){if (&parse_date_offset(\$t,$now,\$y,\$m,\$d,\$rd,\$rs,%options)){$rel=1;$parse .= " ".__LINE__ if$debug;next}}if (defined$M or defined$rd){if ($t =~ s/^\s*(?:at|\@|\+)($break)//x){$rel=1;$parse .= " ".__LINE__ if$debug;next}}last}continue {$passes++;&debug_display($tz,$tzo,$H,$M,$S,$m,$d,$y,$rs,$rd,$rel,$passes,$parse,$t)if$debug}if ($passes==0){print "nothing matched\n" if$debug;return (undef,"no match on time/date")if wantarray();return undef}}&debug_display($tz,$tzo,$H,$M,$S,$m,$d,$y,$rs,$rd,$rel,$passes,$parse,$t)if$debug;$t =~ s/^\s+//;if ($t ne ''){print "NOT WHOLE\n" if$debug;if ($options{WHOLE}){return (undef,"characters left over after parse")if wantarray();return undef}}if (!defined$y and!defined$m and!defined$rd){print "no date defined, trying to find one." if$debug;if (defined$rs or defined$H){if ($options{DATE_REQUIRED}){return (undef,"no date specified")if wantarray();return undef}if (defined$rs){print "simple offset: $rs\n" if$debug;my$rv=$now + $rs;return ($rv,$t)if wantarray();return$rv}$rd=0}else {print "no time either!\n" if$debug;return (undef,"no time specified")if wantarray();return undef}}if ($options{TIME_REQUIRED}&&!defined($rs)&&!defined($H)&&!defined($rd)){return (undef,"no time found")if wantarray();return undef}my$secs;my$jd;if (defined$rd){if (defined$rs ||!(defined($H)|| defined($M)|| defined($S))){print "fully relative\n" if$debug;my ($j,$in,$it);my$definedrs=defined($rs)? $rs : 0;my ($isdst_now,$isdst_then);my$r=$now + $rd * 86400 + $definedrs;$isdst_now=(localtime($r))[8];$isdst_then=(localtime($now))[8];if (($isdst_now==$isdst_then)|| $options{GMT}){return ($r,$t)if wantarray();return$r}print "localtime changed DST during time period!\n" if$debug}print "relative date\n" if$debug;$jd=$options{GMT}? gm_julian_day($now): local_julian_day($now);print "jd($now) = $jd\n" if$debug;$jd += $rd}else {unless (defined$y){if ($options{PREFER_PAST}){my ($day,$mon011);($day,$mon011,$y)=(&righttime($now))[3,4,5];print "calc year -past $day-$d $mon011-$m $y\n" if$debug;$y -= 1 if ($mon011+1 < $m)|| (($mon011+1==$m)&& ($day < $d))}elsif ($options{PREFER_FUTURE}){print "calc year -future\n" if$debug;my ($day,$mon011);($day,$mon011,$y)=(&righttime($now))[3,4,5];$y += 1 if ($mon011 >= $m)|| (($mon011+1==$m)&& ($day > $d))}else {print "calc year -this\n" if$debug;$y=(localtime($now))[5]}$y += 1900}$y=expand_two_digit_year($y,$now,%options)if$y < 100;if ($options{VALIDATE}){require Time::DaysInMonth;my$dim=Time::DaysInMonth::days_in($y,$m);if ($y < 1000 or $m < 1 or $d < 1 or $y > 9999 or $m > 12 or $d > $dim){return (undef,"illegal YMD: $y, $m, $d")if wantarray();return undef}}$jd=julian_day($y,$m,$d);print "jd($y, $m, $d) = $jd\n" if$debug}if (!defined($H)){if (defined($rd)|| defined($rs)){($S,$M,$H)=&righttime($now,%options);print "HMS set to $H $M $S\n" if$debug}}my$carry;print "before ",(defined($rs)? "$rs" : "")," $jd $H $M $S\n" if$debug;$S=0 unless$S;$M=0 unless$M;$H=0 unless$H;if ($options{VALIDATE}and ($S < 0 or $M < 0 or $H < 0 or $S > 59 or $M > 59 or $H > 23)){return (undef,"illegal HMS: $H, $M, $S")if wantarray();return undef}$S += $rs if defined$rs;$carry=int($S / 60)- ($S < 0 && $S % 60 && 1);$S -= $carry * 60;$M += $carry;$carry=int($M / 60)- ($M < 0 && $M % 60 && 1);$M %= 60;$H += $carry;$carry=int($H / 24)- ($H < 0 && $H % 24 && 1);$H %= 24;$jd += $carry;print "after rs  $jd $H $M $S\n" if$debug;$secs=jd_secondsgm($jd,$H,$M,$S);print "jd_secondsgm($jd, $H, $M, $S) = $secs\n" if$debug;my$tzadj;if ($tz){$tzadj=tz_offset($tz,$secs);if (defined$tzadj){print "adjusting secs for $tz: $tzadj\n" if$debug;$tzadj=tz_offset($tz,$secs-$tzadj);$secs -= $tzadj}else {print "unknown timezone: $tz\n" if$debug;undef$secs;undef$t}}elsif (defined$tzo){print "adjusting time for offset: $tzo\n" if$debug;$secs -= $tzo}else {unless ($options{GMT}){if ($options{ZONE}){$tzadj=tz_offset($options{ZONE},$secs)|| 0;$tzadj=tz_offset($options{ZONE},$secs-$tzadj);unless (defined($tzadj)){return (undef,"could not convert '$options{ZONE}' to time offset")if wantarray();return undef}print "adjusting secs for $options{ZONE}: $tzadj\n" if$debug;$secs -= $tzadj}else {$tzadj=tz_local_offset($secs);print "adjusting secs for local offset: $tzadj\n" if$debug;$tzadj=tz_local_offset($secs-$tzadj);$secs -= $tzadj}}}print "returning $secs.\n" if$debug;return ($secs,$t)if wantarray();return$secs}sub mkoff {my($offset)=@_;if (defined$offset and $offset =~ s#^([-+])(\d\d):?(\d\d)$##){return ($1 eq '+' ? 3600 * $2 + 60 * $3 : -3600 * $2 + -60 * $3)}return undef}sub parse_tz_only {my($tr,$tz,$tzo)=@_;$$tr =~ s#^\s+##;my$o;if ($$tr =~ s#^
  			([-+]\d\d:?\d\d)
  			\s+
  			\(
  				"?
  				(?:
  					(?:
  						[A-Z]{1,4}[TCW56]
  					)
  					|
  					IDLE
  				)
  			\)
  			$break
  			##x){$$tzo=&mkoff($1);printf "matched at %d.\n",__LINE__ if$debug;return 1}elsif ($$tr =~ s#^GMT\s*([-+]\d{1,2})($break)##x){$o=$1;if ($o < 24 and $o !~ /^0/){printf "adjusted at %d. ($o 00)\n",__LINE__ if$debug;$o="${o}00"}$o =~ s/\b(\d\d\d)/0$1/;$$tzo=&mkoff($o);printf "matched at %d. ($$tzo, $o)\n",__LINE__ if$debug;return 1}elsif ($$tr =~ s#^(?:GMT\s*)?([-+]\d\d:?\d\d)($break)##x){$o=$1;$$tzo=&mkoff($o);printf "matched at %d.\n",__LINE__ if$debug;return 1}elsif ($$tr =~ s#^"?((?:[A-Z]{1,4}[TCW56])|IDLE)$break##x){$$tz=$1;$$tz .= " DST" if $$tz eq 'MET' && $$tr =~ s#^DST$break##x;printf "matched at %d: '$$tz'.\n",__LINE__ if$debug;return 1}return 0}sub parse_date_only {my ($tr,$yr,$mr,$dr,$uk)=@_;$$tr =~ s#^\s+##;if ($$tr =~ s#^(\d\d\d\d)([-./])(\d\d?)\2(\d\d?)(T|$break)##){($$yr,$$mr,$$dr)=($1,$3,$4);printf "matched at %d.\n",__LINE__ if$debug;return 1}elsif ($$tr =~ s#^(\d\d?)([-./])(\d\d?)\2(\d\d\d\d?)($break)##){if ($uk || $1>12){($$yr,$$mr,$$dr)=($4,$3,$1)}else {($$yr,$$mr,$$dr)=($4,$1,$3)}printf "matched at %d.\n",__LINE__ if$debug;return 1}elsif ($$tr =~ s#^(\d\d\d\d)/(\d\d?)$break##x){($$yr,$$mr,$$dr)=($1,$2,1);printf "matched at %d.\n",__LINE__ if$debug;return 1}elsif ($$tr =~ s#^(?xi)
  			(?:
  				(?:Mon|Monday|Tue|Tuesday|Wed|Wednesday|
  					Thu|Thursday|Fri|Friday|
  					Sat|Saturday|Sun|Sunday),?
  				\s+
  			)?
  			(\d\d?)
  			(\s+ | - | \. | /)
  			(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\.?
  			(?:
  				\2
  				(\d\d (?:\d\d)? )
  			)?
  			$break
  			##){($$yr,$$mr,$$dr)=($4,$mtable{"\u\L$3"},$1);printf "%d: %s - %s - %s\n",__LINE__,$1,$2,$3 if$debug;print "y undef\n" if ($debug &&!defined($$yr));return 1}elsif ($$tr =~ s#^(?xi)
  			(?:
  				(?:Mon|Monday|Tue|Tuesday|Wed|Wednesday|
  					Thu|Thursday|Fri|Friday|
  					Sat|Saturday|Sun|Sunday),?
  				\s+
  			)?
  			(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\.?
  			((\s)+ | - | \. | /)
  				
  			(\d\d?)
  			,?
  			(?:
  				(?: \2|\3+)
  				(\d\d (?: \d\d)?)
  			)?
  			$break
  			##){($$yr,$$mr,$$dr)=($5,$mtable{"\u\L$1"},$4);printf "%d: %s - %s - %s\n",__LINE__,$1,$2,$4 if$debug;print "y undef\n" if ($debug &&!defined($$yr));return 1}elsif ($$tr =~ s#^(?xi)
  			(January|Jan\.?|February|Feb\.?|March|Mar\.?|April|Apr\.?|May|
  			    June|Jun\.?|July|Jul\.?|August|Aug\.?|September|Sep\.?|
  			    October|Oct\.?|November|Nov\.?|December|Dec\.?)
  			\s+
  			(\d+)
  			(?:st|nd|rd|th)?
  			\,?
  			(?: 
  				\s+
  				(?:
  					(\d\d\d\d)
  					|(?:\' (\d\d))
  				)
  			)?
  			$break
  			##){($$yr,$$mr,$$dr)=($3 || $4,$mtable{"\u\L$1"},$2);printf "%d: %s - %s - %s - %s\n",__LINE__,$1,$2,$3,$4 if$debug;print "y undef\n" if ($debug &&!defined($$yr));printf "matched at %d.\n",__LINE__ if$debug;return 1}elsif ($$tr =~ s#^(\d\d?)([-/.])(\d\d?)\2(\d\d?)($break)##x){if ($1 > 31 || (!$uk && $1 > 12 && $4 < 32)){($$yr,$$mr,$$dr)=($1,$3,$4)}elsif ($1 > 12 || $uk){($$yr,$$mr,$$dr)=($4,$3,$1)}else {($$yr,$$mr,$$dr)=($4,$1,$3)}printf "matched at %d.\n",__LINE__ if$debug;return 1}elsif ($$tr =~ s#^(\d\d?)/(\d\d?)($break)##x){if ($1 > 31 || (!$uk && $1 > 12)){($$yr,$$mr,$$dr)=($1,$2,1)}elsif ($2 > 31 || ($uk && $2 > 12)){($$yr,$$mr,$$dr)=($2,$1,1)}elsif ($1 > 12 || $uk){($$mr,$$dr)=($2,$1)}else {($$mr,$$dr)=($1,$2)}printf "matched at %d.\n",__LINE__ if$debug;return 1}elsif ($$tr =~ s#^(\d\d)(\d\d)(\d\d)($break)##x){if ($1 > 31 || (!$uk && $1 > 12)){($$yr,$$mr,$$dr)=($1,$2,$3)}elsif ($1 > 12 || $uk){($$yr,$$mr,$$dr)=($3,$2,$1)}else {($$yr,$$mr,$$dr)=($3,$1,$2)}printf "matched at %d.\n",__LINE__ if$debug;return 1}elsif ($$tr =~ s#^(?xi)
  			(\d{1,2})
  			(\s+ | - | \. | /)
  			(January|Jan\.?|February|Feb\.?|March|Mar\.?|April|Apr\.?|May|
  			    June|Jun\.?|July|Jul\.?|August|Aug\.?|September|Sep\.?|
  			    October|Oct\.?|November|Nov\.?|December|Dec\.?)
  			(?:
  				\2
  				(
  					\d\d
  					(?:\d\d)?
  				)
  			)
  			$break
  			##){($$yr,$$mr,$$dr)=($4,$mtable{"\u\L$3"},$1);printf "matched at %d.\n",__LINE__ if$debug;return 1}elsif ($$tr =~ s#^(?xi)
  			(\d+)
  			(?:st|nd|rd|th)?
  			\s+
  			(January|Jan\.?|February|Feb\.?|March|Mar\.?|April|Apr\.?|May|
  			    June|Jun\.?|July|Jul\.?|August|Aug\.?|September|Sep\.?|
  			    October|Oct\.?|November|Nov\.?|December|Dec\.?)
  			(?: 
  				\,?
  				\s+
  				(\d\d\d\d)
  			)?
  			$break
  			##){($$yr,$$mr,$$dr)=($3,$mtable{"\u\L$2"},$1);printf "%d: %s - %s - %s - %s\n",__LINE__,$1,$2,$3,$4 if$debug;print "y undef\n" if ($debug &&!defined($$yr));printf "matched at %d.\n",__LINE__ if$debug;return 1}return 0}sub parse_time_only {my ($tr,$hr,$mr,$sr,$tzr,%options)=@_;$$tr =~ s#^\s+##;if ($$tr =~ s!^(?x)
  			(?:
  				(?:
  					([012]\d)		(?# $1)
  					(?:
  						([0-5]\d) 	(?# $2)
  						(?:
  						    ([0-5]\d)	(?# $3)
  						)?
  					)
  					\s*
  					([apAP][mM])?  		(?# $4)
  				) | (?:
  					(\d{1,2}) 		(?# $5)
  					(?:
  						\:
  						(\d\d)		(?# $6)
  						(?:
  							\:
  							(\d\d)	(?# $7)
  								(
  									(?# don't barf on database sub-second timings)
  									[:.,]
  									\d+
  								)?	(?# $8)
  						)?
  					)
  					\s*
  					([apAP][mM])?		(?# $9)
  				) | (?:
  					(\d{1,2})		(?# $10)
  					([apAP][mM])		(?# ${11})
  				)
  			)
  			(?:
  				\s+
  				"?
  				(				(?# ${12})
  					(?: [A-Z]{1,4}[TCW56] )
  					|
  					IDLE
  				)	
  			)?
  			$break
  			!!){my$ampm;$$hr=$1 || $5 || $10 || 0;$$mr=$2 || $6 || 0;$$sr=$3 || $7 || 0;if (defined($8)&& exists($options{SUBSECOND})&& $options{SUBSECOND}){my($frac)=$8;substr($frac,0,1)='.';$$sr += $frac}print "S = $$sr\n" if$debug;$ampm=$4 || $9 || $11 || '';$$tzr=$12;$$hr += 12 if$ampm and "\U$ampm" eq "PM" && $$hr!=12;$$hr=0 if $$hr==12 && "\U$ampm" eq "AM";printf "matched at %d, rem = %s.\n",__LINE__,$$tr if$debug;return 1}elsif ($$tr =~ s#^noon$break##ix){($$hr,$$mr,$$sr)=(12,0,0);printf "matched at %d.\n",__LINE__ if$debug;return 1}elsif ($$tr =~ s#^midnight$break##ix){($$hr,$$mr,$$sr)=(0,0,0);printf "matched at %d.\n",__LINE__ if$debug;return 1}return 0}sub parse_time_offset {my ($tr,$rsr,%options)=@_;$$tr =~ s/^\s+//;return 0 if$options{NO_RELATIVE};if ($$tr =~ s{^(?xi)					
  			(?:
  				(-)				(?# 1)
  				|
  				[+]
  			)?
  			\s*
  			(?:
  				(\d+(?:\.\d+)?) 		(?# 2)
  				| 		
  				(?:(\d+)\s+(\d+)/(\d+))		(?# 3 4/5)
  			)
  			\s*
  			(sec|second|min|minute|hour)s?		(?# 6)
  			(
  				\s+
  				ago				(?# 7)
  			)?
  			$break
  			}{}){$$rsr=0 unless defined $$rsr;return 0 if defined($5)&& $5==0;my$num=defined($2)? $2 : $3 + $4/$5;$num=-$num if $1;$$rsr += $umult{"\L$6"}* $num;$$rsr=-$$rsr if $7 || $$tr =~ /\b(day|mon|month|year)s?\s*ago\b/;printf "matched at %d.\n",__LINE__ if$debug;return 1}return 0}sub expand_two_digit_year {my ($yr,$now,%options)=@_;return$yr if$yr > 100;my ($y)=(&righttime($now,%options))[5];$y += 1900;my$century=int($y / 100)* 100;my$within=$y % 100;my$r=$yr + $century;if ($options{PREFER_PAST}){if ($yr > $within){$r=$yr + $century - 100}}elsif ($options{PREFER_FUTURE}){if ($yr < $within-20){$r=$yr + $century + 100}}elsif ($options{UNAMBIGUOUS}){return undef}else {if ($within > 80 && $within - $yr > 60){$r=$yr + $century + 100}if ($within < 30 && $yr - $within > 59){$r=$yr + $century - 100}}print "two digit year '$yr' expanded into $r\n" if$debug;return$r}sub calc {my ($rsr,$yr,$mr,$dr,$rdr,$now,$units,$count,%options)=@_;confess unless$units;$units="\L$units";print "calc based on $units\n" if$debug;if ($units eq 'day'){$$rdr=$count}elsif ($units eq 'week'){$$rdr=$count * 7}elsif ($umult{$units}){$$rsr=$count * $umult{$units}}elsif ($units eq 'mon' || $units eq 'month'){($$yr,$$mr,$$dr)=&monthoff($now,$count,%options);$$rsr=0 unless $$rsr}elsif ($units eq 'year'){($$yr,$$mr,$$dr)=&monthoff($now,$count * 12,%options);$$rsr=0 unless $$rsr}else {carp "interal error"}print "calced rsr $$rsr rdr $$rdr, yr $$yr mr $$mr dr $$dr.\n" if$debug}sub monthoff {my ($now,$months,%options)=@_;my ($d,$m11,$y)=(&righttime($now,%options))[3,4,5 ];$y += 1900;print "m11 = $m11 + $months, y = $y\n" if$debug;$m11 += $months;print "m11 = $m11, y = $y\n" if$debug;if ($m11 > 11 || $m11 < 0){$y -= 1 if$m11 < 0 && ($m11 % 12!=0);$y += int($m11/12);no integer;$m11 %= 12}print "m11 = $m11, y = $y\n" if$debug;if ($d > 30 or ($d > 28 && $m11==1)){require Time::DaysInMonth;my$dim=Time::DaysInMonth::days_in($y,$m11+1);print "dim($y,$m11+1)= $dim\n" if$debug;$d=$dim if$d > $dim}return ($y,$m11+1,$d)}sub righttime {my ($time,%options)=@_;if ($options{GMT}){return gmtime($time)}else {return localtime($time)}}sub parse_year_only {my ($tr,$yr,$now,%options)=@_;$$tr =~ s#^\s+##;if ($$tr =~ s#^(\d\d\d\d)$break##){$$yr=$1;printf "matched at %d.\n",__LINE__ if$debug;return 1}elsif ($$tr =~ s#\'(\d\d)$break##){$$yr=expand_two_digit_year($1,$now,%options);printf "matched at %d.\n",__LINE__ if$debug;return 1}return 0}sub parse_date_offset {my ($tr,$now,$yr,$mr,$dr,$rdr,$rsr,%options)=@_;return 0 if$options{NO_RELATIVE};my$j;my$wday=(&righttime($now,%options))[6];$$tr =~ s#^\s+##;if ($$tr =~ s#^(?xi)
  			\s*
  			(\d+)
  			\s*
  			(day|week|month|year)s?
  			(
  				\s+
  				ago
  			)?
  			$break
  			##){my$amt=$1 + 0;my$units=$2;$amt=-$amt if $3 || $$tr =~ m#\b(sec|second|min|minute|hour)s?\s*ago\b#;&calc($rsr,$yr,$mr,$dr,$rdr,$now,$units,$amt,%options);printf "matched at %d.\n",__LINE__ if$debug;return 1}elsif ($$tr =~ s#^(?xi)
  			(?:
  				(?:
  					now
  					\s+
  				)?
  				(\+ | \-)
  				\s*
  			)?
  			(\d+)
  			\s*
  			(day|week|month|year)s?
  			$break
  			##){my$one=$1 || '';my$two=$2 || '';my$amt="$one$two"+0;&calc($rsr,$yr,$mr,$dr,$rdr,$now,$3,$amt,%options);printf "matched at %d.\n",__LINE__ if$debug;return 1}elsif ($$tr =~ s#^(?xi)
  			(Mon|Tue|Wed|Thu|Fri|Sat|Sun|Monday|Tuesday
  				|Wednesday|Thursday|Friday|Saturday|Sunday)
  			\s+
  			after
  			\s+
  			next
  			$break
  			##){$$rdr=$wdays{"\L$1"}- $wday + ($wdays{"\L$1"}> $wday ? 7 : 14);printf "matched at %d.\n",__LINE__ if$debug;return 1}elsif ($$tr =~ s#^(?xi)
  			(Mon|Tue|Wed|Thu|Fri|Sat|Sun|Monday|Tuesday
  				|Wednesday|Thursday|Friday|Saturday|Sunday)
  			\s+
  			before
  			\s+
  			last
  			$break
  			##){$$rdr=$wdays{"\L$1"}- $wday - ($wdays{"\L$1"}< $wday ? 7 : 14);printf "matched at %d.\n",__LINE__ if$debug;return 1}elsif ($$tr =~ s#^(?xi)
  			next\s+
  			(Mon|Tue|Wed|Thu|Fri|Sat|Sun|Monday|Tuesday
  				|Wednesday|Thursday|Friday|Saturday|Sunday)
  			$break
  			##){$$rdr=$wdays{"\L$1"}- $wday + ($wdays{"\L$1"}> $wday ? 0 : 7);printf "matched at %d.\n",__LINE__ if$debug;return 1}elsif ($$tr =~ s#^(?xi)
  			last\s+
  			(Mon|Tue|Wed|Thu|Fri|Sat|Sun|Monday|Tuesday
  				|Wednesday|Thursday|Friday|Saturday|Sunday)
  			$break##){printf "c %d - %d + ( %d < %d ? 0 : -7 \n",$wdays{"\L$1"},$wday,$wdays{"\L$1"},$wday if$debug;$$rdr=$wdays{"\L$1"}- $wday + ($wdays{"\L$1"}< $wday ? 0 : -7);printf "matched at %d.\n",__LINE__ if$debug;return 1}elsif ($options{PREFER_PAST}and $$tr =~ s#^(?xi)
  			(Mon|Tue|Wed|Thu|Fri|Sat|Sun|Monday|Tuesday
  				|Wednesday|Thursday|Friday|Saturday|Sunday)
  			$break##){printf "c %d - %d + ( %d < %d ? 0 : -7 \n",$wdays{"\L$1"},$wday,$wdays{"\L$1"},$wday if$debug;$$rdr=$wdays{"\L$1"}- $wday + ($wdays{"\L$1"}< $wday ? 0 : -7);printf "matched at %d.\n",__LINE__ if$debug;return 1}elsif ($options{PREFER_FUTURE}and $$tr =~ s#^(?xi)
  			(Mon|Tue|Wed|Thu|Fri|Sat|Sun|Monday|Tuesday
  				|Wednesday|Thursday|Friday|Saturday|Sunday)
  			$break
  			##){$$rdr=$wdays{"\L$1"}- $wday + ($wdays{"\L$1"}> $wday ? 0 : 7);printf "matched at %d.\n",__LINE__ if$debug;return 1}elsif ($$tr =~ s#^today$break##xi){$$rdr=0;printf "matched at %d.\n",__LINE__ if$debug;return 1}elsif ($$tr =~ s#^tomorrow$break##xi){$$rdr=1;printf "matched at %d.\n",__LINE__ if$debug;return 1}elsif ($$tr =~ s#^yesterday$break##xi){$$rdr=-1;printf "matched at %d.\n",__LINE__ if$debug;return 1}elsif ($$tr =~ s#^last\s+(week|month|year)$break##xi){&calc($rsr,$yr,$mr,$dr,$rdr,$now,$1,-1,%options);printf "matched at %d.\n",__LINE__ if$debug;return 1}elsif ($$tr =~ s#^next\s+(week|month|year)$break##xi){&calc($rsr,$yr,$mr,$dr,$rdr,$now,$1,1,%options);printf "matched at %d.\n",__LINE__ if$debug;return 1}elsif ($$tr =~ s#^now $break##x){$$rdr=0;return 1}return 0}sub debug_display {my ($tz,$tzo,$H,$M,$S,$m,$d,$y,$rs,$rd,$rel,$passes,$parse,$t)=@_;print "---------<<\n";print defined($tz)? "tz: $tz.\n" : "no tz\n";print defined($tzo)? "tzo: $tzo.\n" : "no tzo\n";print "HMS: ";print defined($H)? "$H, " : "no H, ";print defined($M)? "$M, " : "no M, ";print defined($S)? "$S\n" : "no S.\n";print "mdy: ";print defined($m)? "$m, " : "no m, ";print defined($d)? "$d, " : "no d, ";print defined($y)? "$y\n" : "no y.\n";print defined($rs)? "rs: $rs.\n" : "no rs\n";print defined($rd)? "rd: $rd.\n" : "no rd\n";print$rel ? "relative\n" : "not relative\n";print "passes: $passes\n";print "parse:$parse\n";print "t: $t.\n";print "--------->>\n"}1;
TIME_PARSEDATE

$fatpacked{"Time/Timezone.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TIME_TIMEZONE';
  package Time::Timezone;require 5.002;require Exporter;@ISA=qw(Exporter);@EXPORT=qw(tz2zone tz_local_offset tz_offset tz_name);@EXPORT_OK=qw();use Carp;use strict;use vars qw($VERSION);$VERSION=2015.0925;sub tz2zone {my($TZ,$time,$isdst)=@_;use vars qw(%tzn_cache);$TZ=defined($ENV{'TZ'})? ($ENV{'TZ'}? $ENV{'TZ'}: 'GMT'): '' unless$TZ;if (!defined$isdst){my$j;$time=time()unless defined$time;($j,$j,$j,$j,$j,$j,$j,$j,$isdst)=localtime($time)}if (defined$tzn_cache{$TZ}->[$isdst]){return$tzn_cache{$TZ}->[$isdst]}if ($TZ =~ /^
  		    ( [^:\d+\-,] {3,} )
  		    ( [+-] ?
  		      \d {1,2}
  		      ( : \d {1,2} ) {0,2} 
  		    )
  		    ( [^\d+\-,] {3,} )?
  		    /x){$TZ=$isdst ? $4 : $1;$tzn_cache{$TZ}=[$1,$4 ]}else {$tzn_cache{$TZ}=[$TZ,$TZ ]}return$TZ}sub tz_local_offset {my ($time)=@_;$time=time()unless defined$time;return&calc_off($time)}sub calc_off {my ($time)=@_;my (@l)=localtime($time);my (@g)=gmtime($time);my$off;$off=$l[0]- $g[0]+ ($l[1]- $g[1])* 60 + ($l[2]- $g[2])* 3600;if ($l[7]==$g[7]){}elsif ($l[7]==$g[7]+ 1){$off += 86400}elsif ($l[7]==$g[7]- 1){$off -= 86400}elsif ($l[7]< $g[7]){$off += 86400}else {$off -= 86400}return$off}CONFIG: {use vars qw(%dstZone %zoneOff %dstZoneOff %Zone);%dstZone=("brst"=>-2*3600,"adt"=>-3*3600,"edt"=>-4*3600,"cdt"=>-5*3600,"mdt"=>-6*3600,"pdt"=>-7*3600,"ydt"=>-8*3600,"hdt"=>-9*3600,"bst"=>+1*3600,"mest"=>+2*3600,"met dst"=>+2*3600,"sst"=>+2*3600,"fst"=>+2*3600,"eest"=>+3*3600,"cest"=>+2*3600,"wadt"=>+8*3600,"kdt"=>+10*3600,"eadt"=>+11*3600,"nzdt"=>+13*3600,);%Zone=("gmt"=>0,"ut"=>0,"utc"=>0,"wet"=>0,"wat"=>-1*3600,"azost"=>-1*3600,"cvt"=>-1*3600,"at"=>-2*3600,"fnt"=>-2*3600,"ndt"=>-2*3600-1800,"art"=>-3*3600,"nft"=>-3*3600-1800,"mnt"=>-4*3600,"ewt"=>-4*3600,"ast"=>-4*3600,"bot"=>-4*3600,"vet"=>-4*3600,"est"=>-5*3600,"cot"=>-5*3600,"act"=>-5*3600,"pet"=>-5*3600,"cst"=>-6*3600,"cest"=>+2*3600,"mst"=>-7*3600,"pst"=>-8*3600,"yst"=>-9*3600,"hst"=>-10*3600,"cat"=>-10*3600,"ahst"=>-10*3600,"taht"=>-10*3600,"nt"=>-11*3600,"idlw"=>-12*3600,"cet"=>+1*3600,"mez"=>+1*3600,"met"=>+1*3600,"mewt"=>+1*3600,"swt"=>+1*3600,"set"=>+1*3600,"fwt"=>+1*3600,"west"=>+1*3600,"eet"=>+2*3600,"ukr"=>+2*3600,"sast"=>+2*3600,"bt"=>+3*3600,"eat"=>+3*3600,"irst"=>+3*3600+1800,"zp4"=>+4*3600,"msd"=>+4*3600,"sct"=>+4*3600,"zp5"=>+5*3600,"azst"=>+5*3600,"mvt"=>+5*3600,"uzt"=>+5*3600,"ist"=>+5*3600+1800,"zp6"=>+6*3600,"lkt"=>+6*3600,"pkst"=>+6*3600,"yekst"=>+6*3600,"wast"=>+7*3600,"ict"=>+7*3600,"wit"=>+7*3600,"cct"=>+8*3600,"wst"=>+8*3600,"hkt"=>+8*3600,"bnt"=>+8*3600,"cit"=>+8*3600,"myt"=>+8*3600,"pht"=>+8*3600,"sgt"=>+8*3600,"jst"=>+9*3600,"kst"=>+9*3600,"east"=>+10*3600,"gst"=>+10*3600,"nct"=>+11*3600,"nzt"=>+12*3600,"nzst"=>+12*3600,"fjt"=>+12*3600,"idle"=>+12*3600,);%zoneOff=reverse(%Zone);%dstZoneOff=reverse(%dstZone);$zoneOff{0}='gmt';$dstZoneOff{3600}='bst'}sub tz_offset {my ($zone,$time)=@_;return&tz_local_offset()unless($zone);$time=time()unless defined$time;my(@l)=localtime($time);my$dst=$l[8];$zone=lc$zone;if ($zone =~ /^([\-\+]\d{3,4})$/){my$sign=$1 < 0 ? -1 : 1 ;my$v=abs(0 + $1);return$sign * 60 * (int($v / 100)* 60 + ($v % 100))}elsif (exists$dstZone{$zone}&& ($dst ||!exists$Zone{$zone})){return$dstZone{$zone}}elsif(exists$Zone{$zone}){return$Zone{$zone}}undef}sub tz_name {my ($off,$time)=@_;$time=time()unless defined$time;my(@l)=localtime($time);my$dst=$l[8];if (exists$dstZoneOff{$off}&& ($dst ||!exists$zoneOff{$off})){return$dstZoneOff{$off}}elsif (exists$zoneOff{$off}){return$zoneOff{$off}}sprintf("%+05d",int($off / 60)* 100 + $off % 60)}1;
TIME_TIMEZONE

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny;use 5.006;our$VERSION='0.31';use strict;use warnings;use Exporter 5.57 'import';our@EXPORT=our@EXPORT_OK=qw(try catch finally);use Carp;$Carp::Internal{+__PACKAGE__}++;BEGIN {my$su=$INC{'Sub/Util.pm'}&& defined&Sub::Util::set_subname;my$sn=$INC{'Sub/Name.pm'}&& eval {Sub::Name->VERSION(0.08)};unless ($su || $sn){$su=eval {require Sub::Util}&& defined&Sub::Util::set_subname;unless ($su){$sn=eval {require Sub::Name;Sub::Name->VERSION(0.08)}}}*_subname=$su ? \&Sub::Util::set_subname : $sn ? \&Sub::Name::subname : sub {$_[1]};*_HAS_SUBNAME=($su || $sn)? sub(){1}: sub(){0}}my%_finally_guards;sub try (&;@) {my ($try,@code_refs)=@_;my$wantarray=wantarray;my ($catch,@finally)=();for my$code_ref (@code_refs){if (ref($code_ref)eq 'Try::Tiny::Catch'){croak 'A try() may not be followed by multiple catch() blocks' if$catch;$catch=${$code_ref}}elsif (ref($code_ref)eq 'Try::Tiny::Finally'){push@finally,${$code_ref}}else {croak('try() encountered an unexpected argument (' .(defined$code_ref ? $code_ref : 'undef').') - perhaps a missing semi-colon before or')}}_subname(caller().'::try {...} '=>$try)if _HAS_SUBNAME;local$_finally_guards{guards}=[map Try::Tiny::ScopeGuard->_new($_),@finally ];my$prev_error=$@;my (@ret,$error);my$failed=not eval {$@=$prev_error;if ($wantarray){@ret=$try->()}elsif (defined$wantarray){$ret[0]=$try->()}else {$try->()};return 1};$error=$@;$@=$prev_error;if ($failed){push @$_,$error for @{$_finally_guards{guards}};if ($catch){for ($error){return$catch->($error)}}return}else {return$wantarray ? @ret : $ret[0]}}sub catch (&;@) {my ($block,@rest)=@_;croak 'Useless bare catch()' unless wantarray;_subname(caller().'::catch {...} '=>$block)if _HAS_SUBNAME;return (bless(\$block,'Try::Tiny::Catch'),@rest,)}sub finally (&;@) {my ($block,@rest)=@_;croak 'Useless bare finally()' unless wantarray;_subname(caller().'::finally {...} '=>$block)if _HAS_SUBNAME;return (bless(\$block,'Try::Tiny::Finally'),@rest,)}{package Try::Tiny::ScopeGuard;use constant UNSTABLE_DOLLARAT=>("$]" < '5.013002')? 1 : 0;sub _new {shift;bless [@_ ]}sub DESTROY {my ($code,@args)=@{$_[0]};local $@ if UNSTABLE_DOLLARAT;eval {$code->(@args);1}or do {warn "Execution of finally() block $code resulted in an exception, which " .'*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. ' .'Your program will continue as if this event never took place. ' ."Original exception text follows:\n\n" .(defined $@ ? $@ : '$@ left undefined...')."\n" }}}__PACKAGE__ 
TRY_TINY

$fatpacked{"XS/Parse/Infix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'XS_PARSE_INFIX';
  package XS::Parse::Infix 0.23;use v5.14;use warnings;require XS::Parse::Keyword;sub B::Deparse::_deparse_infix_wrapperfunc_scalarscalar {my ($self,$wrapper_func_name,$op,$ctx)=@_;my$lhs=$op->first;my$rhs=$op->last;$_=$self->deparse($_,6)for$lhs,$rhs;return "$wrapper_func_name($lhs, $rhs)"}sub B::Deparse::_deparse_infix_wrapperfunc_listlist {my ($self,$wrapper_func_name,$op,$ctx)=@_;my$lhs=$op->first;my$rhs=$op->last;for my$var (\$lhs,\$rhs){my$argop=$$var;my$kid;if($argop->name eq "null" and $argop->first->name eq "pushmark" and ($kid=$argop->first->sibling)and B::Deparse::null($kid->sibling)){my$add_refgen;if($kid->name eq "rv2av" and $kid->first->name ne "gv"){$argop=$kid->first}elsif($kid->name eq "padav" or $kid->name eq "rv2av"){$add_refgen++}else {print STDERR "Maybe UNWRAP list ${\ $kid->name }\n"}$$var=$self->deparse($argop,6);$$var="\\$$var" if$add_refgen}else {my@args;$argop=$argop->first->sibling;while(not B::Deparse::null($argop)){push@args,$self->deparse($argop,6);$argop=$argop->sibling}$$var="[" .join(", ",@args)."]"}}return "$wrapper_func_name($lhs, $rhs)"}sub B::Deparse::_deparse_infix_named {my ($self,$opname,$op,$ctx)=@_;my$lhs=$op->first;my$rhs=$op->last;return join " ",$self->deparse_binop_left($op,$lhs,14),$opname,$self->deparse_binop_right($op,$rhs,14)}0x55AA;
XS_PARSE_INFIX

$fatpacked{"XS/Parse/Infix/Builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'XS_PARSE_INFIX_BUILDER';
  package XS::Parse::Infix::Builder 0.23;use v5.14;use warnings;require XS::Parse::Infix::Builder_data;sub write_XSParseInfix_h {shift;open my$out,">","XSParseInfix.h" or die "Cannot open XSParseInfix.h for writing - $!\n";$out->print(XS::Parse::Infix::Builder_data->XSPARSEINFIX_H)}sub extra_compiler_flags {shift;return "-I.",XS::Parse::Infix::Builder_data->BUILDER_CFLAGS}sub extend_module_build {my$self=shift;my ($build)=@_;eval {$self->write_XSParseInfix_h}or do {warn $@;return};my@flags=@{$build->extra_compiler_flags};push@flags,$self->extra_compiler_flags;$build->extra_compiler_flags(@flags)}0x55AA;
XS_PARSE_INFIX_BUILDER

$fatpacked{"XS/Parse/Infix/Builder_data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'XS_PARSE_INFIX_BUILDER_DATA';
  package XS::Parse::Infix::Builder_data 0.23;use v5.14;use warnings;use constant BUILDER_CFLAGS=>;my$XSParseInfix_h=do {local $/;readline DATA};sub XSPARSEINFIX_H() {$XSParseInfix_h}0x55AA;__DATA__ #ifndef __XS_PARSE_INFIX_H__
  #define __XS_PARSE_INFIX_H__
  
  #define XSPARSEINFIX_ABI_VERSION 1
  
  /* Infix operator classifications */
  /* No built-in operators use the _MISC categories, but they are provided for
   * custom infix operators to use so they are still found by selections */
  enum XSParseInfixClassification {
    XPI_CLS_NONE = 0,
    XPI_CLS_PREDICATE,   /* any boolean-returning operator */
    XPI_CLS_RELATION,    /*  ... any predicate that is typewise symmetric */
    XPI_CLS_EQUALITY,    /*      ... any relation that is true for (x == x) and false otherwise */
    XPI_CLS_SMARTMATCH,  /*  ... the predicate smartmatch (~~) */
    XPI_CLS_MATCHRE,     /*  ... the predicate regexp match (=~) */
    XPI_CLS_ISA,         /*  ... the predicate instance of (isa) */
    XPI_CLS_MATCH_MISC,  /*  ... any other match-like predicate */
    XPI_CLS_ORDERING,    /* cmp or <=> */
  };
  
  enum XSParseInfixSelection {
    XPI_SELECT_ANY,
    XPI_SELECT_PREDICATE, /* any predicate */
    XPI_SELECT_RELATION,  /* any relation */
    XPI_SELECT_EQUALITY,  /* any equality */
    XPI_SELECT_ORDERING,  /* any ordering */
  
    XPI_SELECT_MATCH_NOSMART, /* any equality or other match operator, including smartmatch */
    XPI_SELECT_MATCH_SMART,   /* any equality or other match operator, not including smartmatch */
  };
  
  /* lhs_flags, rhs_flags */
  enum {
    XPI_OPERAND_TERM = 0, /* the "default" termexpr with no context */
    /* other space reserved for other scalar types */
    XPI_OPERAND_TERM_LIST = 6, /* term in list context */
    XPI_OPERAND_LIST      = 7, /* list in list context */
  
    /* Other bitflags */
    XPI_OPERAND_ONLY_LOOK = (1<<3),
  };
  
  struct XSParseInfixHooks {
    U16 flags;
    U8 lhs_flags, rhs_flags;
    enum XSParseInfixClassification cls;
  
    const char *wrapper_func_name;
  
    /* These two hooks are ANDed together; both must pass, if present */
    const char *permit_hintkey;
    bool (*permit) (pTHX_ void *hookdata);
  
    /* These hooks are alternatives; the first one defined is used */
    OP *(*new_op)(pTHX_ U32 flags, OP *lhs, OP *rhs, void *hookdata);
    OP *(*ppaddr)(pTHX); /* A pp func used directly in newBINOP_custom() */
  };
  
  struct XSParseInfixInfo {
    const char *opname;
    OPCODE opcode;
  
    const struct XSParseInfixHooks *hooks;
    void *hookdata;
  };
  
  static OP *(*xs_parse_infix_new_op_func)(pTHX_ const struct XSParseInfixInfo *info, U32 flags, OP *lhs, OP *rhs);
  #define xs_parse_infix_new_op(info, flags, lhs, rhs)  S_xs_parse_infix_new_op(aTHX_ info, flags, lhs, rhs)
  static OP *S_xs_parse_infix_new_op(pTHX_ const struct XSParseInfixInfo *info, U32 flags, OP *lhs, OP *rhs)
  {
    if(!xs_parse_infix_new_op_func)
      croak("Must call boot_xs_parse_infix() first");
  
    return (*xs_parse_infix_new_op_func)(aTHX_ info, flags, lhs, rhs);
  }
  
  static void (*register_xs_parse_infix_func)(pTHX_ const char *kw, const struct XSParseInfixHooks *hooks, void *hookdata);
  #define register_xs_parse_infix(opname, hooks, hookdata)  S_register_xs_parse_infix(aTHX_ opname, hooks, hookdata)
  static void S_register_xs_parse_infix(pTHX_ const char *opname, const struct XSParseInfixHooks *hooks, void *hookdata)
  {
    if(!register_xs_parse_infix_func)
      croak("Must call boot_xs_parse_infix() first");
  
    return (*register_xs_parse_infix_func)(aTHX_ opname, hooks, hookdata);
  }
  
  #define boot_xs_parse_infix(ver) S_boot_xs_parse_infix(aTHX_ ver)
  static void S_boot_xs_parse_infix(pTHX_ double ver) {
    SV **svp;
    SV *versv = ver ? newSVnv(ver) : NULL;
  
    /* XS::Parse::Infix is implemented in XS::Parse::Keyword's .so file */
    load_module(PERL_LOADMOD_NOIMPORT, newSVpvs("XS::Parse::Keyword"), versv, NULL);
  
    svp = hv_fetchs(PL_modglobal, "XS::Parse::Infix/ABIVERSION_MIN", 0);
    if(!svp)
      croak("XS::Parse::Infix ABI minimum version missing");
    int abi_ver = SvIV(*svp);
    if(abi_ver > XSPARSEINFIX_ABI_VERSION)
      croak("XS::Parse::Infix ABI version mismatch - library supports >= %d, compiled for %d",
          abi_ver, XSPARSEINFIX_ABI_VERSION);
  
    svp = hv_fetchs(PL_modglobal, "XS::Parse::Infix/ABIVERSION_MAX", 0);
    abi_ver = SvIV(*svp);
    if(abi_ver < XSPARSEINFIX_ABI_VERSION)
      croak("XS::Parse::Infix ABI version mismatch - library supports <= %d, compiled for %d",
          abi_ver, XSPARSEINFIX_ABI_VERSION);
  
    xs_parse_infix_new_op_func = INT2PTR(OP *(*)(pTHX_ const struct XSParseInfixInfo *, U32, OP *, OP *),
        SvUV(*hv_fetchs(PL_modglobal, "XS::Parse::Infix/new_op()@0", 0)));
    register_xs_parse_infix_func = INT2PTR(void (*)(pTHX_ const char *, const struct XSParseInfixHooks *, void *),
        SvUV(*hv_fetchs(PL_modglobal, "XS::Parse::Infix/register()@1", 0)));
  }
  
  #endif
XS_PARSE_INFIX_BUILDER_DATA

$fatpacked{"XS/Parse/Keyword.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'XS_PARSE_KEYWORD';
  package XS::Parse::Keyword 0.23;use v5.14;use warnings;require XSLoader;XSLoader::load(__PACKAGE__,our$VERSION);0x55AA;
XS_PARSE_KEYWORD

$fatpacked{"XS/Parse/Keyword/Builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'XS_PARSE_KEYWORD_BUILDER';
  package XS::Parse::Keyword::Builder 0.23;use v5.14;use warnings;require XS::Parse::Keyword::Builder_data;sub write_XSParseKeyword_h {shift;open my$out,">","XSParseKeyword.h" or die "Cannot open XSParseKeyword.h for writing - $!\n";$out->print(XS::Parse::Keyword::Builder_data->XSPARSEKEYWORD_H)}sub extra_compiler_flags {shift;return "-I.",XS::Parse::Keyword::Builder_data->BUILDER_CFLAGS}sub extend_module_build {my$self=shift;my ($build)=@_;eval {$self->write_XSParseKeyword_h}or do {warn $@;return};my@flags=@{$build->extra_compiler_flags};push@flags,$self->extra_compiler_flags;$build->extra_compiler_flags(@flags)}0x55AA;
XS_PARSE_KEYWORD_BUILDER

$fatpacked{"XS/Parse/Keyword/Builder_data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'XS_PARSE_KEYWORD_BUILDER_DATA';
  package XS::Parse::Keyword::Builder_data 0.23;use v5.14;use warnings;use constant BUILDER_CFLAGS=>;my$XSParseKeyword_h=do {local $/;readline DATA};sub XSPARSEKEYWORD_H() {$XSParseKeyword_h}0x55AA;__DATA__ #ifndef __XS_PARSE_KEYWORD_H__
  #define __XS_PARSE_KEYWORD_H__
  
  #define XSPARSEKEYWORD_ABI_VERSION 2
  
  struct XSParseKeywordPieceType;
  struct XSParseKeywordPieceType {
    int type;
    union {
      char                                  c;      /* LITERALCHAR */
      const char                           *str;    /* LITERALSTR */
      const struct XSParseKeywordPieceType *pieces; /* SCOPEs */
      void                                (*callback)(pTHX_ void *hookdata); /* SETUP */
    } u;
  };
  
  enum {
    XPK_FLAG_EXPR     = (1<<0),
    XPK_FLAG_STMT     = (1<<1),
    XPK_FLAG_AUTOSEMI = (1<<2),
  };
  
  enum {
    /* skip zero */
  
    /*                                    emits */
    XS_PARSE_KEYWORD_LITERALCHAR = 1,   /* nothing */
    XS_PARSE_KEYWORD_LITERALSTR,        /* nothing */
    XS_PARSE_KEYWORD_AUTOSEMI,          /* nothing */
    XS_PARSE_KEYWORD_FAILURE = 0x0f,    /* nothing */
  
    XS_PARSE_KEYWORD_BLOCK = 0x10,      /* op */
    XS_PARSE_KEYWORD_ANONSUB,           /* cv */
    XS_PARSE_KEYWORD_ARITHEXPR,         /* op */
    XS_PARSE_KEYWORD_TERMEXPR,          /* op */
    XS_PARSE_KEYWORD_LISTEXPR,          /* op */
    /* TODO: XS_PARSE_KEYWORD_FULLEXPR = 0x15 */
    XS_PARSE_KEYWORD_IDENT = 0x16,      /* sv */
    XS_PARSE_KEYWORD_PACKAGENAME,       /* sv */
    XS_PARSE_KEYWORD_LEXVARNAME,        /* sv */
    XS_PARSE_KEYWORD_LEXVAR,            /* padix */
    XS_PARSE_KEYWORD_ATTRS,             /* i / {attr.name + attr.val} */
    XS_PARSE_KEYWORD_VSTRING,           /* sv */
  
    XS_PARSE_KEYWORD_INFIX = 0x40,      /* infix */
  
    XS_PARSE_KEYWORD_SETUP = 0x70,      /* invokes callback, emits nothing */
  
    XS_PARSE_KEYWORD_SEQUENCE = 0x80,   /* contained */
    XS_PARSE_KEYWORD_REPEATED,          /* i, contained */
    XS_PARSE_KEYWORD_CHOICE,            /* i, contained */
    XS_PARSE_KEYWORD_TAGGEDCHOICE,      /* i, contained */
    XS_PARSE_KEYWORD_SEPARATEDLIST,     /* i, contained */
    XS_PARSE_KEYWORD_PARENSCOPE = 0xb0, /* contained */
    XS_PARSE_KEYWORD_BRACKETSCOPE,      /* contained */
    XS_PARSE_KEYWORD_BRACESCOPE,        /* contained */
    XS_PARSE_KEYWORD_CHEVRONSCOPE,      /* contained */
  };
  
  enum {
    XPK_LEXVAR_SCALAR = (1<<0),
    XPK_LEXVAR_ARRAY  = (1<<1),
    XPK_LEXVAR_HASH   = (1<<2),
    XPK_LEXVAR_ANY    = XPK_LEXVAR_SCALAR|XPK_LEXVAR_ARRAY|XPK_LEXVAR_HASH,
  };
  
  enum {
    XPK_TYPEFLAG_OPT      = (1<<16),
    XPK_TYPEFLAG_SPECIAL  = (1<<17), /* on XPK_LITERALSTR: keyword
                                        on XPK_BLOCK: scoped
                                        on XPK_LEXVAR: my */
  
    /* These three are shifted versions of perl's G_VOID, G_SCALAR, G_LIST */
    XPK_TYPEFLAG_G_VOID   = (1<<18),
    XPK_TYPEFLAG_G_SCALAR = (2<<18),
    XPK_TYPEFLAG_G_LIST   = (3<<18),
  
    XPK_TYPEFLAG_ENTERLEAVE = (1<<20), /* wrap ENTER/LEAVE pair around the item */
  
    XPK_TYPEFLAG_MAYBEPARENS = (1<<21), /* parens themselves are optional on PARENSCOPE */
  };
  
  #define XPK_BLOCK_flags(flags) {.type = XS_PARSE_KEYWORD_BLOCK|(flags), .u.pieces = NULL}
  #define XPK_BLOCK              XPK_BLOCK_flags(0)
  #define XPK_BLOCK_VOIDCTX      XPK_BLOCK_flags(XPK_TYPEFLAG_SPECIAL|XPK_TYPEFLAG_G_VOID)
  #define XPK_BLOCK_SCALARCTX    XPK_BLOCK_flags(XPK_TYPEFLAG_SPECIAL|XPK_TYPEFLAG_G_SCALAR)
  #define XPK_BLOCK_LISTCTX      XPK_BLOCK_flags(XPK_TYPEFLAG_SPECIAL|XPK_TYPEFLAG_G_LIST)
  
  #define XPK_PREFIXED_BLOCK_flags(flags,...) \
    {.type = XS_PARSE_KEYWORD_BLOCK|flags, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  #define XPK_PREFIXED_BLOCK(...)            XPK_PREFIXED_BLOCK_flags(0, __VA_ARGS__)
  #define XPK_PREFIXED_BLOCK_ENTERLEAVE(...) XPK_PREFIXED_BLOCK_flags(XPK_TYPEFLAG_ENTERLEAVE, __VA_ARGS__)
  
  #define XPK_SETUP(setup)       {.type = XS_PARSE_KEYWORD_SETUP, .u.callback = setup}
  
  #define XPK_ANONSUB {.type = XS_PARSE_KEYWORD_ANONSUB}
  
  #define XPK_ARITHEXPR_flags(flags) {.type = XS_PARSE_KEYWORD_ARITHEXPR|(flags)}
  #define XPK_ARITHEXPR              XPK_ARITHEXPR_flags(0)
  #define XPK_ARITHEXPR_VOIDCTX      XPK_ARITHEXPR_flags(XPK_TYPEFLAG_G_VOID)
  #define XPK_ARITHEXPR_SCALARCTX    XPK_ARITHEXPR_flags(XPK_TYPEFLAG_G_SCALAR)
  #define XPK_TERMEXPR_flags(flags) {.type = XS_PARSE_KEYWORD_TERMEXPR|(flags)}
  #define XPK_TERMEXPR              XPK_TERMEXPR_flags(0)
  #define XPK_TERMEXPR_VOIDCTX      XPK_TERMEXPR_flags(XPK_TYPEFLAG_G_VOID)
  #define XPK_TERMEXPR_SCALARCTX    XPK_TERMEXPR_flags(XPK_TYPEFLAG_G_SCALAR)
  #define XPK_LISTEXPR_flags(flags) {.type = XS_PARSE_KEYWORD_LISTEXPR|(flags)}
  #define XPK_LISTEXPR              XPK_LISTEXPR_flags(0)
  #define XPK_LISTEXPR_LISTCTX      XPK_LISTEXPR_flags(XPK_TYPEFLAG_G_LIST)
  
  #define XPK_IDENT           {.type = XS_PARSE_KEYWORD_IDENT                       }
  #define XPK_IDENT_OPT       {.type = XS_PARSE_KEYWORD_IDENT      |XPK_TYPEFLAG_OPT}
  #define XPK_PACKAGENAME     {.type = XS_PARSE_KEYWORD_PACKAGENAME                 }
  #define XPK_PACKAGENAME_OPT {.type = XS_PARSE_KEYWORD_PACKAGENAME|XPK_TYPEFLAG_OPT}
  
  #define XPK_LEXVARNAME(kind) {.type = XS_PARSE_KEYWORD_LEXVARNAME, .u.c = kind}
  
  #define XPK_LEXVAR_MY(kind) {.type = XS_PARSE_KEYWORD_LEXVAR|XPK_TYPEFLAG_SPECIAL, .u.c = kind}
  
  #define XPK_ATTRIBUTES {.type = XS_PARSE_KEYWORD_ATTRS}
  
  #define XPK_VSTRING     {.type = XS_PARSE_KEYWORD_VSTRING}
  #define XPK_VSTRING_OPT {.type = XS_PARSE_KEYWORD_VSTRING|XPK_TYPEFLAG_OPT}
  
  #define XPK_COMMA  {.type = XS_PARSE_KEYWORD_LITERALCHAR, .u.c = ','}
  #define XPK_COLON  {.type = XS_PARSE_KEYWORD_LITERALCHAR, .u.c = ':'}
  #define XPK_EQUALS {.type = XS_PARSE_KEYWORD_LITERALCHAR, .u.c = '='}
  
  #define XPK_LITERAL(s) {.type = XS_PARSE_KEYWORD_LITERALSTR, .u.str = (const char *)s}
  #define XPK_STRING(s)  XPK_LITERAL(s)
  #define XPK_AUTOSEMI   {.type = XS_PARSE_KEYWORD_AUTOSEMI}
  #define XPK_KEYWORD(s) {.type = XS_PARSE_KEYWORD_LITERALSTR|XPK_TYPEFLAG_SPECIAL, .u.str = (const char *)s}
  
  #define XPK_INFIX(select) {.type = XS_PARSE_KEYWORD_INFIX, .u.c = select}
  #define XPK_INFIX_RELATION       XPK_INFIX(XPI_SELECT_RELATION)
  #define XPK_INFIX_EQUALITY       XPK_INFIX(XPI_SELECT_EQUALITY)
  #define XPK_INFIX_MATCH_NOSMART  XPK_INFIX(XPI_SELECT_MATCH_NOSMART)
  #define XPK_INFIX_MATCH_SMART    XPK_INFIX(XPI_SELECT_MATCH_SMART)
  
  #define XPK_SEQUENCE(...) \
    {.type = XS_PARSE_KEYWORD_SEQUENCE, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  /* First piece of these must be something probe-able */
  #define XPK_OPTIONAL(...) \
    {.type = XS_PARSE_KEYWORD_SEQUENCE|XPK_TYPEFLAG_OPT, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  #define XPK_REPEATED(...) \
    {.type = XS_PARSE_KEYWORD_REPEATED, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  /* Every piece must be probeable */
  #define XPK_CHOICE(...) \
    {.type = XS_PARSE_KEYWORD_CHOICE, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  /* Every piece must be probeable, and followed by XPK_TAG */
  #define XPK_TAGGEDCHOICE(...) \
    {.type = XS_PARSE_KEYWORD_TAGGEDCHOICE, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0}, {0} }}
  #define XPK_TAG(val) \
    {.type = val}
  #define XPK_COMMALIST(...) \
    {.type = XS_PARSE_KEYWORD_SEPARATEDLIST, .u.pieces = (const struct XSParseKeywordPieceType []){ \
        {.type = XS_PARSE_KEYWORD_LITERALCHAR, .u.c = ','}, __VA_ARGS__, {0}}}
  
  #define XPK_FAILURE(s) {.type = XS_PARSE_KEYWORD_FAILURE, .u.str = (const char *)s}
  
  #define XPK_PARENSCOPE(...) \
    {.type = XS_PARSE_KEYWORD_PARENSCOPE, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  #define XPK_PARENSCOPE_OPT(...) \
    {.type = XS_PARSE_KEYWORD_PARENSCOPE|XPK_TYPEFLAG_OPT, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  
  #define XPK_ARGSCOPE(...) \
    {.type = XS_PARSE_KEYWORD_PARENSCOPE|XPK_TYPEFLAG_MAYBEPARENS, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  
  #define XPK_BRACKETSCOPE(...) \
    {.type = XS_PARSE_KEYWORD_BRACKETSCOPE, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  #define XPK_BRACKETSCOPE_OPT(...) \
    {.type = XS_PARSE_KEYWORD_BRACKETSCOPE|XPK_TYPEFLAG_OPT, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  
  #define XPK_BRACESCOPE(...) \
    {.type = XS_PARSE_KEYWORD_BRACESCOPE, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  #define XPK_BRACESCOPE_OPT(...) \
    {.type = XS_PARSE_KEYWORD_BRACESCOPE|XPK_TYPEFLAG_OPT, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  
  #define XPK_CHEVRONSCOPE(...) \
    {.type = XS_PARSE_KEYWORD_CHEVRONSCOPE, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  #define XPK_CHEVRONSCOPE_OPT(...) \
    {.type = XS_PARSE_KEYWORD_CHEVRONSCOPE|XPK_TYPEFLAG_OPT, .u.pieces = (const struct XSParseKeywordPieceType []){ __VA_ARGS__, {0} }}
  
  /* This type defined in XSParseInfix.h */
  typedef struct XSParseInfixInfo XSParseInfixInfo;
  
  typedef struct {
    union {
      OP *op;
      CV *cv;
      SV *sv;
      int i;
      struct { SV *name; SV *value; } attr;
      PADOFFSET padix;
      XSParseInfixInfo *infix;
    };
    int line;
  } XSParseKeywordPiece;
  
  struct XSParseKeywordHooks {
    U32 flags;
  
    /* used by build1 */
    struct XSParseKeywordPieceType piece1;
    /* alternatively, used by build */
    const struct XSParseKeywordPieceType *pieces;
  
    /* These two hooks are ANDed together; both must pass, if present */
    const char *permit_hintkey;
    bool (*permit) (pTHX_ void *hookdata);
  
    void (*check)(pTHX_ void *hookdata);
  
    /* These are alternatives; the first one defined is used */
    int (*parse)(pTHX_ OP **opp, void *hookdata);
    int (*build)(pTHX_ OP **out, XSParseKeywordPiece *args[], size_t nargs, void *hookdata);
    int (*build1)(pTHX_ OP **out, XSParseKeywordPiece *arg0, void *hookdata);
  };
  
  static void (*register_xs_parse_keyword_func)(pTHX_ const char *kwname, const struct XSParseKeywordHooks *hooks, void *hookdata);
  #define register_xs_parse_keyword(kwname, hooks, hookdata)  S_register_xs_parse_keyword(aTHX_ kwname, hooks, hookdata)
  static void S_register_xs_parse_keyword(pTHX_ const char *kwname, const struct XSParseKeywordHooks *hooks, void *hookdata)
  {
    if(!register_xs_parse_keyword_func)
      croak("Must call boot_xs_parse_keyword() first");
  
    (*register_xs_parse_keyword_func)(aTHX_ kwname, hooks, hookdata);
  }
  
  #define boot_xs_parse_keyword(ver) S_boot_xs_parse_keyword(aTHX_ ver)
  static void S_boot_xs_parse_keyword(pTHX_ double ver) {
    SV **svp;
    SV *versv = ver ? newSVnv(ver) : NULL;
  
    load_module(PERL_LOADMOD_NOIMPORT, newSVpvs("XS::Parse::Keyword"), versv, NULL);
  
    svp = hv_fetchs(PL_modglobal, "XS::Parse::Keyword/ABIVERSION_MIN", 0);
    if(!svp)
      croak("XS::Parse::Keyword ABI minimum version missing");
    int abi_ver = SvIV(*svp);
    if(abi_ver > XSPARSEKEYWORD_ABI_VERSION)
      croak("XS::Parse::Keyword ABI version mismatch - library supports >= %d, compiled for %d",
          abi_ver, XSPARSEKEYWORD_ABI_VERSION);
  
    svp = hv_fetchs(PL_modglobal, "XS::Parse::Keyword/ABIVERSION_MAX", 0);
    abi_ver = SvIV(*svp);
    if(abi_ver < XSPARSEKEYWORD_ABI_VERSION)
      croak("XS::Parse::Keyword ABI version mismatch - library supports <= %d, compiled for %d",
          abi_ver, XSPARSEKEYWORD_ABI_VERSION);
  
    register_xs_parse_keyword_func = INT2PTR(void (*)(pTHX_ const char *, const struct XSParseKeywordHooks *, void *),
        SvUV(*hv_fetchs(PL_modglobal, "XS::Parse::Keyword/register()@2", 0)));
  }
  
  #endif
XS_PARSE_KEYWORD_BUILDER_DATA

$fatpacked{"XSLoader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'XSLOADER';
  package XSLoader;$VERSION="0.24";package DynaLoader;boot_DynaLoader('DynaLoader')if defined(&boot_DynaLoader)&& !defined(&dl_error);package XSLoader;sub load {package DynaLoader;my ($caller,$modlibname)=caller();my$module=$caller;if (@_){$module=$_[0]}else {$_[0]=$module}my$boots="$module\::bootstrap";goto &$boots if defined &$boots;goto \&XSLoader::bootstrap_inherit unless$module and defined&dl_load_file;my@modparts=split(/::/,$module);my$modfname=$modparts[-1];my$modpname=join('/',@modparts);my$c=()=split(/::/,$caller,-1);$modlibname =~ s,[\\/][^\\/]+$,, while$c--;if ($modlibname !~ m{^/}){FOUND: {for (@INC){if ($_ eq $modlibname){last FOUND}}goto \&XSLoader::bootstrap_inherit}}my$file="$modlibname/auto/$modpname/$modfname.so";my$bs=$file;$bs =~ s/(\.\w+)?(;\d*)?$/\.bs/;if (-s $bs){eval {do$bs};warn "$bs: $@\n" if $@;goto \&XSLoader::bootstrap_inherit}goto \&XSLoader::bootstrap_inherit if not -f $file;my$bootname="boot_$module";$bootname =~ s/\W/_/g;@DynaLoader::dl_require_symbols=($bootname);my$boot_symbol_ref;my$libref=dl_load_file($file,0)or do {require Carp;Carp::croak("Can't load '$file' for module $module: " .dl_error())};push(@DynaLoader::dl_librefs,$libref);$boot_symbol_ref=dl_find_symbol($libref,$bootname)or do {require Carp;Carp::croak("Can't find '$bootname' symbol in $file\n")};push(@DynaLoader::dl_modules,$module);boot: my$xs=dl_install_xsub($boots,$boot_symbol_ref,$file);push(@DynaLoader::dl_shared_objects,$file);return &$xs(@_)}sub bootstrap_inherit {require DynaLoader;goto \&DynaLoader::bootstrap_inherit}1;
XSLOADER

$fatpacked{"auto/Clone/autosplit.ix"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'AUTO_CLONE_AUTOSPLIT.IX';
  1;
AUTO_CLONE_AUTOSPLIT.IX

$fatpacked{"common/sense.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'COMMON_SENSE';
  package common::sense;our$VERSION=3.75;sub import {local $^W;${^WARNING_BITS} ^= ${^WARNING_BITS} ^ "\x0c\x3f\x33\x00\x03\xf0\x0f\xc0\xf0\xfc\x33\x00\x00";$^H |= 0x1c820fc0;@^H{qw(feature___SUB__ feature_evalbytes feature_fc feature_say feature_state feature_switch feature_unicode)}=(1)x 7}1
COMMON_SENSE

$fatpacked{"lib/relative.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIB_RELATIVE';
  package lib::relative;use strict;use warnings;use Cwd ();use File::Basename ();use File::Spec ();use lib ();our$VERSION='1.000';sub import {my ($class,@paths)=@_;my$file=(caller)[1];my$dir=-e $file ? File::Basename::dirname(Cwd::abs_path$file): Cwd::getcwd;lib->import(map {File::Spec->file_name_is_absolute($_)? $_ : File::Spec->catdir($dir,$_)}@paths)}1;
LIB_RELATIVE

$fatpacked{"ok.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OK';
  package ok;our$VERSION='1.302190';use strict;use Test::More ();sub import {shift;if (@_){goto&Test::More::pass if $_[0]eq 'ok';goto&Test::More::use_ok}my (undef,$file,$line)=caller();($file =~ /^\(eval/)or die "Not enough arguments for 'use ok' at $file line $line\n"}
OK

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


#  Author:  Nicholas Hubbard
#  WWW:     https://github.com/NicholasBHubbard/yabsm
#  License: MIT

#  This is the toplevel script of yabsm. The actual program that is
#  installed on the end users system is this script but fatpacked.

our $VERSION = '3.1.0';

use strict;
use warnings;
use v5.16.3;

sub usage {
    print <<END_USAGE;
usage: yabsm [--help] [--version] <command> <arg(s)>

  find, f <SUBJECT> <QUERY>               Find a snapshot of SUBJECT using
                                          QUERY. SUBJECT must be a backup or
                                          subvol defined in /etc/yabsmd.conf.

  check-config, c <?FILE>                 Check that FILE is a valid yabsm
                                          config file. If FILE is not specified
                                          then check /etc/yabsmd.conf. If errors
                                          are present print their messages to
                                          stderr and exit with non zero status,
                                          else print 'all good'.

  test-remote-config, tr <BACKUP>         Test that the remote BACKUP has been
                                          properly configured. For BACKUP to be
                                          properly configured yabsm should be
                                          able to connect to the remote host and
                                          use the btrfs command with sudo
                                          without having to enter any passwords.
                                          This is a root only command.

  bootstrap-backup, bootstrap <BACKUP>    Perform the boostrap phase of the
                                          btrfs incremental backup process for
                                          BACKUP. This is a root only command.

  print-subvols, subvols                  Print the names of all the subvols
                                          defined in /etc/yabsmd.conf.

  print-backups, backups                  Print the names of all the backups
                                          defined in /etc/yabsmd.conf.
END_USAGE
}

use lib::relative 'lib';

# Every command has their own module with a main() function
use Yabsm::Commands::Find;
use Yabsm::Commands::CheckConfig;
use Yabsm::Commands::TestRemoteBackupConfig;
use Yabsm::Commands::PrintSubvols;
use Yabsm::Commands::PrintBackups;

# command dispatch table
my %run_command =
   ( 'find'               => \&Yabsm::Commands::Find::main
   , 'check-config'       => \&Yabsm::Commands::CheckConfig::main
   , 'test-remote-config' => \&Yabsm::Commands::TestRemoteBackupConfig::main
   , 'print-crons'        => \&Yabsm::Commands::PrintCrons::main
   , 'print-subvols'      => \&Yabsm::Commands::PrintSubvols::main
   , 'print-backups'      => \&Yabsm::Commands::PrintBackups::main
   );

sub unabbreviate {

    # provide the user with command abbreviations

    my $cmd = shift // die;

    if    ($cmd eq 'f')         { return 'find'               }
    elsif ($cmd eq 'c')         { return 'check-config'       }
    elsif ($cmd eq 'tr')        { return 'test-remote-config' }
    elsif ($cmd eq 'crons')     { return 'print-crons'        }
    elsif ($cmd eq 'subvols')   { return 'print-subvols'      }
    elsif ($cmd eq 'backups')   { return 'print-backups'      }
    else                        { return $cmd                 }
}

                 ####################################
                 #               MAIN               #
                 ####################################

my $cmd = shift @ARGV || (usage() and exit 1);

if ($cmd eq '--help' || $cmd eq '-h') { usage() and exit 0 }

if ($cmd eq '--version') { say $VERSION and exit 0 }

my $full_cmd = unabbreviate($cmd);

if (not exists $run_command{ $full_cmd} ) {
    die "yabsm: error: no such command '$cmd'\n";
}

$run_command{ $full_cmd }->(@ARGV);

exit 0; # all good
