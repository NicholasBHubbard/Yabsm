#  Author:  Nicholas Hubbard
#  WWW:     https://github.com/NicholasBHubbard/yabsm
#  License: MIT
#
#  This package exists to provide the read_config() function which is
#  used to create the configuration hash that is used constantly in the
#  rest of the yabsm program (usually a reference called $config_ref).
#
#  See t/Config.t for testing of read_config().
#
#  If the configuration has errors read_config() will print useful
#  error messages to STDERR and kill the program.
#
#  read_config() returns a 3D hash. Here is a Data::Dumper dump of the
#  hash generated by the yabsm default config:
#
#  $VAR1 = 'subvols';
#  $VAR2 = {
#            'root' => {
#                        'midnight_want' => 'yes',
#                        'hourly_keep' => '36',
#                        'midnight_keep' => '21',
#                        'mountpoint' => '/',
#                        'monthly_keep' => '0',
#                        'monthly_want' => 'no',
#                        '_5minute_keep' => '24',
#                        '_5minute_want' => 'yes',
#                        'hourly_want' => 'yes'
#                      },
#            'home' => {
#                        'monthly_keep' => '0',
#                        'mountpoint' => '/home',
#                        'monthly_want' => 'no',
#                        '_5minute_keep' => '24',
#                        '_5minute_want' => 'yes',
#                        'hourly_keep' => '36',
#                        'midnight_want' => 'yes',
#                        'midnight_keep' => '21',
#                        'hourly_want' => 'yes'
#                      }
#          };
#  $VAR3 = 'backups';
#  $VAR4 = {
#            'homeBackup' => {
#                              'timeframe' => 'midnight',
#                              'backup_dir' => '/.backups/home',
#                              'remote' => 'yes',
#                              'host' => 'myHost',
#                              'keep' => '60',
#                              'subvol' => 'home'
#                            }
#          };
#  $VAR5 = 'misc';
#  $VAR6 = {
#            'yabsm_snapshot_dir' => '/.snapshots/yabsm'
#          };

package Yabsmrc;

use strict;
use warnings;
use 5.010;

use FindBin '$Bin';
use lib '.';
use Base;

use List::Util 'any';
use Carp;

sub read_config {

    # read_config() reads a yabsm configuration file and returns a
    # config hash or kills the program in the presence of errors.

    my $file = shift // '/etc/yabsmrc';

    open(my $fh, '<', $file) or die "[!] Error: failed to open file '$file'\n";

    # %config will be returned.
    my %config; 

    while (<$fh>) {

	next if /^\s*$/; # skip blank lines
	next if /^\s*#/; # skip comment lines

	s/#.*//;         # remove eol comments
	s/\s+$//;        # remove trailing whitespace

	if (/^define_subvol\s+(\S+)\s+{$/) {
	    my $subvol = $1;

	    if (not $subvol =~ /^[a-zA-Z]/) {
		die "[!] Parse Error (line $.): invalid subvol name '$subvol' does not start with alphabetic character\n";
	    }
	    else {
		# create the key
		$config{subvols}{$subvol} = undef;
	    }

	    # parse define_subvol block
	    while (1) {
		
		$_ = <$fh>;

		if (not defined $_) {
		    die "[!] Parse Error: reached end of file\n";
		}

		next if /^\s*$/; # skip blank lines
		next if /^\s*#/; # skip comment lines
		
		s/#.*//;         # remove eol comments
		s/\s+//g;        # remove all whitespace

		last if /^}$/;   # terminate on closing brace

		my ($key, $val) = split /=/, $_, 2;

		if (not defined $key || not defined $val) {
		    die "[!] Parse Error (line $.): cannot parse '$_'\n";
		}

		# perl hash keys cant start with numbers.
		$key =~ s/5minute/_5minute/;
		
		$config{subvols}{$subvol}{$key} = $val;
	    } 
	}

	elsif (/^define_backup\s+(\S+)\s+{$/) {
	    my $backup = $1;

	    if (not $backup =~ /^[a-zA-Z]/) {
		die "[!] Parse Error (line $.): invalid backup name '$backup' does not start with alphabetic character\n";
	    }
	    else {
		# create the key
		$config{backups}{$backup} = undef;
	    }

	    # parse define_backup block
	    while (1) {

		$_ = <$fh>;

		if (not defined $_) {
		    die "[!] Parse Error: reached end of file\n";
		}

		next if /^\s*$/; # skip blank lines
		next if /^\s*#/; # skip comment lines
		
		s/#.*//;         # remove eol comments
		s/\s+//g;        # remove all whitespace
		
		last if /^}$/;   # terminate on closing brace

		my ($key, $val) = split /=/, $_, 2;

		if (not defined $key || not defined $val) {
		    die "[!] Parse Error (line $.): cannot parse '$_'\n";
		}

		$config{backups}{$backup}{$key} = $val;
	    } 
	}

	else { # misc setting

	    s/#.*//g; # remove eol comments
	    s/\s+//g; # remove all whitespace

	    my ($key, $val) = split /=/, $_, 2;

	    if (not defined $key || not defined $val) {
		die "[!] Parse Error (line $.): cannot parse '$_'\n";
	    }

	    $config{misc}{$key} = $val;
	}
    }

    close $fh;

    # Static error checking
    my @errors = check_config(\%config);

    # We found errors. Print their messages and die.
    if (@errors) {
	# make all the errors one string.
	my $errors = join "\n", @errors;
	die "$errors\n";
    }
    
    # No errors. All good.
    return wantarray ? %config : \%config;
}

sub check_config {

    # Comprehensively check the config hash produced by
    # read_config(). All errors that are found are pushed onto the
    # @errors array. The @errors array is returned. The caller will
    # know if the config is valid if they are returned an empty array.

    my $config_ref = shift // confess Base::missing_arg();

    # return this
    my @errors; 

    # check all defined subvols
    foreach my $subvol (Base::all_subvols($config_ref)) {

	# we will confirm that all of these settings have been defined.
	my @required_settings = required_subvol_settings();

	# go through all of the settings for $subvol
	while (my ($key, $val) = each %{$config_ref->{subvols}{$subvol}}) {

	    if ($key eq 'mountpoint') {
		@required_settings = grep { $_ ne $key } @required_settings;
		if (not -d $val) {
		    push @errors, "[!] Config Error: subvol '$subvol': no such directory '$val'"
		}
	    }

	    # *_want setting
	    elsif ($key =~ /^(_5minute|hourly|midnight|monthly)_want$/) {
		@required_settings = grep { $_ ne $key } @required_settings;
		if (not ($val eq 'yes' || $val eq 'no')) {
		    push @errors, "[!] Config Error: subvol '$subvol': value for '$key' does not equal yes or no";
		}
	    }

	    # *_keep setting
	    elsif ($key =~ /^(_5minute|hourly|midnight|monthly)_keep$/) {
		@required_settings = grep { $_ ne $key } @required_settings;
		if (not $val =~ /^\d+$/) {
		    push @errors, "[!] Config Error: subvol '$subvol': value for '$key' is not an integer greater or equal to 0";
		}
	    }

	    else {
		push @errors, "[!] Config Error: subvol '$subvol': '$key' is not a valid subvol setting";
	    }
	} # end of while each loop
	
	# are we missing required settings?
	if (@required_settings) {
	    for (@required_settings) {
		push @errors, "[!] Config Error: subvol '$subvol': missing required setting '$_'";
	    }
	} 
    } # end of outer loop

    # check backups
    foreach my $backup (Base::all_backups($config_ref)) {

	my @required_settings = required_backup_settings();
	
	# go through all of the settings for $backup
	while (my ($key, $val) = each %{$config_ref->{backups}{$backup}}) {

	    if ($key eq 'subvol') {
		if (not Base::is_subvol($config_ref, $val)) {
		    push @errors, "[!] Config Error: backup '$backup': no defined subvol '$val'";
		}
		@required_settings = grep { $_ ne $key } @required_settings;
	    }

	    elsif ($key eq 'backup_dir') {
		# TODO figure out how to validate backup path
		@required_settings = grep { $_ ne $key } @required_settings;
	    }

	    elsif ($key eq 'keep') {
		if (not ($val =~ /^\d+$/ && $val >= 1)) {
		    push @errors, "[!] Config Error: backup '$backup': value for '$key' is not a positive integer";
		}
		@required_settings = grep { $_ ne $key } @required_settings;
	    }

	    elsif ($key eq 'timeframe') {
		if (not Base::is_backup_timeframe($val)) {
		    push @errors, "[!] Config Error: backup '$backup': value for '$key' is not one of (hourly, midnight, monthly)";
		}
		@required_settings = grep { $_ ne $key } @required_settings;
	    }
	    
	    elsif ($key eq 'remote') {
		
		@required_settings = grep { $_ ne $key } @required_settings;

		if ($val eq 'yes') {
		    if (not exists $config_ref->{backups}{$backup}{host}) {
			push @errors, "[!] Config Error: backup '$backup': remote backups require 'host' setting";
		    }
		}
		elsif ($val eq 'no') {
		    if (exists $config_ref->{backups}{$backup}{host}) {
			push @errors, "[!] Config Error: backup '$backup': 'host' is not a valid setting for a non-remote backup";
		    }
		}
		else {
		    push @errors, "[!] Config Error: backup '$backup': value for '$key' does not equal yes or no";
		}
	    }

	    else {
		# we deal with the 'host' key in the 'remote' key check
		if (not ($key eq 'host')) { 
		    push @errors, "[!] Config Error: backup '$backup': '$key' is not a valid backup setting";
		}
	    }
	} #end of inner loop

	# missing one or more required settings
	if (@required_settings) {
	    for (@required_settings) {
		push @errors, "[!] Config Error: backup '$backup': missing required setting '$_'";
	    }
	} 
    } # end of outer loop

    # check misc settings
    my @required_misc_settings = required_misc_settings();

    while (my ($key, $val) = each %{$config_ref->{misc}}) {
	
	if ($key eq 'yabsm_snapshot_dir') {
	    @required_misc_settings = grep { $_ ne $key } @required_misc_settings;
	}

	else {
	    push @errors, "[!] Config Error: '$key' is not a valid setting";
	}
    }
    
    if (@required_misc_settings) {
	for (@required_misc_settings) {
	    push @errors, "[!] Config Error: missing required misc setting '$_'";
	}
    } 

    return wantarray ? @errors : \@errors;
}

sub required_subvol_settings {

    # return an array of all required subvol settings.

    my @settings = qw(mountpoint 
		      _5minute_want 
		      _5minute_keep 
		      hourly_want 
		      hourly_keep 
		      midnight_want 
		      midnight_keep 
		      monthly_want 
		      monthly_keep);

    return wantarray ? @settings : \@settings;
}

sub required_backup_settings {

    # return an array of all required backup settings. Note that 'host'
    # is not included.

    my @settings = qw(subvol remote keep backup_dir timeframe);

    return wantarray ? @settings : \@settings;
}

sub required_misc_settings {

    # return an array of all required misc settings. At this point
    # 'yabsm_snapshot_dir' is the only one.

    return wantarray ? ('yabsm_snapshot_dir') : ['yabsm_snapshot_dir'];
}

1;
