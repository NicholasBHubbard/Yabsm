#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Yabsm.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YABSM';
  package Yabsm;use strict;use warnings;use 5.010;use File::Copy 'move';use Time::Piece;use List::Util 'any';use Net::OpenSSH;sub initialize_yabsm_directories {my ($config_ref)=@_;my$yabsm_root_dir=target_dir($config_ref);mkdir$yabsm_root_dir if not -d $yabsm_root_dir;mkdir$yabsm_root_dir .'/.tmp' if not -d $yabsm_root_dir .'/.tmp';for my$subvol (all_subvols($config_ref)){my$subvol_dir="$yabsm_root_dir/$subvol";if (not -d $subvol_dir){mkdir$subvol_dir}my$hourly_want=$config_ref->{"${subvol}_hourly_want"};my$daily_want=$config_ref->{"${subvol}_daily_want"};my$midnight_want=$config_ref->{"${subvol}_midnight_want"};my$monthly_want=$config_ref->{"${subvol}_monthly_want"};if ($hourly_want eq 'yes' && not -d "$subvol_dir/hourly"){mkdir "$subvol_dir/hourly"}if ($daily_want eq 'yes' && not -d "$subvol_dir/daily"){mkdir "$subvol_dir/daily"}if ($midnight_want eq 'yes' && not -d "$subvol_dir/midnight"){mkdir "$subvol_dir/midnight"}if ($monthly_want eq 'yes' && not -d "$subvol_dir/monthly"){mkdir "$subvol_dir/monthly"}}return 1}sub ask_user_for_subvolume {my ($config_ref)=@_;my@all_subvols=all_subvols($config_ref);my%int_subvol_hash;for (my$i=0;$i <= $#all_subvols;$i++){$int_subvol_hash{$i + 1 }=$all_subvols[$i]}my$subvol;while (not defined$subvol){say 'select subvolume:';for (my$i=1;$i <= keys%int_subvol_hash;$i++){my$int=$i;my$subvol=$int_subvol_hash{$int };if ($i % 4==0){print "$int -> $subvol\n"}else {print "$int -> $subvol" .' 'x4}}print "\n>>> ";my$input=<STDIN>;$input =~ s/\s//g;exit 0 if$input =~ /^q(uit)?$/;if (exists$int_subvol_hash{$input }){$subvol=$int_subvol_hash{$input }}else {print "No option '$input'! Try again!\n\n"}}return$subvol}sub ask_user_for_query {my$query;while (not defined$query){print "enter query:\n>>> ";my$input=<STDIN>;$input =~ s/^\s+|\s+$//g;exit 0 if$input =~ /^q(uit)?$/;if (is_valid_query($input)){$query=$input}else {print "'$input' is not a valid query! Try again!\n\n"}}return$query}sub all_snapshots_of {my ($config_ref,$subvol)=@_;my@all_snaps;for my$tf ('hourly','daily','midnight','monthly'){my$target_dir=target_dir($config_ref,$subvol,$tf);if (-d "$target_dir"){push@all_snaps,glob "$target_dir/*"}}my$snaps_sorted_ref=sort_snapshots(\@all_snaps);return wantarray ? @$snaps_sorted_ref : $snaps_sorted_ref}sub all_subvols {my ($config_ref)=@_;my@subvols=sort keys %{$config_ref->{subvols}};return wantarray ? @subvols : \@subvols}sub all_backups {my ($config_ref)=@_;my@backups=sort keys %{$config_ref->{backups}};return wantarray ? @backups : \@backups}sub target_dir {my ($config_ref,$subvol,$timeframe)=@_;my$target_dir=$config_ref->{misc}{snapshot_directory}.'/yabsm';if (defined$subvol){if ($subvol eq 'tmp'){return$target_dir .'/.tmp'}else {$target_dir .= "/$subvol" if defined$subvol}}$target_dir .= "/$timeframe" if defined$timeframe;return$target_dir}sub immediate_to_snapstring {my ($all_snaps_ref,$imm)=@_;if (is_literal_time($imm)){return literal_time_to_snapstring($imm)}if (is_relative_time($imm)){return relative_time_to_snapstring($imm)}if (is_newest_time($imm)){return newest_snap($all_snaps_ref)}if (is_oldest_time($imm)){return oldest_snap($all_snaps_ref)}die "[!] Internal Error: '$imm' is not an immediate"}sub literal_time_to_snapstring {my ($lit_time)=@_;my$yr_mon_day_hr_min='^(\d{4})-(\d{1,2})-(\d{1,2})-(\d{1,2})-(\d{1,2})$';my$yr_mon_day='^(\d{4})-(\d{1,2})-(\d{1,2})$';my$mon_day='^(\d{1,2})-(\d{1,2})$';my$mon_day_hr='^(\d{1,2})-(\d{1,2})-(\d{1,2})$';my$mon_day_hr_min='^(\d{1,2})-(\d{1,2})-(\d{1,2})-(\d{1,2})$';if ($lit_time =~ /$yr_mon_day_hr_min/){return nums_to_snapstring($1,$2,$3,$4,$5)}if ($lit_time =~ /$yr_mon_day/){return nums_to_snapstring($1,$2,$3,0,0)}if ($lit_time =~ /$mon_day/){my$t=localtime;return nums_to_snapstring($t->year,$1,$2,0,0)}if ($lit_time =~ /$mon_day_hr/){my$t=localtime;return nums_to_snapstring($t->year,$1,$2,$3,0)}if ($lit_time =~ /$mon_day_hr_min/){my$t=localtime;return nums_to_snapstring($t->year,$1,$2,$3,$4)}die "[!] Internal Error: '$lit_time' is not a valid literal time"}sub relative_time_to_snapstring {my ($rel_time)=@_;my (undef,$amount,$unit)=split '-',$rel_time,3;my$n_units_ago_snapstring=n_units_ago_snapstring($amount,$unit);return$n_units_ago_snapstring}sub snapstring_to_nums {my ($snap)=@_;my@nums=$snap =~ /day=(\d{4})_(\d{2})_(\d{2}),time=(\d{2}):(\d{2})$/;return wantarray ? @nums : \@nums}sub nums_to_snapstring {my ($yr,$mon,$day,$hr,$min)=map {sprintf '%02d',$_}@_;return "day=${yr}_${mon}_${day},time=${hr}:$min"}sub snapstring_to_time_piece_obj {my ($snap)=@_;my ($yr,$mon,$day,$hr,$min)=snapstring_to_nums($snap);return Time::Piece->strptime("$yr/$mon/$day/$hr/$min",'%Y/%m/%d/%H/%M')}sub time_piece_obj_to_snapstring {my ($time_piece_obj)=@_;my$yr=$time_piece_obj->year;my$mon=$time_piece_obj->mon;my$day=$time_piece_obj->mday;my$hr=$time_piece_obj->hour;my$min=$time_piece_obj->min;return nums_to_snapstring($yr,$mon,$day,$hr,$min)}sub sort_snapshots {my ($snaps_ref)=@_;my@sorted_snaps=sort {cmp_snaps($a,$b)}@$snaps_ref;return wantarray ? @sorted_snaps : \@sorted_snaps}sub cmp_snaps {my ($snap1,$snap2)=@_;my@snap1_nums=snapstring_to_nums($snap1);my@snap2_nums=snapstring_to_nums($snap2);for (my$i=0;$i <= $#snap1_nums;$i++){return -1 if$snap1_nums[$i]> $snap2_nums[$i];return 1 if$snap1_nums[$i]< $snap2_nums[$i]}return 0}sub n_units_ago_snapstring {my ($n,$unit)=@_;my$seconds_per_unit;if ($unit =~ /^(m|mins|minutes)$/){$seconds_per_unit=60}elsif ($unit =~ /^(h|hrs|hours)$/){$seconds_per_unit=3600}elsif ($unit =~ /^(d|days)$/){$seconds_per_unit=86400}else {die "\"$unit\" is not a valid time unit"}my$current_time=current_time_snapstring();my$time_piece_obj=snapstring_to_time_piece_obj($current_time);$time_piece_obj -= ($n * $seconds_per_unit);return time_piece_obj_to_snapstring($time_piece_obj)}sub snap_closest_to {my ($all_snaps_ref,$target_snap)=@_;my$snap;for (my$i=0;$i <= $#{$all_snaps_ref};$i++){my$this_snap=$all_snaps_ref->[$i];my$cmp=cmp_snaps($this_snap,$target_snap);if ($cmp==0){$snap=$this_snap;last}if ($cmp==1){if ($i==0){$snap=$this_snap}else {my$prev_snap=$all_snaps_ref->[$i-1];$snap=snap_closer($target_snap,$prev_snap,$this_snap)}last}}if (not defined$snap){$snap=oldest_snap($all_snaps_ref)}return$snap}sub snap_closer {my ($target_snap,$snap1,$snap2)=@_;my$target_epoch=snapstring_to_time_piece_obj($target_snap)->epoch;my$snap1_epoch=snapstring_to_time_piece_obj($snap1)->epoch;my$snap2_epoch=snapstring_to_time_piece_obj($snap2)->epoch;my$v1=abs($target_epoch - $snap1_epoch);my$v2=abs($target_epoch - $snap2_epoch);if ($v1 <= $v2){return$snap1}else {return$snap2}}sub snaps_newer {my ($all_snaps_ref,$target_snap)=@_;my@snaps_newer=();for (my$i=0;$i <= $#{$all_snaps_ref};$i++){my$this_snap=$all_snaps_ref->[$i];my$cmp=cmp_snaps($this_snap,$target_snap);if ($cmp==-1){push@snaps_newer,$this_snap}else {last}}return wantarray ? @snaps_newer : \@snaps_newer}sub snaps_older {my ($all_snaps_ref,$target_snap)=@_;my@snaps_older=();my$last_idx=$#{$all_snaps_ref};for (my$i=0;$i <= $last_idx;$i++){my$this_snap=$all_snaps_ref->[$i];my$cmp=cmp_snaps($this_snap,$target_snap);if ($cmp==1){@snaps_older=@{$all_snaps_ref}[$i .. $last_idx];last}}return wantarray ? @snaps_older : \@snaps_older}sub snaps_between {my ($all_snaps_ref,$target_snap1,$target_snap2)=@_;my$older;my$newer;if (-1==cmp_snaps($target_snap1,$target_snap2)){$newer=$target_snap1;$older=$target_snap2}else {$newer=$target_snap2;$older=$target_snap1}my@snaps_between=();my$last_idx=$#{$all_snaps_ref};for (my$i=0;$i <= $last_idx;$i++){my$this_snap=$all_snaps_ref->[$i];my$cmp=cmp_snaps($this_snap,$newer);if ($cmp==1 || $cmp==0){push@snaps_between,$this_snap if$cmp==0;for (my$j=$i+1;$j <= $last_idx;$j++){my$this_snap=$all_snaps_ref->[$j];my$cmp=cmp_snaps($this_snap,$older);if ($cmp==1 || $cmp==0){push@snaps_between,$this_snap if$cmp==0;last}push@snaps_between,$this_snap}last}}return wantarray ? @snaps_between : \@snaps_between}sub newest_snap {my ($ref,$subvol)=@_;my$newest_snap;if (ref($ref)eq 'ARRAY'){$newest_snap=$ref->[0]}else {my$all_snaps_ref=all_snapshots_of($ref,$subvol);$newest_snap=$all_snaps_ref->[0]}return$newest_snap}sub oldest_snap {my ($ref,$subvol)=@_;my$oldest_snap;if (ref($ref)eq 'ARRAY'){$oldest_snap=$ref->[-1]}else {my$all_snaps_ref=all_snapshots_of($ref,$subvol);$oldest_snap=$ref->[-1]}return$oldest_snap}sub answer_query {my ($config_ref,$subvol,$query)=@_;my$all_snaps_ref=all_snapshots_of($config_ref,$subvol);my@snaps_to_return;if (is_immediate($query)){my$target=immediate_to_snapstring($all_snaps_ref,$query);my$snap=snap_closest_to($all_snaps_ref,$target);push@snaps_to_return,$snap}elsif (is_newer_query($query)){my (undef,$immediate)=split /\s/,$query,2;my$target=immediate_to_snapstring($all_snaps_ref,$immediate);@snaps_to_return=snaps_newer($all_snaps_ref,$target)}elsif (is_older_query($query)){my (undef,$immediate)=split /\s/,$query,2;my$target=immediate_to_snapstring($all_snaps_ref,$immediate);@snaps_to_return=snaps_older($all_snaps_ref,$target)}elsif (is_between_query($query)){my (undef,$imm1,$imm2)=split /\s/,$query,3;my$target1=immediate_to_snapstring($all_snaps_ref,$imm1);my$target2=immediate_to_snapstring($all_snaps_ref,$imm2);@snaps_to_return=snaps_between($all_snaps_ref,$target1,$target2)}else {die "[!] Internal Error: '$query' is not a valid query"}return wantarray ? @snaps_to_return : \@snaps_to_return}sub is_valid_query {my ($query)=@_;if (is_immediate($query)){return 1}if (is_newer_query($query)){return 1}if (is_older_query($query)){return 1}if (is_between_query($query)){return 1}return 0}sub is_immediate {my ($imm)=@_;return is_newest_time($imm)|| is_oldest_time($imm)|| is_literal_time($imm)|| is_relative_time($imm)}sub is_literal_time {my ($lit_time)=@_;my$re1='^\d{4}-\d{1,2}-\d{1,2}-\d{1,2}-\d{1,2}$';my$re2='^\d{4}-\d{1,2}-\d{1,2}$';my$re3='^\d{1,2}-\d{1,2}$';my$re4='^\d{1,2}-\d{1,2}-\d{1,2}$';my$re5='^\d{1,2}-\d{1,2}-\d{1,2}-\d{1,2}$';return any {$lit_time =~ /$_/}($re1,$re2,$re3,$re4,$re5)}sub is_relative_time {my ($query)=@_;my ($back,$amount,$unit)=split '-',$query,3;return 0 if any {not defined}($back,$amount,$unit);my$back_correct=$back =~ /^b(ack)?$/;my$amount_correct=$amount =~ /^\d+$/;my$unit_correct=any {$_ eq $unit}qw/minutes mins m hours hrs h days d/;return$back_correct && $amount_correct && $unit_correct}sub is_newer_query {my ($query)=@_;my ($keyword,$imm)=split /\s/,$query,2;return 0 if any {not defined}($keyword,$imm);my$keyword_correct=$keyword =~ /^newer$/;my$imm_correct=is_immediate($imm);return$keyword_correct && $imm_correct}sub is_older_query {my ($query)=@_;my ($keyword,$imm)=split /\s/,$query,2;return 0 if any {not defined}($keyword,$imm);my$keyword_correct=$keyword =~ /^older$/;my$imm_correct=is_immediate($imm);return$keyword_correct && $imm_correct}sub is_newest_time {my ($query)=@_;return$query eq 'newest'}sub is_oldest_time {my ($query)=@_;return$query eq 'oldest'}sub is_between_query {my ($query)=@_;my ($keyword,$imm1,$imm2)=split /\s/,$query,3;return 0 if any {not defined}($keyword,$imm1,$imm2);my$keyword_correct=$keyword =~ /^bet(ween)?$/;my$imm1_correct=is_immediate($imm1);my$imm2_correct=is_immediate($imm2);return$keyword_correct && $imm1_correct && $imm2_correct}sub is_subvol {my ($config_ref,$subvol)=@_;return any {$_ eq $subvol}all_subvols($config_ref)}sub is_timeframe {my ($tframe)=@_;return any {$_ eq $tframe}qw/hourly daily midnight monthly/}sub update_etc_crontab {my ($config_ref)=@_;open (my$etc_crontab_fh,'<','/etc/crontab')or die "[!] Error: failed to open file '/etc/crontab'\n";open (my$tmp_fh,'>','/tmp/yabsm-update-tmp')or die "[!] Error: failed to open tmp file '/tmp/yabsm-update-tmp'\n";while (<$etc_crontab_fh>){s/\s+$//;next if /yabsm --take-snap/;say$tmp_fh $_}my@cron_strings=generate_cron_strings($config_ref);say$tmp_fh for@cron_strings;close$etc_crontab_fh;close$tmp_fh;move '/tmp/yabsm-update-tmp','/etc/crontab';return}sub generate_cron_strings {my ($config_ref)=@_;my@cron_strings;for my$subvol (all_subvols($config_ref)){my$hourly_want=$config_ref->{subvols}{$subvol}{hourly_want};my$hourly_take=$config_ref->{subvols}{$subvol}{hourly_take};my$daily_want=$config_ref->{subvols}{$subvol}{daily_want};my$daily_take=$config_ref->{subvols}{$subvol}{daily_take};my$midnight_want=$config_ref->{subvols}{$subvol}{midnight_want};my$monthly_want=$config_ref->{subvols}{$subvol}{monthly_want};my$hourly_cron=('*/' .int(60 / $hourly_take).' * * * * root' .' /usr/local/bin/yabsm' ." --take-snap $subvol hourly")if$hourly_want eq 'yes';my$daily_cron=('0 */' .int(24 / $daily_take).' * * * root' .' /usr/local/bin/yabsm' ." --take-snap $subvol daily")if$daily_want eq 'yes';my$midnight_cron=('59 23 * * * root' .' /usr/local/bin/yabsm' ." --take-snap $subvol midnight")if$midnight_want eq 'yes';my$monthly_cron=('0 0 1 * * root' .' /usr/local/bin/yabsm' ." --take-snap $subvol monthly")if$monthly_want eq 'yes';push@cron_strings,grep {defined}($hourly_cron,$daily_cron,$midnight_cron,$monthly_cron)}return wantarray ? @cron_strings : \@cron_strings}sub do_ssh_backup {my ($config_ref,$backup,$timeframe)=@_;if (is_ssh_backup($config_ref,$backup)){do_ssh_backup($config_ref,$backup,$timeframe);return 1}my$subvol=$config_ref->{backups}{$backup}{subvol};my$newest_snap=newest_snap($config_ref,$subvol);my$target_dir=target_dir($config_ref,'tmp');my$mountpoint=$config_ref->{subvols}{$subvol}{mountpoint};my$snap=$target_dir .current_time_snapstring();my ($ssh_name,$backup_path)=split /:/,$config_ref->{backups}{$backup}{path},2;$backup_path .= '/$yabsm/$subvol/$timeframe';system("btrfs subvol snapshot -r $mountpoint $snap");system("btrfs send -p $newest_snap $snap |" ." ssh $ssh_name \"sudo -n btrfs receive $backup_path\"");system("btrfs subvol delete $snap");return 1}sub take_new_snapshot {my ($config_ref,$subvol,$timeframe)=@_;my$mountpoint=$config_ref->{subvols}{$subvol}{mountpoint};my$target_dir=target_dir($config_ref,$subvol,$timeframe);my$snapshot_name=current_time_snapstring();system('btrfs subvol snapshot -r ' .$mountpoint ." $target_dir/$snapshot_name");return 1}sub current_time_snapstring {my ($min,$hr,$day,$mon,$yr)=map {sprintf '%02d',$_}(localtime)[1..5];$mon++;$yr += 1900;return "day=${yr}_${mon}_${day},time=${hr}:$min"}sub delete_appropriate_snapshots {my ($config_ref,$subvol,$timeframe)=@_;my$existing_snaps_ref=all_snapshots_of($config_ref,$subvol);my$num_snaps=scalar @$existing_snaps_ref;my$num_to_keep=$config_ref->{subvols}{$subvol}{"{$timeframe}_keep"};if ($num_snaps==$num_to_keep + 1){my$oldest_snap=pop @$existing_snaps_ref;system("btrfs subvolume delete $oldest_snap");return}elsif ($num_snaps <= $num_to_keep){return}else {while ($num_snaps > $num_to_keep){my$oldest_snap=pop @$existing_snaps_ref;system("btrfs subvolume delete $oldest_snap");$num_snaps--}}return}1;
YABSM

$fatpacked{"Yabsmrc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YABSMRC';
  package Yabsmrc;use strict;use warnings;use 5.010;sub read_config {my$file=shift // '/etc/yabsmrc';open(my$fh,'<',$file)or die "[!] Error: failed to open file '$file'\n";my@errors;my%config;while (my$line=<$fh>){next if$line =~ /^\s*$/;next if$line =~ /^\s*#/;$line =~ s/#.*//;$line =~ s/^\s*//;$line =~ s/\s*$//;if (_is_define_subvol_header($line)){my$subvol_name=_parse_subvol_name($line);_process_define_subvol_block($fh,\%config,\@errors,$subvol_name);next}if (_is_define_backup_header($line)){my$backup_name=_parse_backup_name($line);_process_define_backup_block($fh,\%config,\@errors,$backup_name);next}if (_is_misc_setting($line)){my ($key,$val)=split /\s*=\s*/,$line,2;$config{misc}{$key}=$val;next}die "[!] Parse Error (line $.): cannot parse '$line'\n"}close$fh;if (@errors){say STDERR for@errors;exit 1}else {return wantarray ? %config : \%config}}sub _is_define_subvol_header {my ($line)=@_;return$line =~ /^define_subvol\s+.+\s+\{$/}sub _is_define_backup_header {my ($line)=@_;return$line =~ /^define_backup\s+.+\s+\{$/}sub _parse_subvol_name {my ($line)=@_;my ($name)=$line =~ /^define_subvol\s+(.+)\s+\{$/;if (not $name){die "[!] Parse Error (line $.): cannot parse subvol name from '$line'"}$name =~ s/\s//g;return$name}sub _parse_backup_name {my ($line)=@_;my ($name)=$line =~ /^define_backup\s+(.+)\s+\{$/;if (not $name){die "[!] Parse Error (line $.): cannot parse backup name from '$line'"}$name =~ s/\s//g;return$name}sub _is_misc_setting {my ($line)=@_;my%misc_setting=map {$_=>1}qw(snapshot_directory);my ($setting,undef)=split /\s*=\s*/,$line,2;return$misc_setting{$setting }}sub _process_define_subvol_block {my ($fh,$config_ref,$errors_ref,$subvol_name)=@_;while (my$line=<$fh>){next if$line =~ /^\s*$/;next if$line =~ /^\s*#/;$line =~ s/#.*//;$line =~ s/\s//g;last if$line =~ /}/;my ($key,$val)=split /=/,$line,2;my$valid_setting=_check_subvol_setting($errors_ref,$key,$val);if ($valid_setting){$config_ref->{subvols}{$subvol_name}{$key}=$val}}}sub _process_define_backup_block {my ($fh,$config_ref,$errors_ref,$backup_name)=@_;while (my$line=<$fh>){next if$line =~ /^\s*$/;next if$line =~ /^\s*#/;$line =~ s/#.*//;$line =~ s/\s//g;last if$line =~ /}/;my ($key,$val)=split /=/,$line,2;_check_backup_setting($errors_ref,$key,$val);$config_ref->{backups}{$backup_name}{$key}=$val}}sub _check_subvol_setting {my ($errors_ref,$key,$val)=@_;my%valid_subvol_key=map {$_=>1}qw(mountpoint hourly_want hourly_take hourly_keep daily_want daily_take daily_keep midnight_want midnight_keep monthly_want monthly_keep);if (not $valid_subvol_key{$key }){push @$errors_ref,"[!] Config Error (line $.): invalid subvol setting '$key'";return 0}if ($key =~ /_want$/){if (not ($val eq 'yes' || $val eq 'no')){push @$errors_ref,"[!] Config Error (line $.): '$val' does not equal 'yes' or 'no'";return 0}else {return 1}}if ($key =~ /_keep$/){if (not $val =~ /^\d+$/){push @$errors_ref,"[!] Config Error (line $.): '$val' is not a integer greater than or equal to 0";return 0}else {return 1}}if ($key eq 'hourly_take'){if (not ($val =~ /^\d+$/ && $val <= 60)){push @$errors_ref,"[!] Config Error (line $.): '$val' is not an integer between 0 and 60";return 0}else {return 1}}if ($key eq 'daily_take'){if (not ($val =~ /^\d+$/ && $val <= 24)){push @$errors_ref,"[!] Config Error (line $.): '$val' is not an integer between 0 and 24";return 0}else {return 1}}}sub _check_backup_setting {my ($errors_ref,$key,$val)=@_;my%valid_backup_key=map {$_=>1}qw(subvol path hourly_want hourly_take hourly_keep daily_want daily_take daily_keep midnight_want midnight_keep monthly_want monthly_keep);if (not $valid_backup_key{$key }){push @$errors_ref,"[!] Config Error (line $.): invalid backup setting '$key'";return 0}if ($key =~ /_want$/){if (not ($val eq 'yes' || $val eq 'no')){push @$errors_ref,"[!] Config Error (line $.): '$val' does not equal 'yes' or 'no'";return 0}else {return 1}}if ($key =~ /_keep$/){if (not $val =~ /^\d+$/){push @$errors_ref,"[!] Config Error (line $.): '$val' is not a integer greater than or equal to 0";return 0}else {return}}if ($key eq 'hourly_take'){if (not ($val =~ /^\d+$/ && $val <= 60)){push @$errors_ref,"[!] Config Error (line $.): '$val' is not an integer between 0 and 60";return 0}else {return 1}}if ($key eq 'daily_take'){if (not ($val =~ /^\d+$/ && $val <= 24)){push @$errors_ref,"[!] Config Error (line $.): '$val' is not an integer between 0 and 24";return 0}else {return 1}}}1;
YABSMRC

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


#  Author: Nicholas Hubbard
#  Email:  nhub73@keemail.me
#  WWW:    https://github.com/NicholasBHubbard/yabsm

use strict;
use warnings;
use 5.010;

sub usage {
    print <<END_USAGE;
Usage: yabsm [OPTION] [arg...]

  --take-snap, -s <SUBVOL> <CATEGORY>     take a new snapshot

  --find, -f <?SUBVOL> <?QUERY>           find a snapshot of SUBVOL using QUERY

  --update-crontab, -u                    update cronjobs in /etc/crontab, based
                                          off settings specified in /etc/yabsmrc

  --check-config, -c                      check /etc/yabsmrc for errors. If
                                          errors are present print their info
                                          to stdout. Exit with code 0 in either
                                          case.

  --help, -h                              print help (this message) and exit

  Please see 'man yabsm' for more detailed information about yabsm.
END_USAGE
}

use Getopt::Long qw(:config no_ignore_case no_auto_abbrev);

# Import Yabsm.pm
use FindBin '$Bin';
use lib "$Bin/lib";
use Yabsm;
use Yabsmrc;

my @YABSM_TAKE_SNAPSHOT;
my $UPDATE_CRONTAB;
my $YABSM_BACKUP;
my @YABSM_FIND;
my @CHECK_CONFIG;
my $HELP;

GetOptions( 'take-snap|s=s{2}'      => \@YABSM_TAKE_SNAPSHOT
	  , 'find|f=s{0,2}'         => \@YABSM_FIND
	  , 'update-crontab|u'      => \$UPDATE_CRONTAB
	  , 'check-config|c=s{0,1}' => \@CHECK_CONFIG
	  , 'backup|b=s'            => \$YABSM_BACKUP
	  , 'send-backup|b=s'       => \$YABSM_BACKUP
	  , 'help|h'                => \$HELP
	  );

if ($HELP) {
    usage();
    exit 0;
}

if (@CHECK_CONFIG) {

    # The user can optionally pass the absolute path to a config. If
    # no path is given we just check '/etc/yabsmrc'. 
    my ($config_path) = @CHECK_CONFIG;

    $config_path = $config_path || '/etc/yabsmrc';

    Yabsmrc::read_config($config_path);

    exit 0;
}

my $CONFIG_REF = Yabsmrc::read_config('../export/yabsmrc');

if ($UPDATE_CRONTAB) {

    die "[!] Permission Error: must be root to update /etc/crontab\n" if $<;

    Yabsm::initialize_yabsm_directories($CONFIG_REF);
    Yabsm::update_etc_crontab($CONFIG_REF);

    exit 0;
}

if (@YABSM_TAKE_SNAPSHOT) {

    die "[!] Permission Error: must be root to take a new snapshot\n" if $<;

    # --take-snapshot option takes two string args. We can be sure
    # that both args are defined as Getopt::Long will kill the program
    # if they are not.
    my ($subvol, $timeframe) = @YABSM_TAKE_SNAPSHOT;

    if (not Yabsm::is_subvol($CONFIG_REF, $subvol)) {
	die "[!] Error: '$subvol' is not a yabsm subvolume\n";
    }

    if (not Yabsm::is_timeframe($timeframe)) {
	die "[!] Error: '$timeframe' is not a valid timeframe\n";
    }

    Yabsm::initialize_yabsm_directories($CONFIG_REF);
    Yabsm::take_new_snapshot($CONFIG_REF, $subvol, $timeframe);
    Yabsm::delete_appropriate_snapshots($CONFIG_REF, $subvol, $timeframe);

    exit 0;
}

if (@YABSM_FIND) {

    # these variables may or may not be defined.
    my ($arg1, $arg2) = @YABSM_FIND;

    # the following logic exists to set the $subvol and $query variables
    my ($subvol, $query);

    if ($arg1) {
	if (Yabsm::is_subvol($CONFIG_REF, $arg1)) {
	    $subvol = $arg1;
	}
	elsif (Yabsm::is_valid_query($arg1)) {
	    $query = $arg1;
	}
	else {
	    die "[!] Error: '$arg1' is neither a subvolume or query\n";
	}
    }
    
    if ($arg2) {
	if (Yabsm::is_subvol($CONFIG_REF, $arg2)) {
	    $subvol = $arg2;
	}
	elsif (Yabsm::is_valid_query($arg2)) {
	    $query = $arg2;
	}
	else {
	    die "[!] Error: '$arg2' is neither a subvolume or query\n";
	}
    }

    if (not defined $subvol) {
	$subvol = Yabsm::ask_user_for_subvolume($CONFIG_REF);
    }

    if (not defined $query) {
	$query = Yabsm::ask_user_for_query();
    }

    # $subvol and $query are properly set at this point
    my @snaps = Yabsm::answer_query($CONFIG_REF, $subvol, $query);

    say for @snaps;

    exit 0;
}

if ($YABSM_BACKUP) {

    Yabsm::do_ssh_backup($CONFIG_REF, $YABSM_BACKUP, 'test');

    exit 0;
}

# no options were passed
usage();
exit 1;
